var store = [{
        "title": "Kurs programowania Java",
        "excerpt":"Na tej stronie znajdziesz zestaw odnośników do artykułów, które pomogą Ci poznać Javę od podstaw. Artykuły podzieliłem na sekcje. Każda z nich zawiera artykuły, które pomogą Ci poszerzyć wiedzę na temat programowania w języku Java.   Kurs starałem się tworzyć dla zupełnie początkujących. Jeśli jednak jakikolwiek temat nie jest dla Ciebie wystarczająco jasno opisany proszę daj znać. Postaram się odpowiedzieć na każde pytanie. Zawsze możesz zadać swoje pytanie w komentarzach pod każdym artykułem.   Jeśli dopiero zaczynasz przygodę z programowaniem możesz dowiedzieć się czym właściwie jest programowanie. Pamiętaj też o  przygotowaniu środowiska programisty.   Podstawy składni   Zacznij od poznania podstawowej składni języka Java. Poniższa lista artykułów pomoże Ci w zdobyciu odpowiedniej wiedzy:      Metody w języku Java   Obiekty w języku Java   Pierwszy program w Java   Tablice w języku Java   Pętle i instrukcje warunkowe w języku Java   Typy proste w języku Java   Interfejsy w języku Java   Dziedziczenie w języku Java   Wyjątki w języku Java   Referencja, sterta i garbage collector – obiektów w Javie ciąg dalszy   Konwersja i rzutowanie w języku Java   Porównywanie obiektów, metody equals i hashCode w języku Java   Typ wyliczeniowy w języku Java   Adnotacje w języku Java   Modyfikatory dostępu w języku Java   Przerwa na testy jednostkowe   Jeśli zapoznasz się już z podstawową składnią języka Java koniecznie zrób przerwę na poznanie testów jednostkowych. Testy jednostkowe są czymś bardzo ważnym w codziennej pracy programisty.   Nie jest to temat prosty dla początkujących, jednak moim zdaniem warto już od samego początku zwracać na niego uwagę. Czym skorupka za młodu nasiąknie, tym na starość trąci ;).   Z tego właśnie powodu zachęcam Cię do przeczytania artykułów poświęconych testom jednostkowym:      Testy jednostkowe z JUnit   Testy jednostkowe z JUnit 5   Test Driven Development na przykładzie   Testy jednostkowe z Mockito   Pamiętaj o praktyce   Języka programowania uczy się dokładnie w ten sam sposób jak zwykłego języka. Najlepszą nauką jest praktyka. Właśnie z tego powodu każdy z artykułów kończy się ćwiczeniami do wykonania.   Przygotowałem też osobny artykuł zawierający zestaw ćwiczeń dla początkujących programistów. Jeśli przerobisz ćwiczenia z tego artykułu zapraszam Cię do osobnego działu z przykładowymi zadaniami do rozwiązania. Znajdziesz tam zadania o różnym poziomie trudności, zawsze z przykładowym rozwiązaniem.   Bardziej zaawansowane elementy składni   Jak poznasz już podstawy składni możesz przejść do bardziej zaawansowanych elementów:      Typy generyczne w języku Java   Konstrukcja try-with-resources w języku Java   Klasy wewnętrzne i anonimowe w języku Java   Wyrażenia lambda w języku Java   Strumienie w języku Java   Wątki w języku Java   Elementy biblioteki standardowej   Język Java posiada tak zwaną bibliotekę standardową. Biblioteka standardowa to zestaw gotowych klas, które dostępne są wraz z językiem programowania. Poniższa lista zawiera artykuły opisujące wybrane elementy biblioteki standardowej języka Java:      Kolekcje w języku Java   Operacje na plikach w języku Java   Serializacja w języku Java   Wyrażenia regularne w języku Java   Wyrażenia regularne część 2   String cache i StringBuilder w praktyce   Formatter – formatowanie łańcuchów znaków   Przydatne narzędzia i biblioteki      Walidacja obiektów w języku Java   Format JSON w języku Java   Co dalej?   Koniecznie zapoznaj się z tym jak używać języka Java z linii poleceń. Pozwoli Ci to lepiej zrozumieć robotę jaką odwala za nas IDE.   Jeśli nadal chcesz rozwijać swoją wiedzę związaną z językiem Java zachęcam Cię do przerobienia kursu programowania aplikacji webowych.   Bez względu na to czy zdecydujesz się na rozwijanie wiedzy związanej z Javą koniecznie musisz zwrócić uwagę na Git’a. Pomoże Ci w tym kurs git dla początkujących.   Jeśli znajdziesz chwilę, żeby napisać mi co sądzisz o kursie będę wdzięczny. Każda konstruktywna krytyka jest mile widziana. Mój adres e-mail to marcin małpka samouczekprogramisty.pl.  ","categories": [],
        "tags": [],
        "url": "/kurs-programowania-java/",
        "teaser": "/assets/images/splash/kurs_java_splash.gif"
      },{
        "title": "Kurs aplikacji webowych",
        "excerpt":"Jeśli znasz już język programowania Java możesz zabrać się za pisanie aplikacji webowych.  W przypadku gdy jest to Twoja pierwsza styczność z aplikacjami tego typu zachęcam do przeczytania wprowadzenia do aplikacji webowych.   Nie zapominaj też o poznaniu narzędzi do budowania, które opisałem w dziale opisującym narzędzia.   Jeśli jakiekolwiek zagadnienie nie będzie dla Ciebie jasne proszę zadaj pytanie w komentarzu pod artykułem, postaram się pomóc.   Odrobina teorii   Aplikacje webowe związane są z przesyłaniem danych przez Internet. W praktyce wiąże się to z przesyłaniem danych przy pomocy protokołu HTTP. Jak zwykle twierdzę, że zrozumienie podstaw pomaga lepiej pracować dlatego właśnie napisałem artykuł opisujący protokół HTTP.   Podstawy specyfikacji serwletów   Ogromna większość aplikacji webowych pisana w języku Java oparta jest o specyfikację serwletów. Serwlety to podstawa, którą moim zdaniem trzeba znać. Nie znam aplikacji webowej napisanej w języku Java, która nie używałaby tej specyfikacji. Nawet jeśli używasz bibliotek pomocniczych, które ułatwiają pracę pod spodem uda Ci się znaleźć serwlety. Właśnie z tego powodu moim zdaniem dobrze jest poznać te podstawy.      Serwlety w aplikacjach webowych   Nagłówki, sesje i ciasteczka   Filtry w aplikacjach webowych   Kontekst serwletu i obiekty nasłuchujące w aplikacjach webowych   Deskryptor wdrożenia w aplikacjach webowych   Poznaj więcej specyfikacji JEE   Skoro udało Ci się poznać specyfikację serwletów nadszedł czas na kolejne specyfikacje z parasola JEE:      REST web service z Java EE część 1   REST web service z Java EE część 2   Walidacja obiektów w języku Java   Format JSON w języku Java   Pamiętaj o praktyce   Powtarzam to bez przerwy. Najlepszym sposobem na naukę jest praktyka. Wybierz sobie projekt, który jest dla Ciebie interesujący i spróbuj go zrealizować samodzielnie. Potrzebujesz przykładu? Nie ma sprawy! Na blogu realizowałem kilka projektów, od początku do końca. Gotowy kod wraz z artykułami opisującymi ważniejsze fragmenty znajdziesz na stronie grupującej przykładowe projekty realizowane na blogu.   Co dalej?   Jeśli swobodnie tworzysz już aplikacje webowe nie zapominaj o przydatnych narzędziach i dobrych praktykach. Na tej samej stronie znajdziesz też spis artykułów dotyczących testów automatycznych.   Na tym etapie system kontroli wersji nie powinien być dla Ciebie czymś nowym. Jeśli jednak jeszcze nie udało Ci się go poznać zapraszam do kursu gita gdzie poznasz Git’a w praktyczny sposób od podstaw.   Aplikacje webowe to studnia bez dna :). Proszę daj znać jaki temat powinienem dodatkowo opisać. Jeśli tylko będę miał wystarczającą wiedzę na ten temat postaram się naskrobać artykuł. A może chcesz poznać język SQL? Jeśli tak to świetnie, bo przygotowałem darmowy kurs SQL na blogu.   Na koniec mam tę samą prośbę co zawsze. Jeśli znajdziesz chwilę, żeby napisać mi co sądzisz o kursie będę wdzięczny. Każda konstruktywna krytyka jest mile widziana. Mój adres e-mail to marcin małpka samouczekprogramisty.pl.  ","categories": [],
        "tags": [],
        "url": "/kurs-aplikacji-webowych/",
        "teaser": "/assets/images/splash/kurs_aplikacji_webowych_splash.jpeg"
      },{
        "title": "Kurs SQL",
        "excerpt":"Na tej stronie znajdziesz zestaw artykułów, który pozwoli Ci w praktyczny sposób nauczyć się podstaw języka SQL. Jest to solidna baza, która pozwoli Ci rozbudowywać swoją wiedzę związaną z tym językiem. W kursie staram się pokazywać najczęściej używane elementy SQL, które wspierane są przez większość znanych mi baz danych.   Jeśli z bazami danych masz do czynienia pierwszy raz, zachęcam Cię do przeczytania artykułu wprowadzającego do relacyjnych baz danych.   Praktyka to podstawa   Powtarzam to do upadłego, uczysz się przez praktykę. Dlatego właśnie kurs który przygotowałem pozwoli Ci w praktyce sprawdzić działanie każdego zapytania, które znajdziesz w treści artykułu.   Każdy artykuł kończy się zestawem zapytań do samodzielnego przygotowania. Te zapytania także możesz przetestować i sprawdzić z przykładowymi rozwiązaniami.   Składnia SQL   Do tej pory w ramach kursu SQL ukazały się następujące artykuły:           Pobieranie danych z bazy – SELECT            Klauzula WHERE w zapytaniach SQL            Sortowanie, aliasy, ograniczanie wyników i zwracanie unikalnych wartości            Funkcje i grupowanie wierszy w SQL            Klauzula JOIN w zapytaniach SQL            Podzapytania SQL            Funkcje analityczne w SQL       Co dalej?   Jeśli jakikolwiek temat nie jest dla Ciebie wystarczająco jasno opisany proszę daj znać, postaram się go rozwinąć w kolejnym artykule.   Na koniec mam tę samą prośbę co zawsze. Jeśli znajdziesz chwilę, żeby napisać mi co sądzisz o kursie będę wdzięczny. Każda konstruktywna krytyka jest mile widziana. Mój adres e-mail to marcin małpka samouczekprogramisty.pl.  ","categories": [],
        "tags": [],
        "url": "/kurs-sql/",
        "teaser": "/assets/images/splash/kurs_sql_splash.jpeg"
      },{
        "title": "Kurs Git",
        "excerpt":"Pracuję nad pierwszym komercyjnym kursem na stronie. Jakiś czas temu zdecydowałem, że będzie to kurs związany z systemem kontroli wersji Git.   Będzie to kurs z materiałami w formie:      filmów wideo,   plików pdf:            z materiałami omówionymi z filmach,       ściągawek z komendami Git’a,           ćwiczeń do samodzielnego wykonania,   Mam nadzieję, że udało Ci się już poznać sposób w jaki tworzę treści do nauki. Jeśli tak to wiesz, że możesz spodziewać się praktycznych ćwiczeń które pomogą Ci utrwalić zdobytą wiedzę.   Dla kogo jest ten kurs?   Kurs jest tworzony z myślą o początkujących. Przeprowadzę Cię w nim przez cały proces pracy z Git’em. Od momentu instalacji Git’a do efektywnej pracy z Git’em w linii poleceń i IDE.   Kiedy będzie kurs?   Nie wiem jak Tobie, ale mi bardzo podobają się gry z wytwórni Blizzard. Podoba mi się też ich filozofia wypuszczania nowych produktów. Nie ogłaszają dnia premiery a jedynie raportują postępy prac nad produktem.   Kurs będzie dostępny jak tylko jego jakość i zawartość będzie odpowiadać moim standardom. Dzisiaj nie potrafię podać Ci dokładnej daty.   To jak? Jesteś ze mną?   Jeśli chcesz żebym powiadamiał Cię o postępach prac nad kursem dopisz się do samouczkowego newslettera. Jeśli zapiszesz się na listę na pewno będę miał dla Ciebie ofertę specjalną jeszcze przed wypuszczeniem kursu.          ","categories": [],
        "tags": [],
        "url": "/kurs-git/",
        "teaser": "/assets/images/splash/kurs_git.png"
      },{
        "title": "Czym właściwie jest programowanie",
        "excerpt":"Kto może zostać programistą   Programowanie to zajęcie, które wymaga znajomości wielu zagadnień. To wiedza, którą zdobywa się przez kilka ładnych lat. Nie znam żadnego programisty, który nauczył się wszystkiego w jeden wieczór. To jest po prostu niemożliwe. Tak i na tym blogu będziemy razem przechodzili przez serię artykułów, które pomogą Ci zgłębić podstawowe zagadnienia. Pokażę Ci dalszą drogę, która pomoże Ci zostać programistą.   Programowanie jako zajęcie wymaga pewnych umiejętności. Umiejętności te są pomocne przy zgłębianiu niezbędnej wiedzy. Poza umiejętnościami bardzo istotne jest także zaangażowanie i wytrwałość. Oczywiście “talent” pomaga, jednak ciężka, systematyczna praca to podstawa. Bez talentu można programować, jednak bez ciężkiej pracy włożonej w naukę już nie (jestem tego bardzo dobrym przykładem).   Nie bez powodu piszę blog po polsku. Zależy mi na tym, żeby ludzie, którzy nie czują się swobodnie czytając angielskie teksty również znaleźli coś dla siebie. Jednak muszę to powiedzieć z pełną stanowczością. Język angielski to podstawa. Jest to uniwersalny język komunikacji, który każdy programista po prostu musi znać. Jeśli go nie znasz zachęcam do przyłożenia się do zajęć z języka angielskiego. Jeśli nie masz dostępu do takich zajęć w internecie można znaleźć bardzo dużo darmowych materiałów pomagających w nauce.   Mówi się, że programista powinien charakteryzować się analitycznym myśleniem, rozumieć zagadnienia matematyczne. Oczywiście ścisły umysł to predyspozycja, która bardzo pomaga – sam znam architektów (tych od budownictwa) czy chemików, którzy samodzielnie nauczyli się programowania. Jednak mam wrażenie, że przy odpowiedniej ilości ciężkiej pracy i humanista też w programowaniu znajdzie coś dla siebie. Spróbuj, to na pewno nie zaszkodzi! :)   Podsumowując:     ucz się języka angielskiego, na pewno przyda się nie tylko do programowania,   nie bój się przedmiotów ścisłych,   wkładaj dużo pracy w naukę programowania.   Rozmowa z komputerem   Do porozumiewania się ze swoimi przyjaciółmi, znajomymi używamy dobrze znanych słów i zwrotów. Rozumiemy się nawzajem, jesteśmy w stanie przekazać sobie pewne informacje. Jeśli posługujemy się językami obcymi porozumiemy się swobodnie z większą grupą ludzi. Podobnie jest z komputerem. Jeśli chcesz się z nim porozumieć musisz mówić jego językiem. Nie chcę Cię tu zanudzać wpisem o zerach i jedynkach fruwających w pamięci komputera jednak pewne podstawy są tu potrzebne.   Język programowania to nic innego jak język, który rozumieją programiści. Są w stanie się nim swobodnie posługiwać, który następnie tłumaczony jest do języka komputera. Słowa przetłumaczone są na ciąg zer i jedynek zrozumiały przez komputer. Ten etap tłumaczenia możemy nazwać kompilacją (ang. compile).   Języki programowania możemy podzielić na języki niskopoziomowe i wysokopoziomowe. Te pierwsze są bardzo trudne do samodzielnego używania. Programy napisane przy ich pomocy mogą być uruchamiane tylko na konkretnych rodzajach komputerów. Na przykład program napisany w języku niskiego poziomu na Twój komputer nie może być uruchomiony na komputerze Twojego kolegi1.   Tego typu ograniczenia sprawiają, że języków niskiego poziomu nie używa się powszechnie, a jedynie do bardzo specyficznych zastosowań, które są bardzo odległe od podstaw i nauki programowania :) Dzięki tym samym ograniczeniom języki wysokiego poziomu zyskują na popularności.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Polski? Angielski? Niemiecki? Rosyjski? Francuski?   F? Erlang? JavaScript? Java? Perl? Ruby? Podobnie jak istnieje wiele języków, którymi mówią ludzie istnieje także wiele języków programowania. Każdy z tych języków charakteryzuje się specyficzną składnią (ang. syntax). Każdy z nich ma również specyficzny zakres zastosowań. Po prostu jego właściwości sprawiają, że lepiej nadaje się np. do pisania gier komputerowych niż tworzenia interaktywnych stron internetowych.   W ramach pierwszego kursu dostępnego na blogu skupimy się na języku Java. Wybór padł na ten język ponieważ Google nadal raportuje spore zainteresowanie tym językiem, jak i jest on w miarę uniwersalny i bardzo powszechny. W następnym artykule skupimy się na omówieniu podstaw tego języka jednak zanim do tego dojdzie chciałbym Wam przybliżyć następujące pojęcia:      język obiektowy (ang. objective language)   maszyna wirtualna (ang. virtual machine)   Czym jest język obiektowy?   Weźmy za przykład stół i jego projekt. Fabryka produkuje setki stołów, wszystkie według tego samego projektu. Podobne projekty istnieją w języku programowania. Stół możemy uznać za tak zwaną instancję (ang. instance) lub obiekt (ang. object) klasy stół.   Innymi słowy projekt służy nam do tworzenia obiektów/instancji. Odpowiednikiem projektu w języku programowania jest klasa (ang. class).   Język obiektowy jest językiem, który pozwala na tworzenie swoich własnych klas. Mając definicję klasy jesteśmy w stanie stworzyć jej instancję.   Czym jest maszyna wirtualna?   Maszyna wirtualna to program napisany w języku niższego poziomu. Program ten pozwala na pewną abstrakcję, upraszcza niektóre aspekty rozmowy z komputerem. Jako przykład podam tu maszynę wirtualną języka Java. Maszyna ta do pewnego stopnia zwalnia programistę z odpowiedzialności zarządzania pamięcią.   Instancje klas, które tworzymy zajmują pamięć. Komputer musi dokładnie wiedzieć ile pamięci ma zarezerwować na daną instancję. Jeśli język korzysta z maszyny wirtualnej wspomagającej zarządzenie pamięcią programista nie musi się tym przejmować (oczywiście jest to pewne uproszczenie, ale na tym etapie zaawansowania w zupełności wystarczy).   Na dzisiaj wystarczy. Dzisiaj było bardzo mocno teoretycznie, następnym razem zaczniemy bawić się programowaniem. Czy którykolwiek z elementów wydał się dla Ciebie niezbyt jasny? Proszę daj mi znać o tym w komentarzu. Jeśli uznasz wpis za ciekawy proszę podziel się nim ze swoimi znajomymi.   Do następnego razu! :)                 Jest to duże uproszczenie, chodzi tu o tak zwaną architekturę procesora. Każda architektura ma swój specyficzny zestaw komend tzw. assembler, która czasami nie może być uruchamiana na różnych procesorach. &#8617;           ","categories": ["Programowanie"],
        "tags": [],
        "url": "/czym-wlasciwie-jest-programowanie/",
        "teaser": "/assets/images/2015/10/07_czym_jest_programowanie.jpg"
      },{
        "title": "Przygotowanie środowiska programisty",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   W poprzednim artykule pobieżnie opisałem czym właściwie jest programowanie. Do rozpoczęcia nauki niezbędne będzie zainstalowanie paru dodatkowych narzędzi niezbędnych dla programisty. Zanim do tego przejdziemy postaram się wytłumaczyć czym właściwie jest wersjonowanie oprogramowania.   Wersjonowanie oprogramowania   Czy widziałeś czasami dziwne numerki dołączone do nazwy programu, którego aktualnie używasz? Np. 1.0.7, 0.7, 1.2-rc1, 3.14? To nic innego jak wersja oprogramowania, którego używasz.   Nowsze wersje oprogramowania przeważnie zawierają zestaw nowych funkcjonalności niedostępnych w poprzednich wersjach. Poprawiają błędy znalezione przez użytkowników. Rozwiązują problemy związane z bezpieczeństwem.   Jeśli program jest w stanie współpracować z innym programem mówimy wówczas, że jest on kompatybilny (ang. compatible). Czasami zdarza się, że nowsza wersja nie jest kompatybilna wstecz ze starą wersja oprogramowania. Oznacza to, że programy używające innego programu w wersji 1 nie będą mogły używać go w wersji 2.   Poniżej przedstawię Ci przykładowy opis jednego z możliwych standardów wersjonowania programów. Nie jest to standard jedyny, jednak jest dość popularny.   Wersjonowanie oprogramowania X.Y.Z   Standardowo na wersję oprogramowania składają się trzy osobne liczby. Mówiąc o wersji oprogramowania możemy mieć na myśli np. wersję 2.7.0. Wersja ta składa się z 3 członów:     2 – (ang. major) każdy nowy numer oznacza nową wersję, która nie jest kompatybilna wstecz,   7 – (ang. minor) każda nowa wersja oznacza wprowadzenie nowych funkcjonalności kompatybilnych wstecz,   0 – (and. patch) kolejny numer wersji w tym członie symbolizuje zbiór łatek.   Jako łatkę (ang. patch) możemy traktować fragment kodu poprawiający błędy (ang. bugs) znalezione w starszej wersji oprogramowania. Zbiór łatek przeważnie grupowany jest w osobne wersje. Np. wersja 2.7.1 zawierająca kila łatek poprawia błędy znalezione w wersji 2.7.0.   A teraz kilka przykładów:      Wersja 2.0.0 wprowadza zmiany, które nie są kompatybilne z wersją 1.8.0,   Wersja 1.8.0 wprowadza nową funkcjonalność kompatybilną z 1.7.5,   Wersja 1.7.5 wprowadza poprawki funkcjonalności względem wersji 1.7.4.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Instalacja niezbędnych narzędzi   Naszą naukę zaczniemy od języka Java. Jest to język obiektowy, wymagający wirtualnej maszyny (oba pojęcia wyjaśniłem poprzednio – zachęcam do powtórki w razie wątpliwości). Istnieje wiele implementacji wirtualnej maszyny Javy. Mówiąc o wielu implementacjach mam tu na myśli różne firmy dostarczające JVM (ang. Java Virtual Machine). Najbardziej popularną z nich jest maszyna wirtualna firmy Oracle. Zanim jednak przejdziemy przez proces instalacji chciałbym wyjaśnić Ci jedną ważną kwestię..   Czym różni się JDK od JRE?   W przypadku języka Java często będziesz miał styczność z terminami JRE oraz JDK. Bardzo istotne jest zrozumienie różnicy pomiędzy nimi.   JRE (ang. Java Runtime Environment) – jest to maszyna wirtualna nie zawierająca dodatkowych narzędzi niezbędnych dla programisty. W uproszczeniu można powiedzieć że zawiera wyłącznie implementację wirtualnej maszyny – program java. Do uruchamiania programów napisanych w języku Java wystarczy JRE.   JDK (ang. Java SE Development Kit) – jest to zestaw narzędzi dla programisty. Zestaw ten jest niezbędny do pisania programów w języku Java. Poza programem java zawiera wiele innych. Jednym z dodatkowych programów zawartych w zestawie jest javac – kompilator1 języka Java.   Instalacja JDK   Proces instalacji jest różny na różnych systemach operacyjnych. Sam używam jednej  z dystrybucji systemu Linux jednak na potrzeby tego wpisu pożyczyłem komputer  z systemem Windows 7. Cały proces zaczynamy od ściągnięcia odpowiedniej wersji maszyny wirtualnej.   Ważne jest żeby była to wersja 1.8 bądź nowsza (poniżej zobaczysz proces instalacji dla wersji 1.8u60).   Krok pierwszy polega na ściągnięciu odpowiedniej wersji JDK ze strony Oracle.   Proszę pamiętaj o tym, żeby ściągnąć wersję odpowiednią dla Twojego systemu. Jeśli masz system 32-bitowy ściągnij plik jdk-8u60-windows-i586.exe. W przypadku systemu 64-bitowego ściągnij plik jdk-8u60-windows-x64.exe. Instrukcja opisująca to jak dowiedzieć się jaki masz system dostępna jest na stronie pomocy systemu Windows.   Aby móc ściągnąć jeden z plików musisz przeczytać i zaakceptować warunki licencji.             Pobierz JDK.        Po ściągnięciu pliku uruchom go i postępuj zgodnie z instrukcją instalacji. Poniżej prezentuję kolejne ekrany widoczne podczas instalacji JDK.             Instalacja JDK krok I                  Instalacja JDK krok II                  Instalacja JDK krok III                  Instalacja JDK krok IV        Czego używają programiści do pisania kodu   W najprostszym przypadku wystarczy zwykły edytor tekstu. W systemie operacyjnym Windows tę funkcję spełnia Notatnik. Większość języków programowania nie wymaga innego narzędzia do pisania kodu.   Chociaż takie narzędzie w zupełności wystarczy do efektywnej pracy przydają się bardziej zaawansowane narzędzia. Jednym z nich jest „zintegrowane środowisko programistyczne” – IDE (ang. Integrated Development Environment). IDE poza bardziej zaawansowanym edytorem zawiera zestaw dodatkowych narzędzi przydatnych programiście. Np. „profiler”, „debuger”, zestaw narzędzi do refaktoryzacji itp. Jeśli jesteś zainteresowany, którymkolwiek z tych zagadnień daj znać, na pewno napiszę artykuł na jego temat ;)   Nie ma jednego, słusznego IDE, którego programista powinien używać. Sam swoją przygodę zaczynałem z Eclipse i NetBeans. Jednak po pierwszych doświadczeniach z IntelliJ IDEA i opinii wśród innych programistów wydaję mi się, że powinieneś zacząć właśnie od tego IDE. Postaram się przeprowadzić Cię przez cały proces instalacji.   Instalacja IntelliJ IDEA   Podobnie jak w przypadku instalacji JDK używałem maszyny z systemem Windows 7. Aby ściągnąć IntelliJ IDEA musisz na stronie https://www.jetbrains.com/idea/download nacisnąć przycisk z napisem „Download Community”.             Pobierz IntelliJ IDEA.        Instalacja IntelliJ nie zawiera tak wiele ekranów jak instalacja JDK :) Jednak to nie wszystko. Teraz, gdy mamy już działające IDE należy je skonfigurować. Na pierwszym ekranie masz możliwość wyboru zestawu kolorów. Ja wybrałem ciemny, oczywiście możesz to później zmienić.             Instalacja krok I        Tworzenie pierwszego projektu w IntelliJ IDEA   Świeżo po instalacji IntelliJ IDEA niestety nie wie, którego JDK ma użyć (tak, możesz mieć kilka zainstalowanych JDK na jednym komputerze). Dlatego przy tworzeniu pierwszego projektu należy wskazać odpowiednią ścieżkę gdzie poprzednio zainstalowaliśmy JDK.             Instalacja krok II                  Tworzenie projektu krok I        Następnie wybieramy ścieżkę gdzie zainstalowaliśmy JDK.             Tworzenie projektu krok II        Po dodaniu JDK możemy je wybrać w menu rozwijanym. Na kolejnym ekranie nie wybieramy żadnego szablonu. Ostatni ekran to wybór nazwy projektu – ja wybrałem test.             Tworzenie projektu krok III                  Tworzenie projektu krok IV                  Tworzenie projektu krok V        I tak utworzyliśmy swój pierwszy projekt w IntelliJ IDEA! :) Co prawda nie ma w nim jeszcze ani linijki kodu ale tym szczegółem zajmiemy się następnym razem.             Tworzenie projektu krok VI        Podsumowanie   I tak dobrnęliśmy do końca przygotowania podstawowego środowiska dla programisty. Jeśli masz pytania dotyczące któregokolwiek z tematów proszę zadaj je w komentarzach. Proszę także podziel się tym artykułem ze swoimi znajomymi jeśli uznasz go za interesujący.                 Kompilator to narzędzie tłumaczące język wysokiego poziomu na instrukcje zrozumiałe przez komputer. W naszym przypadku javac jest kompilatorem tłumaczącym język Java na tak zwany bajtkod (ang. bytecode). Ten drugi jest interpretowany i wykonywany przez maszynę wirtualną. &#8617;           ","categories": ["Kurs programowania Java","Programowanie"],
        "tags": [],
        "url": "/przygotowanie-srodowiska-programisty/",
        "teaser": "/assets/images/2015/10/18_przygotowanie_srodowiska_programisty.jpg"
      },{
        "title": "Metody w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Metoda   boolean isBig(int someNumber) {     return someNumber &gt; 100; }   Więc jesteś już po przeczytaniu swojego pierwszego fragmentu kodu! Brawo! Programowanie to nie tylko pisanie, ale także czytanie kodu. Ale do rzeczy…   Metoda to nic innego jak worek grupujący zestaw instrukcji. Kod grupujemy w ten sposób z kilku powodów. Wymienię dwa, które moim zdaniem są najważniejsze:      jeśli jakiś fragment kodu ma być wykonany w wielu miejscach zdecydowanie lepiej jest utworzyć metodę i ją uruchomić (wywołać), niż kopiować ten sam fragment kodu wielokrotnie. Jest to istotne ponieważ w przypadku błędu trzeba go poprawić w jednym miejscu a nie w kilku1,   programy są duże, bez odpowiedniego podziału opanowanie całego projektu/programu jest bardzo czasochłonne. Sensowny podział na mniejsze części pozwala szybciej zrozumieć kod.   Typy danych   Zanim przejdę do omówienia metod musisz dowiedzieć się czym są typy danych.   Metoda wyżej przyjmuje argument someNumber. Argument ten ma swój typ int. Typ w języku programowania opisuje rodzaj danych. Na przykład w kodzie powyżej widoczne są dwa typy:     boolean – typ przechowujący wartości prawda/fałsz. Prawda reprezentowana jest przez wartość true. Fałsz to false. Typ ten może nam pomóc przechowywać informację o tym czy ktoś jest wysoki, czy jest pełnoletni, czy ma niebieski kolor oczu itp.   boolean isTall = true; boolean hasBlueEyes = false;      int – typ przechowujący liczby całkowite. Liczby te możesz zapisać na wiele sposobów, skupię się na najprostszym – ciąg cyfr (opcjonalnie poprzedzony znakiem). Ten typ może nam posłużyć do przechowywania informacji o aktualnej temperaturze, wzroście, odległości z miasta A do B itp.   Tutaj muszę też powiedzieć o pewnych ograniczeniach. int podobnie jak każda inna wartość reprezentowana jest w pamięci komputera. Każda z wartości zajmuje określony rozmiar pamięci. Przez to ograniczenie nie jesteśmy w stanie przechowywać wszystkich liczb w zmiennej. W przypadku Javy w zmiennej typu int możemy przechowywać liczby od -2 147 483 648 do 2 147 483 647. Jak widzisz są do dość duże liczby jednak do pewnych zastosowań potrzebujemy innych typów danych.   int temperature = -12; int height = 186; int distance = 2589; int numberOfErrors = 0;   Innym popularnym typem danych jest String. Służy on do przechowywania łańcuchów znaków:   String name = \"Marcin\"; String weekday = \"Monday\"; String someSentence = \"Samouczek Programisty jest git ;)\";   Omówienie składni definiowania metody   Powtórzę ten sam fragment kodu jeszcze raz:   boolean isBig(int someNumber) {     return someNumber &gt; 100; }   Powyższe trzy linijki to definicja metody. W ten sposób tworzy się metodę. Metoda to zestaw instrukcji, który opcjonalnie może zwracać jakąś wartość. Szablon metody wygląda następująco:   &lt;typ zwracany&gt; &lt;nazwa metody&gt;(&lt;opcjonalna lista argumentów&gt;) {     &lt;ciało metody&gt; }   Argumenty metody   Metody mogą przyjmować dowolnie dużo argumentów albo mogą nie przyjmować ich wcale. To, że jest to możliwe nie oznacza, że tak powinno się robić. W większości przypadków metody zawierające dużą liczbę argumentów są oznaką złych praktyk (ang. code smell). Duża liczba argumentów w metodzie pogarsza czytelność kodu.   Argumenty zawsze mają postać &lt;typ argumentu&gt; &lt;nazwa argumentu&gt;. Jeśli występuje więcej argumentów oddzielone są one przecinkiem. Na przykład metoda niżej pobiera trzy argumenty i zwraca ich sumę:   int addNumbers(int number1, int number2, int number3) {     return number1 + number2 + number3; }       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Wartość zwracana   Metoda może zwracać jakąś wartość. Do zwrócenia wartości z metody służy słowo kluczowe return. Na przykład metoda niżej nie pobiera żadnych argumentów i zwraca łańcuch znaków:   String getName() {     return \"Marcin\"; }   Metoda może także nie zwracać żadnej wartości, wówczas używa się słowa kluczowego void do określenia typu zwracanej wartości. Na przykład metoda poniżej nie przyjmuje żadnych argumentów i nie zwraca żadnej wartości:   void printSomething() {     System.out.println(\"Something\"); }   Jeśli metoda nie zwraca żadnej wartości również możesz użyć w jej ciele słowa kluczowego return. W takim przypadku return służy do wcześniejszego zakończenia działania metody (nie przejmuj się konstrukcją if, omówię ją niżej):   void printSomethingIfNumberIsBig(int number) {     if (number &lt; 10) {         return;     }     System.out.println(\"Something\"); }   Wiesz już, że metody mogą przyjmować wiele argumentów. W języku Java nie jest możliwe zwracanie wielu wartości. Metoda może nie zwrócić nic (void) lub pojedynczą wartość.   Ciało metody   Ciało metody to kod zawarty pomiędzy nawiasami klamrowymi {}. Przeanalizuję teraz ciała trzech metod pokazanych powyżej.   Metoda printSomething nie zwraca żadnej wartości. W środku zawiera wyłącznie fragment kodu. W tym przypadku zawiera wywołanie metody System.out.println. Ta metoda wyświetla przekazany argument na konsoli:   System.out.println(\"Something\");   Metoda addNumbers dodaje trzy zmienne number1, number2 i number3. Wynik dodawania zwracany jest jako wynik metody. Słowo kluczowe return wskazuje wynik metody:   return number1 + number2 + number3;   Podobnie w przypadku metody isBig słowo kluczowe return wskazuje wynik:   return someNumber &gt; 100;   Ciało tej metody zawiera operator porównania &gt;. someNumber &gt; 100 może zwrócić wartość logiczną. W zależności od wartości zmiennej someNumber wartość ta będzie różna:     jeśli someNumber równa się 10 wówczas someNumber &gt; 100 oznacza fałsz – false,   jeśli someNumber równa się 100 wówczas someNumber &gt; 100 oznacza fałsz – false,   jeśli someNumber równa się 101 wówczas someNumber &gt; 100 oznacza prawdę – true.   Pamiętaj o tym, że słowo kluczowe return może występować w metodach, które nie zwracają żadnej wartości.   Definicja metody a jej wywołanie   Musisz nauczyć się rozróżniać dwa różne zapisy. Definicję metody:   boolean isBig(int someNumber) {     return someNumber &gt; 100; }   Wywołanie metody:   boolean someVariable = isBig(10);  printSomething();   Pierwszy z nich to definicja metody. W ten sposób tworzy się metodę. Samo utworzenie metody nie powoduje jej wywołania. Drugi fragment kodu to wywołanie metody isBig i przypisanie wyniku do zmiennej someVariable. W trzecim fragmencie wywołana jest metoda printSomething.   Teraz celowo trochę zamieszam Ci w głowie. Spójrz na kod poniżej:   boolean isBig = isBig(10);   Ta linijka to wywołanie metody isBig, która zwraca wartość i przypisuje ją do zmiennej o nazwie isBig. W tym przypadku isBig może oznaczać dwie różne rzeczy:      nazwę metody,   zmienną przechowującą typ boolean – w tym przypadku wynik działania metody isBig.   Wywołanie metody   Wiesz już, że samo utworzenie metody nic nie daje. Metodę trzeba wywołać, aby została wykonana. Zwróć uwagę na ten fragment kodu:   int someNumber = 123; boolean result = isBig(someNumber);   Ten fragment kodu zawiera kolejno:     Pierwsza linijka to utworzenie zmiennej i przypisanie do niej wartości:            int określający typ zmiennej,       someNumber nazwa zmiennej,       znak =, który oznacza przypisanie do zmiennej,       wartość 123, tak zwany literał.           Druga linijka to wywołanie metody i przypisanie wyniku do zmiennej:            boolean określający typ zmiennej,       result nazwę zmiennej,       znak przypisania,       wywołanie metody isBig, jako argument do jej wywołania przekazałem wartość zmiennej someNumber.           Zauważ, że linijki z kodem kończą się znakiem ;. Wywołanie metody zawsze zawiera nazwę nawiasy () i nie zawiera {}.   Nazewnictwo   Każdy język programowania ma swego rodzaju standardy określające sposób w jaki powinno się nazywać metody, zmienne, funkcje, klasy itp. W języku Java używa się tzw. Camel Case. W uproszczeniu sprowadza się on do tego, że kolejne słowa łączy się w jeden ciąg znaków. Każde kolejne słowo pisze się wielką literą:      someSampleName,   example,   SampleClassName.   Swego rodzaju wyjątkiem są tu nazwy klas, które także zaczynają się od wielkiej litery.   Nie każdy ciąg znaków może być użyty jako nazwy klasy/zmiennej/metody. Niektórych znaków nie można używać. Podobnie jest z niektórymi słowami. Java ma zestaw słów, które są zastrzeżone i nie mogą być użyte jako nazwa zmiennej. Kilka przykładów:      boolean – jest to typ danych, nie można tak nazwać zmiennej,   class – jest to słowo kluczowe użyte przy definicji klasy,   return – słowo kluczowe użyte w metodzie oznacza wartość zwracaną przez daną metodę,   void – słowo kluczowe pokazujące brak zwracanej wartości,   #2someName! – nie wszystkie znaki są dopuszczalne. Dla uproszczenia można przyjąć, że można używać wyłącznie małych i wielkich liter od a do z bez polskich znaków2.   Konstrukcja if   Tę konstrukcję wprowadzam teraz tylko abyś mógł użyć jej w rozwiązaniu ćwiczenia. Szerzej opisałem ją w osobnym artykule.   Zacznę od fragmentu kodu:  boolean result = isBig(123); if (result) {     System.out.println(\"Liczba jest duza.\"); } else {     System.out.println(\"Liczba nie jest duza.\"); }   Pierwszą linijkę już znasz. To wywołanie metody isBig i przypisanie wyniku do zmiennej o nazwie result. Kolejna linijka to konstrukcja if. Konstrukcja ta sprawdza czy result ma wartość true. Jeśli tak, to zostanie wywołany kod, który jest w bloku otoczonym {}. Jeśli result ma wartość false wówczas zostanie wywołany kod znajdujący się w bloku po else.   Więc jeśli result ma wartość true wówczas zostanie wywołany kod:   System.out.println(\"Liczba jest duza.\");   Jeśli result ma wartość false to wywołany zostanie kod:   System.out.println(\"Liczba nie jest duza.\");   Ćwiczenie   Na koniec mam dla Ciebie małe ćwiczenie. Napisz metodę, która sprawdzi czy temperatura przekazana jako argument jest dodatnia. Po rozwiązaniu zadania możesz rzucić okiem na przykładowe rozwiązanie.   Jeszcze nie wiesz jak uruchomić tę metodę w działającym programie. Dowiesz się jak to zrobić w kolejnych etapach kursu.   Podsumowanie   I jak czujesz się po pierwszej lekcji? Udało Ci się wykonać ćwiczenie? Daj znać jak Ci poszło w komentarzach. W następnym artykule przeczytasz o klasach. Jeśli chcesz być na bieżąco proszę polub stronę Samouczka na Facebook’u.   Naukę dobrze jest rozpocząć w gronie znajomych motywując się nawzajem, proszę poleć im tę stronę – razem zaczniecie uczyć się programowania.                 DRY (ang. Don’t Repeat Yourself) zasada kładąca nacisk na redukcję powtarzającego się kodu. &#8617;                  Reguły są oczywiście dużo bardziej rozbudowane, jednak dla naszych potrzeb takie uproszczenie w zupełności wystarczy. &#8617;           ","categories": ["Kurs programowania Java","Programowanie"],
        "tags": [],
        "url": "/metody-w-jezyku-java/",
        "teaser": "/assets/images/2015/10/22_metody_w_jezyku_java.png"
      },{
        "title": "Obiekty w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Pakiet   Programy komputerowe składają się z wielu plików. Przy dużym projekcie składającym się z kilku tysięcy plików kluczowe staje się odpowiednie zarządzanie plikami z kodem źródłowym programu. Bez takiego zarządzania wydajność programisty mocno spada.   Więc czym jest pakiet? Pakiet wraz z nazwą klasy tworzy swego rodzaju “unikalny adres”. Podobnie jak ludzie mają swoje adresy tak klasy mają swoje pakiety, które pomagają zlokalizować klasy w trakcie działania programu.   package pl.samouczekprogramisty.kursjava;   Rozbijmy tę linię kodu na części pierwsze:     package – to słowo kluczowe podobnie jak class czy if, informuje kompilator o tym w jakim pakiecie znajduje się plik,   pl.samouczekprogramisty.kursjava – właściwa nazwa pakietu. Podobnie jak w przypadku omówionego w poprzednim artykule nazewnictwa metod tutaj obowiązują podobne zasady. Dla uproszczenia możemy powiedzieć, że dozwolone są małe litery oraz znak kropki.   Istnieje kilka zarezerwowanych nazw pakietów. Służą one do odróżnienia klas dostarczonych wraz z wirtualną maszyną Javy od klas tworzonych przez programistów. Innymi słowy pakiety tworzone przez Ciebie nie mogą zaczynać się od java. ani od javax..   Pakiety służą do grupowania klas, interfejsów, typów wyliczeniowych czy adnotacji. Jeśli czytasz artykuły chronologicznie te terminy prawdopodobnie są dla Ciebie nowe. Nie przejmuj się, opisałem je dokładnie w kolejnych artykułach.   Jak udało Ci się zauważyć nazwy pakietów są specyficzne. Przyjęło się, że za pakiet używa się odwróconej nazwy domeny. Takie podejście pozwala na łatwiejsze uniknięcie konfliktów. W przypadku naszego kursu użyłem pl.samouczekprogramisty.kursjava. Istotne jest tutaj odwzorowanie struktury katalogów. Każdy człon pakietu odpowiada katalogowi na dysku.             Pakiety w języku Java        W pliku źródłowym może znajdować się wyłącznie jedna linia z pakietem. Musi znajdować się na początku pliku. Nie jest to linia obowiązkowa, jednak używanie domyślnego pakietu nie jest dobrą praktyką1.   Nazwy pakietów powinny odwzorowywać ich zawartość. Np pakiet pl.samouczekprogramisty.animals mógłby zawierać klasę Dog, ale już klasa Owner powinna znaleźć się prawdopodobnie w innym miejscu.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Klasa   Klasy służą do grupowania atrybutów i metod, pakietów używamy do grupowania klas. Zanim pokażę Ci przykład kodu przejdziemy przez parę funkcji IDE, które na pewno przydadzą się w przyszłości.   Skróty klawiaturowe   IDE czy zwykły edytor tekstu są narzędziami pracy programisty. Znajomość narzędzi pracy znacząco zwiększa wydajność pracy. Innymi słowy bardzo przydatne jest używanie skrótów klawiaturowych. Postaram się przybliżyć Wam kilka z nich.   Po lewej stronie widzisz okno do przeglądania struktury projektu. To okienko możecie włączać/wyłączać używając skrótu &lt;Alt + 1&gt;2. Po kliknięciu w obszar tego okienka przyda się skrót &lt;Alt + Ins&gt;. W tym kontekście przyda się on do stworzenia nowego pakietu oraz pliku z naszą pierwszą klasą. Po naciśnięciu tego skrótu pokaże się Ci takie okienko.             Tworzenie pakietu        Gdy mamy już nasz pakiet używając tego samego skrótu możemy stworzyć klasę. W naszym przykładzie stworzyłem pakiet pl.samouczekprogramisty.kursjava.engine a w nim klasę Cogwheel.             Tworzenie klasy                  Tworzenie pakietu, dialog        package pl.samouczekprogramisty.kursjava.engine;  /**  * Created by &lt;uzytkownik&gt; on &lt;data&gt;.  */ public class Cogwheel { }   Podobnie jak poprzednio teraz linijka po linijce przeanalizuję wygenerowany kod. Pierwsza linijka nie jest już dla Ciebie niczym nowym, ot zwykła deklaracja pakietu. Ciekawsze są kolejne linie.   Komentarze w kodzie   Kolejne 3 linie to komentarz w kodzie. Komentarz w kodzie to dodatkowa wiadomość dla programisty. Czasami dodanie komentarza nad fragmentem bardziej skomplikowanego kodu pomaga w jego zrozumieniu. Komentarz jest pomijany w trakcie wykonywania programu.   W języku Java występują 2 typy komentarzy:      komentarze w kilku liniach – przykład widzisz powyżej, wszystko co znajduję się pomiędzy /** a */ traktowane jest jako komentarz.   komentarz jednoliniowy – wszystko co znajduje się za // do końca linii traktowane jest jako komentarz. Parę przykładów pokazałem poniżej:   int count = 3; // number of already read books // flag indicating if book was read boolean wasRead = false;   Definicja klasy   Kolejne 2 linijki to już właściwa definicja klasy:   public class Cogwheel { }   Poniżej opiszę każdy z elementów osobno:     public – modyfikator dostępu. Temat modyfikatorów dostępu opisałem dokładniej w osobnym artykule. Na tym etapie możesz założyć, że przed klasą stawiamy słowo kluczowe public i oznacza ono, że jest ona widoczna dla innych klas,   class – słowo kluczowe informujące kompilator o tym, że ma do czynienia z definicją klasy,   Cogwheel – nazwa klasy. Przyjęło się, że nazwę klasy zaczynamy wielką literą. Podobnie jak w przypadku pakietów nie możesz używać wszystkich znaków. Dla uproszczenia możesz założyć, że nazwa klasy musi zaczynać się wielką literą, później możesz używać wielkich/mały liter bądź cyfr,   {} – para nawiasów określająca tak zwany blok, podobnie jak w metodzie grupuje on kilka instrukcji. Wszystkie linie kodu znajdujące się między nawiasami klamrowymi składają się na pełną definicję klasy.   Poniżej ta sama klasa ale już trochę bardziej rozbudowana   public class Cogwheel {     private int size;     private int numberOfCogs;      public Cogwheel() {     }      public Cogwheel(int size, int noCogs) {         this.size = size;         numberOfCogs = noCogs;     } }   Pierwszy nowy element to tak zwany atrybut klasy:   private int size;      private – modyfikator dostępu. Tym razem jest to słowo kluczowe private. Oznacza tyle, że dany element (w tym przypadku atrybut) dostępny jest wyłącznie z wnętrza danej klasy,   int – znany już typ,   size – nazwa atrybutu. Konwencja nazewnicza zakłada, że nazwy atrybutów piszemy małą literą. Podobnie jak poprzednio w nazwach możemy używać małych liter, wielkich liter i cyfr.   Kolejne dwie metody to tak zwane konstruktory. Zauważ, że ich definicje są specjalne – nie mają typu zwracanego. Konstruktor służy, jak sama nazwa wskazuje, do tworzenia nowych instancji klasy. Każda klasa musi mieć konstruktor. Konstruktory to specjalne metody, które inicjalizują instancje klas.   Konstruktory wywołuje się dokładnie tak samo jak inne metody, dodatkowo używamy słowa kluczowego new:   cogwheel = new Cogwheel(); cogwheel = new Cogwheel(1, 2);   Pierwszy konstruktor to konstruktor bezparametrowy. Kolejny przyjmuje argument size i noCogs ale to dla Ciebie nic nowego, o argumentach wiesz wszystko z artykułu o metodach w języku Java. Nowością tutaj jest ciało konstruktora.   this.size = size; numberOfCogs = noCogs;   Obie linie przypisują wartość do atrybutu klasy. Pierwsza zawiera dodatkowe słowo kluczowe this aby odróżnić parametr size od atrybutu size. W następnej linii widzisz, że this nie jest wymagane jeśli jednoznacznie jesteśmy w stanie zidentyfikować atrybut.   Generowanie konstruktorów   IDE może nam pomóc przy pisaniu konstruktorów. Po naciśnięciu znanego już skrótu &lt;Alt + Insert&gt; w edytorze klasy pokaże się takie okienko.             Tworzenie konstruktora        W kolejnym można wybrać atrybuty klasy, które mają być przekazywane jako parametry.             Wybieranie parametrów konstruktora        Zauważ, że w poprzednim przykładzie klasy Cogwheel nie umieściłem definicji żadnego konstruktora. Kilka akapitów wcześniej napisałem, że każda klasa musi mieć konstruktor. Więc jak to właściwie jest z tym konstruktorem? Otóż kompilator tworzy domyślny konstruktor automatycznie jeśli programista nie zdefiniuje żadnego innego konstruktora.   Jeśli utworzysz jakikolwiek inny konstruktor przyjmujący parametry kompilator nie doda domyślnego, bezparametrowego konstruktora.   Kolejny przykład klasy   Poniżej już troszkę bardziej skomplikowany przykład. Proszę przeczytaj poniższy fragment kodu.   package pl.samouczekprogramisty.kursjava;   import pl.samouczekprogramisty.kursjava.engine.Cogwheel;   public class Engine {     private boolean started;     private Cogwheel cogwheel;       public Engine() {         cogwheel = new Cogwheel(4, 450);         started = true;     }     public Engine(Cogwheel cogwheel) {         this.cogwheel = cogwheel;     }       public void start() {         started = initiateStartingSequence();     }     private boolean initiateStartingSequence() {         return true;     }     public void stop() {         started = false;     }     public boolean isStarted() {         return started;     }     public void setStarted(boolean started) {         this.started = started;     } }   Poza używaniem typów, które już znasz, możesz używać już istniejących klas. Właśnie w ten sposób klasa Engine ma atrybut typu Cogwheel. Zwróć uwagę, że klasa Engine znajduje się w innym pakiecie niż klasa Cogwheel. Kompilator musi wiedzieć gdzie szukać tej klasy, właśnie z tego powodu dodaje się linijkę importującą tę klasę:   import pl.samouczekprogramisty.kursjava.engine.Cogwheel;      Deklaracja importu to coś zupełnie innego niż deklaracja pakietu, importów w klasie może być wiele (możemy korzystać z wielu innych klas), natomiast nasza klasa może być wyłącznie w jednym pakiecie.     Jeśli importujesz wiele klas z jednego pakietu zamiast wypisywać je wszystkie możemy użyć * np import pl.samouczekprogramisty.kursjava.engine.*; Tutaj przychodzi z pomocą IDE. Okazuje się, że programista używający IDE nie musi pisać tych linii, IDE dodaje te linijki automatycznie. IDE także pomaga przy pisaniu samego kodu. W trakcie pisania zobaczysz menu kontekstowe podpowiadające programiście fragmenty kodu. Skrótami klawiaturowymi, które jeszcze mogą przy tym pomóc są &lt;Ctrl + Space&gt; i &lt;Ctrl + Shift + Space&gt;. Oba z nich pomagają programiście, drugi jest bardziej „inteligenty” podpowiadając wyłącznie kod, który jest poprawny w danym kontekście.              Pomoc IDE        Metody nie zwracające żadnej wartości   Zwróćmy jeszcze uwagę na metodę   public void start() {     started = initiateStartingSequence(); }   Nowe dla Ciebie jest słowo kluczowe void w miejscu typu zwracanego. To słowo kluczowe informuje, że dana metoda nie zwraca żadnej wartości. W ciele tej metody do atrybutu started przypisuję wartość zwróconą przez metodę initiateStartingSequence.   Słowo kluczowe this   Proszę zwróć uwagę na dwa poniższe fragmenty kodu:   public class Engine {     private Cogwheel cogwheel;      public Engine(Cogwheel cogwheel) {         this.cogwheel = cogwheel;     } }   public class Engine {     private Cogwheel cogwheel;      public Engine(Cogwheel otherCogwheel) {         cogwheel = otherCogwheel;     } }   W pierwszym przypadku w konstruktorze zostało użyte słowo kluczowe this. Było ono potrzebne aby kompilator był w stanie odróżnić parametr cogwheel od atrybutu klasy cogwheel. W drugim przypadku słowo to nie było konieczne ponieważ w tym kontekście od razu wiadomo czym jest cogwheel – jest atrybutem klasy. Oba konstruktory robią dokładnie to samo, przypisują wartość parametru to atrybutu nowej instancji.   Gettery i settery   Znasz już 2 modyfikatory dostępu, private i public. Wiesz też, że atrybuty, metody które poprzedzone są modyfikatorem private są dostępne wyłącznie w danej klasie. Jak więc z zewnątrz można dowiedzieć się jaka jest wartość atrybutu started w instancji klasy Engine? Z pomocą przychodzą tak zwane “gettery” i “settery”. Jest to nic innego jak specyficzne metody, których jedynym zadaniem jest odpowiednio pobranie bądź ustawienie wartości atrybutu. Poniżej przykłady:   engine = new Engine(); // tworzymy instancje klasy engine.isStarted(); // zwraca wartość atrybutu engine.setStarted(true); // ustawia wartość atrybutu started w instancji engine   Gettery i settery to metody, których nazwy są określone przez specyfikację Java Beans. W skrócie:     metody pobierające wartość atrybutu mają nazwę get typ zwracany odpowiada typowi atrybutu. Metoda nie przyjmuje żadnego parametru. Specyfikacja dopuszcza pewien wyjątek w nazwie jeśli atrybut jest typu boolean. W takim przypadku możemy użyć nazwy is, reszta pozostaje bez zmian.   public boolean isStarted() // zwraca wartość atrybutu started public boolean getStarted() // zwraca wartość atrybutu started public Cogwheel getCogwheel() // zwraca wartość atrybutu cogwheel      metoda ustawiająca wartość atrybutu. Nową wartością jest parametr przekazany do tej metody. Nazwa metody musi pasować do wzorca set. Metoda musi przyjmować jeden parametr odpowiadający typowi atrybutu i nie może zwracać żadnej wartości.   public void setStarted(boolean started) // ustawia wartość atrybutu started public void setCogwheel(Cogwheel cogwheel) // ustawia wartość atrybutu cogwheel   Generowanie getterów setterów   Podobnie jak w przypadku generowania konstruktorów IDE pomaga w generowaniu getterów/setterów. W edytorze pomaga przy tym skrót &lt;Alt + Enter&gt; naciśnięty gdy kursor znajduje się na nazwie atrybutu.             Wybieranie parametrów konstruktora        Metody te można także wygenerować przy pomocy skrótu &lt;Alt + Insert&gt; naciśniętego w edytorze i wybraniu opcji “Getter and Setter”.             Tworzenie getterów i setterów        Ćwiczenie   Najwyższy czas na Twoje ćwiczenie. W ramach ćwiczenia utwórz nowy projekt, w nim utwórz 2 różne pakiety. W pakietach utwórz klasy odpowiadające kilku rodzajom zwierząt wraz z kilkoma atrybutami. Postaraj się używać przy tym poznanych dzisiaj skrótów. Jeśli chcesz, możesz spojrzeć na przykładowe rozwiązanie, które umieściłem na githubie.   Podsumowanie   Bardzo się cieszę, że doczytałeś do tego miejsca! Jak poszło Ci z ćwiczeniem? Proszę daj znać w komentarzach. Jeśli podobają Ci się artykuły na blogu byłbym bardzo wdzięczny gdybyś polecił blog swoim znajomym. Jak już powtarzałem – w grupie łatwiej się uczy :) Polub stronę na Facebooku, a nie przegapisz żadnego nowego artykułu. Do zobaczenia!                 Jeśli nie umieścisz żadnej deklaracji pakietu, dany typ (klasa, interfejs etc.) zostanie umieszczony w domyślnym, pustym pakiecie. &#8617;                  Taka notacja oznacza jednoczesne naciśnięcie dwóch klawiszy, w tym przypadku jest to Alt i 1. &#8617;           ","categories": ["Kurs programowania Java","Programowanie"],
        "tags": [],
        "url": "/obiekty-w-jezyku-java/",
        "teaser": "/assets/images/2015/11/01_obiekty_w_jezyku_java.jpg"
      },{
        "title": "Pierwszy program w Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Zaczynamy!   Zaczynamy z grubej rury, bez patyczkowania się:      otwórz IDE,   utwórz nowy projekt,   utwórz nowy pakiet (Alt + Insert),   utwórz nową klasę (Alt + Insert).   To już znasz, teraz czas na nowe rzeczy. Wszystkie elementy zostały opisane w poprzednich artykułach z cyklu:     Kurs programowania Java – przygotowanie środowiska   Kurs programowania Java – metody   Kurs programowania Java – obiekty i pakiety   Live templates   W ciele klasy, która została stworzona w poprzednim punkcie naciśnij Ctrl + J. Pokaże się okienko z podpowiedziami. To jest bardzo przydatna funkcja IDE pozwalająca bardzo szybki sposób pisać kod programiście.   Z okienka, które się pokazało wybierz psvm. Bum! Cała metoda już “się napisała” :) Teraz w edytorze wpisz sout i naciśnij Enter. Bum! Znów cała linijka jest gotowa. Napisaliśmy tylko kilka znaków, a całe ciało metody zostało stworzone za nas.   Poprzednie dwa akapity to nic innego jak funkcja Live templates IDE (dosłownie przetłumaczyć można to na żywe szablony). W trakcie kursu będziemy poznawali kolejne szablony pomagające w pisaniu kodu.             Dialog po naciśnięciu skrótu        Tworzenie zmiennych lokalnych   Następnie wewnątrz () wpisz message, bądź cokolwiek innego co nadaje się na nazwę zmiennej.   Jak widzisz IDE zaznacza tę nazwę na czerwono pokazując nam błąd. Oczywiście zmienna nie została jeszcze utworzona. Po naciśnięciu Alt + Enter pokaże nam okienko z możliwymi sposobami rozwiązania problemu.   Z okienka wybierz “Create local variable…“. IDE utworzy nam zmienną, musimy wybrać jej typ. Z dostępnej listy wybierz String i przypisz do niego jakiekolwiek zdanie otoczone \"\", jak w przykładzie:   String message = \"To jest mój pierwszy łańcuch znaków! Potocznie \\\"string\\\".\";       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Uruchomienie programu   Może nie uwierzysz, ale przy pomocy tych kilku skrótów klawiaturowych napisałeś swój pierwszy program, który możemy uruchomić! Jak to zrobić? Naciśnij skrót Alt + Shift + F10.   Z okienka, które się pokazało wybierz nazwę klasy i „Run”. To spowoduje uruchomienie programu, który napisałeś.   W dolnej część IDE pokaże się okno wyświetlające nasz program. Proste prawda? Nagrałem też filmik, pokazujący jak doszedłem do gotowej klasy. Możesz go obejrzeć na kanale youtube             Dialog uruchomienia programu        Istnieje również skrót Shift + F10, który pozwala na uruchomienie aktualnie edytowanej klasy (jeśli taka możliwość istnieje).   Omówienie kodu programu   Najwyższy czas na analizę kodu, który napisaliśmy.   package pl.samouczekprogramisty.kursjava;   public class Main {     public static void main(String[] args) {         String message = \"To jest mój pierwszy łańcuch znaków! Potocznie \\\"string\\\".\";         System.out.println(message);     } }   Linijka z pakietem to dla Ciebie nic nowego, więcej na temat pakietu przeczytasz w artykule o obiektach w języku Java. Później definiujemy klasę, również nic nowego. W tym samym artykule przeczytasz więcej o klasach.   Następna linijka to już dwie nowe rzeczy.   public static void main(String[] args)   Metody statyczne   Ten fragment kodu to nic innego jak definiowanie metody. Więcej o metodach przeczytasz w artykule o metodach w języku Java. Nowe jest jednak słowo kluczowe static. Przy pomocy tego słowa kluczowego definiujemy metody statyczne.   Jak pamiętasz do wywołania metody potrzebujemy instancji klasy:   Engine engine = new Engine(); engine.start();   Metody statyczne różnią się od zwykłych metod tym, że do ich wywołania nie potrzebujemy instancji klasy. Taką metodę możemy wywołać na klasie. Biorąc nasza przykładową klasę Main z metodą main wywołanie wyglądałoby następująco.   Main.main();   Typ tablicowy   Kolejna nowa rzecz to typ przekazywanego argumentu. String[] oznacza tablicę obiektów typu String. O tablicach więcej przeczytasz w jednym z kolejnych artykułów. Klasę String omówimy jednak trochę dokładnej, kilka akapitów poniżej.   System.out.println(message);   Ta konstrukcja jest trochę bardziej skomplikowana. Odwołujemy się tutaj do atrybutu out klasy System. System.out także jest obiektem, jest to obiekt klasy java.io.PrintStream. Klasa ta definiuje wiele metod, jedną z nich jest println, która wypisuje to co przekażemy jej jako parametr w osobnej linii1.   Klasa String   W każdym języku programowania, który znam istnieje sposób na zapisanie łańcucha znaków w sposób zrozumiały dla komputera. W języku Java do tego celu używamy klasy String.   String someRandomWord = \"słowo\";   Jak widzisz w linijce tworzymy zmienną someRandomWord typu String i przypisujemy jej wartość \"słowo\". Wszystko co jest otoczone \" oznacza String. Jest to konstrukcja wbudowana w język Java. Do utworzenia instancji obiektu String nie potrzebujemy konstruktora, wystarczy otoczyć łańcuch znaków \"\" jak w przykładzie wyżej.   Jeśli wewnątrz łańcucha znaków chcesz umieścić \" musisz go poprzedzić ukośnikiem \\ jak w przykładzie poniżej.   String escapedCharacter = \"This is an \\\" escaped charecter\";   Łańcuchy znaków możemy ze sobą łączyć przy pomocy symbolu +.   String productName = \"Coca\" + \"Cola\";   Kilka metod klasy String   Podobnie jak inne klasy String ma zestaw metod, których możemy użyć. Poniżej kilka z nich:     length – zwraca długość łańcucha znaków   int length = productName.length(); // w naszym przypadku zwraca 8      contains – sprawdza czy w łańcuchu znaków znajduje się ten przekazany jako parametr   productName.contains(„ocaCol”); // w naszym przypadku zwraca true productName.contains(„Pepsi”); // w naszym przypadku zwraca false      endsWith – spradza czy łańcuch kończy się przekazanym argumentem   productName.endsWith(„ola”); // w naszym przypadku zwraca true productName.endsWith(„oca”); // w naszym przypadku zwraca false   Metod jest sporo. Ponownie z pomocą przychodzi IDE. Wystarczy, że napiszesz . (kropkę) po instancji i od razu dostaniesz podpowiedzi z metodami, które możesz wywołać.             Dialog z metodami klasy String        JavaDoc   Przypadkiem nie próbuj ich zapamiętać! Owszem parę podstawowych wejdzie Ci w krew po pewnym czasie ale zakuwanie ich z kartką w ręku nie ma najmniejszego sensu. Z pomocą przychodzi dokumentacja. Każda klasa z biblioteki standardowej ma dokładną dokumentację opisującą wszystkie metody, ich argumenty i typy zwracane.   Na przykład dokumentację dla klasy String możesz znaleźć pod tym adresem https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/lang/String.html.   Pewnie pamiętasz jak na początku w artykule opisującym czym jest programowanie przekonywałem, że angielski to podstawa? :)   Biblioteka standardowa   String i dużo innych klas są częścią tak zwanej biblioteki standardowej. Jest to nic innego jak zestaw klas dostarczony wraz z językiem dostępny dla programisty. Znajdują się w w niej różne klasy używane na co dzień przez programistów np. java.io.PrintStream, java.lang.String czy java.lang.System, które poznałeś w tym artykule.   Zadanie   Napisz program, który wyświetli trzy różne zdania opisujące aktualną pogodę. W czwartej linii wypisz sumaryczną długość trzech poprzednich zdań.   Podsumowanie   Prawda, że nie było tak strasznie? Jeśli podobał Ci się dzisiejszy artykuł proszę polub stronę na Facebook’u.   Zależy mi na tym, żeby dotrzeć do jak największej liczby osób, które chcą się nauczyć programować, jeśli mógłbyś przekazać im informację o stronie byłbym ogromnie wdzięczny. Do następnego razu!                 To jest spore uproszczenie, tutaj musielibyśmy mówić o strumieniach, plikach, IO itd. dzisiaj to pominiemy, skupimy się na tym w przyszłości. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/pierwszy-program-w-java/",
        "teaser": "/assets/images/2015/11/08_pierwszy_program_w_java.png"
      },{
        "title": "Tablice w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Czym jest tablica   Tydzień ma siedem dni. Załóżmy, że pierwszy dzień tygodnia to poniedziałek. Wtorek jest drugi, środa jest następna itd. Dni możemy ułożyć w swego rodzaju ponumerowany szereg.   Tablica jednowymiarowa to nic innego jak właśnie taki ponumerowany szereg. W Javie elementy w tablicy numerujemy od 0. Więc w naszym przypadku poniedziałek ma numer 0, wtorek 1 itd. Numer identyfikujący każdy element tablicy to indeks.   Tablice grupują obiekty tego samego typu1. Mogą to być łańcuchy znaków, liczby, wartości logiczne, instancje klas stworzonych przez Ciebie, itd.   Tworzenie tablicy   Przekładając nasz przykład z dniami tygodnia na Javę dojdziemy do takiego fragmentu kodu   String[] daysOfWeek = new String[7]; daysOfWeek[0] = \"poniedziałek\"; daysOfWeek[1] = \"wtorek\"; daysOfWeek[2] = \"środa\"; daysOfWeek[3] = \"czwartek\"; daysOfWeek[4] = \"piątek\"; daysOfWeek[5] = \"sobota\"; daysOfWeek[6] = \"niedziela\";   W pierwszej linijce tworzymy nową tablicę obiektów typu String. Tablica może pomieścić 7 elementów. Poniedziałek ma indeks 0, niedziela ma indeks 6.   Raz przypisany obiekt w tablicy możemy nadpisać.   daysOfWeek[0] = \"Monday\";   Teraz pod indeksem 0 znajduje się Monday, pod 1 bez zmian nadal jest wtorek.   Jeśli spróbujesz odwołać się do nieistniejącego elementu w tablicy zostanie rzucony wyjątek java.lang.ArrayIndexOutOfBoundsException. O wyjątkach przeczytasz w jednym z kolejnych artykułów. Aktualnie wystarczy Ci informacja, że wyjątki sygnalizują sytuacje wyjątkowe :) i mogą przerwać działanie programu. Poniższa linijka zakończy program wyjątkiem, odwołujemy się tam do ósmego, nieistniejącego elementu tablicy.   System.out.println(daysOfWeek[7]);   Tablicę można też od razu zainicjalizować wartościami. Oba sposoby inicjalizacji tworzą obiekt tablicy. Zauważ, że w drugim przypadku nie musimy podawać jej długości. Jest ona znana na podstawie przekazanych wartości.   String[] wintersMonths = new String[] {\"grudzień\", \"styczeń\", \"luty\"};       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Atrybut length   Tablica to obiekt. Podobnie jak inne obiekty posiada swoje atrybuty i metody. Jedynym publicznie dostępnym atrybutem metody jest length. Atrybut ten przechowuje rozmiar tablicy   System.out.println(wintersMonths.length); // w naszym przypadku wyświetli 3   Tablice wielowymiarowe   Wyżej napisałem, ze w tablicy możesz trzymać dowolny obiekt. Tablica też jest obiektem :) Więc nic nie stoi na przeszkodzie, żeby w tablicach umieścić inne tablice. Tablica dwuwymiarowa to nic innego jak tabela zawierająca wiersze i kolumny w której możesz przechowywać dane.   Możliwe jest tworzenie tablic, które mają więcej niż 2 wymiary, jednak w praktyce raczej ich się nie spotyka. Jeśli potrzebna jest tak skomplikowana tablica programiści zazwyczaj przechowują dane w inny sposób używając zbiorów, map czy list2.   W naszym przykładzie tablicy dwuwymiarowej użyjemy do przechowywania stanu gry kółko krzyżyk   int[][] ticTacToeBoard = new int[3][]; ticTacToeBoard[0] = new int[3]; ticTacToeBoard[1] = new int[3]; ticTacToeBoard[2] = new int[3];   W pierwszy wierszu inicjalizujemy wyłącznie jeden z wymiarów. Musimy tam podać tylko liczbę wierszy, które będzie przechowywała nasza tablica dwuwymiarowa. Kolejne 3 linie kodu to inicjalizacja wierszy tablicy.   Jeśli każdy z wierszy tablicy wielowymiarowej ma dokładnie taki sam rozmiar możemy zainicjalizować ją w jednej linijce. Poniższy przykład ma ten sam efekt jak poprzedni:   int[][] ticTacToeBoard = new int[3][3];   ticTacToeBoard[0] odwołuje się do pierwszego wiersza w tablicy. ticTacToeBoard[0][0] odwołuje się do pierwszej komórki w pierwszym wierszu. W ten sposób każde pole na naszej planszy ma unikalny indeks składający się z dwóch liczb:                  00       01       02                 10       11       12                 20       21       22           Podobnie jak w przypadku tablicy jednowymiarowej i tu możemy przypisywać wartości. Poniżej przykładowy przebieg gry.   int nought = 1; // kółko int cross = 2; // krzyżyk ticTacToeBoard[1][1] = nought; ticTacToeBoard[2][2] = cross; ticTacToeBoard[0][0] = nought; ticTacToeBoard[1][2] = cross; ticTacToeBoard[0][2] = nought; ticTacToeBoard[0][1] = cross;   Spróbuj narysować sobie na kartce powyższy przebieg gry. Kto ma szanse na wygraną? :)   Magiczne liczby   Przykład z planszą do gry świetnie nadaje się do wytłumaczenia czym właściwie są magiczne liczby (ang. magic numbers). W kodzie programu bardzo często występują liczby. Liczby te w rzeczywistości mają jakieś znaczenie. W naszym przykładzie 1 to nie zwykła jedynka, a wartość oznaczająca kółko. Dobrą praktyką jest przypisanie takich „magicznych wartości” do zmiennych/stałych3 i używanie ich w kodzie. Na dłuższą metę kod używający nazwanych zmiennych w miejscu „magic numbers” jest bardziej czytelny i łatwiejszy w utrzymaniu.   ticTacToeBoard[1][1] = nought; ticTacToeBoard[2][2] = cross; ticTacToeBoard[1][1] = 1; ticTacToeBoard[2][2] = 2;   Poza czytelnością zyskujemy kolejną rzecz. Nie łamiemy zasady DRY (ang. Don’t Repeat Yourself)4.   Tablice o różnej liczbie elementów   Powyższy przykład do pokazujący planszę do gry w kółko i krzyżyk pokazuje kwadratową tablice dwuwymiarową. W języku Java istnieje możliwość utworzenia zagnieżdżonych tablic, w których każdy element ma różną długość. Proszę spójrz na przykład poniżej:   int[][] irregularArray = new int[3][]; irregularArray[0] = new int[3]; irregularArray[1] = new int[5]; irregularArray[2] = new int[2];   W tym przykładzie każda z zagnieżdżonych tablic ma różną długość.   Metody o zmiennej liczbie argumentów (ang. varargs)   Znasz już metodę main, domyślnie przyjmuje ona tablicę łańcuchów znaków. Równie dobrze tę metodę możemy zapisać jako:   public static void main(String ... args);   Inny przykład metody z wieloma argumentami to metoda sumująca wszystkie przekazane liczby:   int sum(int ... numbers);   Magiczny wielokropek to coś w rodzaju wzbogacenia składni (ang. syntactic sugar). Nasza metoda z przykładu może przyjąć dowolną liczbę argumentów typu int (ang. varargs). W szczególności może też nie przyjąć żadnego.   sum(); sum(1, 2, 3);   Metody mogą przyjmować wiele argumentów. Jednak argument z wielokropkiem może być tylko jeden i musi występować jako ostatni.   Jak wspomniałem wielokropek to wzbogacenie składni. W związku z tym obie metody w skompilowanej klasie są tożsame:   int sum(int ... numbers); int sum(int[] numbers);   Materiały dodatkowe   Jeśli chcesz przeczytać o tablicach w innym miejscu zachęcam do rzucenia okiem na linki poniżej:      Fragment wykładu na jednym z uniwersytetów w Stanach Zjednoczonych dotyczący tablic.   Zadania      Napisz metodę pobierającą dwuelementową tablicę liczb i zwracający ich sumę.   Napisz program pobierający trójelementową tablicę liczb i zwracający największą liczbę.   Jak przechowałbyś stan sudoku? Napisz program, który stworzy instancje tablicy służących do przechowywania sudoku i uzupełnij ją przykładową planszą.   Jak przechowałbyś stan gry w szachy? Napisz program, który stworzy instancje tablic służące do przechowywania stanu gry w szachy. Potrafiłbyś zachować w nim ostatni stan partii Kasparowa z Deep Blue?   Zachęcam Cię, do samodzielnego rozwiązania zadań, jeśli jednak miałbyś jakikolwiek problem możesz rzucić okiem na przykładowe rozwiązania. Pamiętaj, że rozwiązując zadania samodzielnie nauczysz się najwięcej.   Podsumowanie   Bardzo się cieszę, że przeczytałeś artykuł aż do końca. Jeśli masz jakiekolwiek uwagi proszę podziel się nimi w komentarzach. Byłbym także bardzo wdzięczny gdybyś przekazał swoim znajomym informację o blogu – jak zawsze zależy mi na dotarciu do jak największej grupy ludzi, którzy chcą uczyć się programować.   Jak zwykle informacje o artykule prezentuję na stronie na Facebooku. Polub ją, a będziesz otrzymywał informacje o nowych artykułach.                 Znów uproszczenie, jak poznamy dziedziczenie dowiesz się trochę więcej na ten temat. &#8617;                  Są to 3 podstawowe typy kolekcji w języku Java. Przeczytasz o nich w jednym z kolejnych artykułów. &#8617;                  O stałych przeczytasz w innym artykule. &#8617;                  W uproszczeniu zasada mówi o nie powtarzaniu tego samego kodu wielokrotnie, przeczytasz o tym w jednym z kolejnych artykułów. Poprę to lepszym przykładem niż ten w tym artykule. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/tablice-w-jezyku-java/",
        "teaser": "/assets/images/2015/11/11_tablice_w_jezyku_java.png"
      },{
        "title": "Pętle i instrukcje warunkowe w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Operatory logiczne   Zanim przejdę do opisania instrukcji warunkowych przeczytasz coś więcej na temat operatorów logicznych.   &lt; jest operatorem logicznym, który znasz z poprzednich artykułów. W Javie istnieje kilka operatorów logicznych:      == równe,   &lt; mniejsze,   &lt;= mniejsze bądź równe,   &gt; większe,   &gt;= większe bądź równe   Ich działanie możesz zobaczyć na kilku przykładach poniżej:   int x = 1; int y = 1; int z = 2;   x == y; // true x == z; // false x &lt; y; // false x &lt; z; // true x &lt;= y; // true // itd.   Proste operacje logiczne możesz ze sobą łączyć przy pomocy dodatkowych operatorów:     &amp;&amp; logiczne i,   || logiczne lub.   Pomocna przy tym może być następująca tabelka. Pokazuje ona podstawowe operacje logiczne1.                  Operacja       Wynik                       prawda i prawda       prawda                 prawda i fałsz       fałsz                 fałsz i prawda       fałsz                 fałsz i fałsz       fałsz                 prawda lub prawda       prawda                 prawda lub fałsz       prawda                 fałsz lub prawda       prawda                 fałsz lub fałsz       fałsz           Przekładając kilka powyższych linii na przykłady ze zmiennymi w Java wygląda to następująco:   int x = 1; int y = 1; int z = 2; x == y &amp;&amp; z &gt; y; // true &amp;&amp; true =&gt; true x &lt;= y &amp;&amp; z &lt;= x; // true &amp;&amp; false =&gt; false x == y || z &gt; y; // true || true =&gt; true x &lt;= y || z &lt;= x; // true || false =&gt; true   Operatory w języku Java mają swój priorytet. Dzięki temu mnożenie jest wykonywane przed dodawaniem. Podobnie jest tutaj, operatory &lt;, ==, &lt; itp. mają wyższy priorytet niż &amp;&amp; czy ||.   Skrócony cykl   Operatory &amp;&amp; i || są operatorami, które czasami mogą pomiąć sprawdzanie drugiej części warunku. Proszę spójrz na przykład:   public boolean metodaA() {     System.out.println(\"metodaA\");     return true; }  public boolean metodaB() {     System.out.println(\"metodaB\");     return false; }  metodaA() || metodaB();  // 1 metodaB() &amp;&amp; metodaA();  // 2   metodaA i metodaB to metody zwracające wartość logiczną. Dodatkowo każda z nich wypisuje na konsolę łańcuch znaków.   W pierwszym przypadku wartość całego wyrażenia to true jeśli którykolwiek z członów ma wartość true. W związku z tym drugi człon (w tym przypadku metodaB) nie musi być sprawdzany, ponieważ pierwszy (w tym przypadku metodaA) zwraca true.   W drugim przypadku wartość całego wyrażenia to false jeśli którykolwiek z członów ma wartość false. W związku z tym drugi człon (w tym przypadku metodaA) nie musi być sprawdzany,  ponieważ pierwszy (w tym przypadku metodaB) zwraca false.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Instrukcje warunkowe   Instrukcja if, else if, else   Do tej pory każda linijka kodu, którą napisałeś w działającym programie została wykonana. W większych programach często musimy decydować co powinno być wykonane. Na przykład jeśli jest temperatura jest większa niż 37°C2 oznacza to, że możesz być chory. Jeśli jest mniejsza niż 36°C możesz być osłabiony.   To jest najprostsza instrukcja warunkowa. Blok kodu zostanie wykonany jeśli wartość w nawiasie () będzie prawdą. W przykładzie sprawdzamy, czy temperatura jest mniejsza niż 36 stopni.   if (temperature &lt; 36) {     System.out.println(\"Jesteś osłabiony?\"); }   else, podobnie jak if, jest słowem kluczowym. Jeśli warunek przy instrukcji if nie zostanie spełniony wywołany zostanie zestaw instrukcji w bloku else.   if (temperature &lt; 36) {     System.out.println(\"Jesteś osłabiony?\"); } else {     System.out.println(\"Masz 36 lub więcej stopni.\"); }   W języku Java możesz także połączyć else z if jak w przykładzie poniżej:   int temperature = 38; if (temperature &lt; 36) {     System.out.println(\"Jesteś osłabiony?\"); } else if (temperature &lt; 37) {     System.out.println(\"Wszystko w normie!\"); } else if (temperature &lt; 38) {     System.out.println(\"Jesteś przeziębiony?\"); } else {     System.out.println(\"Masz co najmniej 38 stopni! Biegiem do lekarza!\"); }   Kod ten na początku sprawdza czy temperatura jest mniejsza niż 36°C. Jeśli ten warunek nie jest spełniony sprawdzamy czy temperatura jest mniejsza niż 37°C. Podobnie działa kolejny warunek. Jeśli żaden z nich nie jest spełniony zostaje wykonany kod w bloku po else.   Instrukcja switch   Jeśli mamy kilka warunków if następujących po sobie możemy zamienić je na inną konstrukcję – switch. Przejdźmy od razu do przykładu:   int temperature = 37; switch (temperature) {     case 35:         System.out.println(\"Jesteś osłabiony?\");         break;     case 36:         System.out.println(\"Wszystko w normie!\");         break;     case 37:         System.out.println(\"Jesteś przeziębiony?\");         break;     case 38:         System.out.println(\"Chyba jesteś chory.\");         break;     default:         System.out.println(\"Nie wiem jak się czujesz :(\");         break; }   switch w przykładzie powyżej sprawdza wartość zmiennej temperature i w zależności od jej wartości wykonuje odpowiedni kod zdefiniowany w case poniżej. W naszym przypadku na ekranie zostanie wypisane Jesteś przeziębiony?.   Proszę zwróć uwagę na nowe słowo kluczowe break. switch dopasowuje case do wartość zmiennej, i wykonuje kod od pierwszego pasującego warunku do słowa kluczowego break.   int temperature = 35; switch (temperature) {     case 35:         System.out.println(\"Jesteś osłabiony?\");     case 36:         System.out.println(\"Wszystko w normie!\");     case 37:         System.out.println(\"Jesteś przeziębiony?\");         break;     case 38:         System.out.println(\"Chyba jesteś chory.\");         break; }   W przykładzie powyżej break zostało pominięte przy case 35 oraz case 36. Wartość zmiennej pasuje do case 35. Przez pominięcie słowa kluczowego break na ekranie zostaną wypisane 3 linijki. Dzieje się tak dlatego, że słowo kluczowe break zostało wypisane dopiero przy case 37.   Jesteś osłabiony? Wszystko w normie! Jesteś przeziębiony?   Warunek default zostaje wykonany jeśli żadna gałąź case nie pasuje do wartości zmiennej. Zachęcam Cię do eksperymentowania :).   Instrukcja switch jest trochę ograniczona. Sprawdzana zmienna może być zmienną kilku typów na przykład int czy String.   Pętle w języku Java   Pętla for   Pętla pozwala na wykonanie fragmentu kodu wielokrotnie. Na przykład jeśli chcemy wypisać wszystkie liczby od 0 do 10 możemy to zrobić przy pomocy pętli   for (int number = 0; number &lt;= 10; number++) {     System.out.println(number); }   Pierwsza linijka to nic innego jak właśnie definicja pętli for. Kod wewnątrz nawiasu () możemy podzielić na trzy części:     inicjalizacja zmiennych,   sprawdzenie warunku,   zmiana wartości zmiennych.   W części inicjalizującej zmienne robimy coś co już znasz, tworzymy zmienną number i przypisujemy jej wartość 0. Kolejna część to sprawdzenie czy wartość zmiennej jest mniejsza bądź równa 10. Nowa dla Ciebie jest trzecia część a właściwie operator ++. Proszę spójrz na przykład poniżej:   int counter = 0; counter = counter + 1; counter += 1; counter++;   Każda z trzech ostatnich linii zwiększa o jeden wartość zmiennej counter. Ostatnia wersja jest najkrótsza dlatego jest najczęściej spotykana w tego typu pętlach.   Kolejnym przykładem użycia pętli może być wyświetlenie każdego elementu tablicy   int[] primeNumbers = new int[] {2, 3, 5, 7}; for (int index = 0; index &lt; primeNumbers.length; index++) {     System.out.println(primeNumbers[index]); }   W pierwszej linijce definiujemy tablicę z kilkoma liczbami pierwszymi (jeśli nie wiesz czym są liczby pierwsze możesz przeczytać o nich w artykule na Wikipedii). Następnie w pętli wyświetlamy każdy element tej tablicy.   Istnieje też uproszczona wersja pętli for. Jeśli nie musisz mieć dostępu do zmiennej reprezentującej na przykład indeks tablicy możesz użyć poniżej wersji pętli.   for (int primeNumber : primeNumbers) {     System.out.println(primeNumber); }   Tutaj w pierwszej linijce do zmiennej primeNumber przypisujemy kolejne elementy tablicy primenNumbers, które następnie wyświetlamy na ekranie.   Obie wersje pętli for możesz utworzyć dużo łatwiej. Z jednego z poprzednich artykułów wiesz już o istnieniu live templates. Okazuje się, że IntelliJ Idea pomaga nam także w tworzeniu pętli. Wystarczy, że wpiszesz fori i naciśniesz Enter, IntelliJ Idea wstawi szablon pętli za Ciebie. Jeśli w ten sam sposób chcesz wstawić szablon uproszczonej pętli for możesz wpisać I i nacisnąć Enter.   Pętla while   W języku Java istnieją także inne konstrukcje pętli. Kolejnym przykładem jest pętla while. Tym razem przejdziemy od razu do przykładu   int number = 0; while (number &lt; 10) {     System.out.println(number);     number++; }   Pętla while wykonuje swoje ciało (kod wewnątrz {}) tak długo jak spełniony jest warunek zapisany pomiędzy () (lub pętla nie zostanie przez nas przerwana). Podobnie jak w poprzednich przykładach pętla wyświetla zestaw liczb, tym razem liczby od 0 do 9.   Poniżej kolejny przykład pętli while. Tym razem warunek zakończenia pętli sprawdzany jest w jej ciele. Użyliśmy do tego celu instrukcji warunkowej if. Słowo kluczowe break napotkane wewnątrz pętli natychmiast przerywa jej wykonanie (dotyczy to także pętli for).   int number = 0; while (true) {     System.out.println(number);     number++;     if (number == 10) {         break;     } }   Nieskończona pętla   Pętle mają to do siebie, że przy źle zdefiniowanych warunkach mogą wykonywać kod wewnątrz swojego ciała w nieskończoność. Jest to dość częsty błąd, szczególnie spotykany na początku przygody z programowaniem. Dlatego należy uważnie sprawdzać warunki zakończenia pętli, żeby uniknąć tego błędu.   Poniżej przykład pętli wyświetlającej 1 w nieskończoność.   while(true) {     System.out.println(1); }   Słowa kluczowe wewnątrz pętli   Znasz już słowo kluczowe break. Powoduje ono zakończenie pętli w której aktualnie jesteś. Kolejna iteracja nie zostanie uruchomiona. Istnieje także słowo kluczowe continue, które także można użyć w ciele pętli (zarówno for jak i while).   To słowo kluczowe powoduje przeskoczenie do kolejnej iteracji pętli. Proszę spójrz na przykład poniżej, który wypisuje liczby nieparzyste mniejsze od 10 używając pętli while:   int i = 0; while (i &lt; 10) {     i++;     if (i % 2 == 0) {         continue;     }     System.out.println(i); }   Zadania      Poza poznanym dzisiaj operatorem ++ istnieje też jego odpowiednik zmniejszający wartość zmiennej o 1. Jest nim --. Napisz program, który wypisze na ekranie malejąco wszystkie liczby od 20 do 10.   Napisz pętlę while, która wypisze na ekranie wszystkie liczby od 10 do 20 włącznie.   Napisz pętlę for, która wypisze na ekranie wszystkie liczby nieparzyste od -10 do 40.   Przerób pętlę z zadania trzeciego na pętlę while.   Napisz metodę, która jako jedyny argument przyjmie zmienną typu int[] i zwróci sumę wszystkich elementów tablicy.   Przerób funkcję z zadania piątego tak, żeby metoda przyjmowała tablicę dwuwymiarową typu int[][].   Przygotowałem też zestaw przykładowych rozwiązań powyższych zadań. Zachęcam jednak do ich samodzielnego rozwiązania, wtedy nauczysz się najwięcej.   Podsumowanie   Dzisiaj znów nauczyłeś się paru nowych rzeczy dotyczących Javy. Mam nadzieję, że artykuł Ci się spodobał. Jeśli tak będę wdzięczny jeśli podzielisz się nim ze swoimi znajomymi. Proszę polub stronę na Facebooku jeśli nie chcesz pominąć żadnego nowego artykułu. Na dzisiaj już starczy wiedzy :) Miłego dnia i do następnego razu!                 Tak zwaną algebrę Boole’a &#8617;                  Tutaj lepszym pomysłem byłyby liczby “z przecinkiem”, napisałem osobny artykuł na temat liczb zmiennoprzecinkowych. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/petle-i-instrukcje-warunkowe-w-jezyku-java/",
        "teaser": "/assets/images/2015/11/08_pierwszy_program_w_java.png"
      },{
        "title": "Typy proste w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Typ prosty   Znasz już typy proste z poprzednich artykułów. int czy boolean są tu dobrymi przykładami. Typy proste nie są instancjami obiektów więc nie mają żadnych metod. Poniżej przykład zmiennych typów, które już znasz:   int age = 18; boolean isAdult = true;   Jednak poza powyższymi przykładami istnieją też inne typy proste:     byte typ, który może przechowywać liczby całkowite z zakresu od -128 do 127,   short typ, który może przechowywać liczby całkowite z zakresu od -32’768 do 32’767,   int ten już znasz, nowy dla Ciebie będzie zakres możliwych liczb do przechowania -2’147’483’648 do 2’147’483’647,   long podobnie jak poprzednie typy służy do przechowywania liczb całkowitych, jednak tutaj zakres jest znacznie większy: od -9’223’372’036’854’775’808 do 9’223’372’036’854’775’807.   byte daysInMonth = 31; short daysInYear = 365; long veryLargeNumber = 72036854775807L;   Proszę zwróć uwagę na zmienną veryLargeNumber. Zauważyłeś L na końcu? Dołączenie L na końcu sprawia, że używamy literału typu long.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Czym jest literał?   Zaraz, zaraz! Czym jest literał!? To nic skomplikowanego, jest to po prostu fragment kodu programu, który może być przypisany do zmiennej i nie jest wywołaniem konstruktora ani złożoną instrukcją. Przykładowe literały, które przechowują liczby:   18 0b11100 -0xFF00 0777 +78_123_898 45L 45l      18 – nic nowego, zwykła liczba, którą już znasz,   0b11100 – też liczba, tylko zapisana binarnie, o tym typie zapisywania liczb przeczytasz w jednym z kolejnych artykułów,   -0xFF00 – tym razem liczba zapisana w systemie szesnastkowym,   0777 – tak wygląda liczba zapisana w systemie ósemkowym,   +78_123_898 – to nic innego jak 78123898, tylko zapisane w troszkę inny sposób. Znak + na początku jest zbędny (domyślnie literały przechowują liczby dodatnie). Znaki _ podobnie nie są obowiązkowe, służą jedynie do zwiększenia czytelności liczby.   45L – domyślnie wszystkie literały liczb całkowitych mają typ int. Żeby dać znać kompilatorowi o tym, ze ten literał może przechowywać większe wartości musimy dodać L na końcu   45l – podobnie jak powyżej literał typu long, jednak tutaj na końcu widzimy małą literę l. Mimo tego, że taka konstrukcja jest dopuszczalna nie jest dobrą praktyką. l często może być pomylone z 1, szczególnie jeśli używana jest czcionka o stałej szerokości.   Domyślna konwersja   Możesz zadać sobie teraz pytanie. Dlaczego musimy dodawać L na końcu liczby typu long, a nie musimy nic dodawać dla liczby typu short czy int? Okazuje się, że kompilator wykonuje za nas automatycznej konwersji typu:   short daysInYear = (short) 365;   Wartość w nawiasie mówi o tym na jaki typ chcemy rzutować 365 będące typu int. W tym przypadku rzutowanie nie jest potrzebne bo kompilator wykona tę konwersję za nas. Jeśli jednak będziesz chciał przypisać wartość typu int do wartości typu short musisz takiej konwersji dokonać.   int someSmallNumber = 356; short daysInYear = (short) someSmallNumber;   W przykładzie powyżej kompilator już takiej konwersji nie wykona automatycznie, programista musi sam o nią zadbać.   Zupełnie inną sprawą jest czy powinniśmy tak robić :) Jakim cudem int, który może przechowywać dużo większe liczby może się “zmieścić” w typie short? Otóż nie może :)   short overflow = (short) 1_111_111; System.out.println(overflow);   Jak myślisz co zostanie wyświetlone na konsoli? Nie, nie będzie to 1’111’111. Komputer wyświetli -3001 :) Dzieje się tak dlatego, że liczba 1’111’111 jest większa od maksymalnej wartości jaką może przechowywać short.   To co musisz zapamiętać z tego podrozdziału to fakt, że część konwersji wykonywana jest automatycznie, a część spada na programistę. Te drugie są bardziej niebezpieczne bo mogą prowadzić do niespodziewanych rezultatów.   Znak   Znasz już klasę String. Instancja klasy String przechowuje łańcuch znaków. Pojedynczy znak natomiast może być przechowywany w zmiennej typu char jak w przykładzie poniżej.   char firstAlphabetLetter = 'a';   'a' też jest literałem, jest to literał typu char. Jeśli jesteśmy przy znakach to możemy zahaczyć też o łańcuchy znaków. Znany Ci już \"xyz\" to literał typu String.   Liczby zmiennoprzecinkowe   Do tej pory używaliśmy wyłącznie liczb całkowitych. W Javie istnieją też oczywiście typy proste, które mogą przechowywać liczby zmiennoprzecinkowe. Istnieją dwa takie typy:     float,   double.   Podobnie jak w przypadku int i long, float i double różnią się wielkością liczb, które mogą przechowywać. double może przechowywać dużo większe liczby niż float. Na końcu literałów typu float musimy dodawać f bądź F jak w przykładzie poniżej.   float pi = 3.14F; double g = 9.80665;   Chociaż typy te doskonale nadają się do przechowywania np. temperatury w programie, który napiszesz w ramach ćwiczenia to już do “poważnych” obliczeń te typy się nie nadają. W dużym uproszczeniu można powiedzieć, że komputer ma problem z przechowywaniem pewnych ułamków. W poważniejszych obliczeniach wymagających liczb zmiennoprzecinkowych używamy innych typów takich jak java.math.BigDecimal.   123 jest literałem, podobnie jest z 3.14F, ten drugi to literał przechowujący liczbę zmiennoprzecinkową. W Javie zawsze do oddzielenia liczby całkowitej (3) od dziesiętnej (14) używamy znaku . (kropki).   Typy proste a obiekty   Każdy z typów prostych ma odpowiadający mu obiekt:   byte b1 = 10; Byte b2 = Byte.valueOf((byte) 10);   short s1 = 10; Short s2 = Short.valueOf((short) 10);   int i1 = 10; Integer i2 = Integer.valueOf(10);   long l1 = 10L; Long l2 = Long.valueOf(10L);   boolean bo1 = true; Boolean bo2 = Boolean.valueOf(true)   char c1 = 'c'; Character c2 = Character.valueOf('c');   float f1 = 1.2F; Float f2 = Float.valueOf(1.2F);   double d1 = 1.2; Double d2 = Double.valueOf(1.2);   Jak widzisz tworzenie obiektów jest trochę “trudniejsze” niż tworzenie zmiennych typów prostych. Jednak nie jest to wymagane. W Javie istnieje tak zwany autoboxing/unboxing:   Byte b3 = 10; Short s3 = 10; Integer i3 = 10; Long l3 = 10L; Boolean bo3 = true; Character c3 = 'c'; Float f3 = 1.2F; Double d3 = 1.2   W przykładach powyżej kompilator Javy automatycznie opakował typy proste do obiektów (autoboxing). Operacja odwrotna (unboxing) także jest możliwa:   int i4 = Integer.valueOf(12);   Pobieranie danych od użytkownika   Teraz jak znasz już wszystkie typy proste w języku Java nadszedł moment na napisane pierwszego interaktywnego programu. W programie zapytamy użytkownika o siedem kolejnych temperatur i policzymy średnią temperaturę. Do napisania takiego programu użyjemy znanych już pętli.   Zanim jednak do tego przejdziemy musisz poznać klasę java.util.Scanner. Jest to klasa dostępna w standardowej bibliotece Javy, która może nam pomóc w pobieraniu danych od użytkownika.   Standardowe wejście i standardowe wyjście   W przypadku komputerów możemy mówić o tak zwanym standardowym wejściu i standardowym wyjściu. Możemy to uprościć do tego, że standardowe wyjście to znaki, które wypisujemy na konsoli. Standardowe wyjście jest reprezentowane przez obiekt System.out. Już to znasz: System.out.println(\"standardowe wyjście\"). To nic innego jak użycie metody println na obiekcie System.out.   Klasa Scanner używa obiektu standardowego wejścia upraszczając programiście pobieranie danych od użytkownika:   Scanner inputScanner = new Scanner(System.in);   Klasa Scanner ma kilka ciekawych metod, których możemy użyć, m.in.:     inputScanner.nextInt(),   inputScanner.nextDouble().   Metody te odpowiednio pobierają liczbę całkowitą i liczbę zmiennoprzecinkową. Poniżej przykładowy program pobierający siedem temperatur dla kolejnych dni.   public class AverageTemperature {     public static void main(String... args) {         double[] temperature = new double[7];         Scanner inputScanner = new Scanner(System.in);           for(int i = 0; i &lt; temperature.length; i++) {             System.out.println(\"Wprowadź liczbę \" + i);             temperature[i] = inputScanner.nextDouble();         }           double summarizedTemp = 0;         for (double temp : temperature) {             summarizedTemp += temp;         }           System.out.println(\"Średnia temperatura wynosi \" + (summarizedTemp / temperature.length));     } }   Jeśli masz jakiekolwiek pytania dotyczące kodu powyżej proszę zadaj je w komentarzach.   Ćwiczenie   Teraz ćwiczenie dla Ciebie. Napisz program, który policzy średnią z kilku przedmiotów. Możemy założyć, że uczeń w szkole ma 3 przedmioty i z każdego z nich dostał po 4 oceny.   Do wykonania tego zadania możesz potrzebować tablic wielowymiarowych i zagnieżdżonych pętli. Dla przypomnienia możesz zajrzeć do artykułu o tablicach wielowymiarowych i pętlach w języku Java.   Zagnieżdżona pętla to nic innego jak pętla umieszczona w ciele innej pętli. Dla przykładu pętle, które mogą pomóc Ci wykonać zadanie mogą wyglądać tak:   int numberOfClasses = 3; int numberOfNotes = 4; for (int classIndex = 0; classIndex &lt; numberOfClasses; classIndex++) {     for (int noteIndex = 0; noteIndex &lt; numberOfNotes; noteIndex++) {         // zadanie ;)     } }   Jeśli masz jakiekolwiek pytania podziel się nimi w komentarzach. Pochwal się też jeśli udało Ci się wykonać to zadanie :) Jeśli będziesz miał problemy z jego wykonaniem możesz rzucić okiem do przykładowego rozwiązania.   Materiały dodatkowe   Temat bynajmniej nie jest wyczerpany. Jeśli chcesz bardziej pogłębić swoją wiedzę przygotowałem dla Ciebie zestaw linków z dodatkowymi materiałami do nauki. Część z nich jest w języku angielskim.     Dokumentacja do klasy Scanner   System szesnastkowy zapisu liczb,   System ósemkowy zapisu liczb,   Rozdział w Java Language Specification dotyczący typów prostych,   Rozdział w Java Language Specification dotyczący literałów,   Kod źródłowy przykładów użytych w artykule.   Podsumowanie   Dzisiaj poznałeś całkiem sporo nowych rzeczy. Znasz już wszystkie typy proste w Javie i typy je opakowujące. Wiesz już czym jest literał i jakie są ich rodzaje. Umiesz pobierać dane od użytkownika. Innymi słowy masz już wszystkie klocki potrzebne do budowania interaktywnych programów :).   Mam nadzieję, że artykuł Ci się spodobał. Jeśli tak to proszę podziel się nim ze swoimi znajomymi. Jeśli chcesz wiedzieć o nowych wpisach proszę polub samouczkową stronę na Facebook’u. Trzymaj się! Do następnego razu!  ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/typy-proste-w-jezyku-java/",
        "teaser": "/assets/images/2015/11/29_typy_proste_w_jezyku_java.jpg"
      },{
        "title": "Interfejsy w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Interfejs   Wyobraź sobie kuchenkę mikrofalową. Kuchenka ma zestaw przycisków, parę pokręteł możliwe, że dodatkowy wyświetlacz. Ten zestaw to nic innego jak właśnie interfejs (ang. interface). Interfejs to zestaw „mechanizmów” służących do interakcji, w tym przypadku z kuchenką mikrofalową.   Pojęcie interfejsu można także przenieść do świata programowania. Mówimy wówczas o tak zwanym API (ang. Application Programming Interface).   Interfejs w kontekście programowania w języku Java to zestaw metod bez ich implementacji (bez kodu definiującego zachowanie metody)1. Właściwa implementacja metod danego interfejsu znajduje się w klasie implementującej dany interfejs.   W języku Java do definiowania interfejsów używamy słowa kluczowego interface. Interfejsy, podobnie jak klasy, definiujemy w osobnych plikach. Nazwa pliku musi odpowiadać nazwie interfejsu.   public interface Clock {     long secondsElapsedSince(LocalDateTime date); }   Powyżej mamy przykład interfejsu o nazwie Clock, który ma jedną metodę secondsElapsedSince, która przyjmuje argument typu LocalDateTime2 i zwraca wynik typu long mówiący o liczbie sekund, która minęła od czasu przekazanego w argumencie.   Wszystkie metody zawarte w interfejsie domyślnie są publiczne więc w tym przypadku można ominąć słowo kluczowe public, nie jest potrzebne.   Poza zwykłymi metodami w interfejsie mogą się znajdować      metody domyślne,   metody prywatne,   metody statyczne,   stałe.   Więcej o metodach statycznych możesz przeczytać w artykule opisującym pierwszy program w języku Java. Nie jest to dla Ciebie nic nowego. Metody domyślne i stałe wymagają dodatkowego wyjaśnienia.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Metody domyślne   Istnieje możliwość zdefiniowania tak zwanych metod domyślnych. Metody te mogą mieć właściwą implementacje w ciele interfejsu. Metody takie poprzedzone są słowem kluczowym default jak w przykładzie poniżej   public interface MicrowaveOven {     void start();      void setDuration(int durationInSeconds);      boolean isFinished();      void setPower(int power);      default String getName() {         return \"MicrovaweOwen\";     } }   Klasy, które implementują interfejs mogą nadpisać metodę domyślną.   Metody prywatne   Metody prywatne poprzedzone są słowem kluczowym private3. Metody prywatne, w odróżnieniu od pozostałych, mogą być wywołane wyłącznie w definicji interfejsu.   Z racji tego ograniczenia, metody prywatne w interfejsach mają sens wyłącznie w połączeniu z metodami domyślnymi. Proszę spójrz na przykład poniżej, w którym modyfikuję interfejs MicrowaveOven:   public interface MicrowaveOven {     // removed for brevity     default Duration getRecommendedDefrostTime(double foodWeightInGrams) {         double frostRate = 0.8;         int power = 300;         return getRecommendedTime(power, frostRate, foodWeightInGrams);     }      default Duration getRecommendedWarmingUpTime(double foodWeightInGrams) {         double frostRate = 0.2;         int power = 700;         return getRecommendedTime(power, frostRate, foodWeightInGrams);     }      private Duration getRecommendedTime(int power, double frostRate, double foodWeightInGrams) {         double durationInMinutes = foodWeightInGrams / ((1 - frostRate) * power);         long durationInSeconds = (long) (durationInMinutes * 60);         return Duration.ofSeconds(durationInSeconds);     } }   Metody prywatne w interfejsach pozwalają na usunięcie kodu, który powtarza się w wielu miejscach. Ten powtarzający się kod jest wówczas zawarty w ciele metody prywatnej.   Więcej o dobrych praktykach w programowaniu możesz przeczytać w osobnym artykule opisującym DRY, KISS i YAGNI. Kilka uwag zebrałem też w artykule opisującym najczęściej popełniane błędy.   W przykładzie powyżej dwie domyślne metody getRecommendedDefrostTime i getRecommendedWarmingUpTime używają metody prywatnej getRecommendedTime, która pozwala na użycie „magicznego” wzoru na obliczanie zalecanej długości czasu pracy mikrofalówki. Bez tej metody wzór musiałby znaleźć się w obu metodach co powodowałoby duplikację kodu4.   Wartości niezmienne i stałe   int counter = 123;   counter to zmienna. Do zmiennej counter możemy przypisać nową wartość:   counter = counter + 1;   Wartości niezmienne w odróżnieniu od zmiennych poprzedzamy słowem kluczowym final. Poniżej możesz zobaczyć przykład klasy z atrybutem, którego wartości nie możemy przypisać na nowo. Atrybuty tego typu możemy inicjalizować jak w przykładzie poniżej: bezpośrednio bądź w ciele konstruktora.   public class Calculator {     public final double PI = 3.14;     public final double SQRT_2;      public Calculator() {         SQRT_2 = Math.sqrt(2);     } }   Wartości niezmienne, podobnie jak metody, mogą być przypisane do instancji bądź klasy. Jeśli taka wartość przypisana jest do klasy mówimy wówczas o stałej. Jeśli chcemy aby stała była przypisana do klasy poprzedzamy ją słowem kluczowym static.   Do stałych wartość możemy przypisać wyłącznie raz – podczas inicjalizacji klasy. Zgodnie z konwencją nazewniczą stałe piszemy wielkimi literami.   public interface Cat {     int NUMBER_OF_PAWS = 4; }   W interfejsie powyżej mamy stałą, która pokazuje ile łap ma kot. Domyślnie wszystkie atrybuty interfejsu są stałymi publicznymi przypisanymi do interfejsu więc słowa kluczowe public static final mogą zostać pominięte.   Implementacja interfejsu   Sam interfejs nie jest zbyt wiele warty bez jego implementacji. Poniżej możesz zobaczyć przykładową, prostą implementację.   public interface Clock {     long secondsElapsedSince(LocalDateTime date); }  public class BrokenClock implements Clock {     public long secondsElapsedSince(LocalDateTime date) {         return 300;     } }   Klasa BrokenClock implementuje interfejs Clock. Zwróć uwagę na słowo kluczowe implements. Używamy go żeby pokazać że klasa BrokenClock implementuje interfejs Clock.   W języku Java jedna klasa może implementować wiele interfejsów. W takim przypadku klasa implementująca musi definiować metody wszystkich interfejsów, które implementuje5.   Dziedziczenie interfejsów   Dziedziczenie to temat na osobny, obszerny artykuł. Jednak już teraz wspomnę, że interfejsy mogą dziedziczyć po innych interfejsach. Dziedziczenie oznaczane jest słowem kluczowym extends. Interfejs, który dziedziczy po innych interfejsach zawiera wszystkie metody z tych interfejsów.   public interface Cat {     int NUMBER_OF_PAWS = 4;      String getName(); }  public interface LasagnaEater {     String getLasagnaRecipe(); }  public interface FatCat extends Cat, LasagnaEater {     double getWeight(); }   W przykładzie powyżej klasa implementująca interfejs FatCat, musi zaimplementować 3 metody:     String getName(),   String getLasagnaRecipe(),   duble getWeight().   Interfejs znacznikowy   A czy możliwa jest sytuacja kiedy interfejs nie ma żadnej metody? Oczywiście, że tak. Mówimy wówczas o interfejsie znacznikowym. Jak sama nazwa wskazuje służy on do oznaczenia, danej klasy. Dzięki temu możesz przekazać zestaw dodatkowych informacji. Przykładem takiego interfejsu jest java.io.Serializable, którego używamy aby dać znać kompilatorowi, że dana klasa jest serializowalna (o serializacji przeczytasz w innym artykule).   Interfejs a typ obiektu   Każdy obiekt w języku Java może być przypisany do zmiennej określonego typu. W najprostszym przypadku jest to jego klasa.   Interfejsy pozwalają na przypisane obiektu do zmiennej typu interfejsu. Wydaje się to trochę skomplikowane jednak mam nadzieję, że przykład poniżej pomoże w zrozumieniu tego tematu.   public class Garfield implements FatCat {     // implementacja metod }   Diagram poniżej to tak zwany diagram klas. Więcej o tej notacji przeczytasz we wprowadzeniu do UML.             Przykład hierarchii dziedziczenia        Garfield garfield = new Garfield(); FatCat fatCat = new Garfield(); Cat cat = new Garfield(); LasagnaEater lasagnaEater = new Garfield();   Instancję klasy Garfield możemy przypisać zarówno do zmiennej klasy Garfield jak i każdego z interfejsów, który ta klasa implementuje (bezpośrednio lub pośrednio). Chociaż w trakcie wykonania programu każdy z obiektów jest tego samego typu (instancja klasy Garfield), to w trakcie kompilacji sprawa wygląda trochę inaczej:     na obiekcie garfield możemy wykonać wszystkie metody udostępnione w klasie Garfield i interfejsach, które ta klasa implementuje:            getWeight(),       getName(),       getLasagnaReceipe().           na obiekcie fatCat możemy wykonać wszystkie metody udostępnione w interfejsie FatCat i interfejsach po których dziedziczy:            getWeight(),       getName(),       getLasagnaReceipe().           na obiekcie cat możemy wykonać wyłącznie metody z interfejsu Cat:            getName().           na obiekcie lasagnaEater możemy wykonać wyłącznie metody z interfejsu LasagnaEater:            getLasagnaReceipe().           Zastosowania interfejsów   Do czego właściwie potrzebne są nam interfejsy? Czy nie jest to po prostu zestaw dodatkowych linijek kodu, które trzeba napisać i nic one nie wnoszą? Otóż nie.   Interfejsy w bardzo prosty sposób ułatwiają różnego rodzaju integrację różnych fragmentów kodu. Wyobraź sobie sytuację, w której Piotrek pisze program obliczający średnią temperaturę w każdym z województw. Współpracuje on z Kasią, która pisze program udostępniający aktualną temperaturę w danej miejscowości.   Aby Piotrek mógł napisać swój program musi skorzystać z programu Kasi. Musi się z nim zintegrować. Taką integrację ułatwiają właśnie interfejsy.   Piotrek z Kasią uzgadniają, że będą używali następującego interfejsu   public interface Thermometer {     double getCurrentTemperatureFor(String city); }   Dzięki niemu Piotrek może pisać swój program równolegle z Kasią.   Co więcej może się okazać, że implementacja Kasi nie jest zbyt dokładna. Ania implementuje ten sam interfejs ale temperatury przez nią zwracane są dokładniejsze. Wówczas Piotrek w ogóle nie musi zmieniać swojego programu. Wystarczy, ze użyje innej implementacji interfejsu Thermometer dostarczonej przez Anię.   To właśnie jest kolejna zaleta interfejsów. Dzięki nim możemy pisać programy, które możemy w łatwiejszy sposób modyfikować. Interfejsy jasno oddzielają komponenty programu. Dzięki takiemu podejściu komponenty można z łatwością wymieniać.   Interfejs czyli widok na obiekt   Postaram się pokazać Ci kolejny przykład. Ważne jest żeby zrozumieć koncept interfejsów. Są one bardzo ważne i często używane w codziennym programowaniu. Wyobraź sobie piekarnik. Piekarnik to obiekt. W piekarniku możesz upiec chleb, zrobić dobrą pieczeń czy upiec ciasteczka. Każde z tych dań wymaga innych ustawień piekarnika.   Inna temperatura, inny czas pieczenia, inny tryb. W programowaniu często chcemy ukryć takie szczegóły przez innymi klasami. Na zewnątrz w formie interfejsu wystawiamy jedynie dobrze zdefiniowane metody. Każda z tych metod może być umieszczona w osobnym interfejsie, który będzie implementowany przez obiekt piekarnika:   public interface BakingOven {     void bakeCookies();     void bakeBread(); }   public interface RoastingOven {     void roastChicken(); }   public class Oven implements BakingOven, RoastingOven {      private int time;     private int temperature;      @Override     public void bakeBread() {         temperature = 200;         time = 120;         turnOn();     }      @Override     public void bakeCookies() {         temperature = 180;         time = 90;         turnOn();     }      @Override     public void roastChicken() {         temperature = 130;         time = 240;         turnOn();     }      private void turnOn() {         System.out.println(String.format(\"Start. Heat up to %s and work for %d minutes.\", temperature, time));     }      public static void main(String[] args) {         Oven oven = new Oven();         BakingOven bakingOven = oven;         RoastingOven roastingOven = oven;          bakingOven.bakeBread();         bakingOven.bakeCookies();         roastingOven.roastChicken();     } }   Po uruchomieniu tego fragmentu kodu na konsoli pokaże się:   Start. Heat up to 200 and work for 120 minutes Start. Heat up to 180 and work for 90 minutes. Start. Heat up to 130 and work for 240 minutes.   Użyłem tutaj mechanizmu formatowania łańcuchów znaków. Jeśli chcesz przeczytać o tym więcej zachęcam do przeczytania osobnego artykułu na temat formatowania łańcuchów znaków w języku Java.   Interfejsy opisują spójny zakres funkcjonalności udostępniony przez dany obiekt. Metody, które są w nim zawarte powinny być ze sobą powiązane. Możesz porównać interfejsy do “widoku” na obiekt/klasę. Widząc obiekt przez pryzmat interfejsu możesz widzieć tylko podzbiór jego możliwości.   Zadanie   Napisz dwie klasy implementujące interfejs Computation. Niech jedna z implementacji przeprowadza operację dodawania, druga mnożenia.   public interface Computation {     double compute(double argument1, double argument2); }   Użyj obu implementacji do uzupełnienia programu poniżej:   public class Main {     public static void main(String[] args) {         Main main = new Main();         Computation computation;          if (main.shouldMultiply()) {             computation = new Multiplication(); // zaimplementuj brakującą klasę         }         else {             computation = new Addition(); // zaimplementuj brakującą klasę         }          double argument1 = main.getArgument();         double argument2 = main.getArgument();          double result = computation.compute(argument1, argument2);         System.out.println(\"Wynik: \" + result);     }      private boolean shouldMultiply() {         return false; // tutaj zapytaj użytkownika co chce zrobić (mnożenie czy dodawanie)     }      private double getArgument() {         return 0; // tutaj pobierz liczbę od użytkownika     } }   Program po uruchomieniu powinien zapytać użytkownika jaką operację chce wykonać, następnie pobrać dwa argumenty niezbędne do wykonania tej operacji. Ostatnią linijką powinien być wynik dodawania/mnożenia wyświetlony użytkownikowi. Przygotowałem też dla Ciebie przykładowe rozwiązanie zadania, pamiętaj jednak, że rozwiązując je samodzielnie nauczysz się najwięcej.   Materiały dodatkowe   Oczywiście nie wyczerpaliśmy tematu mimo sporej objętości artykułu. Zachęcam do samodzielnego pogłębiania wiedzy korzystając z materiałów dodatkowych. Specyfikacja Języka Java jest w języku angielskim.     Opis interfejsu na Wikipedii   Rozdział w Java Language Specification dotyczący interfejsów   Kod źródłowy przykładów użytych w artykule   Podsumowanie   Dzisiaj poruszyłem bardzo wiele zagadnień. Po lekturze artykułu wiesz prawie wszystko interfejsach i ich przeznaczeniu. Teraz znasz też kilka nowych słów kluczowych w języku Java. Wystarczająca dawka wiedzy jak na jeden dzień :)   Mam nadzieję, że artykuł był dla Ciebie ciekawy, jeśli cokolwiek nie było zrozumiałe bądź wymaga dokładniejszego wyjaśnienia daj znać, postaram się pomóc.   Jak zwykle na koniec mam do Ciebie prośbę. Proszę podziel się artykułem ze swoimi znajomymi, zależy mi na dotarciu do jak największej liczby osób, które chcą nauczyć się programowania :). Zapraszam także na Samouczek Programisty na Facebooku. Możesz też zapisać się do samouczkowego newslettera żeby nie pomiąć żadnego nowego artykułu.   Do następnego razu!                 Wyjątkiem tutaj są tak zwane metody domyślne, o których przeczytasz niżej. &#8617;                  LocalDateTime jest jednym z typów z biblioteki standardowej służącym do przedstawiania daty/czasu. &#8617;                  Jest to tak zwany modyfikator dostępu, w oddzielnym artykule przeczytasz więcej o modyfikatorach dostępu. &#8617;                  Albo musiałby znaleźć się w innej domyślnej metodzie. Takie rozwiązanie powodowałoby rozszerzenie dostępnego interfejsu, co nie zawsze jest dobrym rozwiązaniem. &#8617;                  Jest od tego wyjątek, o klasach abstrakcyjnych przeczytasz w innym artykule. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/interfejsy-w-jezyku-java/",
        "teaser": "/assets/images/2015/12/16_interfejsy_w_jezyku_java_artykul.jpg"
      },{
        "title": "Choinka",
        "excerpt":"Na początku z okazji Bożego Narodzenia życzę Ci dużo wytrwałości w dążeniu do wyznaczonego celu. Nie jesteś w stanie nauczyć się programować bez swojej ciężkiej i systematycznej pracy więc życzę Ci także zapału, nie tego słomianego :)   Mam nadzieję, że jednym z Twoich założeń jest nauczenie się programowania. Trzymam kciuki za jego realizację, będę się starał aby Ci w tym pomóc na blogu. Mam także nadzieję, że w trakcie Świąt chwila spędzona przed komputerem będzie przyjemnym przerywnikiem od świętowania przy stole.   Zadanie   Bez zbędnego owijania w bawełnę przechodzimy do zadania dla Ciebie. Zadanie nie jest skomplikowane, pamiętam, że mi podczas nauki programowania zadał je jeden z moich prowadzących na uczelni. Był nim dr Paweł Rogaliński lub dr inż. Marek Piasecki, niestety nie pamiętam dokładnie.   Zadanie polega na wydrukowaniu choinki na ekranie :) Twoim zadaniem jest przyjęcie argumentu od użytkownika którym będzie wysokość choinki. Program powinien wypisać na konsoli choinkę tej wysokości.   Załóżmy, że użytkownik poprosi o choinkę wysokości 5 wówczas na ekranie powinno pokazać się drzewko (ważne jest drukować je czcionką o stałej szerokości co jest domyślnym ustawieniem na konsoli):       *    ***   *****  ******* *********   Do wykonania zadania użyj pętli. Dokładnie opisane są w tym artykule. Pobieranie danych od użytkownika opisałem w artykule o typach prostych w języku Java.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dodatkowe wskazówki   StringBuilder   Łańcuchy znaków można ze sobą łączyć znakiem +:   String example = \"some\" + \" \" + \"example\";   Może to jednak nie być wydajne. W niektórych przypadkach Java przy każdym połączeniu tworzy nowy obiekt String. Łączenie łańcuchów znaków można ulepszyć używając do tego klasy StringBuilder jak w przykładzie poniżej.   char treeSymbol = '*'; StringBuilder treeRepresentation = new StringBuilder(); treeRepresentation.append(\" \"); treeRepresentation.append(treeSymbol); treeRepresentation.append(System.lineSeparator()); treeRepresentation.append(treeSymbol); treeRepresentation.append(treeSymbol); String christmasTree = treeRepresentation.toString();   Metoda append służy do dołączania poszczególnych części łańcucha znaków. Na końcu wywołanie metody toString zwraca właściwy obiekt String.   Nowa dla Ciebie może taże być metoda System.lineSeparator(). Bez wchodzenia w zbędne szczegóły, metoda po prostu zwraca znak nowej linii. Zmienna christmasTree z przykładu powyżej wygląda następująco.    * **   Podsumowanie   Mam nadzieję, że zadanie Ci się podoba :) Jeśli myślisz, że komukolwiek z Twoich znajomych jego rozwiązanie mogłoby także przynieść trochę satysfakcji proszę przekaż mu link do tego wpisu. Gdy będziesz miał problem z rozwiązaniem zadania możesz rzucić okiem na przykładowe rozwiązanie, które umieściłem na githubie. Jeśli nie chcesz przegapić żadnego nowego wpisu możesz polubić stronę na facebooku :)   Jeszcze raz Wesołych Świąt!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/choinka/",
        "teaser": "/assets/images/2015/12/25_choinka.jpg"
      },{
        "title": "Dziedziczenie w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Dziedziczenie   Na początku postaram się wyjaśnić czym właściwie jest dziedziczenie. Nie jest to nic skomplikowanego.   Niektóre obiekty mogą mieć między sobą dużo wspólnego. Na przykład zarówno samochód osobowy jak i samochód ciężarowy mają silnik, kierownicę, drzwi, światła itd. Co prawda każdy z tych elementów może być różny, jednak bez wątpienia oba te pojazdy mają wiele wspólnego. Przede wszystkim oba są pojazdami. Możemy powiedzieć, że samochód ciężarowy rozszerza (ang. extends) funkcjonalność pojazdu.   W naszym przykładzie pojazd możemy uznać, za tak zwaną klasę bazową (lub nadklasę). Natomiast samochód osobowy i samochód ciężarowy rozszerzają funkcjonalność pojazdu. Możemy też powiedzieć, że każda z nich jest klasą pochodną (lub „podklasą”). Proszę spójrz na przykład:   public class Vehicle { }  public class Car extends Vehicle { }  public class Truck extends Vehicle { }   Dziedziczenie jest jedną z podstaw programowania obiektowego (nie tylko w języku Java). Dzięki dziedziczeniu możemy ograniczyć ilość powielonego kodu poprzez definiowanie atrybutów, konstruktorów, metod w klasach bazowych.   Dziedziczenie może być wielopoziomowe, jednak w języku Java zawsze bezpośrednio możemy dziedziczyć od jednej klasy.   public class Vehicle { }  public class Car extends Vehicle { }  public class SUV extends Car { }   W przykładzie powyżej SUV dziedziczy po klasie Car. Klasa Car jest podklasą klasy Vehicle. Zatem pośrednio SUV także dziedziczy po klasie Vehicle.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Modyfikatory dostępu   Dzięki dziedziczeniu możemy mieć dostęp do metod, atrybutów, konstruktorów klas po których dziedziczymy. Do określenia czy dany element może być dostępny w ramach podklasy służą modyfikatory dostępu.   Do tej pory poznałeś modyfikatory dostępu takie jak:      public – element oznaczony tym modyfikatorem dostępny jest “z zewnątrz” obiektu, stanowi jego interfejs,   private – element oznaczony tym modyfikatorem jest dostępna wyłącznie wewnątrz obiektu, także klasy pochodne nie mają do niego dostępu.   W przypadku dziedziczenia znaczenie ma także modyfikator protected. Element poprzedzony tym atrybutem może być dostępny wewnątrz klasy bądź przez każdą inną klasę która po niej dziedziczy.   Przygotowałem osobny artykuł poświęcony modyfikatorom dostępu. Jeśli chcesz dowiedzieć się więcej o modyfikatorach powinieneś go przeczytać.   Niżej możesz zobaczyć publiczną klasę Greeter. Używa ona trzech modyfikatorów dostępu: public, protected i private:      klasa Greeter ma modyfikator public,   atrybut message ma modyfikator private,   metoda sayHello ma modyfikator protected.   public class Greeter {     private String message = \"Hello!\"      protected void sayHello() {         System.out.println(message);     } }   Przesłonięcie i przeciążenie metody   Pytanie o to, czym różni się przesłonięcie od przeciążenia metody często trafia się na rozmowach o pracę. Pamiętam je jako jedno z obowiązkowych pytań na stanowiska początkujących programistów. Warto znać tę różnicę.   Sygnatura metody   Zanim wytłumaczę Ci te pojęcia musisz wiedzieć czym jest sygnatura metody. Specyfikacja języka Java określa sygnaturę metody jako jej nazwę wraz z listą argumentów. W szczególności w skład sygnatury metody nie wchodzi typ zwracany przez daną metodę.   W poniższym przykładzie sygnaturą metody jest main(String[]) (nazwy parametrów nie są istotne):  public static void main(String[] args) throws Exception {     System.out.println(\"something important\"); }       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Przesłonięcie metody   Łatwo sobie wyobrazić sytuację, w której metoda o tej samej sygnaturze występuje zarówno w klasie bazowej jak i klasie pochodnej. W tej sytuacji mówimy o tym, że klasa pochodna przesłania metodę z klasy bazowej (ang. override). Proszę spójrz na przykład poniżej.   public class Vehicle {     public void startEngine() {         System.out.println(\"Engine starts. Brum brum brum.\");     } }   public class Car extends Vehicle {     public void startEngine() {         System.out.println(\"Force driver to fasten seat belts.\");     } }   W naszym przykładzie wywołanie metody startEngine na obiekcie typu Car zmusi kierowcę do zapięcia pasów (wyświetli się komunikat Force driver to fasten seat belts). Jeśli tę samą metodę wywołamy na instancji obiektu klasy Vehicle wówczas pojawi się komunikat Engine starts. Brum brum brum..   Co jeśli chcielibyśmy nieznacznie zmodyfikować oryginalną metodę? Jest na to sposób. Słowo kluczowe super pozwala na wywołanie nadpisanej metody z klasy bazowej. Rozszerzając przykład powyżej moglibyśmy napisać taki fragment kodu:   public class Car extends Vehicle {     public void startEngine() {         super.startEngine();         System.out.println(\"Force driver to fasten seat belts.\");     } }   W takim przypadku wywołanie metody startEngine na instancji obiektu Car na początku wywoła tę metodę z klasy bazowej (wyświetli się komunikat Engine starts...) następnie pokazany zostanie komunikat Force driver... (zachęcam do eksperymentowania z IDE).   Adnotacja @Override informuje kompilator o tym, że dana metoda powinna przesłaniać inną metodę w klasie bazowej. Jeśli warunek ten nie będzie spełniony możesz spodziewać się błędu kompilacji.   Przeciążenie metody   Przeciążenie (ang. overload) metody nie jest związane z dziedziczeniem. Mówimy o tym, że metoda jest przeciążona jeśli w ramach jednej klasy występuje wiele metod o tej samej nazwie. W tym przypadku każda z tych metod, mimo tej samej nazwy, ma różną sygnaturę. Metody te różnią się między sobą listą argumentów. Spójrz na przykład poniżej:   public abstract class Vehicle {     protected final int tankCapacity = 60;     protected int fuelLevel = tankCapacity;      public void fillTank() {         int toFill = tankCapacity - fuelLevel;         fillTank(toFill);     }      public void fillTank(int toFill) {         if (toFill + fuelLevel &gt; tankCapacity) {             System.out.println(\"I can't fill tank with \" + toFill + \" litres.\");         }         else {             fuelLevel += toFill;             System.out.println(\"I've filled the tank with \" + toFill + \" litres.\");         }     } }  W przykładzie tym metoda fillTank jest przeciążona. Pierwsza jej wersja nie pobiera żadnych argumentów. Druga liczbę typu int. Obie służą do napełnienia zbiornika paliwem.   Częstą praktyką jest używanie wewnątrz przeciążonej metody wywołania jej innego odpowiednika. Zazwyczaj metody z mniejszą liczbą argumentów wywołują te z większą. W takim przypadku możesz nadać domyślne wartości parametrów dla metod z większą ich liczbą.   W przykładzie powyżej bezargumentowa metoda fillTank wylicza ile paliwa brakuje do pełnego zbiornika. Następnie wywołuje przeciążoną metodę przekazując jej liczbę brakujących litrów   Przeciążać można także metody statyczne. Jako przykład może tu posłużyć metoda z biblioteki standardowej LocalDateTime.of. Metoda ta jest przeciążona aż siedem razy.   Konstruktory nie są wyjątkiem, także można je przeciążać. Dzięki temu pozwalasz na tworzenie danego obiektu na wiele różnych sposobów:   public class DieselEngine implements Engine { }  public class Car extends Vehicle {     public Car() {         this(new DieselEngine());     }      public Car(Engine engine) {         super(engine, NUMBER_OF_WHEELS);     } }   Podobnie jak w zwykłym przeciążeniu także i tutaj często odwołuje się do innego konstruktora. Służy do tego słowo kluczowe this. W przykładzie powyżej bezparametrowy konstruktor wywołuje konstruktor przyjmujący instancję klasy implementującą interfejs Engine. W tym przypadku nowa instancja klasy DieselEngine tworzona jest wewnątrz konstruktora bezparametrowego.   Konstruktory a dziedziczenie   Konstruktory w przypadku dziedziczenia zachowują się tak samo jak metody. Także możemy wywołać konstruktor z klasy bazowej wewnątrz klasy dziedziczącej używając słowa kluczowego super (jeśli pozwala na to modyfikator dostępu).   Klasa pochodna musi mieć możliwość wywołania konstruktora klasy bazowej. Jeśli tego nie robi domyślnie wywoływany jest konstruktor bezparametrowy   public class Animal {     public Animal() {     } }   public class Dog extends Animal {     public Dog() {         super();     } }   W powyższym przykładzie wewnątrz konstruktora klasy Dog wywołujemy konstruktor klasy Animal wywołując super(). Jak napisałem wyżej możemy pominąć to wywołanie, wówczas kompilator zrobi to za nas. Ma to pewne konsekwencje. Jeśli w klasie bazowej zdefiniujemy konstruktor z parametrami wówczas konstruktor bezparametrowy nie zostanie utworzony automatycznie.   W takich przypadkach w konstruktorach klas pochodnych musimy wywołać konstruktor klasy bazowej. Pokazałem to w przykładzie poniżej:   public class Vehicle {     private int numberOfWheels;     private Engine engine;       public Vehicle(Engine engine, int numberOfWheels) {         this.engine = engine;         this.numberOfWheels = numberOfWheels;     } }   public class Car extends Vehicle {     private static final int NUMBER_OF_WHEELS = 4;       public Car(Engine engine) {         super(engine, NUMBER_OF_WHEELS);     } }   Jak widzisz w przykładzie powyżej klasa Car nie musi definiować konstruktora z taką samą liczbą parametrów jak klasa bazowa, ale musi wywołać konstruktor klasy Vehicle i przekazać dwa parametry. Dzieje się tak, ponieważ w klasie Vehicle jest tylko konstruktor z dwoma parametrami.   Klasy abstrakcyjne   Czasami może wystąpić sytuacja, w której klasa bazowa jest swego rodzaju uogólnieniem, abstrakcją, która nie ma sensu bez konkretnych implementacji. Wówczas możemy mówić o klasie abstrakcyjnej.   Nie ma możliwości stworzenie instancji klasy abstrakcyjnej. W naszym przykładzie klasa Vehicle mogłaby być klasą abstrakcyjną. Klasy abstrakcyjne poprzedzamy słowem kluczowym abstract. Proszę spójrz na przykład poniżej.   public abstract class Vehicle {     private int numberOfWheels;     private Engine engine;       public Vehicle(Engine engine, int numberOfWheels) {         this.engine = engine;         this.numberOfWheels = numberOfWheels;     } }   public class Car extends Vehicle {     private static final int NUMBER_OF_WHEELS = 4;       public Car(Engine engine) {         super(engine, NUMBER_OF_WHEELS);     } }   Jak widzisz klasa abstrakcyjna może mieć konstruktor, jednak służy on tylko do tego, żeby uniknąć duplikacji kodu w klasach pochodnych. Klasa Car używa konstruktora zdefiniowanego w abstrakcyjnej klasie Vehicle.   Klasy i metody finalne   Możliwość dziedziczenia i nadpisywania metod daje bardzo duże możliwości. Wyobraź sobie następujący kod:   public interface BankAccount {     void deposit(BigDecimal amount);     void withdraw(BigDecimal amount); }   public class Transfer {     public void transferMoney(BankAccount source, BankAccount destination, BigDecimal amount) {         source.withdraw(amount);         destination.deposit(amount);     } }   Co stanie się jeśli programista utworzy nową klasę jak w przykładzie poniżej?   public class FraudTransfer extends Transfer{     public void transferMoney(BankAccount source, BankAccount destination, BigDecimal amount) {         destination.deposit(amount);     } }   Przy takiej implementacji konto docelowe zostałoby zasilone dodatkową kwotą jednak ta kwota nie byłaby pobrana z konta źródłowego. Niedobrze.   W takich przypadkach możemy użyć słowa kluczowego final. Słowo to umieszczone przed klasą oznacza, że nie możemy po danej klasie dziedziczyć. W przypadku metody oznacza, że metoda nie może zostać nadpisana.   Dla przykładu niektóre klasy w pakiecie java.lang są finalne (na przykład Integer czy String). Nie można nadpisać ich implementacji.   Klasa java.lang.Object   Teraz już wiesz czym jest dziedziczenie. A wiesz, że używałeś go od pierwszej lekcji nauki języka Java? :)   Z jednego z poprzednich artykułów wiesz o tym, że kompilator dodaje automatycznie konstruktor bezparametrowy jeśli nie zdefiniujesz żadnego w swojej klasie. Podobnie jest z dziedziczeniem, każda klasa domyślnie dziedziczy po klasie java.lang.Object (chyba, że zdefiniujesz inną klasę po której dziedziczysz).   Dzięki tej klasie masz dostęp do zestawu metod, które zdefiniowane są w ciele klasy Object. Na przykład metoda String toString() ma swoją podstawową implementację w klasie Object1.   Dobre praktyki   Dziedziczenie to bardzo pomocny mechanizm. Jak napisałem wcześniej pozwala nam na uniknięcie duplikowania kodu. Jednak ma też swoje wady. Hierarchie dziedziczenia, które mają dużo poziomów mogą stać się mało czytelne. Tak zagmatwany kod może stać się trudny w utrzymaniu. Powinniśmy unikać takiej sytuacji.   Nie ma tu jasnej reguły, jednak w przypadku gdy w programie występuje wielopoziomowe dziedziczenie starałbym się uprościć taki kod. Bardzo często mówi się o preferowaniu kompozycji nad dziedziczeniem. Kompozycja to nic innego jak zawarcie innego obiektu jako atrybut naszej klasy. Kompozycja w wielu przypadkach potrafi uprościć skomplikowane hierarchie dziedziczenia.   Zadanie   Na koniec mam dla Ciebie zadanie do wykonania, przećwiczysz w nim zagadnienia omówione w tym artykule.   Napisz program, w którym zasymulujesz hierarchię dziedziczenia zwierząt. Stwórz abstrakcyjną klasę Animal, po której będą dziedziczyły klasy Fish i Mammal. Wszystkie te klasy powinny być abstrakcyjne. Następnie stwórz konkretne klasy które dziedziczą po Fish i Mammal. Będą to odpowiednio Goldfish i Human.   Nadpisz metodę toString w każdej z tych klas. Stwórz instancje obu tych klas i wyświetl je na konsoli.   Jeśli miałbyś problemy z zadaniem możesz spojrzeć na przykładowe rozwiązanie.   Dodatkowe materiały   Poniżej przygotowałem dla Ciebie zestaw linków z dodatkowymi materiałami, część z nich jest w języku angielskim.     https://pl.wikipedia.org/wiki/Dziedziczenie_%28programowanie%29   https://docs.oracle.com/javase/specs/jls/se12/html/jls-11.html#jls-11   https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html   https://docs.oracle.com/javase/tutorial/java/concepts/inheritance.html   kod źródłowy przykładów z tego artykułu   Podsumowanie   Bardzo się cieszę, że przeczytałeś artykuł do końca. Dzisiaj dowiedziałeś się czegoś więcej o dziedziczeniu. Poznałeś słowa kluczowe abstract i final. Wiesz już czym jest nadpisywanie metod czy klasa bazowa. Innymi słowy poznałeś kolejny zestaw narzędzi niezbędnych dla każdego programisty. Tak trzymaj! :)   Na koniec bardzo proszę Cię o podzielenie się artykułem ze swoimi znajomymi, którzy są zainteresowani taką tematyką. Jak zwykle zależy mi na tym, żeby z blogiem i jego zawartością dotrzeć do jak największej liczby czytelników takich jak Ty :) Jeśli jeszcze tego nie zrobiłeś prosiłbym o polubienie strony na Facebook’u.   Do następnego razu!                 Domyślna implementacja pokazuje nazwę klasy wraz z pakietem oraz jej adres w pamięci np. pl.samouczekprogramisty.kursjava.cars.X@14ae5a5. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/dziedziczenie-w-jezyku-java/",
        "teaser": "/assets/images/2016/01/24_dziedziczenie_w_jezyku_java_artykul.jpeg"
      },{
        "title": "Wyjątki w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Czym jest wyjątek?   Wyjątek (ang. exception) jest specjalną klasą. Jest ona specyficzna ponieważ w swoim łańcuchu dziedziczenia ma klasę java.lang.Throwable. Instancje, które w swojej hierarchii dziedziczenia mają tę klasę mogą zostać „rzucone” (ang. throw) przerywając standardowe wykonanie programu.   Przykładem może być tutaj walidacja argumentów metody. Załóżmy, że nasza metoda jako argument przyjmuje liczbę godzin i zwraca liczbę sekund, odpowiadających przekazanemu argumentowi. Możemy założyć, że akceptujemy wyłącznie argumenty dodatnie lub 0.   Innymi słowy jeśli metoda zostanie wywołana z argumentem mniejszym od 0 możemy uznać to za nieprawidłowe wywołanie i zasygnalizować taką sytuację rzucając wyjątek.   public int getNumberOfSeconds(int hour) {     if (hour &lt; 0) {         throw new IllegalArgumentException(\"Hour must be &gt;= 0: \" + hour);     }     return hour * 60 * 60; }   W przykładzie powyżej użyliśmy wyjątku występującego w standardowej bibliotece języka Java: java.lang.IllegalArgumentException. Do rzucania wyjątku używamy słowa kluczowego throw.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Co się dzieje po rzuceniu wyjątku?   Wyobraź sobie kilka metod, które wywołują siebie nawzajem. Te kilka wywołań nazywamy stosem wywołań. Proszę zwróć uwagę na przykład poniżej:   package pl.samouczekprogramisty.kursjava.exception;  public class StackTraceExample {     public static void main(String[] args) {         StackTraceExample example = new StackTraceExample();         example.method1();     }      public void method1() {         method2();     }      public void method2() {         method3();     }      public void method3() {         throw new RuntimeException(\"BUM! BUM! BUM!\");     } }   W naszym przykładzie w metodzie main tworzymy instancję klasy StackTraceExample i na instancji wywołujemy metodę method1, metoda ta wywołuje z kolei metodę method2. method2 wywołuje method3, która rzuca wyjątek java.lang.RuntimeException (kolejny wyjątek z biblioteki standardowej).   Tą listę metod wywołujących siebie nawzajem nazywamy stosem wywołań. W naszym przypadku stos wygląda następująco:      main   method1   method2   method3   A co stanie się po uruchomieniu tego programu? Oczywiście zostanie rzucony wyjątek, a programista zobaczy stos wywołań metod (ang. stacktrace), jak w przykładzie poniżej:   Exception in thread \"main\" java.lang.RuntimeException: BUM! BUM! BUM!     at pl.samouczekprogramisty.kursjava.exception.StackTraceExample.method3(StackTraceExample.java:18)     at pl.samouczekprogramisty.kursjava.exception.StackTraceExample.method2(StackTraceExample.java:14)     at pl.samouczekprogramisty.kursjava.exception.StackTraceExample.method1(StackTraceExample.java:10)     at pl.samouczekprogramisty.kursjava.exception.StackTraceExample.main(StackTraceExample.java:6)     at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)     at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)     at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)     at java.lang.reflect.Method.invoke(Method.java:498)     at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)   W pracy programisty umiejętność czytania tego typu komunikatów jest bardzo istotna. Dzisiaj stacktrace widzisz pierwszy raz, zapewniam Cię, że zobaczysz go jeszcze dużo razy ;)   Zrozumieć stacktrace   Proszę zwróć uwagę na stos wywołań metod, który wspomniałem wyżej i porównaj go ze stacktrace’em. Widzisz pewną zależność? Dokładnie – stacktrace to nic innego jak odwrócony stos wywołań metod od rozpoczęcia programu do miejsca w którym został rzucony wyjątek.   Pierwsza linijka mówi o tym jaki wyjątek został rzucony, kolejne linijki to metody, które były wywoływane. Każda linia składa się z nazwy klasy wraz z pakietem, w nawiasach znajduje się nazwa pliku oddzielona dwukropkiem od numeru linii w tym pliku. W naszym przypadku wyjątek RuntimeException został rzucony po wywołaniu metody pl.samouczekprogramisty.kursjava.exception.StackTraceExample.method3, która znajduje się w 18 linijce pliku StackTraceExample.java.   Ostatnie linijki także pokazują na kod programu, jednak ten nie jest już napisany prze mnie. Program powyżej uruchamiałem z IDE i to właśnie przez IntelliJ IDEA stacktrace zawiera te 5 dodatkowych linijek.   Obsługa wyjątków   Już wiesz jak można rzucić wyjątek. Najwyższy czas zacząć je obsługiwać :) Mówimy, że wyjątek jest obsługiwany, jeśli reagujemy na jego wystąpienie i próbujemy “naprawić” program w trakcie jego działania. Możemy też powiedzieć, że łapiemy wyjątek.   Do obsługi wyjątków służy blok try/catch. Proszę spójrz na przykład poniżej:   int hours = -3; int numberOfSeconds = 0; try {     numberOfSeconds = instance.getNumberOfSeconds(hours); } catch (IllegalArgumentException exception) {     numberOfSeconds = instance.getNumberOfSeconds(hours * -1); } System.out.println(numberOfSeconds);   Znasz już metodę getNumberOfSeconds. Wiesz, że rzuca wyjątek IllegalArgumentException jeśli argument jest mniejszy od 0. W przykładzie powyżej otaczamy wywołanie metody blokiem try {…} catch. Jeśli kod wewnątrz nawiasów { } rzuci wyjątek i blok catch będzie obsługiwał ten typ wyjątku wówczas zostanie wywołany kod w bloku catch i wyjątek nie przerwie działania programu.   W przykładzie powyżej pierwsze wywołanie metody rzuci wyjątek ponieważ przekazaliśmy -3 jako argument. Rzucony wyjątek jest obsługiwany przez klauzulę catch (klasa wyjątku “pasuje”) więc zostaje wywołany kod wewnątrz bloku.   Pod blokiem try może znajdować się wiele bloków catch. Pierwszy pasujący zostanie wykonany. Rzucony wyjątek może być obsłużony przez dany blok catch jeśli klasa wyjątku w () znajduje się w hierarchii dziedziczenia rzuconego wyjątku. Nie jest to skomplikowane, zdecydowanie łatwiej wygląda to na przykładzie   try {     throw new IllegalArgumentException(); } catch (ArithmeticException exception) {     // 1 } catch (RuntimeException exception) {     // 2 } catch (Exception exception) {     // 3 }   Blok catch 1 nie zostanie wykonany bo ArithmeticException nie znajduje się w hierarchii dziedziczenia wyjątku IllegalArgumentException. Blok catch 2 zostanie wykonany bo IllegalArgumentException dziedziczy po RuntimeException. Następny blok nie zostanie wykonany ponieważ w przypadku obsługi wyjątku pierwszy pasujący blok catch jest wykonywany jako jedyny.   Obsługa kilku rodzajów wyjątków w jednym bloku catch   Może zdarzyć się sytuacja, w której chciałbyś obsłużyć kilka wyjątków a nie mają one wspólnej klasy bazowej. Wówczas w nawiasach po catch możesz oddzielić klasy wyjątków symbolem | jak w przykładzie poniżej.   try {     someMagicMethod(); } catch (ArithmeticException | IllegalArgumentException exception) {      // handle exception }   Rodzaje wyjątków checked oraz unchecked   Każdy wyjątek w języku Java dziedziczy po klasie Throwable. Wyróżniamy dwa rodzaje wyjątków, tak zwane “checked exceptions” oraz “unchecked exceptions”. Różnica między nimi sprowadza się do tego, że te pierwsze muszą być obsłużone przez programistę, wymaga tego kompilator. Przykładowym wyjątkiem typu unchecked jest IllegalArgumentException, natomiast IOException jest wyjątkiem typu checked.             Hierarchia dziedziczenia wyjątków        Reguła podziału wyjątków na te dwa rodzaje jest prosta. Jeśli wyjątek w swojej hierarchii dziedziczenia ma Exception i nie ma RuntimeException jest wyjątkiem typu checked. W każdym innym przypadku jest to wyjątek typu unchecked.   Kiedy zatem stosować wyjątki typu checked? Zalecenie jest proste, za każdym razem kiedy program ma możliwość “naprawienia” zaistniałej sytuacji wyjątkowej powinniśmy rzucić wyjątek typu checked. Reguła ta jednak jest bardzo często łamana ponieważ obsługa tego typu wyjątków wymaga trochę więcej kodu ;)   Klauzula throws   Wyjątek można obsłużyć na dwa sposoby. Jeden już znasz, to otoczenie fragmentu kodu blokami try/catch. Drugi sprowadza się do “zepchnięcia” odpowiedzialności obsłużenia wyjątku o poziom niżej, do metody wywołującej. Służy do tego klauzula throws, którą dodajemy do deklaracji metody. Spójrz na przykład poniżej:   public class CheckedExceptions {     public static void main(String[] args) {         CheckedExceptions instance = new CheckedExceptions();         try {             instance.methodWithCheckedException();         }          catch (IOException e) {             e.printStackTrace();         }     }       private void methodWithCheckedException() throws IOException {         throw new IOException();     } }   Metoda methodWithCheckedException rzuca wyjątek IOException, który jest typu checked. Nie obsługuje go jednak wewnątrz ale informuje o tym, że może rzucić taki wyjątek dzięki throws. W metodzie main mamy standardowy blok catch, gdzie wyjątek jest obsłużony.   Klauzula finally   Blok finally możemy umieścić po try. Kod wewnątrz tego bloku zawsze zostanie wykonany1. W rzeczywistości blok try nie musi mieć żadnej klauzuli catch jeśli ma blok finally.   try {     throw new RuntimeException(); } finally {     System.out.println(\"Surprise!\"); }   Może być także sytuacja w której mamy zarówno try, catch jak i finally. Jeśli wewnątrz try zostanie rzucony wyjątek, który jest obsługiwany przez blok catch to dodatkowo, jako ostatni, uruchomi się blok finally.   Dobre praktyki przy używaniu wyjątków   Poniżej zebrałem dla Ciebie zestaw kilku dobrych praktyk przy pracy z wyjątkami:     Pierwsza i najważniejsza zasada, blok try powinien być jak najmniejszy. Takie podejście bardzo ułatwia znajdowanie błędów w bardziej skomplikowanych programach. Dzięki małemu blokowi try także możemy napisać lepszy kod do obsługi wyjątku – wiemy dokładnie z którego miejsca wyjątek może zostać rzucony więc wiemy także jak najlepiej na niego zareagować.   Blok finally bardzo często jest niezbędny. Szczególnie jeśli operujemy na instancjach, które wymagają “zamknięcia”.   Używaj klas wyjątków, które idealnie pasują do danej sytuacji. Jeśli nie ma takiego wyjątku w bibliotece standardowej utwórz własną klasę wyjątku.   Tworząc instancję wyjątków podawaj możliwie najdokładniejszy opis w treści wyjątku. Pozwala to na dużo łatwiejsze znajdowanie błędów w programie jeśli komunikat wyjątku jest szczegółowy.   Nie zapominaj o używaniu wyjątków typu checked. Chociaż wymagają trochę więcej kodu i generują często irytujące błędy kompilacji ich używanie jest czasami wskazane.   Zadanie   Napisz program, który pobierze od użytkownika liczbę i wyświetli jej pierwiastek. Do obliczenia pierwiastka możesz użyć istniejącej metody java.lang.Math.sqrt(). Jeśli użytkownik poda liczbę ujemną rzuć wyjątek java.lang.IllegalArgumentException. Obsłuż sytuację, w której użytkownik poda ciąg znaków, który nie jest liczbą.   Zachęcam do samodzielnego rozwiązania zadania, jeśli rozwiązujesz zadanie samodzielnie uczysz się najwięcej. Jeśli jednak chciałbyś zobaczyć przykładowe rozwiązanie, to umieściłem je na githubie.   Dodatkowe materiały do nauki      http://docs.oracle.com/javase/tutorial/essential/exceptions/index.html   https://docs.oracle.com/javase/specs/jls/se12/html/jls-11.html   https://www.youtube.com/watch?v=Nl16BzP6Fao   kod źródłowy przykładów użytych w artykule   Podsumowanie   Bardzo się cieszę, że dobrnąłeś tak daleko. Mam nadzieję, że artykuł przypadł Ci do gustu. Na koniec mam do Ciebie prośbę, podziel się artykułem ze swoimi znajomymi, którzy mogą być zainteresowani tym tematem. Niezmiennie zależy mi na tym, żeby dotrzeć do jak największej grupy czytelników :) Jeśli nie chcesz ominąć kolejnych artykułów polub nasz profil na Facebook’u i dopisz się do newslettera.   Do następnego razu i życzę Ci udanego dnia :)                 Są pewne sytuacje kiedy to nie jest prawdą, np. jeśli wirtualna maszyna Javy zostanie wyłączona. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/wyjatki-w-jezyku-java/",
        "teaser": "/assets/images/2016/01/31_wyjatki_w_jezyku_java_artykul.jpeg"
      },{
        "title": "Referencja, sterta i garbage collector – obiektów w Javie ciąg dalszy",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Sterta i stos w wirtualnej maszynie Java   Z poprzednich artykułów wiesz, że maszyna wirtualna Javy zarządza za Ciebie pamięcią. Oznacza to tyle, że miejsce na obiekty, które tworzysz jest rezerwowane (i zwalniane jeśli obiekt nie jest już wykorzystywany) w tej pamięci. Pamięć ta nazywana jest stertą (ang. heap space).   Maszyna wirtualna Javy startuje zapewniając sobie miejsce na stertę w pamięci RAM (ang. Random Access Memory). Mówimy, ze alokuje tę pamięć. Na przykład jeśli Twój komputer ma 4GB pamięci RAM maszyna wirtualna podczas startu może przydzielić sobie 512MB. Obszar ten potencjalnie może się powiększyć w zależności od ustawień maszyny wirtualnej i dostępnej pamięci.      Tutaj drobna dygresja na temat dysku i pamięci operacyjnej. W czasach dysków HDD (ang. Hard Disk Drive) czas dostępu do pamięci RAM był znacząco krótszy. Obecnie przy dyskach SSD (ang. Solid State Drive) różnica nadal istnieje jednak nie jest tak duża.     Dzięki temu krótkiemu czasowi dostępu do pamięci RAM programy mogły być bardziej wydajne – działać “szybciej”. Załóżmy że przeczytanie 1MB z pamięci ram zajmuje 1 sekundę (w rzeczywistości jest to około 250 nanosekundy więc cztery miliony razy krócej!), w takiej skali przeczytanie 1MB z dysku HDD zajmuje 1 minutę i 20 sekund, a przesłanie pakietu (paczki danych mniejszej niż 1MB) przez internet z Kalifornii do Holandii i z powrotem aż 10 minut!        Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Czym różni się obiekt od referencji i zmiennej?   Każdy obiekt w Javie zajmuje jakiś obszar na wspomnianej stercie. Zmienne, które wskazują na obiekty na stercie zawierają referencje. Referencje możemy przedstawić jako „sznurki” łączące zmienną z właściwym obiektem na stercie (obszarem pamięci na stercie gdzie znajduje się obiekt). Referencji (sznurków) do obiektu może być wiele. Proszę spójrz na przykład:   public class ObjectVersusReference {     public static void main(String[] args) {         Object referenceToObjectX = new Object();         Object anotherReferenceToObjectX = referenceToObjectX;         Object refferenceToObjectY = new Object();          System.out.println(referenceToObjectX.toString());         System.out.println(anotherReferenceToObjectX.toString());         System.out.println(refferenceToObjectY.toString());     } }   W pierszej linijce metody main tworzona jest nowa zmienna typu Object o nazwie referenceToObjectX. W kolejnej linijce tworzona jest kolejna zmienna, która jest kopią isteniejącej już zmiennej. Trzecia linijka to wywołanie konstruktora, czyli utworzenie nowego obiektu i przypisanie go do zmiennej referenceToObjectY. Innymi słowy zmienne referenceToObjectX oraz anotherReferenceToObjectX zawierają tę samą referencję do tego samego obiektu na stercie.   Poniżej pokazałem to co zostanie wypisane na konsoli po uruchomieniu powyższego przykładu   java.lang.Object@7f31245a java.lang.Object@7f31245a java.lang.Object@6d6f6e28   java.lang.Object@7f31245a to nic innego jak wynik domyślnej implementacji metody toString znajdującej się w klasie Object. Metoda ta zwraca nazwę klasy wraz z pakietem oraz adres obiektu na stercie. 7f31245a to adres obiektu (oczywiście w Twoim przypadku te numery mogą być różne – Java może przydzielić tym obiektom inny adres przy każdym uruchomieniu)1.   Zauważyłeś, że dwie pierwsze linijki są takie same? To nic innego jak konsekwencja tego, że referencje są “sznurkami” wskazującymi na obiekty. Mamy dwie różne zmienne, które wskazują na ten sam adres na stercie. Jaka jest tego konsekwencja? Jeśli zmienimy zawartość obiektu pod tym adresem obie referencje będą pokazywały, nową, zmienioną wersję obiektu. Rzuć okiem na przykład.   public class ObjectFieldsChanging {     private int attribute;       public ObjectFieldsChanging(int attribute) {         this.attribute = attribute;     }       public int getAttribute() {         return attribute;     }       public void setAttribute(int attribute) {         this.attribute = attribute;     }       public static void main(String[] args) {         ObjectFieldsChanging reference1 = new ObjectFieldsChanging(123);         ObjectFieldsChanging reference2 = reference1;           System.out.println(reference1.getAttribute());         System.out.println(reference2.getAttribute());           reference1.setAttribute(1);           System.out.println(reference1.getAttribute());         System.out.println(reference2.getAttribute());     } }   Zmieniliśmy obiekt tylko pod jedną ze zmiennych, ale w związku z tym, że obie pokazują na ten sam adres na stercie zmiana dotyczyła obu.   Przypisanie nowej instancji obiektu do istniejącej zmiennej oczywiście “przepina sznurek” do innego miejsca na stercie (zmienna jest referencją do nowego obiektu, innego miejsca w pamięci).   ObjectFieldsChanging reference1 = new ObjectFieldsChanging(123); ObjectFieldsChanging reference2 = reference1; reference2 = new ObjectFieldsChanging(3);      Kolejna dygresja, jeśli po powyższych wyjaśnieniach masz mętlik w głowie pomiń ten akapit przy pierwszym czytaniu. Obiekty trzymane są na stercie, zmienne trzymane są na stosie (ang. stack) :). “Niestety” nie wszystkie zmienne wskazują na obiekty na stercie. Jeśli utworzysz zmienną lokalną (nie będącą atrybutem klasy) typu prostego (np. int czy double) wylądują one bezpośrednio na stosie. Referencja to nic innego jak numer, adres w pamięci. W przypadku zmiennych przechowywanych na stosie ten adres zostaje zastąpiony właściwą wartością zmiennej (np. liczbą 123).    Różnica między \"string\" a new String(\"string\")   Wiesz już, że obiekty zajmują obszar na stercie. Java stara się być trochę mądrzejsza i ograniczać ilość zajętego miejsca. Jedną z takich optymalizacji jest zachowanie w przypadku literałów reprezentujących typ String.   String x1 = new String(\"x\"); String x2 = new String(\"x\"); String x3 = \"x\"; String x4 = \"x\";   Dwie pierwsze linijki to dwie zmienne, dwie referencje i dwa różne obiekty (które mają w taką samą zawartość). Dwie ostatnie linijki to dwie zmienne, dwie referencje i jeden obiekt. Obie referencje pokazują na obiekt utworzony w 3 linijce. Innymi słowy konstruktor tworzy kopię przekazanego literału. Literał może czasami ograniczyć ilość zużytego miejsca na stercie.   Garbage Collector w wirtualenej maszynie Javy   Zbieracz śmieci :) Gargage collector, inaczej GC, jest komponentem wirtualnej maszyny Javy odpowiedzialnym za czyszczenie sterty2. Jeśli na stercie znajdą się obiekty, które już nie są używane zostają one usunięte aby zwolnić miejsce dla nowych obiektów.   Gdyby nie było tego mechanizmu pamięć nie byłaby zwalniana i po pewnym czasie program nie mógłby działać, nie miałby miejsca na alokację pamięci dla nowo tworzonych obiektów. GC używa różnych zaawansowanych algorytmów, które pozwalają zdecydować czy dany obiekt jest aktualnie wykorzystywany przez działający program.   GC działa w tle, w większości przypadków nawet nie będziesz wiedział kiedy. Wirtualna maszyna sama decyduje kiedy powinna go uruchomić. Istnieją sposoby aby zasugerować uruchomienie GC ale w rzeczywistości nie masz na to wpływu.   GC jest dość skomplikowanym mechanizmem, którego na tym etapie nie musisz w 100% rozumieć. Powinieneś wiedzieć o tym, że jest i odwala za Ciebie mnóstwo pracy :)   GC nie jest rozwiązaniem wszystkich problemów. Dalej możesz napisać program, który zajmie całą dostępną stertę i maszyna wirtualna nie będzie miała możliwości tworzenia nowych obiektów. W takiej sytuacji Twój program zostanie zamknięty, rzucony zostanie wyjątek java.lang.OutOfMemoryError.   null i NullPointerException   Oj, ten wyjątek zobaczysz wiele razy w trakcie swojej kariery :) Zanim jednak przejdziemy do wyjątku przeczytaj o magicznym null.   Będzie to trochę abstrakcyjne ale właśnie tak jest zdefiniowane w specyfikacji języka Java. Null jest typem, który nie ma nazwy. W związku z tym, że nie ma nazwy nie ma możliwości utworzyć zmiennej typu null. Wyrażenie null zwraca referencję do null.   Object object = new Object(); // ok null something = new null(); // compilation error   W praktyce jednak można zapomnieć o typie null i uznać to jako specjalny literał, który możemy przypisać do zmiennej każdego innego typu (który nie jest typem prostym). Możemy też założyć, że to jest “pusta” wartość zmiennej przechowującej referencję do obiektu.   A co się stanie jeśli wywołamy metodę na referencji wskazującej na null? Zostanie rzucony wyjątek java.lang.NullPointerException. Innymi słowy za każdym razem kiedy zobaczysz NullPointerException (a zobaczysz go nie raz) oznacza to, że zmienna ma wartość null.   Dodatkowe materiały do nauki      https://gist.github.com/jboner/2841832 – zestawienie czasów na podstawie których przygotowałem jeden z akapitów   http://edu.pjwstk.edu.pl/wyklady/ppj/scb/ObRef/ObRef.html   https://docs.oracle.com/javase/specs/jls/se12/html/jls-4.html#jls-4.1   kod źródłowy przykładów użytych w artykule   https://pl.wikipedia.org/wiki/Referencja_%28informatyka%29   Zadanie   Zadanie będzie nietypowe :) Spróbuj napisać program, który spowoduje przepełnienie sterty i skończy się wyjątkiem java.lang.OutOfMemoryError. Od razu powiem, że dla początkującego programisty nie jest to zadanie proste więc należy Ci się podpowiedź. Jak myślisz jak duża tablica z liczbami typu Long zmieści się w pamięci? Czy jeden wymiar tablicy zapełni pamięć? :)   Podsumowanie   Bardzo się cieszę, że dotrwałeś do końca :) Mam nadzieję, że artykuł przypadł Ci do gustu. Na koniec mam do Ciebie prośbę – polub nasz profil na Facebook’u i podziel się artykułem ze znajomymi. Dzięki temu dotrę do większej grupy czytelników a właśnie na tym mi zależy.   Jeśli masz jakiekolwiek pytania proszę zadaj je w komentarzach, postaram się pomóc :)   Miłego dnia i do następnego razu!                 Właściwie to zależy od implementacji maszyny wirtualnej Javy, nie mamy gwarancji, że ten numerek będzie adresem. &#8617;                  Nie tylko sterty, wirtualna maszyna Javy alokuje też pamięć w innych celach, na przykład tak zwany “metaspace”, który też jest czyszczony przez GC. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/referencja-sterta-garbage-collector/",
        "teaser": "/assets/images/2016/02/04_referencja_sterta_garbage_collector_artykul.jpeg"
      },{
        "title": "System dwójkowy",
        "excerpt":"Czym różni się cyfra od liczby?   Cyfra i liczba to dwie różne rzeczy. Cyfra to reprezentacja graficzna liczby np. znak 9. Cyfra to znak graficzny podobnie jak litera. Liczba to wartość, która może składać się z wielu cyfr. Wyjaśniłem tę różnicę na początku ponieważ przyda się ona do zrozumienia pozostałej części artykułu.   Suma i iloczyn   Każdy z nas miał to na matematyce, jednak dla przypomnienia wyjaśnię jeszcze i te pojęcia. 1 + 2 = 3. To jest operacja dodawania. Wynikiem operacji dodawania jest suma. 2 * 3 = 6. To jest operacja mnożenia. Wynikiem operacji mnożenia jest iloczyn.   Pojęcia te można ze sobą łączyć opisując dłuższe równania. 1 * 2 + 3 * 4 = 14 można opisać jako sumę iloczynów, (1 + 2) * (3 + 4) = 21 można opisać jako iloczyn sum.   System dziesiętny   1234, ot zwykła liczba. Liczba zapisana przy pomocy czterech cyfr. Takiej notacji uczyliśmy się od początku naszego życia. W ten sposób liczymy pieniądze, upływające lata czy mierzymy nasz wzrost. A co myślisz o liczbie 10011010010 ;) ? Okazuje się że 10011010010 zapisane binarnie to ta sama liczba co 1234 zapisana w systemie dziesiętnym.   Zanim przejdziemy do systemu binarnego omówmy trochę dokładniej system dziesiętny. Będzie tu trochę matematyki, jednak to nic trudnego i zupełnie nie ma się czego bać :).       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Potęgi      100 = 1 (10 do potęgi 0 równa się 1) właściwie to każda liczba większa od zera podniesiona do „zerowej potęgi” równa się 1.   101 = 10   102 = 100   103 = 1000 i tak dalej…   Teraz zapiszmy trochę inaczej naszą liczbę z przykładu:     1 * 1000 + 2 * 100 + 3 * 10 + 4 * 1 = 1 * 103 + 2 * 102 + 3 * 101 + 4 * 100 = 1234     Innymi słowy każdą liczbę w systemie dziesiętnym możemy zapisać przy pomocy sumy iloczynów potęg liczby 10. Może się to wydawać trochę skomplikowane jednak to nic trudnego, po prostu słownie opisałem 1 * 103 + 2 * 102 + 3 * 101 + 4 * 100.   Jeśli 10 nazwiemy bazą systemu dziesiętnego to cyfry, które służą do zapisywania liczb w tym systemie są z zakresu 0 do 9. Zapamiętaj, że tę własność można uogólnić. Innymi słowy jeśli bazę systemu zapisu liczb zastąpimy X wówczas możemy powiedzieć, że liczbę w tym systemie można zapisać przy pomocy cyfr od 0 do X-11.   A co stałoby się gdybyśmy potęgi 10 zamienili potęgami 2? Powstałby system binarny zapisywania liczb :).   System binarny, system dwójkowy   System binarny jest bardzo podobny do systemu dziesiętnego:     podobnie jak podstawą w systemie dziesiętnym, system binarny ma swoją podstawę. W systemie dziesiętnym jest to 10. W systemie binarnym podstawą jest 2,   podobnie jak w systemie dziesiętnym cyframi, które można używać do zapisu liczb są cyfry z zakresu 0 do (podstawa – 1). Więc w systemie dziesiętnym mamy zakres od 0 do 9. W systemie binarnym są to tylko dwie cyfry 0 lub 1,   podobnie jak w systemie dziesiętnym każdą liczbę można wyrazić za pomocą dodawania kolejnych potęg pomnożonych przez liczbę (103 * 1 + 102 * 2 + …), podobnie jest w systemie dwójkowym.   Potęgi 2      20 = 1   21 = 2   22 = 4   23 = 8   24 = 16   25 = 32   26 = 64   27 = 128   28 = 256   29 = 512   210 = 1024   Więc spróbujmy teraz zapisać naszą przykładową liczbę 1234 w systemie binarnym      1024 + 128 + 64 + 16 + 2 = 1 * 210 + 1 * 27 + 1 * 26 + 1 * 24 + 1 * 21 = 1 * 210 + 0 * 29 + 0 * 28 + 1 * 27 + 1 * 26 + 0 * 25 + 1 * 24 + 0 * 23 + 0 * 22 + 1 * 21 + 0 * 20     Mając już zapis liczby jako sumę iloczynów kolejnych potęg możemy spisać kolejne mnożne: 1, 0, 0, 1, 1, 0, 1, 0, 0, 1 i 0. Łącząc je w całość powstaje nam 10011010010 czyli nic innego jak 1234 zapisane w systemie binarnym.   Przekształcanie liczby do postaci binarnej   Wiesz już czym jest postać binarna. Nadszedł czas na algorytm, który pozwoli Ci przekształcić liczbę dziesiętną w binarną. Zanim do niego przejdziemy musisz wiedzieć czym jest dzielenie całkowitoliczbowe. Wynikiem całkowitoliczbowego dzielenia 5 / 2  jest 2, resztą z tego dzielenia jest 1. Wynikiem całkowitoliczbowego dzielenia 4 / 2 jest 2, reszta z tego dzielenia wynosi 0.   Algorytm przekształcenia liczby w postaci dziesiętnej na binarną:      Podziel liczbę całkowitoliczbowo przez 2. Zapisz resztę z dzielenia jako pierwszą cyfrę w postaci binarnej. Przypisz do liczby wynik z dzielenia,   Jeśli wynik dzielenia jest większy od zera przejdź do pierwszego kroku.   Poniżej przekształcenie liczby 21 na postać binarną:      Liczba to 21. 21 / 2 = 10 reszty 1, aktualna postać binarna 1,   10 &gt; 0, idziemy dalej,   Liczba to 10. 10 / 2 = 5 reszty 0, aktualna postać binarna 01,   5 &gt; 0, idziemy dalej,   Liczba to 5. 5 / 2 = 2 reszty 1, aktualna postać binarna 101,   2 &gt; 0, idziemy dalej,   Liczba to 2. 2 / 2 = 1 reszty 0, aktualna postać binarna 0101,   1 &gt; 0, idziemy dalej,   Liczba to 1. 1 / 2 = 0 reszty 1, aktualna postać binarna 10101,   0 &gt; 0 nie jest spełnione. Koniec algorytmu. Postać binarna liczby 21 to 10101   Spróbuj napisać program, który realizuje ten algorytm. Możesz sprawdzić poprawność wyniku używając metody Integer.toBinaryString. Polecam napisanie kilku testów jednostkowych, które sprawdzą poprawność Twojego rozwiązania.   Dodatkowe materiały do nauki      W komentarzu InfW4 wspomniał o ciekawych źródłach, dzięki za wskazówkę ;)    Podobnie jak komentujący miałem przyjemność uczęszczać na kursy prof. Janusza Biernata na Politechnice Wrocławskiej, chociaż artykuł nie powstał w oparciu o materiały z Jego książek jeśli interesuje Cię ta tematyka i chciałbyś spojrzeć na temat z bardziej teoretycznej strony możesz zajrzeć do książki, którą pamiętam ze studiów (ostrzegam, jest mocno teoretyczna): Metody i układy arytmetyki komputerowej – Janusz Biernat.   Podsumowanie   Teraz, wiedząc już jak działa system binarny wiesz już skąd wzięła się ta ogromna liczba polubień. 10000000 w systemie binarnym to 27 * 1 czyli 128 :) Jak zwykle mam dla Ciebie ćwiczenia na koniec. Spróbuj zapisać liczby 321 i 2048 w systemie binarnym.   Jeśli chcesz wyższego poziomu trudności zapisz liczby 1024 i 321 w systemie ósemkowym (w systemie, którego podstawą jest 8).   I jak? Trudne? Jeśli masz pytania zadaj je w komentarzach, postaram się pomóc. Bardzo dziękuję Ci za przeczytanie artykułu, jeśli chcesz wiedzieć o najnowszych wpisach polub stronę na Facebooku.   Na koniec mam do Ciebie jeszcze jedną prośbę. Zależy mi na tym, żeby dotrzeć do jak największej liczby czytelników więc jeśli mógłbyś polecić blog swoim znajomym byłbym wdzięczny. Z góry dziękuję i do następnego razu!   PS. Autorem zdjęcia z tytułem artykułu jest mój kolega Wojtek, inne zdjęcia jego autorstwa możecie zobaczyć na https://www.flickr.com/photos/koniu_87/.                 Oczywiście to jest umowne, równie dobrze można używać innych symboli. Np w systemie szesnastkowym stosujemy cyfry 0-9 oraz litery a-f. &#8617;           ","categories": ["Programowanie","Wiedza ogólna"],
        "tags": [],
        "url": "/system-dwojkowy/",
        "teaser": "/assets/images/2016/02/11_system_dwojkowy_artykul.png"
      },{
        "title": "Konwersja i rzutowanie w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Rzutowanie   Zaczniemy od rzutowania (ang. cast). Jak już wiesz kompilator Javy ma pewną wiedzę na temat tego, jaki rodzaj obiektu kryje się pod daną referencją w trakcie kompilacji. Wie to z typu zmiennej do której przypisany jest dany obiekt. Jednak możliwa jest sytuacja kiedy pod referencją typu X przypisany jest obiekt typu Y jak w przykładzie poniżej:   public void differentTypes() {     Object objectInstance = new Object();     Object stringInstance = \"string\"; }   Obie referencje są typu Object, jednak druga z nich przechowuje zmienną typu String. Jest to w 100% poprawny kod. Jednak jeśli na zmiennej stringInstance chciałbyś wywołać metodę, którą implementuje klasa String a nie ma jej w klasie Object skończy się to błędem kompilacji:   Error:(15, 23) java: cannot find symbol   symbol: method length()   location: variable stringInstance of type java.lang.Object   Jak zatem wywołać taką metodę? Przecież jesteśmy pewni, że pod zmienną stringInstance kryje się obiekt typu String. Tutaj z pomocą przychodzi rzutowanie. Java pozwala rzutować typ A na typ B używając wyrażenia rzutowania, możesz je zobaczyć w przykładzie poniżej:   public void differentTypes() {     Object objectInstance = new Object();     Object stringInstance = \"string\";      String realString = (String) stringInstance;     realString.length(); }   Oczywiście nie każde rzutowanie jest poprawne. W przykładzie poniżej możesz zobaczyć błędne rzutowanie z typu Object na typ String. Tego typu operacje kończą się wyjątkiem w trakcie wykonania programu:   public class RuntimeType {     public static void main(String[] args) {         Object[] someMysteriousObjects = new Object[] {\"1234\", new Object()};          String castedString = (String) someMysteriousObjects[0];         String classCastException = (String) someMysteriousObjects[1];     } }   Exception in thread \"main\" java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.String   at pl.samouczekprogramisty.kursjava.RuntimeType.main(RuntimeType.java:8)   Wyjątek mówi tyle, że obiektu typu java.lang.Object nie możemy rzutować do typu java.lang.String. Jakie rzutowanie jest w takim razie dozwolone? Możemy rzutować wyłącznie na typ, który znajduje się hierarchii dziedziczenia danego obiektu. Z tego właśnie powodu rzutowanie String na Object jest dopuszczalne ale odwrotna operacja kończy się błędem.   W jednym z kolejnych artykułów przeczytasz o typach generycznych, które pomagają rozwiązać część sytuacji, kiedy rzutowanie jest potrzebne. W codziennym programowaniu radziłbym unikać tego typu operacji. Z pewnością istnieje inny sposób napisania programu, który pozwoli na uniknięcie rzutowania.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Konwersja   Rzutowanie to specyficzny przypadek konwersji, jest to konwersja jawna, wymuszona przez programistę. W trakcie niektórych operacji może dochodzić do automatycznej konwersji, konwersji niejawnej. Konwersja niejawna może wystąpić na przykład podczas wywołania metod czy operacji arytmetycznych. Poniżej przykład konwersji automatycznej, która zachodzi w trakcie wywołania metody:   public class WideningConversion {     public static void main(String[] args) {         WideningConversion conversion = new WideningConversion();         int intVariable = Integer.MAX_VALUE;         long longVariable = Long.MAX_VALUE;          conversion.methodLongArgument(longVariable);         conversion.methodLongArgument(intVariable); // extending conversion     }      public void methodLongArgument(long argument) {         System.out.println(argument);     } }   Dochodzi do konwersji ponieważ metoda methodLongArgument przyjmuje parametr typu long, a jedno z wywołań przyjmuje zmienną typu int. Jest to tak zwana konwersja rozszerzająca. Może być wykonana niejawnie ponieważ podczas takiej konwersji nie zachodzi ryzyko utracenia informacji (o tym dalej). Kompilator robi to automatycznie za programistę. W przykładzie powyżej zmienna intVariable została automatycznie rozszerzona do typu long. Nie utraciliśmy żadnych informacji ponieważ typ long zawsze może pomieścić liczby które przechowuje int. W przykładzie używam zmiennych statycznych MAX_VALUE, które są typu int lub long i trzymają największą liczbę możliwą do przechowywania przez dany typ.   Konwersja w odwrotną stronę wymaga już jawnego rzutowania. Taka konwersja może prowadzić do utraty informacji. Proszę spójrz na przykład:   public class NarrowingConversion {     public static void main(String[] args) {         NarrowingConversion conversion = new NarrowingConversion();         int intVariable = Integer.MAX_VALUE;         long longVariable = Long.MAX_VALUE;         long longVariableWithoutLoosingInformation = Integer.MAX_VALUE; // automatic conversion from int to long          conversion.methodIntArgument(intVariable);         conversion.methodIntArgument((int) longVariable);         conversion.methodIntArgument((int) longVariableWithoutLoosingInformation);     }      public void methodIntArgument(int argument) {         System.out.println(argument);     } }   Jak myślisz co zostanie wypisane na konsoli po uruchomieniu tego programu?   2147483647 -1 2147483647   Dziwne prawda? :) Środkowa linijka to nic innego jak właśnie “utrata informacji”, która może zajść w trakcie jawnej konwersji1. Ostatnia linijka pokazuje, że nie każda konwersja z long do int prowadzi do utraty informacji.   Konwersja typów zmiennoprzecinkowych do całkowitoliczbowych   Innym przykładem konwersji w której dochodzi do utraty informacji jest konwersja z typów zmiennoprzecinkowych do typów całkowitoliczbowych:   int intValue = (int) 123.123F; long longValue = (long) 456.456;   W obu przypadkach tracimy informację o ułamku, zostaje wyłącznie część całkowitoliczbowa.   Automatyczna konwersja podczas przypisania   Podobnie rzecz się ma w przypadku przypisania wartości zmiennej, tutaj także dochodzi do automatycznej konwersji. Poniższy przykład pokazuje kilka możliwych przypadków:   public class AssignmentConversion {     public static void main(String[] args) {         long longValue = 123;         int intValue = (short) 123;         float floatValue = 12.12F;         double doubleValue = floatValue;          System.out.println(longValue);         System.out.println(intValue);         System.out.println(floatValue);         System.out.println(doubleValue);     } }   Pierwsza linijka metody main to niejawna konwersja z typu int na long (literały całkowitoliczbowe domyślnie są typu int), kolejna zawiera jawne rzutowanie 123 na typ short, które następnie konwertowane jest niejawnie z powrotem na typ int. Ostatni przykład to konwersja z typu float do double.   Automatyczna konwersja podczas operacji arytmetycznych   Podczas operacji arytmetycznych także może dochodzić do niejawnej konwersji. Zgodnie ze specyfikacją języka Java możliwa jest konwersja (zachodzi pierwszy pasujący warunek):     rozszerzająca do typu double jeśli którykolwiek z elementów operacji arytmetycznej jest typu double,   rozszerzająca do typu float jeśli którykolwiek z elementów operacji jest typu float,   rozszerzająca to typu long jeśli którykolwiek z elementów operacji jest typu long,   rozszerzająca do typu int.   Wszystkie cztery przypadki pokazane są w przykładzie poniżej:   public class ArithmeticConversion {     public static void main(String[] args) {         short shortValue = 1;         int intValue = 1;         long longValue = 2;         float floatValue = 3.1F;         double doubleValue = 4.1;          System.out.println(intValue + doubleValue);         System.out.println(intValue + floatValue);         System.out.println(intValue + longValue);         System.out.println(shortValue + shortValue);     } }   Tutaj drobna dygresja, operator dzielenia (/) wykonuje w języku Java dzielenie całkowitoliczbowe jeśli dzielna i dzielnik są całkowitoliczbowe. Jeśli chcemy otrzymać typ zmiennoprzecinkowy co najmniej jeden z elementów musi być typu zmiennoprzecinkowego:   5 / 2 = 2 5.0 / 2 = 2.5 5 / 2.0 = 2.5 6 / 2 = 3 6.0 / 2 = 3.0   Boxing i unboxing   Jak wiesz w języku Java występują zarówno typy proste jak i obiekty reprezentujące liczby np. int i Integer. Kompilator Java jest w stanie dokonać konwersji pomiędzy odpowiadającymi sobie typami prostymi i obiektami automatycznie. Proszę spójrz na przykład poniżej   int primitiveInt = Integer.valueOf(123); long primitiveLong = Long.valueOf(123L); float primitiveFloat = Float.valueOf(123.123F); double primitiveDouble = Double.valueOf(123.123); boolean primitiveBoolean = Boolean.valueOf(true);   Mamy tu do czynienia z tak zwanym “unboxing‘iem”, czyli automatycznym odpakowywaniem obiektu do odpowiadającego mu typu prostego.   Integer objectInteger = 123; Long objectLong = 123L; Float objectFloat = 123.123F; Double objectDouble = 123.123; Boolean objectBoolean = true;   Przykłady powyżej pokazują z kolei “boxing”, czyli automatyczne tworzenie instancji obiektów na podstawie typów prostych.   Podczas boxingu/unboxingu może dość do rzucenia różnych wyjątków, na przykład gdy obiekt przypisywany do typu prostego jest nullem lub gdy do typu prostego próbujemy przypisać inny obiekt (np. Long do int).   Konwersja do typu String   Konwersja do typu String jest specyficznym rodzajem konwersji automatycznej. Jest ona specyficzna ponieważ bazuje na metodzie toString, która może być przedefiniowana przez programistę. Konwersja do typu String zachodzi przy operatorze dodawania + jeśli któryś z dodawanych elementów jest typu String.   Typy proste także są automatycznie konwertowane do typu String, odbywa się to dwuetapowo, na początku zachodzi boxing następne obiekt konwertowany jest do typu String (wywoływana jest metoda toString).   String x = \"123\" + new Object(); String y = new Object() + \"123\"; String z = 1 + \"123\";   Zadania      Napisz program przyjmujący od użytkownika liczbę całkowitą i wyświetl wynik mnożenia tej liczby oraz stałej pi (Math.PI). Wyświetl wynik w postaci liczby całkowitej i liczby zmiennoprzecinkowej.   Napisz program pobierający od użytkownika dwie liczby całkowite. Wyświetl wynik ich dzielenia wraz z częścią ułamkową.   Napisz program, który skończy się wyjątkiem spowodowanym błędem podczas boxingu/unboxingu.   Jak myślisz co otrzymasz przypisując zmienną typu char do zmiennej typu int? Znajdziesz ten numer w tabeli ASCII?   Przygotowałem też dla Ciebie zestaw przykładowych rozwiązań zadań, analizując je także możesz się czegoś nauczyć.   Dodatkowe materiały do nauki      https://docs.oracle.com/javase/specs/jls/se12/html/jls-15.html#jls-15.16 – “cast expression”,   https://docs.oracle.com/javase/specs/jls/se12/html/jls-5.html – rzutowanie i konwersje,   https://github.com/SamouczekProgramisty/KursJava/tree/master/11_konwersja_rzutowanie – kod źródłowy przykładów użytych w artykule.   Podsumowanie   Właśnie dowiedziałeś się o kilku kolejnych zakamarkach języka Java. Mam nadzieję, że Ci się podobało. Jak zwykle na koniec mam do Ciebie prośbę, podziel się artykułem ze swoimi znajomymi, zleży mi na dotarciu do jak największego grona czytelników. Jeśli nie chcesz pominąć żadnego postu polub Samouczka na Facebook’u. Do następnego razu! :)                 Wartość -1 wynika ze sposobu zapisywania liczb w Javie. Wiesz już o binarnym zapisie, tutaj wykorzystywana jest jego specyficzna odmiana – uzupełnienia do dwóch, jeżeli jesteś zainteresowany szczegółami daj znać w komentarzu, skrobnę o tym artykuł :). &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/konwersja-i-rzutowanie-w-jezyku-java/",
        "teaser": "/assets/images/2016/02/17_konwersja_i_rzutowanie_artykul.jpeg"
      },{
        "title": "Zestaw ćwiczeń dla początkujących programistów",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Do rozwiązania zadań niezbędna będzie wiedza, którą możesz zdobyć czytając dotychczasowe artykuły. Jednak znajdą się też zadania, które będą wymagały dodatkowej lektury dokumentacji standardowej biblioteki Javy czy stron na Wikipedii. Aby wykonać te zadania musisz mieć wiedzę opisaną w artykułach w serii kurs programowania java do artukułu o interfejsach włącznie.   Całość podzielona jest na części. Odpowiadają one artykułom, które do tej pory miałeś okazję przeczytać. Polecam robienie ich w kolejności – na przykład ciężko będzie Ci zrobić zadania związane z pętlami bez znajomości tablic.   Zadania starałem się zorganizować w ten sposób aby kolejne bazowały na stworzonych już metodach/obiektach. W codziennym programowaniu właśnie tak to wygląda, budujemy małe klocki, z których można złożyć większą całość. To też będziesz mógł przećwiczyć rozwiązując poniższe zadania.   Operator %   Do tej pory nie opisałem jeszcze jednego dość przydatnego operatora w języku Java. Mianowicie %. Operator % zwraca resztę z dzielenia liczb. Najłatwiej będzie to zrozumieć na przykładzie   4 % 3 == 1; // bo 3 mieści się raz w 4 i zostaje 1 reszty 8 % 3 == 2; // bo 3 mieści się dwa razy w 8 i zostaje 2 reszty 3 % 4 == 3; // bo 4 nie mieści się w 3 i zostaje 3 reszty 15 % 5 == 0; // bo 5 mieści się trzy razy w 15 i zostaje 0 reszty   Jeśli chcielibyśmy zapisać działanie tego operatora przy pomocy równania matematycznego moglibyśmy użyć następującego wzoru:   (a / b) * b + (a % b) == a   Operator ten może się przydać na przykład do sprawdzenia czy liczba jest parzysta. Liczbę uważamy za parzystą jeśli jest podzielna przez 2 bez reszty   boolean isEven = someNumber % 2 == 0;       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Zadania   Metody w języku Java      Napisz metodę, która zwróci Twój aktualny wiek.   Napisz metodę, która zwróci Twoje imię,   Napisz metodę, która jako argument przyjmuje 2 liczby i wypisuje ich sumę, różnicę i iloczyn,   Napisz metodę, która jako argument przyjmuje liczbę i zwraca true jeśli liczba jest parzysta,   Napisz metodę, która jako argument przyjmuje liczbę i zwraca true jeśli liczba jest podzielna przez 3 i przez 5,   Napisz metodę, która jako argument przyjmuje liczbę i zwraca go podniesionego do 3 potęgi,   Napisz metodę, która jako argument przyjmuje liczbę i zwraca jej pierwiastek kwadratowy (poczytaj javadoc do klasy Math, znajdziesz tam metodę, która na pewno Ci pomoże),   Napisz metodę, która jako argument przyjmie trzy liczby. Metoda powinna zwrócić true jeśli z odcinków o długości przekazanych w argumentach można zbudować trójkąt prostokątny.   Obiekty i pakiety      Utwórz klasę Human reprezentującą człowieka, musi posiadać atrybuty takie jak wiek, waga, wzrost, imię i płeć. Klasa powinna także zawierać metody getAge, getWeight, getHeight, getName, isMale.   Utwórz klasę reprezentującą prostokąt, musi posiadać atrybuty długość i szerokość. Klasa powinna posiadać metody obliczające pole, obwód i długość przekątnej.   Utwórz klasę o nazwie MyNumber, której jedyny konstruktor przyjmuje liczbę. Klasa powinna mieć następujące metody   MyNumber isOdd() – true jeśli atrybut jest nieparzysty,   MyNumber isEven() – true jeśli atrybut jest parzysty,   MyNumber sqrt() – pierwiastek z atrybutu,   MyNumber pow(MyNumber x) – atrybut podniesiony do potęgi x (przydatnej metody poszukaj w javadoc do klasy Math),   MyNumber add(MyNumber x) – zwraca sumę atrybutu i x opakowaną w klasę MyNumber,   MyNumber subtract(MyNumber x) – zwraca różnicę atrybutu i x opakowaną w klasę MyNumber.   A teraz ciekawostka, jeśli rozwiązałeś zadanie 3. to muszę Ci zdradzić, że podobna klasa istnieje w standardowej bibliotece języka Java. Jest to klasa BigInteger/BigDecimal. Oczywiście jej możliwości są dużo bardziej rozbudowane, jednak zasada działania jest podobna.   Tablice      Napisz metodę, która zwróci tablicę String[] zawierającą pierwsze 5 liter alfabetu,   Napisz metodę pobierającą trójelementową tablicę liczb, która zwróci tablicę zawierającą te same elementy w odwróconej kolejności   Dużo zadań dotyczących tablic wymaga znajmości pętli, dlatego w następnym akapicie znajdziesz więcej interesujących zadań związanych z tablicami.   Pętle i instrukcje warunkowe      Utwórz metodę pobierającą dodatnią liczbę całkowitą X, która wyświetli na ekranie liczby od zera do X,   Jeśli w zadaniu 1. użyłeś pętli for przerób tę metodę na while (lub odwrotnie),   Napisz klasę ArrayFactory, która w konstruktorze pobierze liczbę całkowitą X. Klasa powinna mieć 2 metody:            int[] oneDimension – zwróci instancję tablicy jednowymiarowej o długości X,       int[][] twoDimension – zwróci instację tablicy dwuwymiarowej gdzie liczba wierszy i liczba kolumn równa się X,           Utwórz metodę, która pobierze liczbę i wypisze każdy znak w osobnej linii zaczynając od ostatniej cyfry (np. dla liczby 123 będą to trzy linie z 3, 2 i 1),   Utwórz metodę, która jako argument pobierze obiekt klasy String i zwróci “odwrócony” argument. Na przykład “pies” przekształci w “seip”,   Utwórz metodę, która pobierze liczbę oraz zwróci ją w formie binarnej (2 =&gt; “10”, 4 =&gt; “100”, 5 =&gt; “101”, itd.). System binarny opisałem w osobnym artykule,   Utwórz metodę, pobierającą łańcuch znaków, która sprawdzi czy jest on palindromem. Np. “kajak” jest palindromem (to samo czytane “od przodu i od tyłu”) jednak “kotek” już nie. Może przydać Ci się metoda String#toCharArray   Do klasy ArrayFactory dodaj metodę zwracającą macierz jednostkową (jedynki “na przekątnej”),   Napisz metodę, która pobierze tablicę liczb całkowitych i wyświetli ją w postaci “[liczba, liczba, liczba]”,   Napisz metodę, która pobierze tablicę liczb całkowitych i posortuje ją w kolejności od najmniejszej do największej liczby. Jednym z podstawowych algorytmów sortowania jest sortowanie bąbelkowe.   Chociaż zadania wymagają wiedzy z zakresu podstaw języka Java nie są bardzo łatwe. Na pewno ciekawostką dla Ciebie będzie to, że na przykład zadanie z palindromem czasami trafia się na rozmowach rekrutacyjnych :)   Typy proste   W tej sekcji znajdują się głównie zadania, które wymagają znajomości klasy Scanner opisanej w artykule dotyczącym typów prostych.     Jeśli w klasie Human użyłeś typów prostych zamień je na odpowiadające im klasy (int =&gt; Integer),   Napisz program, który pobierze od użytkownika liczbę całkowitą, a następnie wyświetli jej binarną reprezentację na ekranie,   Napisz program, który pobierze od użytkownika liczbę całkowitą N reprezentującą długość tablicy, a następnie poprosi o N kolejnych liczb uzupełniając nimi wcześniej stworzoną tablicę. Wyświetl na konsoli tablicę posortowaną w kolejności od najmniejszej do największej liczby,   Napisz program, który pobierze od użytkownika łańcuch znaków i wyświetli na konsoli jego długość, informację czy jest to palindrom czy nie oraz jego odwróconą wartość.   Interfejsy      Stwórz interfejs Figure. Interfejs powinien zawierać metody getPerimeter (zwracającą obwód) oraz getArea (zwracającą powierzchnię). Następnie utwórz klasy Circle, Triangle i Rectangle, niech każda z klas implementuje interfejs Figure. Napisz program, który pobierze od użytkownika:            długość promienia koła,       2 długości boków trójkąta prostokątnego (boki przy kącie prostym),       długość boków prostokąta.           Utworzy instancje tych obiektów i umieści je w tablicy Figure[]. Następnie iterując po obiektach wyświetl pole oraz obwód aktualnego obiektu.   Rozwiązania zadań   Starałem się nie korzystać z bibliotek/API, którego jeszcze nie poznaliśmy w ramach kursu. Używając bardziej zaawansowanych metod niektóre z przedstawionych tu zadań można rozwiązać lepiej, jednak na początek takie proste podejście w zupełności wystarczy. Prosiłbym Cię żebyś jednak spróbował rozwiązać zadania samodzielnie, dopiero jeśli nie będzie już innego wyjścia rzuć okiem na przykładowe rozwiązania.   Rozwiązania, które dostarczyłem nie są jedynymi możliwymi rozwiązaniami, Ty mogłeś rozwiązać dany problem zupełnie inaczej.   Podsumowanie   Mam nadzieję, że zestaw zadań Ci się spodobał. Raz jeszcze prosiłbym Cię, żebyś rozwiązał je samodzielnie, wtedy nauczysz się najwięcej. Jeśli chciałbyś abym napisał kolejny artykuł tego typu daj znać ;) Jeśli będziesz miał problem z którymkolwiek z nich możesz rzucić okiem do gotowych rozwiązań.   Jeśli nie chcesz pominąć żadnego z kolejnych artykułów proszę polub naszą stronę na Facebook’u. Proszę Cię też abyś udostępnił ten artykuł innym Twoim znajomym, którzy mogą być zainteresowani – niezmiennie zależy mi na dotarciu do jak największej liczby czytelników. Do następnego razu! :)  ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/zestaw-cwiczen-dla-poczatkujacych-programistow/",
        "teaser": "/assets/images/2016/03/13_dodatkowe_zadania_artykul.jpg"
      },{
        "title": "Typy generyczne w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Czym są typy generyczne   W uproszczeniu można powiedzieć, że typy generyczne są “szablonami”. Dzięki typom generycznym możemy uniknąć niepotrzebnego rzutowania. Ponadto przy ich pomocy kompilator jest w stanie sprawdzić poprawność typów na etapie kompilacji, oznacza to więcej błędów wykrytych w jej trakcie1.   Poza tym dzięki typom generycznym możemy konstruować bardziej złożone klasy, które możemy używać w wielu kontekstach, łatwiej będzie Ci to zrozumieć na przykładzie.   Porównanie typów generycznych i standardowych   Znasz już zwykłe klasy i interfejsy, zostały one omówione we wcześniejszych artykułach. Klasy mają swoje atrybuty, których typy znasz pisząc program.   public class Apple { }  public class AppleBox {     private Apple apple;      public AppleBox(Apple apple) {         this.apple = apple;     }      public Apple getApple() {         return apple;     } }   W przykładzie powyżej klasa AppleBox “wie” jakiego typu obiekt może przechowywać, jest to obiekt typu Apple. A co jeśli chcielibyśmy zrobić analogiczną klasę dla owoców innego rodzaju? Oczywiście możemy stworzyć podobne pudełko jak w przykładzie poniżej:   public class Orange { }  public class OrangeBox {     private Orange orange;      public OrangeBox(Orange orange) {         this.orange = orange;     }      public Orange getOrange() {         return orange;     } }   Oba przykłady są jak najbardziej poprawne jednak występuje w nich duplikacja. Te same elementy, konstrukcje powielane są wielokrotnie. Duplikacja w kodzie generalnie jest złą praktyką, należy jej unikać. Możemy zatem stworzyć kolejną klasę:   public class FruitBox {     private Object fruit;      public FruitBox(Object fruit) {         this.fruit = fruit;     }      public Object getFruit() {         return fruit;     } }  public class Main {     public static void main(String[] args) {         FruitBox fruitBox = new FruitBox(new Orange());         Orange fruit1 = (Orange) fruitBox.getFruit();     } }   Z racji tego, że atrybut fruit jest typu Object możemy do niego przypisać zarówno instancję klasy Orange jak i Apple. Pojawia się jednak pewien problem. Mianowicie jeśli chcemy pobrać atrybut fruit i przypisać go do zmiennej odpowiedniego typu musimy rzutować. Tego typu konstrukcja może powodować błędy podczas wykonania programu i warto jej unikać. Z pomocą przychodzą typy generyczne. Proszę spójrz na przykład poniżej.   public class BoxOnSteroids&lt;T&gt; {     public T fruit;      public BoxOnSteroids(T fruit) {         this.fruit = fruit;     }      public T getFruit() {         return fruit;     } }  public class Main {     public static void main(String[] args) {         BoxOnSteroids&lt;Apple&gt; appleBox = new BoxOnSteroids&lt;Apple&gt;(new Apple());         BoxOnSteroids&lt;Orange&gt; orangeBox = new BoxOnSteroids&lt;Orange&gt;(new Orange());          Orange fruit = orangeBox.getFruit();     } }   public class BoxOnSteroids&lt;T&gt; to nic innego jak pierwsza linijka definicji klasy. Nowa tutaj jest konstrukcja z nawiasami. Oznacza ona właśnie typ generyczny, który możemy parametryzować innym typem. Typ ten dostaje tymczasową nazwę, w tym przypadku T, której używamy dalej w ciele klasy.   W trakcie tworzenia instancji obiektu BoxOnSteroids podajemy informację o typie, który chcielibyśmy wstawić w miejsce T. W naszym przykładzie są to klasy Apple lub Orange. Dzięki takiej konstrukcji kompilator dokładnie wie jakiego typu obiekt zostanie zwrócony przez metodę getFruit w związku z tym rzutowanie nie jest konieczne2.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Klasy generyczne i parametryzowanie   Wspomniałem wcześniej, że klasy generyczne są szablonami dla nowych klas. W uproszczeniu można powiedzieć, że parametry klasy generycznej są elementami uzupełnianymi w szablonie.   Spróbuję opisać to bardziej obrazowo. Szablon to foremka do wycinania ciastek. Tej foremki możemy użyć do wycięcia wielu ciastek. Każde z nich możemy ozdobić w inny sposób. To w jaki sposób ciastko jest ozdobione jest parametrem tego szablonu:   public class CookieCutter&lt;T&gt; {     private T glaze; }   Definicja klasy generycznej   Klasę generyczną definiujemy w następujący sposób   class Name&lt;T1, T2, ..., Tn&gt; {     /* body */ }   Zauważ, że w nawiasach &lt;&gt; możemy umieścić więcej niż jeden parametr. Chociaż zgodnie ze specyfikacją języka Java możesz użyć dowolnej nazwy która nadaje się na nazwę zmiennej istnieje konwencja nazewnicza sugerująca nazwy parametrów. Zwyczajowo do tego celu używa się wielkich liter T, K, U, V, E.   W miejsce parametrów możemy wstawić dowolny obiekt, nie może to jednak być typ prosty. Innymi słowy Integer jest w porządku, int powoduje błąd.   Instancja klasy generycznej   Skoro już wiemy jak zdefiniować klasę generyczną przydałoby się stworzyć jej instancję, żeby w końcu jej użyć :). Linijka poniżej tworzy instancję klasy generycznej BoxOnSteroids, która parametryzowana jest typem Orange.   BoxOnSteroids&lt;Orange&gt; orangeBox = new BoxOnSteroids&lt;Orange&gt;(new Orange());   Zauważ, że i tutaj występuje pewna duplikacja. Zarówno przy określaniu typu zmiennej jak i przy wywołaniu konstruktora powtarzamy klasę Orange. Nie jest to konieczne. Jeśli kompilator jest w stanie “wywnioskować” jaki typ powinien być użyty możemy go pominąć przy konstruktorze.   BoxOnSteroids&lt;Orange&gt; orangeBox = new BoxOnSteroids&lt;&gt;(new Orange());   Zagnieżdżone typy generyczne   Możesz też tworzyć instancje typów generycznych, które są bardziej skomplikowane. Przykład poniżej pokazuje klasę Pair, która parametryzowana jest dwoma innymi typami.   public class Pair&lt;T, S&gt; {     private T first;     private S second;      public Pair(T first, S second) {         this.first = first;         this.second = second;     }      public T getFirst() {         return first;     }      public S getSecond() {         return second;     } }   Java pozwala na to aby tworząc instancję typu generycznego parametryzować go innym typem generycznym. Brzmi to skomplikowanie, mam nadzieję, że przykład pomoże Ci to zrozumieć:   Pair&lt;BoxOnSteroids&lt;Orange&gt;, BoxOnSteroids&lt;Apple&gt;&gt; pairOfBoxes =         new Pair&lt;&gt;(                 new BoxOnSteroids&lt;&gt;(new Orange()),                 new BoxOnSteroids&lt;&gt;(new Apple())         );   W przykładzie tym tworzony jest obiekt klasy Pair, który parametryzowany jest klasami BoxOnSteroids&lt;Orange&gt; i BoxOnSteroids&lt;Apple&gt;.   Typy generyczne nie rozwiązują wszystkich problemów   Typy generyczne zostały wprowadzone w wersji Javy 1.5. Nie były dostępne od początku jej istnienia. Zatem istnieją sytuacje, w których nawet ich stosowanie może prowadzić do wystąpienia błędów w trakcie wykonywania programu. Proszę spójrz na przykład poniżej:   BoxOnSteroids boxWithoutType = new BoxOnSteroids(new Apple()); BoxOnSteroids&lt;Apple&gt; boxWithApple = boxWithoutType; BoxOnSteroids&lt;Orange&gt; boxWithOrange = boxWithoutType; Apple apple = boxWithApple.getFruit(); Orange orange = boxWithOrange.getFruit(); // ClassCastException   W przykładzie tym tworzona jest instancja klasy generycznej BoxOnSteroids bez wyspecyfikowania klasy, która znajduje się “w środku”. Następnie tę instancję przypisujemy do zmiennych typu BoxOnSteroids&lt;Apple&gt; i BoxOnSteroids&lt;Orange&gt;. O ile w pierwszym przypadku typ owocu trzymanego w środku się zgadza to ostatnia linia nie jest poprawna – generuje błąd typu ClassCastException. Obiekt typu Apple jest rzutowany przez kompilator do typu Orange3.   Słowo kluczowe extends   To słowo kluczowe ma zastosowanie także w przypadku typów generycznych. Dzięki niemu możemy ograniczyć zestaw klas którymi możemy parametryzować nasz typ generyczny. Omówmy to na przykładzie:   public interface Figure {     String getName(); }  public class Circle implements Figure {     public String getName() {         return \"circle\";     } }  public class BoxForFigures&lt;T extends Figure&gt; {     private T element;      public BoxForFigures(T element) {         this.element = element;     }      public T getElement() {         return element;     }      public String getElementName() {         return element.getName();     } }  BoxForFigures&lt;Circle&gt; circleBox = new BoxForFigures&lt;&gt;(new Circle()); BoxForFigures&lt;Apple&gt; appleBox; // complilation error   Jak widzisz przykład definiuje prosty interfejs Figure i klasę Circle, która go implementuje. Następnie definiujemy klasę BoxForFigures, która jest generyczna i może być parametryzowana przez typy dziedziczące/implementujące Figure.   Dzięki takiemu zapisowi kompilator pozwoli nam stworzyć instancję BoxForFigures&lt;Circle&gt; circleBox jednak zacznie się buntować przy BoxForFigures&lt;Apple&gt; appleBox (Apple nie implementuje interfejsu Figure).   Kolejną zaletą używania tego słowa kluczowego jest możliwość wywoływania metod na obiekcie typu parametryzowanego. W przykładzie powyżej wiemy że T jest czymś co implementuje Figure więc musi mieć metody dostępne w tym interfejsie. Właśnie z tego powodu w metodzie getElementName możemy wywołać metodę getName z tego interfejsu.   Dziedziczenie typów generycznych   Tutaj należy się dodatkowe zdanie wyjaśnienia poparte prostym przykładem. Proszę spójrz na początek na klasy Rectangle i Square poniżej:   public class Rectangle implements Figure {     public String getName() {         return \"rectangle\";     } }  public class Square extends Rectangle {     public String getName() {         return \"square\";     } }   Jak wiesz każda klasa w języku Java dziedziczy po klasie Object (bezpośrednio, bądź pośrednio). W naszym przykładzie bezpośrednio po klasie Object dziedziczą klasy Rectangle, BoxForFigures&lt;Rectangle&gt; i BoxForFigures&lt;Square&gt;4. Natomiast Square dziedziczy po Rectangle.             Dziedziczenie typów generycznych.        Ma to swoje konsekwencje widoczne w przykładzie poniżej:   Rectangle rectangle = new Square(); BoxForFigures&lt;Rectangle&gt; rectangleBox = new BoxForFigures&lt;Square&gt;(new Square()); // compilation error   Dzięki takiemu schematowi dziedziczenia do referencji typu Rectangle możemy przypisać obiekt Square. Jednak próba przypisania obiektu BoxForFigures&lt;Square&gt; do referencji BoxForFigures&lt;Rectangle&gt; powoduje błąd kompilacji.   Jednak podobnie jak w przypadku zwykłych klas, klasy generyczne także mogą dziedziczyć po innych klasach. W szczególności mogą także dziedziczyć po klasach generycznych.   class StandardBox&lt;T&gt; {     public T object;      public StandardBox(T object) {         this.object = object;     } }  public class FancyBox&lt;T&gt; extends StandardBox&lt;T&gt; {     public FancyBox(T object) {         super(object);     }     public void saySomethingFancy() {         System.out.println(\"our \" + object + \" is cool!\");     } }  public class Main {     public static void main(String[] args) {         FancyBox&lt;String&gt; box = new FancyBox&lt;&gt;(\"something\");         box.saySomethingFancy();     } }   W naszym przykładzie klasa FancyBox dziedziczy po StandardBox, widoczne jest to na diagramie poniżej.             Dziedziczenie typów generycznych        Metody z generycznymi argumentami – wildcard   FancyBox&lt;?&gt;   Pisząc metody, które jako argumenty przyjmują typy generyczne nie zawsze chcesz dokładnie specyfikować typ. W takim wypadku z pomocą przychodzi znak ?, który może akceptować różne typy.   private static void method1(FancyBox&lt;?&gt; box) {     Object object = box.object;     System.out.println(object); }  private static void plainWildcard() {     method1(new FancyBox&lt;&gt;(new Object()));     method1(new FancyBox&lt;&gt;(new Square()));     method1(new FancyBox&lt;&gt;(new Apple())); }   Jak widzisz w przykładzie powyżej metoda method1 może akceptować różne klasy FancyBox parametryzowaną dowolnym typem.   Przypisanie wartości   Ma to jednak swoje konsekwencje. Klasa, która parametryzowana jest ? nie przyjmie żadnych obiektów poza null. Przykład poniżej zakończy się błędem kompilacji:   FancyBox&lt;?&gt; box = new FancyBox&lt;&gt;(\"object\"); box.object = null; // box.object = \"xxx\"; // compilation error   FancyBox&lt;? extends Figure&gt; “upper bound”   Znak ? może występować także w połączeniu ze słówkiem kluczowym extends. W takim przypadku możesz ograniczyć akceptowane typy “z góry”. W przykładzie poniżej metoda akceptuje jedynie instancje FancyBox, które parametryzowane są klasami dziedziczącymi po Figure.   private static void method2(FancyBox&lt;? extends Figure&gt; box) {     Figure figure = box.object;     System.out.println(figure); }  private static void method3(FancyBox&lt;Figure&gt; box) {     Figure figure = box.object;     System.out.println(figure); }  private static void upperBoundWildcard() {     FancyBox&lt;Figure&gt; fancyFigureBox = new FancyBox&lt;&gt;(new Circle());     FancyBox&lt;Circle&gt; fancyCircleBox = new FancyBox&lt;&gt;(new Circle());     FancyBox&lt;Square&gt; fancySquareBox = new FancyBox&lt;&gt;(new Square());     method2(fancyFigureBox);     method2(fancyCircleBox);     method2(fancySquareBox);     // method3(fancySquareBox); // compilation error }   W przykładzie tym możesz także zobaczyć, że typ FancyBox&lt;Figure&gt; jest bardziej restrykcyjny niż FancyBox&lt;? extends Figure&gt;. W konsekwencji próba wywołania method3 z argumentem innego typu niż FancyBox&lt;Figure&gt; skutkuje błędem kompilacji.   Przypisanie wartości   Podobnie jak w przypadku ? tutaj także są ograniczenia dotyczące przypisywania wartości. Spójrz jeszcze raz na przykład:   private static void method2(FancyBox&lt;? extends Figure&gt; box) {     Figure figure = box.object;     System.out.println(figure);     // box.object = null;     // box.object = new Square(); // compilation error }   Skoro wewnątrz metody parametr box może mieć zarówno typ FancyBox&lt;Square&gt; jak i FancyBox&lt;Circle&gt; (jak i wiele innych) kompilator nie może pozwolić na wstawienie tam obiektu innego niż null. Nie może tego zrobić bo nie wie jakiego typu obiekty przechowywane są w box.   FancyBox&lt;? super Rectangle&gt; “lower bound”   Poza ograniczeniem “z góry” możesz także ograniczyć akceptowalne typy “z dołu”. W przykładzie poniżej metoda akceptuje wyłącznie argumenty typu FancyBox&lt;Object&gt;, FancyBox&lt;Figure&gt; i FancyBox&lt;Rectangle&gt;.   private static void method4(FancyBox&lt;? super Rectangle&gt; box) {     box.object = new Square();     // box.object = new Circle(); // compilation error }  private static void lowerBoundWildcard() {     FancyBox&lt;Rectangle&gt; fancyRectangleBox = new FancyBox&lt;&gt;(new Rectangle());     FancyBox&lt;Figure&gt; fancyFiguraBox = new FancyBox&lt;&gt;(new Rectangle());     FancyBox&lt;Object&gt; fancyObjectBox = new FancyBox&lt;&gt;(new Object());     method4(fancyRectangleBox);     method4(fancyFiguraBox);     method4(fancyObjectBox);     // FancyBox&lt;Square&gt; fancySquareBox = new FancyBox&lt;&gt;(new Square());     // method4(fancySquareBox); // compilation error }   Zauważ, ze w niektórych miejscach nie ma potrzeby podawania typu generycznego. Samo &lt;&gt; wystarczy, kompilator jest w stanie wywnioskować jakiego typu może się tam spodziewać. Typy generyczne są skomplikowane. Jeśli aktualnie masz mętlik w głowie nie przejmuj się, przeczytaj artykuł jeszcze raz, przejrzyj przykłady. Zrozumienie przyjdzie z doświadczeniem.   Przypisanie wartości   Wyżej wspomniałem, że przy ograniczeniu z dołu kompilator wie czego może się spodziewać. W przykładzie:   private static void method4(FancyBox&lt;? super Rectangle&gt; box) {     box.object = null;     box.object = new Rectangle();     box.object = new Square();     // box.object = new Object(); // compilation error }   Parametr box może być typu FancyBox&lt;Object&gt;, FancyBox&lt;Figure&gt; i FancyBox&lt;Rectangle&gt;. Zatem w tym przypadku do pola box.object można przypisać null i każdy obiekt, który dziedziczy po Rectangle.   Typy generyczne są skomplikowane   Nie zostały one dodane do Javy od samego początku. W związku z tym, że twórcy chcieli zachować kompatybilność wstecz5 istnieje wiele kruczków, które nie są trywialne. Pominąłem w artykule np. “type erasure” czy generyczne metody, które nie są istotne na początku. Jeśli jesteś nimi zainteresowany odsyłam do materiałów dodatkowych.   Materiały dodatkowe   Wszystkie przykłady użyte w tym artykule dostępne są na githubie. Poniżej zebrałem dla Ciebie zestaw dodatkowy materiałów, jeśli chciałbyś poszerzyć swoją wiedzę na temat typów generycznych w języku Java.      https://docs.oracle.com/javase/tutorial/java/generics/index.html   https://docs.oracle.com/javase/tutorial/extra/generics/index.html   https://docs.oracle.com/javase/specs/jls/se12/html/jls-4.html#jls-4.5   https://pl.wikipedia.org/wiki/Programowanie_uog%C3%B3lnione   Podsumowanie   Nie jest to oczywiście kompletny artykuł dotyczący typów generycznych w Javie. Pominięte zostały aspekty wymazywania typów czy bardziej szczegółowe informacje dotyczące użycia ?. Jeśli któryś fragment jest dla Ciebie nie do końca zrozumiały daj znać, postaram się rozszerzyć artykuł o dodatkowe przykłady i opisy.   Na koniec mam do Ciebie prośbę. Proszę podziel się artykułem ze swoimi znajomymi, którzy mogą być zainteresowani tematem programowania. Zależy mi na dotarciu do jak największej liczby czytelników. Jeśli nie chcesz ominąć żadnego kolejnego artykułu polub nas na Facebook’u :) Do następnego razu!                 Mała dygresja. Każdy błąd w kodzie kosztuje. Ktoś w końcu płaci za pracę testerów, programistów, administratorów. Im wcześniej wykryjemy błąd tym tańsze jest jego naprawienie. Poprawienie programu działającego na środowisku produkcyjnym może być bardzo drogie. Wykrywanie błędów w trakcie kompilacji, chociaż może być frustrujące dla programisty jest najtańszym rozwiązaniem :) &#8617;                  W praktyce rzutowanie tam występuje jednak jest wykonywane automatycznie przez kompilator generujący bytecode. &#8617;                  Tu właśnie objawia się to automatyczne rzutowanie generowane przez kompilator &#8617;                  W rzeczywistości, po skompilowaniu powstanie jeden plik class z klasą BoxForFigures. &#8617;                  Twórcom zależało na tym aby programy napisane w starej wersji Javy mogły być uruchamiane na najnowszych wersjach maszyny wirtualnej. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/typy-generyczne-w-jezyku-java/",
        "teaser": "/assets/images/2016/03/23_java_typy_generyczne_artykul.jpg"
      },{
        "title": "Porównywanie obiektów, metody equals i hashCode w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Porównywanie typów prostych   Do sprawdzenia “równości” typów prostych służą operatory == oraz !=. Dzięki nim możemy porównać ze sobą każdą zmienną typu prostego. Wynikiem takiego porównania jest wartość typu boolean – true jeśli porównywane obiekty są równe i false w przeciwnym wypadku. Proszę spójrz na przykład poniżej:   System.out.println(\"10 == 10: \" + (10 == 10)); System.out.println(\"10 != 10: \" + (10 != 10)); System.out.println(\"true == true: \" + (true == true)); System.out.println(\"true != true: \" + (true != true)); System.out.println(\"'a' == 'a': \" + ('a' == 'a')); System.out.println(\"'a' != 'a': \" + ('a' != 'a')); System.out.println(\"500L == 500L: \" + (500L == 500L)); System.out.println(\"500L != 500L: \" + (500L != 500L));   Kolejne linijki porównują odpowiednio:     liczby typu int,   zmienne typu boolean,   znaki typu char,   liczby typu long.   Priorytety operatorów   Drobna dygresja dotycząca priorytetów operatorów. W języku Java wszystkie operatory mają tak zwany priorytet. Oznacza to tyle, że priorytet operatorów określa kolejność wykonywania działań. Proszę spójrz na przykład niżej   10 == 4 + 6 4 + 6 == 10 3 * 5 + 2   Operator + ma wyższy priorytet niż operator ==. W związku z tym operacja dodawania wykonana zostanie jako pierwsza i porównanie zwróci true. Podobnie * ma wyższy priorytet niż +. Zatem na początku wykonana zostanie operacja mnożenia a na końcu dodawanie.   Czasami jednak domyślny priorytet operatorów nie jest odpowiedni, chcielibyśmy wykonać operacje w innej kolejności. Z pomocą przychodzą nawiasy, które pozwalają na modyfikację zachowania programu. Przykład poniżej pomaga zrozumieć jak to działa:   3 * (5 + 2)   Mimo tego, że operator * ma wyższy priorytet niż + operacja mnożenia zostanie wykonana jako druga. Pierwsze zostanie wykonane dodawanie ponieważ zostało otoczone parą nawiasów.   Po tym wstępie mogę wyjaśnić dlaczego w przykładzie poniżej potrzebujemy nawiasów:   \"10 == 10: \" + 10 == 10 // compilation error! \"10 == 10: \" + (10 == 10)   Bez dodatkowej pary nawiasów pierwszeństwo miałby operator +. \"10 == 10: \" + 10 == 10 inaczej możemy zapisać jako \"10 == 10: 10\"  == 10, a taki zapis nie jest poprawny. Jest błędny, ponieważ operatorem == nie możemy porównać instancji typu String i wartości typu int.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Porównywanie zmiennoprzecinkowych typów prostych   O ile sprawdzanie równości wartości liczb całkowitych nie jest trudne to ta sama operacja dla typów zmiennoprzecinkowych jest trochę bardziej skomplikowana. W związku ze sposobem reprezentacji liczb zmiennoprzecinkowych typu float i double w pamięci komputera nie jest możliwe ich dokładne porównywanie. Operacja taka jest dopuszczalna ale może prowadzić do dziwnych rezultatów (na przykład, liczby, które teoretycznie powinny być równe według komputera nie są).   W związku z tym liczby zmiennoprzecinkowe powinno się porównywać z pewną dokładnością.   System.out.println(\"0.3 == 0.1 + 0.2: \" + (0.3 == 0.1 + 0.2)); // !!! System.out.println(\"0.3 == 0.1 + 0.2: \" + (Math.abs(0.3 - (0.1 + 0.2)) &lt; 0.000001));   W przykładzie powyżej została użyta metoda Math.abs(). Metoda ta zwraca wartość bezwzględną danej liczby. Następnie wartość tę porównujemy z bardzo małą liczbą. Liczba ta reprezentuje dokładność porównania. Jeśli różnica liczb jest mniejsza niż nasza założona dokładność uznajemy, że porównywane liczby są równe.   Porównanie obiektów   Używając operatora == do porównywania obiektów uzyskamy błędne rezultaty. Do porównania tego typu powinniśmy używać metody equals.   System.out.println(\"test == test: \" + (new String(\"test\") == new String(\"test\"))); System.out.println(\"test equals test: \" + new String(\"test\").equals(new String(\"test\")));   Dlaczego tak się dzieje? Otóż w przypadku obiektów operator == porównuje referencje obiektów (adresy na stercie). Mając dwie różne instancje obiektów mają one dwa różne adresy w pamięci w związku z tym zawsze ich adresy są różne. Innymi słowy w przypadku obiektów przy pomocy operatora == możemy sprawdzić czy dwie referencje wskazują na ten sam obiekt.   String reference1 = new String(\"something\"); String reference2 = reference1; System.out.println(\"reference1 == reference2: \" + (reference1 == reference2));   Metoda equals   Metoda equals jest jedną z metod dostępnych w klasie Object. W związku z tym, że każdy obiekt w języku Java ma tę klasę w swojej hierarchii dziedziczenia możemy tą metodą wywołać na każdym obiekcie.   W większości przypadków domyślna implementacja metody equals nie jest odpowiednia1 w związku z tym programista tworzący nowy obiekt musi tę metodę zaimplementować jeśli chce sprawdzać czy instancje tej klasy są równe.   Istnieje zestaw wytycznych, które metoda equals powinna spełniać aby była poprawnie zaimplementowana. Opiszę je po kolei:   Metoda equals powinna być zwrotna   Oznacza to tyle, że dla każdego obiektu operacja object.equals(object) powinna zwrócić true.   Metoda equals powinna być symetryczna   Oznacza to tyle, że dla każdej pary obiektów X i Y powinna zachodzić właściwość jeśli X.equals(Y) == true wówczas także Y.equals(X) == true.   Metoda equals powinna być przechodnia   Jeśli mamy trzy obiekty X, Y i Z oraz jeśli X.equals(Y) == true i Y.equals(Z) == true to także X.equals(Z) jest prawdą.   Metoda equals powinna być spójna   Innymi słowy kilkukrotne wywołanie metody equals na tych samych obiektach zawsze powinno zwrócić ten sam wynik (zakładając, że obiekty nie były modyfikowane pomiędzy wywołaniami).   Metoda equals powinna zwrócić false przy porówaniu z null   Dla każdego obiektu X, który nie jest null porównanie typu X.equals(null) powinno zwrócić false.   Załóżmy, że mamy klasę Chair. Możemy powiedzieć, że krzesła są “równe” jeśli zostały wyprodukowane w tym samym roku, przez tego samego producenta oraz są tego samego modelu. Założenia te zostały zaimplementowane poniżej.   public class Chair {     private String model;     private String manufacturer;     private int productionYear;       public Chair(String model, String manufacturer, int productionYear) {         this.model = model;         this.manufacturer = manufacturer;         this.productionYear = productionYear;     }          public String getModel() {         return model;     }          public String getManufacturer() {         return manufacturer;     }          public int getProductionYear() {         return productionYear;     }       @Override     public boolean equals(Object obj) {         if (obj == null) {             return false;         }         if (obj instanceof Chair) {             Chair otherChair = (Chair) obj;             return model.equals(otherChair.model) &amp;&amp;                     manufacturer.equals(otherChair.manufacturer) &amp;&amp;                     productionYear == otherChair.productionYear;         }         return false;     }       @Override     public int hashCode() {         return 17 * model.hashCode() + 31 * manufacturer.hashCode() + 7 * productionYear;     } }   Chair chair1 = new Chair(\"Adde\", \"IKEA\", 2016);  Chair chair2 = new Chair(\"Janinge\", \"IKEA\", 2016);  Chair chair3 = new Chair(\"Adde\", \"IKEA\", 2015);  Chair chair4 = new Chair(\"Adde\", \"IKEA\", 2016);   System.out.println(\"chair1.equals(chair2): \" + chair1.equals(chair2));  System.out.println(\"chair1.equals(chair3): \" + chair1.equals(chair3));  System.out.println(\"chair1.equals(chair4): \" + chair1.equals(chair4));  System.out.println(\"chair1.equals(null): \" + chair1.equals(null));   Zauważ, że w naszej implementacji metody equals używamy także metody equals z typu String aby sprawdzić czy model i producent są równi.   Nowy może być także operator instanceof, służy on do sprawdzenia czy dana instancja jest typu Chair. Po tym sprawdzeniu możemy bezpiecznie rzutować obiekt obj i mamy pewność, że nie zostanie rzucony wyjątek ClassCastException. Operator ten zwróci false zawsze jeśli porównywany obiekt ma wartość null. W związku z tym jeden z powyższych warunków jest nadmiarowy i można go usunąć:   @Override public boolean equals(Object obj) {     if (obj instanceof Chair) {         Chair otherChair = (Chair) obj;         return model.equals(otherChair.model) &amp;&amp;                 manufacturer.equals(otherChair.manufacturer) &amp;&amp;                 productionYear == otherChair.productionYear;     }     return false; }   Metoda hashCode   Podobnie jak w przypadku equals hashCode jest zaimplementowane w klasie Object. Zawsze kiedy programista implementuje metodę hashCode powinien też zaimplementować metodęequals.   Metoda ta zwraca liczbę typu int, która służy do przyporządkowania danego obiektu do grupy. Dzięki metodzie hashCode jesteśmy w stanie podzielić wszystkie możliwe instancje danej klasy na rozdzielne grupy. Każda z tych grup reprezentowana jest przez liczbę zwracaną przez metodę hashCode.             hashCode zasada działania.        Obrazowe przyporządkowanie obiektów do grup zostało przedstawione na diagramie powyżej. Koła i trójkąt zostały przyporządkowane do tej samej grupy, rąb i pięciokąt do grupy Hash#2 natomiast trapez został przyporządkowany do grupy Hash#3.   Metoda hashCode wykorzystywana jest przez niektóre kolekcje (tablice na sterydach), o których przeczytasz w jednym z kolejnych artykułów. Implementacja metody hashCode sprowadza się do zwrócenia odpowiedniej liczby, tak zwanego hasha. Przyporządkuje on dany obiekt do grupy używanej w niektórych kolekcjach. Najczęściej metodę hashCode implementuje się w oparciu o hashe atrybutów danej instancji. Hashe atrybutów zazwyczaj mnoży się przez liczby pierwsze i sumuje ze sobą. Użycie liczb pierwszych pomaga w uzyskaniu “dobrych hashy”. Dobra implementacja hashCode pozwala na uzyskanie jak największej liczby grup (hashy), do których przyporządkowujemy obiekty.   Posłużę sie tu klasą Chair wspomianą wyżej. Zakładając, że nasza klasa ma trzy atrybuty i żaden z nich nie może mieć wartości null przykładowa implemetacja może wyglądać następująco:   @Override public int hashCode() {     return 17 * model.hashCode() + 31 * manufacturer.hashCode() + 7 * productionYear; }   W większości przypadków użycie metody Objects.hash przy implementacji metody hashCode jest dobrym pomysłem.   Kontrakt między metodami equals i hashCode   Metody hashCode i equals są ze sobą powiązane i ich implementacja powinna być spójna. Tą zależność określa się kontraktem między metodami hashCode i equals.      Jeśli X.equals(Y) == true wówczas wymagane jest aby X.hashCode() == Y.hashCode(),   Kilkukrotne wywołanie metody hashCode na tym samym obiekcie, który nie był modyfikowany pomiędzy wywołaniami musi zwrócić tę samą wartość,   Jeśli X.hashCode() == Y.hashCode() to nie jest wymagane aby X.equals(Y) == true.   Trzeci przypadek jest ilustrowany na obrazku powyżej gdzie koła i trójkąt mają ten sam hashCode jednak koło i trójkąt nie są równe.   Generatory metod hashCode i equals   Implementacja tych metod w większości przypadków jest dość prosta. W większości z nich także nie jest to kod zbyt skomplikowany. Jednak za każdym razem pisanie tych metod jest uciążliwe. Z pomocą przychodzi IDE. Polecam generowanie tych metod przy jego pomocy. W przypadku IntelliJ IDEA pomocny może okazać się skrót klawiaturowy Alt+Insert. Po jego naciśnięciu pokaże się menu kontekstowe pozwalające na wygenerowanie tych metod.   Dodatkowo warto przyjrzeć się klasie Objects i bibliotekom Guava czy Apache commons-lang. Zawierają one metody pomocnicze użyteczne podczas implementacji metod hashCode i equals.   Zadanie   Na koniec krótkie zadanie dla Ciebie. Napisz klasę reprezentującą człowieka, zaimplementuj metody hashCode i equals. Zastanów się czy to, że ktoś ma to samo imię i nazwisko sprawia, że jest to ta sama osoba? Jaki atrybut może posłużyć do sprawdzenia czy dwie instancje klasy Human reprezentują tę samą osobę?   Jeśli będziesz miał problem z rozwiązaniem zadania przykładowe rozwiązanie umieściłem na githubie. Jak zwykle zachęcam do samodzielnych prób, wtedy nauczysz się najwięcej.   Materiały dodatkowe   Kod źródłowy wszystkich przykładów użytych w artykule znajduje się na githubie. Jeśli chcesz poczytać więcej na temat metod equals i hashCode zapraszam do materiałów dodatkowych:     Object.equals   Object.hashCode   Opis operatorów porównania w specyfikacji języka Java   http://kobietydokodu.pl/niezbednik-juniora-kontrakt-hashcode-i-equals   Podsumowanie   Bardzo się cieszę, że dotarłeś do końca artykułu. Mam nadzieję, że był on dla Ciebie ciekawy i przydatny. Na koniec mam do Ciebie prośbę, podziel się artykułem ze swoimi znajomymi, zależy mi na dotarciu do jak największej liczby czytelników. Jeśli nie chcesz przegapić nowych artykułów polub nas na Facebook’u :) W przypadku jakichkolwiek pytań proszę zdaj je w komentarzach, postaram się odpowiedzieć.   Do następnego razu!                 Domyślna implementacja zachowuje się jak operator ==, porównuje adresy obiektów. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/porownywanie-obiektow-metody-equals-i-hashcode-w-jezyku-java/",
        "teaser": "/assets/images/2016/04/17_equals_hashcode_w_jezyku_java_artykul.jpg"
      },{
        "title": "Kolekcje w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Biblioteka standardowa   Java, podobnie jak wiele innych języków, w tak zwanej bibliotece standardowej1 zawiera zestaw kolekcji. Kolekcja to nic innego jak sposób grupowania obiektów. Kolekcją możemy także nazwać tablicę obiektów, którą już znasz. Jednak tego typu kolekcja na pewne ograniczenia, głównym z nich jest to, że rozmiar, który ustalimy na początku nie może być zmieniony.   Kolekcje możemy opisać jako „tablice na sterydach”. Pozwalają one na dużo więcej niż przechowywanie obiektów w kolejności określonej przez tablicę.   Kolekcje to implementacje tak zwanych struktur danych. O przykładowych implementacjach struktur danych na pewno przeczytasz w jednym z kolejnych artykułów. Na dzisiaj musisz zapamiętać, ze rodzaj kolekcji/struktury danych pozwala napisać program, który jest bardziej bądź mniej wydajny (działa szybciej lub wolniej). To, jaką kolekcję w danym momencie użyjemy ma znaczenie. W kolejnych akapitach postaram się przytoczyć podstawowe kolekcje wraz z przykładami ich użycia.   Hierarchia dziedziczenia   Kolekcje w standardowej bibliotece Javy implementują różne interfejsy, poniższy diagram pokazuje hierarchię dziedziczenia interfejsów dla podstawowych typów kolekcji dostępnych w Javie. Każdy z tych interfejsów ma kilka implementacji, których używa się w różnych sytuacjach.             Dziedziczenie kolekcji w języku Java.        Lista   Lista (ang. list) podobnie jak tablica, grupuje elementy. Jej główną przewagą nad tablicą jest to, że programista nie musi się przejmować rozmiarem listy2, jest ona automatycznie powiększana wraz z dodawaniem nowych elementów. Listy w języku Java reprezentowane są przez interfejs java.util.List. Listy z definicji są kolekcjami dla których kolejność elementów jest istotna, mogą przechowywać ten sam obiekt po kilka razy. Podstawowymi przykładami implementacji interfejsu java.util.List są klasy java.util.LinkedList oraz java.util.ArrayList.   Bez wdawania się w zbędne szczegóły, proszę zapamiętaj, że LinkedList lepiej jest używać jeśli często usuwasz elementy z listy, a ArrayList lepiej jest używać jeśli często chcesz mieć dostęp do losowych elementów w liście. Obiecuje, że dokładne wytłumaczenie dlaczego tak się dzieje znajdziesz w jednym z kolejnych artykułów.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Przydatne metody w java.util.List   Chciałbym pokazać Ci parę metod, które mogą Ci się przydać przy pracy z listami. Jeśli jesteś zainteresowany pełną listą zachęcam do przeczytania dokumentacji dla interfejsu List, tam znajdziesz wszystkie niezbędne szczegóły.   Załóżmy, że nasza zmienna jest typu List&lt;String&gt;. Wówczas będziesz mógł używać m.in. następujących metod:      add – dodaje element do listy,   addAll – jako parametr przyjmuje inną kolekcję i dodaje wszystkie elementy z tej kolekcji do listy,   contains – jako parametr przyjmuje element listy i zwraca flagę informującą czy dany element już istnieje (tutaj przyda Ci się artykuł o porównywaniu obiektów w języku Java),   isEmpty – bezargumentowa metoda zwracająca flagę informującą czy lista jest pusta,   size – bezargumentowa metoda zwracająca liczbę elementów w liście,   indexOf – metoda jako parametr przyjmuje element listy i zwraca indeks pierwszego wystąpienia,   lastIndexOf – metoda jako parametr przyjmuje element listy i zwraca indeks ostatniego wystąpienia.   Opisane wyżej metody użyte zostały w kodzie poniżej.   List&lt;String&gt; listWithNames = new LinkedList&lt;&gt;(); listWithNames.add(\"Piotrek\"); listWithNames.add(\"Krzysiek\");  List&lt;String&gt; otherListWithNames = new LinkedList&lt;&gt;(); otherListWithNames.add(\"Marek\"); otherListWithNames.addAll(listWithNames); otherListWithNames.add(\"Marek\");  System.out.println(otherListWithNames.contains(\"Marek\")); System.out.println(otherListWithNames.get(0)); System.out.println(otherListWithNames.isEmpty()); System.out.println(otherListWithNames.indexOf(\"Marek\")); System.out.println(otherListWithNames.lastIndexOf(\"Marek\"));   Tutaj drobna dygresja, w kodzie wyżej widzisz zapis List&lt;String&gt; listWithNames = new LinkedList&lt;&gt;(). Dlaczego nie napisać LinkedList&lt;String&gt; listWithNames = new LinkedList&lt;&gt;()? Pierwsza wersja pokazuje dobrą praktykę, która polega na definiowaniu zmiennych typu interfejsu a nie klasy implementującej ten interfejs. Dzięki temu w przyszłości z łatwością moglibyśmy przypisać do listWithNames zmienną typu ArrayList&lt;String&gt; bez konieczności zmiany pozostałej części programu.   Zbiór   Zbiór (ang. set) to kolekcja, która służy do przechowywania unikalnych elementów. Zbiory w języku Java implementują interfejs java.util.Set. W przypadku zbioru nie jest istotna kolejność dodawanych elementów. Innymi słowy jeśli do zbioru dodamy na początku element X a później Y to przechodząc po kolei po elementach zbioru możemy dostać je w odwrotnej kolejności. Istnieją także implementacje zbioru, w których kolejność elementów jest zachowana, jednak jest to raczej „szczegół implementacyjny” niż szczególna właściwość zbiorów.   Kolejną cechą zbioru jest to, że przechowuje on unikalne elementy. W odróżnieniu od listy, w zbiorze można przechowywać wyłącznie jedną instancję obiektu.   Skąd możemy wiedzieć, że dana instancja jest już w zbiorze? Otóż służą do tego opisane już metody hashCode oraz equals.   Jeszcze raz przypomnę o kontrakcie między tymi metodami. Poprawne działanie kolekcji wymaga poprawnie zaimplementowanych metod hashCode/equals. Jeśli ten warunek nie jest spełniony niektóre kolekcje mogą działać w dziwny, niespodziewany sposób.   Najważniejszą implementacją interfejsu Set jest klasa java.util.HashSet.   Przydatne metody w java.util.Set   Podobnie jak w przypadku list zachęcam do zapoznania się z pełną listą metod dostępnych w interfejsie Set. Poniżej lista kilku przydatnych metod:     add – dodaje element do zbioru,   addAll – jako parametr przyjmuje inną kolekcję i dodaje wszystkie elementy z tej kolekcji do zbioru (pomijając duplikaty),   contains – jako parametr przyjmuje element zbioru i zwraca flagę informującą czy dany element już istnieje,   isEmpty – bezargumentowa metoda zwracająca flagę informującą czy zbiór jest pusty,   size – metoda zwraca ilość elementów w zbiorze.   Przykład użycia metod znajduje się we fragmencie kodu poniżej.   Set&lt;String&gt; setWithNames = new HashSet&lt;&gt;(); setWithNames.add(\"Marcin\"); setWithNames.add(\"Marek\"); setWithNames.add(\"Marcin\");   Set&lt;String&gt; otherSet = new HashSet&lt;&gt;(); otherSet.add(\"Zenon\"); otherSet.add(\"Marek\");   setWithNames.addAll(otherSet);   System.out.println(setWithNames.isEmpty()); System.out.println(setWithNames.size()); System.out.println(setWithNames.contains(\"Marcin\")); System.out.println(setWithNames.remove(\"Janusz\"));   Mapa   Mapa (ang. map) jest kolekcją, która pozwala przechować odwzorowanie zbioru kluczy na listę wartości. Innymi słowy w mapie możemy trzymać klucze, którym odpowiadają wartości. Klucze muszą być unikalne (dlatego pisałem o zbiorze kluczy), wartości natomiast mogą się powtarzać. Czyli pod kluczem A i pod kluczem B może być ta sama wartość X. Ale sytuacja odwrotna gdzie klucz X występuje dwa razy i jeden z nich wskazuje na element A a inny na element B nie jest możliwa3.   Czytając inne źródła możesz natknąć się na inne nazwy. Słownik, tablica asocjacyjna, mapa – to pojęcia opisujące dokładnie tę samą strukturę danych.   Kluczami w mapie powinny być obiekty, których nie można zmodyfikować (ang. immutable). Np dobrymi kandydatami na klucze są instancje takich klas jak String czy Integer – są to obiekty, których po zainicjalizowaniu nie możemy zmodyfikować. Ponadto klasy kluczy muszą poprawnie implementować metody hashCode/equals. Jeśli jakaś para (klucz, wartość1) istnieje jest w mapie, a Ty spróbujesz dodać kolejną (klucz, wartość2) (ten sam klucz). Wówczas ta ostatnia para będzie przechowywana przez mapę, nadpisze ona poprzedni element.   Podobnie jak Set i List, Map jest interfejsem generycznym, jednak w tym przypadku wymaga on dwóch klas – pierwsza z nich definiuje typ kluczy, druga typ wartości przechowywanych w mapie.   Standardową implementacją mapy w języku Java jest klasa java.util.HashMap.   Przydatne metody w java.util.Map      put – dodaje parę klucz/wartość do mapy,   putAll – jako parametr przyjmuje inną mapę i dodaje wszystkie elementy z do mapy,   containsKey – jako parametr przyjmuje klucz i zwraca flagę informującą czy dany klucz już istnieje,   containsValue – jako parametr przyjmuje wartość i zwraca flagę informującą czy dana wartość już istnieje,   isEmpty – bezargumentowa metoda zwracająca flagę informującą czy mapa jest pusta,   size – bezargumentowa metoda zwracająca liczbę elementów w mapie,   remove – metoda jako parametr przyjmuje klucz i usuwa parę klucz/wartość z mapy,   get – metoda jako parametr przyjmuje klucz i zwraca odpowiadającą mu wartość.   Przykłady użycia metod znajdziesz we fragmencie kodu poniżej.   Map&lt;String, String&gt; pairsMap = new HashMap&lt;&gt;(); pairsMap.put(\"Marcin\", \"Adela\"); pairsMap.put(\"Marek\", \"Magda\");   Map&lt;String, String&gt; otherPairsMap = new HashMap&lt;&gt;(); otherPairsMap.put(\"Marek\", \"Ewa\"); otherPairsMap.put(\"Adam\", \"Ewa\");   pairsMap.putAll(otherPairsMap);   System.out.println(pairsMap.get(\"Marek\")); System.out.println(pairsMap.remove(\"Marek\")); System.out.println(pairsMap.size()); System.out.println(pairsMap.isEmpty()); System.out.println(pairsMap.containsKey(\"Jan\")); System.out.println(pairsMap.containsValue(\"Adela\"));   Pełna lista metod dostępna w interfejsie Map znajduje się w dokumentacji.  Skróty klawiaturowe   W IDE, które proponowałem na początku (IntelliJ IDEA) jest skrót klawiaturowy, który bardzo może Ci się przydać w odkrywaniu nowych metod. Po wpisaniu zmiennej i kropki po niej naciśnij &lt;Ctrl + Spacja&gt; pojawi się menu kontekstowe z dostępnymi atrybutami/metodami tego obiektu.             Skróty klawiaturowe w IntelliJ IDEA        Kolejny przydatny skrót klawiaturowy to &lt;Ctrl + H&gt;. Najedź kursorem na interfejs List, po naciśnięciu tego skrótu pojawi się panel zawierający hierarchię dziedziczenia dla elementu pod kursorem. Także ten panel jest widoczny na zrzucie ekranu powyżej.   Dzięki szybkiemu wglądowi w hierarchii dziedziczenia możesz w łatwy sposób odnaleźć inne implementacje danego interfejsu.   Ograniczenia kolekcji   Jak już napisałem wyżej „kolekcje to tablice na sterydach”. Z tymi sterydami przychodzą także pewne ograniczenia. Głównym ograniczeniem jest to że wraz z kolekcjami opisanymi powyżej nie możesz używać typów prymitywnych (Integer tak, int nie). Możesz to łatwo obejść poprzez używanie odpowiadających im obiektów, jednak obiekty takie zajmują więcej miejsca w pamięci niż typy prymitywne.   Istnieją implementacje kolekcji, które pozwalają na używanie typów prymitywnych jednak na tym etapie nauki Javy nie zaprzątałbym sobie nimi głowy. Standardowe kolekcje są w zupełności wystarczające.   Iterowanie po kolekcjach   Z artykułu opisującego pętle dowiedziałeś się o różnych rodzajach pętli i to właśnie na nich tutaj się skupimy4.   Iterowanie po listach   Najprostszym sposobem jest iterowanie przy użyciu pętli foreach. Zgodnie z definicją listy elementy będą zwracane w kolejności dodawania ich do listy.   Jeśli potrzebujemy dostępu do indeksu elementu możemy użyć także standardowej pętli for. Jeśli takie podejście jest wymagane lepiej jest używać implementacji ArrayList niż LinkedList.   List&lt;String&gt; sampleList = new ArrayList&lt;&gt;(); sampleList.add(\"Marcin\"); sampleList.add(\"Adela\"); sampleList.add(\"Marek\"); sampleList.add(\"Magda\");   System.out.println(\"Iterowanie po liscie (foreach)\"); for(String item : sampleList) {     System.out.println(item); }   System.out.println(\"Iterowanie po liscie (for)\"); for(int index = 0; index &lt; sampleList.size(); index++) {     System.out.println(sampleList.get(index)); }   Iterowanie po zbiorach   Podobnie jak w przypadku list z pomocą przychodzi pętla foreach, jednak tutaj nie mamy już gwarancji zwrócenia obiektów zbioru w tej samej kolejności, w której były one do niego dodawane (zachęcam do sprawdzenia tego samodzielnie).   Set&lt;String&gt; sampleSet = new HashSet&lt;&gt;(); sampleSet.add(\"Marcin\"); sampleSet.add(\"Adela\"); sampleSet.add(\"Marek\"); sampleSet.add(\"Magda\");   System.out.println(\"Iterowanie po zbiorze\"); for(String item : sampleSet) {     System.out.println(item); }   Iterowanie po mapach   Z racji tego, że w mapach mamy zbiór kluczy mapowanych na wartości możemy iterować po samych kluczach, samych wartościach bądź parach klucz, wartość. Powinniśmy używać odpowiedniego sposobu w zależności od naszych potrzeb.   Kolejna dygresja, nowością może być dla Ciebie zapis Map.Entry&lt;String, String&gt;. Jest to notacja wskazująca na tak zwaną klasę wewnętrzną (bądź inerfejs). Interfejs Entry został zdefiniowana wewnątrz Map dlatego odwołujemy się do niego poprzez Map.Entry. Jest to interfejs generyczny, który odpowiada parze klucz/wartość, dlatego typowany jest tymi samymi typami co mapa z przykładu.   Map&lt;String, String&gt; sampleMap = new HashMap&lt;&gt;(); sampleMap.put(\"Marek\", \"Magda\"); sampleMap.put(\"Marcin\", \"Adela\");   System.out.println(\"Iterowanie po wartosciach\"); for(String value : sampleMap.values()) {     System.out.println(value); }   System.out.println(\"Iterowanie po kluczach i pobieranie wartosci\"); for(String key : sampleMap.keySet()) {     String value = sampleMap.get(key);     System.out.println(key + \": \" + value); }   System.out.println(\"Iterowanie po kluczach i wartosciach\"); for(Map.Entry&lt;String, String&gt; entry : sampleMap.entrySet()) {     String key = entry.getKey();     String value = entry.getValue();     System.out.println(key + \": \" + value); }   Porównanie typów kolekcji   Na koniec dla ułatwienia przygotowałem dla Ciebie tabelkę, która grupuje właściwości poszczególnych kolekcji w jednym miejscu wraz z przykładem użycia.                          Lista       Zbiór       Mapa                       Zachowuje kolejność elementów       Tak       Nie       Nie                 Pozwala na przechowywanie kliku takich samych elementów/kluczy       Tak       Nie       Nie                 Przykład użycia (podróżowałeś przez Europę pociągiem)       Miasta, które odwiedziłeś (cała trasa z drogą powrotną, niektóre miasta odwiedziłeś także przy powrocie)       Zbiór miast, które odwiedziłeś (bez duplikatów).       Nazwy państw, które odwiedziłeś wraz z odpowiadającymi im stolicami.           Zadania      Napisz program, który będzie pobierał od użytkownika imiona. Program powinien pozwolić użytkownikowi na wprowadzenie dowolnej liczby imion (wprowadzenie „-” jako imienia przerwie wprowadzanie). Na zakończenie wypisz liczbę unikalnych imion.   Napisz program, który będzie pobierał od użytkownika imiona par dopóki nie wprowadzi imienia „-”, następnie poproś użytkownika o podanie jednego z wcześniej wprowadzonych imion i wyświetl imię odpowiadającego mu partnera.   Jeśli będziesz miał problemy z rozwiązaniem któregokolwiek z zadań na githubie umieściłem przykładowe rozwiązania. Zachęcam do ich sprawdzenia dopiero po przygotowaniu swojej wersji :)   Dodatkowe materiały do nauki   Materiałów na temat kolekcji w internecie jest całkiem sporo, poniżej przygotowałem dla Ciebie zestaw linków do innych blogów/kursów gdzie autorzy także opisują kolekcje. Jeśli będzie brakowało Ci materiałów, bądź będziesz chciał poznać temat z innej strony zachęcam do zapoznania się z nimi. Na początek kod źródłowy przykładów i rozwiązań zadań oraz dokumentacja biblioteki standardowej.     https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Map.html   https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/Set.html   https://docs.oracle.com/en/java/javase/12/docs/api/java.base/java/util/List.html   Kod źródłowy i przykłady rozwiązań zadań na githubie   No i zestaw pozostałych materiałów :)     http://wazniak.mimuw.edu.pl/index.php?title=PO_Kolekcje_wst%C4%99p   http://wazniak.mimuw.edu.pl/index.php?title=PO_Kolekcje_-_przegląd   ArrayList przykład użycia (youtube)   http://tutorials.jenkov.com/java-collections/index.html   http://kobietydokodu.pl/05-kolekcje-w-javie/   Podsumowanie   Cieszę się, że dotrwałeś do końca. Musisz wiedzieć, że bez kolekcji nie ma programowania, ten artykuł jest naprawdę ważny :). Na koniec mam do Ciebie prośbę, proszę pomóż mi dotrzeć do kolejnych Samouków, podziel się z nimi adresem tego bloga i polub stronkę na Facebook’u. Z góry wielkie dzięki!   Do następnego razu!                 Biblioteka standardowa to zestaw klas, które może używać programista, dostarczonych wraz z językiem programowania. &#8617;                  Oczywiście w granicach rozsądku, w skrajnych przypadkach utworzenie listy ze zbyt dużą liczbą elementów może prowadzić do wystąpienia błędu OutOfMemoryError. &#8617;                  Tu znów dygresja, oczywiście istnieją implementacje, które pozwalają na takie zachowanie, jednak nie jest to „domyślne” zachowanie. &#8617;                  Na początku pominiemy strumienie, którymi zajmiemy się w osobnym artykule. &#8617;           ","categories": ["Kurs programowania Java","Programowanie"],
        "tags": [],
        "url": "/kolekcje-w-jezyku-java/",
        "teaser": "/assets/images/2016/08/09_kolekcje_w_jezyku_java_artykul.jpg"
      },{
        "title": "Operacje na plikach w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   System plików   Na początku winien Ci jestem drobne wprowadzenie do czegoś co nazywa się systemem plików. Otóż dysk komputera może pomieścić pewną ilość danych, współczesne dyski twarde mają pojemność z przedziału kilkuset gigabajtów (GB) do kilku terabajtów (TB).   Jest to ogromna przestrzeń, 1 GB to 1’000 MB, to z kolei przekłada się na 1’000’000’000B (109 bajtów). Każdy z tych bajtów to 8 bitów. Na zapisanie dowolnej liczby typu int w Javie potrzebujesz 32 bitów (4 bajtów). Czyli 1GB dysku w teorii może pomieścić 250’000’000 liczb zapisanych w tym formacie. Innymi słowy potrzeba około 3GB aby w tym formacie zapisać datę urodzenia każdego mieszkańca Europy (gdzie datę zapisujemy jako jedną liczbę) :)   Aby komputer wiedział co znajduje się w którym miejscu w tym gąszczu cyferek potrzebny jest system plików. Istnieje wiele rodzajów systemów plików, jednak ich rozróżnienie nie jest nam w tym momencie potrzebne. Jeśli jesteś zainteresowany bardziej szczegółowymi informacjami zachęcam do przeczytania artykułu na wikipedii.   Najważniejsze jest abyś zapamiętał, że system plików organizuje dane na dysku i daje do nich dostęp poprzez znane Ci foldery czy pliki.   Pliki binarne a pliki tekstowe   Wiesz już, że plik mapuje się na pewien obszar danych na dysku. Otwierając jakikolwiek plik czytasz te dane za pośrednictwem systemu plików. Dane te mogą być zapisane w trybie „tekstowym” bądź „binarnym”1.   Sposób zapisu danych ma istotny wpływ na rozmiar pliku. Na przykład zapisanie liczby 1234567 binarnie jako int w Javie wymaga 4 bajtów. Zapisanie tej samej liczby jako łańcuch znaków w pliku tekstowym wymaga już 7 bajtów. Innymi słowy zapis binarny w ogromnej większości przypadków wymaga mniej miejsca na dysku.   Niestety wiąże się to z pewnymi ograniczeniami. Otóż pliki binarne nie są czytelne dla ludzi (ang. human-readable). Czy zdarzyło Ci się kiedyś otworzyć plik binarny w notatniku? Zobaczyłbyś wtedy przysłowiowe „krzaki”, ponieważ notatnik interpretował dane binarne jako tekst.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Ścieżka do pliku   System plików organizuje dane na dysku w hierarchiczną strukturę katalogów wewnątrz których znajdują się pliki. Każdy plik czy katalog ma ścieżkę, która jednoznacznie wskazuje jego miejsce w tej strukturze.   Tutaj napotykamy na pewne różnice pomiędzy różnymi systemami operacyjnymi. Dyski mogą być podzielone na tak zwane partycje, systemy operacyjne z rodziny Windows przedstawiają te partycje jako osobne dyski np. dysk C czy dysk D. W związku z tym ścieżki nieznacznie różnią się pomiędzy różnymi systemami operacyjnymi. I tak ścieżka w systemie z rodziny Windows wygląda następująco:   C:\\katalog\\plik.txt   Analogiczna ścieżka w systemach z rodziny Linux/Unix wygląda trochę inaczej:   /katalog/plik.txt   W kontekście języka Java taka różnica ma pewne konsekwencje. Otóż jeśli chcemy użyć literału String wówczas znak \\ musimy poprzedzić kolejnym \\. Dzieje się tak ponieważ symbol \\ jest wykorzystywany w specjalny sposób. Zatem ścieżka C:\\katalog\\plik.txt zapisana w Javie jako String wygląda następująco \"C:\\\\katalog\\\\plik.txt\".   Ścieżka absolutna i relatywna   Do każdego folderu/pliku możemy odnieść się poprzez ścieżkę absolutną bądź relatywną (możemy je także nazwać ścieżką bezwzględna i względną). Ścieżka absolutna jest ścieżką „od początku”, czyli przechodzi przez całą strukturę katalogów aż do samego pliku.   Załóżmy, że dysk C ma strukturę jak przedstawiono poniżej:   C:\\  ├── folder_1  │ └── plik_1.txt  ├── folder_2  │ ├── folder_2_a  │ │ └── plik_2_a.txt  │ └── plik_2.txt  └── plik.txt   Ścieżka absolutna do pliku plik_2_a.txt wygląda następująco C:\\older_2\\older_2_a\\plik_2_a.txt. Możemy mówić również o ścieżce relatywnej. Mówimy o niej relatywna ponieważ określa adres pliku/katalogu relatywnie do miejsca, w którym się aktualnie znajdujemy.   Zakładając że znajdujemy się w katalogu folder_2 wówczas nasza relatywna ścieżka do pliku plik_2_a.txt jet następująca folder_2_a\\plik_2_a.txt.   Tryb dostępu do pliku   Musisz wiedzieć, że plik możemy otworzyć „do odczytu”, „do zapisu” czy „w trybie dołączania”. Tryb ten jest bardzo istotny, otworzenie do zapisu pliku, który już istnieje i zapisanie choćby jednego znaku kasuje całą dotychczasową zawartość. Podobnie otworzenie do zapisu pliku, który jeszcze nie istnieje powoduje jego utworzenie (jeśli katalog w którym ma znaleźć się plik istnieje).   Tryb „dołączania” nie kasuje zawartości istniejącego pliku, a jedynie dopisuje na końcu nową treść.   Otwierając jakikolwiek plik w języku Java otwieramy go w pewnym trybie. Tryb ten określamy wprost, bądź jest określony domyślnie w zależności od klasy, którą użyjemy do tego celu. Klasy służące do pisania do pliku domyślnie otwierają go „do zapisu”.   Klasy do obsługi operacji na plikach   Musisz wiedzieć, że klasy z biblioteki standardowej do obsługi plików wprowadzają pewne warstwy abstrakcji ułatwiające pracę z plikami. Wygląda to w ten sposób, że mamy klasę X, która jest klasą podstawową udostępniającą bardzo ograniczony zakres operacji. Klasa Y używając interfejsu klasy X udostępnia interfejs wyższego poziomu, z którym programiście łatwiej jest pracować. Takie podejście można porównać do swego rodzaju cebuli ;) gdzie każda kolejna warstwa bazuje na poprzedniej i udostępnia trochę inny interfejs.   Przekładając to na konkretny przykład klas ze standardowej biblioteki Javy mamy klasę java.io.File, która oferuje podstawowe operacje na pliku. Instancja File jest przyjmowana jako parametr do utworzenia instancji klasy java.io.FileReader, która pozwala programiście na tekstowy dostęp do pliku znak po znaku. Z racji tego, że taka forma może być uciążliwa mamy do dyspozycji kolejną klasę java.io.BufferedReader, która pozwala na dostęp do pliku linijka po linijce.   new BufferedReader(new FileReader(new File(\"/path/to/text/file.txt\")));   Z racji tego, że powyższy fragment jest dość długi i byłby uciążliwy do pisania za każdym razem twórcy biblioteki przygotowali zestaw konstruktorów, które umożliwiają skrócenie tego zapisu. W przykładzie poniżej programista nie tworzy wprost instancji klasy File, podaje jedynie ścieżkę do pliku. Ta instancja tworzona jest za nas wewnątrz konstruktora klasy FileReader.   new BufferedReader(new FileReader(\"/path/to/text/file.txt\"));   Po tym wstępie teoretycznym wiesz już na tyle dużo o systemie plików i plikach, że możemy przejść do ich zapisywania i odczytywania. Ścieżki użyte w przykładach są z systemów Linux/Unix, jeśli pracujesz na Windows powinieneś używać ścieżek zgodnych z opisem powyżej.   W artykule tym zajmowali będziemy się wyłącznie sekwencyjnym dostępem do plików. Oznacza to, że pisząc do pliku zawsze dopisujemy linijkę na koniec a czytając, czytamy od początku pliku. Oczywiście możemy też czytać z pliku/pisać do pliku w sposób losowy, wybierając dowolną lokalizację. Takie podejście często jest wykorzystywane w przypadku plików binarnych, których strukturę doskonale znamy i wiemy, że na przykład od bajtu 10 do bajtu 13 włącznie w pliku zawsze znajduje się liczba, która reprezentuje datę urodzenia.   Obsługa plików tekstowych   Zapisywanie danych do pliku   Zapis do pliku tekstowego przedstawiłem we fragmencie kodu poniżej.   String filePath = \"/path/to/text/file.txt\" int number = 1234567; FileWriter fileWriter = null;  try {     fileWriter = new FileWriter(filePath);     fileWriter.write(Integer.toString(number)); } finally {     if (fileWriter != null) {         fileWriter.close();     } }   Przeanalizujmy co się dzieje w tym fragmencie kodu linijka po linijce. Pierwsze trzy linijki to nic innego jak inicjalizacja zmiennych, których będziemy używali później. Nowy tutaj dla Ciebie jest typ FileWriter, jest to klasa ze standardowej biblioteki języka Java odpowiedzialna za zapis do pliku tekstowego.   Zachęcam do przejrzenia pełnej dokumentacji klasy FileWriter. Klasa ta udostępnia wysokopoziomowy interfejs zapisu do pliku danych tekstowych. Polecam sprawdzenie hierarchii dziedziczenia klasy FileWriter w IDE (pamiętasz skrót klawiaturowy z poprzedniego artykułu?).   Następnie wewnątrz klauzuli try tworzymy nową instancję klasy FileWriter przekazując jej ścieżkę do pliku, do którego chcemy pisać. Operacja ta otwiera plik, może się ona nie udać co będzie sygnalizowane odpowiednim wyjątkiem. Kolejna linijka to wywołanie metody write, które zapisuje tekstową reprezentację liczby 1234567 do pliku. Ważne jest abyś pamiętał, że właściwy zapis wcale nie musi w tym miejscu nastąpić ze względu na buforowanie, o którym przeczytasz w jednym z kolejnych akapitów.   Bardzo istotne jest ciało klauzuli finally. Wewnątrz sprawdzamy czy nasz fileWriter został zainicjalizowany. Jeśli nie udałoby się stworzyć jego instancji rzucony zostałby wyjątek ale klauzula finally i tak by się wykonała. Następnie wywołując metodę close zamykamy dostęp do pliku, jeśli ta operacja się powiedzie mamy pewność, że dane zostały zapisane w pliku na dysku.   Zamykanie dostępu do plików   Proszę pamiętaj o zamknięciu strumienia danych. Dlaczego jest to ważne? Podstawowym powodem jest tutaj zarządzanie przez system operacyjny tak zwanymi uchwytami do otwartych plików. Otóż systemy operacyjne, które znam mają limity, które pozwalają na otwarcie np. 2048 plików jednocześnie przez każdy program. Liczba ta jest na tyle duża, że nie zauważasz tego ograniczenia w codziennym użytkowaniu. Jeśli jednak napiszesz program, który będzie otwierał pliki bez ich zamykania możesz z łatwością wyczerpać ten limit.   Bardziej przyziemnym powodem jest tak zwane buforowanie. Zapis do pliku może być buforowany (i jest w części przypadków przez klasy ze standardowej biblioteki Javy). Oznacza to tyle, że wywołanie metody write tak naprawdę jeszcze niczego na dysku nie zapisuje. Zapisuje te dane w buforze, który zrzucany jest na dysk. Taki zabieg jest wykonywany aby przyspieszyć zapis danych. Jeśli nie zamkniesz pliku może do doprowadzić do sytuacji, w której w buforze zostaną dane, które jeszcze nie zostały do pliku zrzucone. Zostaną one wówczas utracone, a tego chcielibyśmy uniknąć :)   Odczytywanie danych z pliku   Przykład kodu poniżej służy do czytania danych z pliku.   String filePath = \"/path/to/text/file.txt\" int number = 0; BufferedReader fileReader = null;  try {     fileReader = new BufferedReader(new FileReader(filePath));     String numberAsString = fileReader.readLine();     number = Integer.parseInt(numberAsString); } finally {     if (fileReader != null) {         fileReader.close();     } }   Podobnie jak poprzednio przeanalizujemy go linijka po linijce. Pierwsze trzy linijki inicjalizują zmienne, które będziemy używali. Wewnątrz klauzuli try znajduje się kod, który tworzy instancję klasy BufferedReader dzięki której możemy czytać z pliku linijka po linijce.   Kolejne dwie linie to czytanie linijki z pliku, parsowanie łańcucha znaków i zapisanie go jako liczby typu int. Metoda readLine, która została użyta zwróci null jeśli w pliku nie znajduje się już więcej danych.   Podobnie jak w przypadku plików otwartych do odczytu tak i w tym przypadku musimy pamiętać o ich zamknięciu, zapewnia to wnętrze bloku finally.   Musisz też wiedzieć, że klasy które pozwalają Ci na czytanie pliku mają tak zwany „wskaźnik”, który zapamiętuje ostatnie miejsce z którego coś przeczytaliśmy. Kolejna próba odczytu przesuwa ten wskaźnik dalej.   Obsługa plików binarnych   Skupimy się teraz na obsłudze plików binarnych. Pewne aspekty pracy z plikami tekstowymi i binarnymi są podobne. W obu przypadkach musimy pamiętać o zamykaniu „strumieni” do plików. W obu przypadkach także skupimy się na dostępie sekwencyjnym.   Zapisywanie danych do pliku   Bez zbędnego wstępu proszę spójrz na przykład poniżej.   String filePath = \"/path/to/binary/file.txt\" int number = 1234567; DataOutputStream outputStream = null;  try {     outputStream = new DataOutputStream(new FileOutputStream(filePath));     outputStream.writeInt(number); } finally {     if (outputStream != null) {         outputStream.close();     } }   Pierwsze trzy i ostatnie pięć linii jest dla Ciebie znajoma. Bardzo podobny kod widziałeś w przykładach powyżej. Skupmy się nad tym co dzieje się w środku klauzuli try. Tworzymy tam instancję klasy FileOutputStream, która zostaje przekazana do konstruktora klasy DataOutputStream. DataOutputStream zapewnia interfejs pozwalający na binarny zapis typów prymitywnych w Javie podczas gdy FileOutputStream pozwala na zapis danych bajt po bajcie.   Używanie DataOutputStream pozwala programiście zapomnieć o szczegółach w jaki liczby powinny być zapisane binarnie, tymi szczegółami zajmuje się właśnie ta klasa przez wywołanie metody writeInt. Pozwala ona w łatwy sposób zapisać binarnie typy proste i łańcuchy znaków (w jednym z kolejnych artykułów przeczytasz o serializacji pozwalającej na zapisanie binarnie dowolnych obiektów).   Po uruchomieniu programu, który zapisuje liczbę do pliku spróbuj otworzyć ten plik w notatniku. Co widzisz? :) Prawda, że jest to mniej czytelne niż tekstowy format pliku?   Odczytywanie danych z pliku   String filePath = \"/path/to/binary/file.txt\" int number = 0; DataInputStream inputStream = null;   try {     inputStream = new DataInputStream(new FileInputStream(filePath));     number = inputStream.readInt(); } finally {   if (inputStream != null) {       inputStream.close();   } }   Podobnie jak poprzednio kod poza klauzulą try już znasz. Nowa tutaj dla Ciebie jest instancja klasy FileInputStream, która przekazana jest do konstruktora klasy DataInputStream. Widzisz tu pewną analogię do poprzedniego przykładu? Podobnie jak poprzednio DataInputStream pozwala na czytanie większych kawałków pliku zapisanego binarnie, dzięki tej klasie możemy przeczytać liczbę typu int zapisaną wcześniej w pliku. Podobnie jak poprzednio klasa ta pozwala na odczyt typów prostych i łańcuchów znaków zapisanych binarnie.   Zadania   Na koniec kilka zadań dla Ciebie:     Napisz program, który pobierze od użytkownika ścieżkę do pliku tekstowego oraz kilka linijek tekstu (dopóki użytkownik nie wprowadzi „-” jako linijki) i zapisze je do pliku tekstowego. Do wykonania tego zadania może Ci się przydać metoda System.lineSeparator() zwracająca znak nowej linii (jeśli chciałbyś oddzielić linie wprowadzone przez użytkownika).   Napisz program, który pobierze od użytkownika ścieżkę do pliku i wyświetli zawartość pliku na ekranie wraz z informacją ile linii znajduje się w pliku.   Napisz program, który poprosi użytkownika nazwę pliku wyjściowego oraz o podanie swojej daty urodzenia (osobno dzień, miesiąc i rok), a następnie zapisze te dane jako trzy osobne liczby binarnie.   Napisz program, który pobierze od użytkownika ścieżkę do pliku binarnego z datą urodzenia, a następnie wyświetli ją na ekranie.   Jak zwykle przykładowe rozwiązania zadań znajdują się na githubie, jednak zachęcam do samodzielnej próby rozwiązania zadań, wtedy nauczysz się najwięcej.   Dodatkowe materiały do nauki   W każdym artykule zachęcam Cię do zapoznania się z dokumentacją, nie inaczej będzie i tym razem. Zapewniam Cię, że jest to najlepsze źródło z kompletną informacją na temat klas z biblioteki standardowej. Innymi słowy zestaw obowiązkowy to dokumentacja biblioteki standardowej, zawsze w przypadku wątpliwości tam znajdziesz dużo potrzebnych informacji:     File   FileWriter   FileReader   BufferedReader   FileOutputStream   FileInputStream   DataOutputStream   DataInputStream   Dodatkowo parę wpisów w innych miejscach w sieci:     kod źródłowy przykładów i przykładowe rozwiązania zadań   http://naukajavy.pl/kurs-jezyka-java/114-zapis-tekstu-do-pliku   http://naukajavy.pl/kurs-jezyka-java/113-odczyt-tekstu-z-pliku   http://wazniak.mimuw.edu.pl/index.php?title=PO_Strumienie   Podsumowanie   Mam nadzieję, że artykuł się podobał. Dzisiaj nauczyłeś się całkiem sporo na temat pracy z plikami w Javie. Dowiedziałeś się czegoś więcej o systemie plików. Po wykonaniu zadań wiesz już jak odczytać/zapisać plik zarówno binarnie jak i w trybie tekstowym. Dużo tego :)   Na koniec jak zwykle prośba do Ciebie, zależy mi na dotarciu do jak największego grona czytelników. Proszę pomóż mi przy tym poprzez polubienie strony na FB i udostępnienie linku do bloga :) Z góry dziękuję.   Do następnego razu Samouku!                 Jest to swego rodzaju uproszczenie, w rzeczywistości pliki tekstowe zapisane są także jako ciąg danych binarnych, jednak programy takie jak notatnik wiedzą jak te dane interpretować i wyświetlają zwykły tekst. &#8617;           ","categories": ["Kurs programowania Java","Programowanie"],
        "tags": [],
        "url": "/operacje-na-plikach-w-jezyku-java/",
        "teaser": "/assets/images/2016/08/17_operacje_na_plikach_artykul.jpg"
      },{
        "title": "Maszyna losująca",
        "excerpt":"Opis zadania   W dzisiejszej części napiszesz program, który użyłem do rozstrzygnięcia konkursu, w którym Samouczek Programisty rozdawał książki. W konkursie należało wypełnić prostą ankietę, wśród uczestników zostały rozlosowane dwie książki. Każdy, kto uzupełnił ankietę dostawał jeden los. Dodatkowo, jeśli osoba wskazała kogoś innego jako polecającego, polecający dostawał dodatkowy los w loterii.   Ankieta została przeprowadzona przy pomocy narzędzia Google Forms, z którego następnie wyniki zostały wyeksportowane do pliku CSV (ang. comma separated values). Plik CSV to jeden z formatów plików tekstowych, w którym jedna linijka odpowiada jednemu rekordowi. Plik ten zawiera kilka kolumn, których zawartość oddzielona jest przecinkami. Plik zawiera też nagłówek, opisujący nazwy kolumn.   W przykładzie poniżej mamy dwa rekordy z takiego pliku. Irek dostaje dwa losy, Mateusz jeden. Dzieje się tak ponieważ Irek polecił Samouczka Mateuszowi.   \"Timestamp\",\"Jak masz na imię?\",\"Jaki jest Twój adres e-mail?\",\"Temat artykułu\",\"Kto polecił Ci stronę www.samouczekprogramisty.pl (podaj adres e-mail)?\" \"2016/08/15 7:16:38 PM GMT+2\",\"Irek\",\"xxx@gmail.com\",\"Scrum lub Agile\",\"\" \"2016/08/15 7:33:13 PM GMT+2\",\"Mateusz\",\"yyy@gmail.com\",\"Algorytmika\",\"xxx@gmail.com\"   Twoim zadaniem jest napisanie programu, który pobierze od użytkownika dwa argumenty:     ścieżkę do pliku wejściowego w formacie CSV na dysku opisanym powyżej (możesz ściągnąć przykładowy plik, który dla Ciebie przygotowałem),   liczbę N &gt;= 1 przedstawiającą liczbę wygrywających.   Program powinien wczytać zawartość pliku, wyłuskać adresy e-mail, a następnie wśród tych adresów wylosować N wygranych. Dla uproszczenia zakładamy, że format pliku jest poprawny oraz, że uczestnicy konkursu nie oszukiwali (nie było podwójnych losów). Sytuacja w której jeden uczestnik wygrywa dwie książki jest dopuszczalna.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Wskazówki   Dla uproszczenia pokażę Ci parę fragmentów kodu czy metod, które mogą Ci się przydać w rozwiązaniu tego zadania.   Aby podzielić rekord na poszczególne pola możesz użyć metody String.split jak w przykładzie poniżej   String[] fields = line.split(\",\");   Aby z pola otoczonego znakami \"\" uzyskać wyłącznie jego zawartość możesz użyć wyrażeń regularnych. Na tym etapie proszę użyj przykładowego kodu, o tym czym są wyrażenia regularne przeczytasz w innym artykule.   private final static Pattern FIELD_PATTERN = Pattern.compile(\"^\\\"(.+)\\\"$\");private static String parseField(String field) { Matcher fieldMatcher = FIELD_PATTERN.matcher(field); if (fieldMatcher.matches()) { return fieldMatcher.group(1); } return null;}   Metoda ta jako argument przyjmuje wartość pola i zwraca to co znajduje się wewnątrz \"\" bądź null jeśli pole nie było uzupełnione.   Aby wybrać losowo X wartości musisz losowo rozłożyć adresy e-mail z pliku. Pomóc Ci w tym może metoda Collections.shuffle, która w losowy sposób miesza elementy listy.   Z tymi narzędziami jesteś przygotowany do napisania swojej pierwszej maszyny losującej :) Jeśli będziesz miał jakiekolwiek pytania możesz zasugerować się przykładowym rozwiązaniem, które dla Ciebie przygotowałem. Jak zwykle zachęcam jednak do samodzielnego rozwiązania zadania, w ten sposób nauczysz się najwięcej.   Podsumowanie   Jeśli tego typu sposób nauki Ci się spodobał proszę daj znać ;) Rozwiązując zadania tego typu w praktyczny sposób przećwiczysz wiedzę, którą zdobyłeś do tej pory. Z biegiem czasu będziesz w stanie rozwiązać zadania o coraz większym poziomie trudności. Wszystko przed Tobą ;)   Na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największego grona czytelników, proszę pomóż mi w tym :) Udostępnij link do bloga na FB swoim znajomym, możesz także zapisać się do newslettera jeśli nie chcesz pominąć kolejnych artykułów. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/zadanie-maszyna-losujaca/",
        "teaser": "/assets/images/2016/08/22_zadanie_maszyna_losujaca_artykul.jpg"
      },{
        "title": "Konstrukcja try-with-resources w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Try-with-resources   Pamiętasz w jaki sposób musieliśmy obchodzić się ze strumieniami danych? Trzeba było koniecznie pamiętać o ich zamknięciu. Generowało to sporą masę powtarzalnego kodu (ang. boilerplate code). Dobrą praktyką jest unikanie, powtórzeń – mniej kodu źródłowego, mniej miejsc do popełniania potencjalnego błędu :). Tutaj z pomocą przyszli twórcy Javy, wprowadzając konstrukcję „try-with-resources”.   Tego typu konstrukcję możemy nazwać cukrem syntaktycznym (ang. syntactic sugar). Takie konstrukcje upraszczają kod, jednak nie są niezbędne dla języka programowania. Innymi słowy programista mógłby sobie bez takich konstrukcji poradzić, jednak ich obecność zmniejsza ilość kodu, która jest potrzebna do wykonania tego samego zadania.   Najlepiej będzie jeśli zobaczymy to na przykładzie. Poniższy fragment kodu prezentuje odczytanie linijki z pliku tekstowego. W tym przykładzie także obsługujemy wyjątki, nie są one wspomniane w sygnaturze metody po klauzuli throws więc odpowiednie bloki catch muszą się znaleźć aby kompilator pozwolił nam ten kod skompilować (pamiętasz wyjątki typu checked i unchecked?)   BufferedReader fileReader = null; try {     fileReader = new BufferedReader(new FileReader(inputPath));     fileReader.readLine(); } catch (FileNotFoundException e) {     e.printStackTrace(); } catch (IOException e) {     e.printStackTrace(); } finally {     if (fileReader != null) {         try {             fileReader.close();         } catch (IOException e) {             e.printStackTrace();         }     } }   Prawda, że dużo tego? I tu z pomocą przychodzi konstrukcja try-with-resources, zobacz proszę jak ona wygląda:   try(BufferedReader fileReader = new BufferedReader(new FileReader(inputPath))) {     fileReader.readLine(); } catch (FileNotFoundException e) {     e.printStackTrace(); } catch (IOException e) {     e.printStackTrace(); }   Konstrukcja wygląda jak try/catch z tym, że przez blokiem objętym try możemy zainicjalizować zmienne, które zostaną automatycznie zamknięte. Kompilator widząc konstrukcję try-with-resources wygeneruje za nas kod zbliżony do tego z pierwszego przykładu (w podobny sposób generuje np. domyślne konstruktory).   Konstrukcję try-with-resources możemy nazwać także „menadżerem kontekstu”, automatycznie zarządza ona za nas kontekstem, w ramach którego dostępne są zmienne zdefiniowane wewnątrz nawiasów (). Co więcej, wewnątrz tych nawiasów możemy zainicjalizować więcej zmiennych, każda z nich zostanie poprawnie zamknięta (zostanie na nich wywołana metoda close). W przykładzie poniżej odczytujemy linijkę z pliku wejściowego i zapisujemy ją do pliku wyjściowego (tutaj pominąłem obsługę wyjątków):   try(         BufferedReader fileReader = new BufferedReader(new FileReader(inputPath));         BufferedWriter fileWriter = new BufferedWriter(new FileWriter(outputPath)) ) {     String line = fileReader.readLine();     fileWriter.write(line); }   Taka struktura tłumaczona jest przez kompilator na sekwencję zagnieżdżonych bloków try/catch/finally. W każdym z tych zagnieżdżonych bloków zarządza kolejną zmienną. Zmienne zamykane są w odwrotnej kolejności niż są deklarowane, zatem w naszym przykładzie pierwszy zostanie zamknięty fileWriter po nim fileReader.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Własne menadżery kontekstu   Całość działa, ponieważ klasy takie jak BufferedWriter czy BufferedReader implementują interfejs java.lang.AutoCloseable. Właściwie to wszystkie znane mi klasy do obsługi strumieni wejściowych/wyjściowych w standardowej bibliotece Javy implementują ten interfejs. To jest właśnie główne wymaganie, które musi być spełnione przez zmienne definiowane wewnątrz () gdy używamy konstrukcji try-with-resources.   Nasunąć się zatem może pytanie, czy możemy stworzyć własną klasę, która będzie działała z tą konstrukcją? Oczywiście! :) Poniżej przykład:   public class MyContextManager implements AutoCloseable {     public MyContextManager() {         System.out.println(\"Wlasnie sie tworze!\");     }      public void doSomething() {         System.out.println(\"Wlasnie cos robie :)\");     }      public void close() {         System.out.println(\"Ktos mnie teraz zamyka!\");     } }  public class MyContextManagerMain {     public static void main(String[] args) {         try (MyContextManager manager = new MyContextManager()) {             manager.doSomething();         }     } }   MyContextManager implementuje interfejs AutoCloseable dzięki czemu możemy użyć go wewnątrz konstrukcji try-with-resources. Jeśli uruchomiłbyś metodę main z powyższego przykładu na konsoli pojawiłyby się następujące linijki:   Wlasnie sie tworze! Wlasnie cos robie :) Ktos mnie teraz zamyka!   Widzisz? Metody close nie wywoływałem nigdzie, a mimo to została automatycznie wykonana podczas działania programu. Stało się tak właśnie dzięki kompilatorowi, który przetłumaczył konstrukcję try-with-resources na kod, który poprawnie zamyka zmienne.   Zadanie   Teraz nadszedł czas na zadanie dla Ciebie. Strony w internecie tworzone są przy pomocy HTML, jest to język znaczników, który jest interpretowany przez przeglądarki internetowe wyświetlające strony www. Przykładem znaczników jest para &lt;em&gt;tekst&lt;/em&gt;, jak widzisz jest tu znacznik otwierający &lt;em&gt; oraz zamykający &lt;/em&gt; (akurat ta para odpowiedzialna jest za wyróżnianie tekstu). Wewnątrz znaczników znajduje się treść np. tekst. Istnieje wiele innych par znaczników np. &lt;h1&gt;&lt;/h1&gt;, &lt;p&gt;&lt;/p&gt;, &lt;ul&gt;&lt;/ul&gt; itd.,   Zaimplementuj klasę HtmlTag, która będzie menadżerem kontekstu. W konstruktorze powinna przyjmować nazwę znacznika np. em. Klasa powinna mieć metodę body, która przyjmie parametr typu String i wypisze go na konsoli. Uruchamiając kod   try (         HtmlTag h1 = new HtmlTag(\"h1\");         HtmlTag em = new HtmlTag(\"em\") ) {     em.body(\"moj tekst\"); }   Na konsoli powinien znaleźć się tekst   &lt;h1&gt; &lt;em&gt; moj tekst &lt;/em&gt; &lt;/h1&gt;   Jak zwykle zachęcam do samodzielnego rozwiązania zadania, jeśli jednak utknąłbyś przygotowałem przykładowe rozwiązanie, które może Ci pomóc.   Materiały dodatkowe      dokumentacja interfejsu AutoCloseable   sekcja z Java Language Specification opisująca konstrukcję try-with-resources   kod źródłowy przykładów i rozwiązanie zadania   Podsumowanie   Po przeczytaniu artykułu wiesz już jak używać konstrukcji try-with-resources, wiesz czym jest cukier syntaktyczny. Mam nadzieję, że spędziłeś trochę czasu rozwiązując zadanie, które pozwoliło Ci przećwiczyć wiedzę w praktyce. Na koniec mam do Ciebie wielką prośbę, zależy mi na dotarciu do jak największej liczby czytelników, możesz mi w tym pomóc polecając blog znajomym i udostępniając link na Facebook’u, z góry dziękuję i do następnego razu.  ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/konstrukcja-try-with-resources-w-jezyku-java/",
        "teaser": "/assets/images/2016/08/25_try-with-resources_artykul.jpg"
      },{
        "title": "Serializacja w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Czym jest serializacja   W jednym z poprzednich artykułów przeczytałeś o strumieniach danych, które pozwalały na zapisywanie oraz odczytywanie danych. Poznałeś wówczas między innymi klasy DataInputStream oraz DataOutputStream. Klasy te pomagają zapisywać typy proste i łańcuchy znaków.   Serializacja to wbudowany mechanizm zapisywania obiektów, który pozwala na binarny zapis całego drzewa obiektów. Oznacza to tyle, że jeśli mamy obiekt X, który posiada referencję do obiektu Y to serializując X również Y zostanie automatycznie zapisany w strumieniu wyjściowym.   Tak zapisany obiekt możesz później otworzyć przy kolejnym uruchomieniu programu. Jednak serializacja ma więcej zastosowań.   Dzięki temu mechanizmowi można na przykład przesyłać obiekty przez sieć. Obiekt, który stworzyliśmy na jednym komputerze (wewnątrz pamięci jednej wirtualnej maszyny Java) może być zserializowany, przesłany przez sieć i zdeserializowany na drugim komputerze tworząc nową instancję obiektu (wewnątrz pamięci drugiej wirtualnej maszyny Javy). Na obu tych komputerach wirtualna maszyna Javy musi mieć dostęp do skompilowanej wersji klasy.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Warunki wymagane do serializacji   Chociaż serializacja dostępna jest automatycznie dla większości obiektów z biblioteki standardowej to jeśli chcesz móc serializować instancje klas, które sam napiszesz musisz spełnić kilka warunków.   Interfejs java.io.Serializable   Jest to tak zwany interfejs znacznikowy, innymi słowy nie zawiera on żadnej metody. Służy on do pokazania wirtualnej maszynie, że instancje danej klasy implementującej ten interfejs mogą być serializowane. Musisz implementować ten interfejs jeśli chcesz aby twoje klasy były serializowalne. Jeśli będziesz próbował zserializować klasę, która nie implementuje tego interfejsu zostanie rzucony wyjątek typu NotSerializableException.   Konstruktor bezparametrowy   Tutaj reguła niestety nie jest trywialna. Pierwsza klasa w hierarchii dziedziczenia, która nie jest serializowalna musi mieć dostępny konstruktor bezparametrowy. Łatwiej to będzie zrozumieć na przykładzie:   public class Fruit {} public class Apple extends Fruit implements Serializable {} public class Tomato implements Serializable {}   W przykładzie powyżej klasa Fruit musi mieć konstruktor bezparametrowy abyśmy mogli poprawnie serializować instancje klasy Apple. Natomiast ani Apple, ani Tomato takiego konstruktora już nie wymagają (Tomato dziedziczy po Object, który taki konstruktor posiada).   Dodatkowo istnieje interfejs java.io.Externalizable (opiszę go dokładnie kilka akapitów niżej), który również zapewnia, że obiekty go implementujące są serializowalne. Jednak w tym przypadku obiekt taki musi także zapewnić konstruktor bezparametrowy, który jest wywoływany w trakcie deserializacji.   Określić pola, które nie są serializowalne   Ten krok jest opcjonalny, jednak w bardziej zaawansowanych przypadkach niezbędny. Wyobraź sobie, że napisałeś klasę Human, która jako jeden z atrybutów posiada wiek zapisany w minutach od urodzenia. Zapisanie tego pola mogłoby prowadzić do odczytania niepoprawnego stanu (zapisujemy obiekt dzisiaj, odczytujemy jutro, wiek w minutach jest zupełnie inny).   Tutaj dochodzimy do słowa kluczowego transient. Otóż słowo to może być stosowane przed atrybutami klasy. Oznacza ono, że dany atrybut nie jest serializowalny i zostanie pominięty przez mechanizm serializacji1.   Przykład serializacji obiektu   Proszę zwróć uwagę na fragment kodu poniżej, który pokazuje jak mechanizm serializacji działa w praktyce.   try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"objects.bin\"))) {     outputStream.writeObject(Integer.valueOf(1));     outputStream.writeObject(Integer.valueOf(2)); }  try (ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"objects.bin\"))) {     Integer number = (Integer) inputStream.readObject();     System.out.println(number);     number = (Integer) inputStream.readObject();     System.out.println(number); }   W pierwszym bloku try-with-resources otwieramy strumień typu ObjectOutputStream, na którym następnie wywołujemy metodę writeObject zapisując do strumienia dwie liczby.   W kolejnym bloku dzięki instancji ObjectInputStream odczytujemy wcześniej zapisane obiekty. Obiekty odczytywane są w takiej samej kolejności w jakiej zostały zapisane, w naszym przypadku na konsoli zostaną wyświetlone liczby 1 a później 2.   Serializacja drzewa obiektów   Wspomniałem już wcześniej, że mechanizm serializacji automatycznie obsługuje drzewa obiektów. W przykładzie poniżej pokazana jest właśnie taka sytuacja. Instancja klasy Car posiada atrybuty typów Engine oraz Tyre[]. Serializując a następnie deserializując instancję tej klasy wszystkie jej atrybuty zostały także zapisane.   Tyre[] tyres = new Tyre[] {new Tyre(16), new Tyre(16), new Tyre(16), new Tyre(16)}; Engine engine = new Engine(\"some model\"); Car serializedCar = new Car(engine, tyres); try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"object-graph.bin\"))) {     outputStream.writeObject(serializedCar); }  Car deserializedCar = null; try (ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"object-graph.bin\"))) {     deserializedCar = (Car) inputStream.readObject();     System.out.println(deserializedCar.getEngine().getModel());     System.out.println(deserializedCar.getTyres().length); }  System.out.println(serializedCar == deserializedCar);   Zwróć proszę uwagę na ostatnią linię. W linijce tej porównywane są dwa adresy instancji klasy Car (pamiętasz różnicę między == a equals?). Oczywiście linijka ta wyświetli false na konsoli co dowodzi, że w procesie deserializacji został stworzony zupełnie nowy obiekt klasy Engine.   Deserializacja atrybutów transient   Zaraz, jak to? Przecież kilka akapitów wyżej napisałem, że atrybuty poprzedzone słowem kluczowym transient nie są serializowane. Tak to prawda, jednak podczas deserializacji atrybuty tego typu należy zainicjalizować pewną wartością. Otóż dla każdego typu mamy taką domyślną wartość:     boolean – false,   liczby całkowite (int, long, itd.) – 0,   liczby ułamkowe (float, duble) – 0.0,   obiekty (Integer, Float, String, CustomClass, itd.) – null   public class Human implements Serializable {     private static final long serialVersionUID = 1L;      private transient Integer age;     private String name;      public Human(String name, Integer age) {         this.age = age;         this.name = name;     }      public Integer getAge() {         return age;     }      public String getName() {         return name;     }      public static void main(String[] args) throws IOException, ClassNotFoundException {         Human human = new Human(\"Krzysiek\", 21);          try (ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"human.bin\"))) {             output.writeObject(human);         }          try (ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"human.bin\"))) {             Human readHuman = (Human) input.readObject();             System.out.println(readHuman.getName());             System.out.println(readHuman.getAge());         }     } }   W przykładzie powyżej po deserializacji pole age będzie miało wartość null ponieważ jest to wartość domyślna dla atrybutów poprzedzonych słowem kluczowym transient, które są obiektami.  Pola statyczne a serializacja   Serializacja dotyczy instancji klasy, nie samej klasy. Zatem jeśli zmodyfikowałeś pole statyczne a następnie zdeserializowałeś taki obiekt wprowadzone zmiany zostaną pominięte. Proszę spójrz na przykład poniżej.   StaticSerialization object = new StaticSerialization(); object.someField = 200; System.out.println(object.someField);  try (ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"static.bin\"))) {     output.writeObject(object); }   W przykładzie tym modyfikujemy wartość pola statycznego someField a następnie serializujemy instancję klasy do pliku.   try (ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"static.bin\"))) {     StaticSerialization otherObject = (StaticSerialization) input.readObject();     System.out.println(otherObject.someField); }   W drugim uruchomieniu programu (w którym nie zmodyfikowaliśmy wartości atrybutu statycznego someField) deserializujemy ten sam plik. W tym przypadku otrzymamy wartość 100 a nie 200, które miał obiekt zapisywany do pliku.   To co trzeba zapamiętać to to, że pola statyczne nie są serializowane a są pobierane z aktualnej definicji klasy (nie z klasy z momentu serializacji).   Możemy powiedzieć, że atrybuty static są też domyślnie transient. Jak zatem takie zmiany odzwierciedlić podczas deserializacji? Jest na to sposób :)   Specjalna obsługa serializacji/deserializacji   W specyficznych przypadkach masz możliwość zmodyfikowania domyślnego zachowania mechanizmu serializacji. Możesz to zrobić jeśli zaimplementujesz poniższe metody.   private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundException private void writeObject(java.io.ObjectOutputStream stream) throws IOException   Metoda readObject(java.io.ObjectInputStream stream), którą zaimplementujesz jest automatycznie wywoływana w momencie odczytywania obiektu ze strumienia, czyli w trakcie wywołania metody ObjectInputStream.readObject().   Mechanizm ten wygląda podobnie w przypadku zapisu obiektu. Metoda writeObject(java.io.ObjectOutputStream stream), którą zaimplementujesz jest automatycznie wywoływana w momencie zapisywania obiektu do strumienia, czyli w trakcie wywołania metody ObjectOutputStream.writeObject().   Poniższy przykład powinien Ci pomóc w zrozumieniu tego mechanizmu:   public class CustomSerialization implements Serializable {     private static final long serialVersionUID = 1L;      private transient int someField;     private String otherField;      public CustomSerialization(int someField, String otherField) {         this.someField = someField;         this.otherField = otherField;     }      public static void main(String[] args) throws IOException, ClassNotFoundException {         CustomSerialization writtenObject = new CustomSerialization(10, \"something\");          try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"custom-serialization.bin\"))) {             outputStream.writeObject(writtenObject);         }          try (ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"custom-serialization.bin\"   ))) {             CustomSerialization readObject = (CustomSerialization) inputStream.readObject();             System.out.println(readObject.someField);             System.out.println(readObject.otherField);         }     }      private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {         stream.defaultReadObject();         someField = stream.readInt();     }      private void writeObject(ObjectOutputStream stream) throws IOException {         stream.defaultWriteObject();         stream.writeInt(someField + 1000);     } }   Jak widzisz obie metody są tu zaimplementowane. writeObject jako argument dostaje strumień, do którego powinniśmy zapisać nasz obiekt. Metoda readObject jako jedyny argument przyjmuje strumień, z którego powinniśmy odczytać stan obiektu.   Warto tutaj zwrócić uwagę na to, że klasa ObjectInputStream posiada metodę defaultReadObject, która przeprowadza standardową deserializację, którą możesz rozszerzyć. Podobnie wygląda to w przypadku klasy ObjectOutputStream i metody defaultWriteObject. Metody te mogą być wywołane wyłącznie w trakcie (de)serializacji obiektu. Zajmują się one (de)serializacją atrybutów klasy, które nie są oznaczone jako static lub transient.   Serializacja a dziedziczenie   W poprzednich przykładach użyliśmy klasy Engine, która implementuje interfejs Serializable. Załóżmy, że utworzyliśmy klasę DieselEngine, która dziedziczy po Engine. Automatycznie instancje klasy DieselEngine będą implementowały interfejs Serializable (dziedzicząc go z Engine). Co powinniśmy zrobić jeśli nie chcielibyśmy aby nasz DieselEngine był serializowalny? Należy użyć wspomnianego już wyjątku NotSerializableException jak w przykładzie poniżej:   public class DieselEngine extends Engine {     public DieselEngine() {         super(\"diesel\");     }       private void writeObject(ObjectOutputStream out) throws IOException {         throw new NotSerializableException(\"DieselEngine isn't serializable!\");     }       private void readObject(ObjectInputStream in) throws IOException {         throw new NotSerializableException(\"DieselEngine isn't serializable!\");     } }   Pełny wpływ na mechanizm serializacji   Istnieje jeszcze jeden, dużo mniej popularny sposób zapewnienia iż obiekt może być serializowany. Jest nim interfejs Externalizable. W tym przypadku interfejs ten zawiera dwie metody, które musimy zaimplementować. Dodatkowo takie klasy muszą mieć konstruktor bezparametrowy, reszta pozostaje bez zmian. W przypadku tego podejścia cały protokół serializacji, kolejność zapisanych pól, format etc. leży po naszej stronie. Poniżej prosty przykład, w którym używam właśnie takiego podejścia.   W tym przypadku do utworzenia obiektu mechanizm serializacji używa standardowego konstruktora bezparametrowego. Po czym wywołuje na tej instancji metodę readExternal.   public class CustomProtocolSerialization implements Externalizable {     private String field;       public CustomProtocolSerialization() {     }       public CustomProtocolSerialization(String field) {         this.field = field;     }       public static void main(String[] args) throws IOException, ClassNotFoundException {         CustomProtocolSerialization object = new CustomProtocolSerialization(\"field value\");           try (ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"externalizable.bin\"))) {             output.writeObject(object);         }           try (ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"externalizable.bin\"))) {             CustomProtocolSerialization readObject = (CustomProtocolSerialization) input.readObject();             System.out.println(readObject.field);         }     }       public void writeExternal(ObjectOutput out) throws IOException {         out.writeUTF(field);     }       public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {         field = in.readUTF();     } }   Pole serialVersionUID   Dodatkowo musisz wiedzieć o statycznym polu w klasie o nazwie serialVersionUID. Jego pełna definicja wygląda następująco:   private static long serialVersionUID;   Pole to ma specyficzne zastosowanie. Mechanizm serializacji używa go do upewnienia się, że deserializowany obiekt „pasuje” do danych zapisanych w strumieniu. Wie o tym na podstawie wartości tego pola. Jeśli w zdeserializowanym obiekcie wartość tego pola jest taka sama jak aktualnej definicji klasy wówczas można bezpiecznie przeprowadzić deserializację.   Kiedy taka sytuacja może wystąpić? Załóżmy, że dzisiaj napiszesz klasę Human, zdeserializujesz jej instancję i zapiszesz w pliku na dysku. Po jakimś czasie wprowadzisz zmiany w klasie i będziesz chciał odczytać starą wersję z pliku. W niektórych przypadkach taka operacja nie będzie dozwolona. Właśnie wtedy pole serialVersionUID może pomóc w wykryciu takiej sytuacji.   Pole to możesz ustawić samodzielnie, jeśli tego nie zrobisz kompilator wygeneruje tę wartość za Ciebie na podstawie definicji klasy.   Materiały dodatkowe   Na początek zestaw dokumentacji do klas, związanych z tematem, jak zwykle znajdziesz tam ogrom informacji.     Serializable   Externalizable   ObjectOutputStream   ObjectInputStream   NotSerializableException   Dodatkowo możesz zajrzeć do specyfikacja mechanizmu serializacji albo artykułu na stronie Oracle. Znalazłem też inne opracowanie, które poruszą także zagadnienie serializacji, także do formatu XML. Możesz też rzucić okiem na przykłady użyte w tym artykule.   Zadania   Na koniec jak zwykle zadania dla Ciebie do przećwiczenia materiału z tego artykułu.     Napisz program, który poprosi użytkownika o wprowadzenie kilku imion, imiona te zapisz w liście a następnie zserializuj ją do pliku. Napisz metodę, która odczyta ten plik i wyświetli zawartość listy na konsoli. Wiesz, że właśnie napisałeś prostą bazę danych? ;)   Napisz klasę Human, która będzie miała dwa atrybuty name typu String oraz age typu int. Jak należałoby serializować instancje tej klasy aby zawsze poprawnie deserializować wiek (z dokładnością do roku)? (Wskazówka, możesz użyć metody Calendar.getInstance().get(Calendar.YEAR), która zwraca aktualny rok)   Przygotowałem też dla Ciebie przykładowe rozwiązania powyższych zadań, jednak traktuj je proszę jako ostatnią deskę ratunku :) Więcej nauczysz się próbując samemu rozwiązać powyższe zadania.   Podsumowanie   Po przeczytaniu tego artykułu wiesz już czym są klasy ObjectOutputStream i ObjectInputStream. Znasz zasady serializacji, poznałeś słowo kluczowe transient. Teraz jesteś w stanie zapisać i odczytać każdą instancję klasy, którą stworzysz.   Bardzo się cieszę, że przeczytałeś cały artykuł. Na koniec mam do Ciebie prośbę. Proszę przekaż adres bloga swoim znajomym, w grupie uczy się raźniej ;) Jeśli nie chcesz ominąć nowych artykułów dopisz się do newslettera i polub stronę Samouczka na Facebook’u. Miłego dnia i do następnego razu :)                 Istnieje też inny, mniej popularny sposób ominięcia pól podczas serializacji– użycie pola serialPersistentFields (jest ono dokładniej opisane w specyfikacji). &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/serializacja-w-jezyku-java/",
        "teaser": "/assets/images/2016/09/02_serializacja_artykul.jpg"
      },{
        "title": "Typ wyliczeniowy w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Enum, typ wyliczeniowy   Wyobraź sobie, że mamy klasę Tshirt, która posiada kilka atrybutów takich jak kolor, rozmiar czy producent. O ile producentów koszulek, podobnie jak ich kolorów jest dość dużo to rozmiary są już bardzo często wspólne dla różnych producentów. Rozmiary możemy wyliczyć: S, M, L czy XL. I właśnie do przechowywania danych tego typu Java ma specjalny typ. Jest to enum zwany także typem wyliczeniowym. Przejdźmy od razu do przykładu:   public enum TshirtSize {     S,     M,     L,     XL }   Fragment kodu powyżej pokazuje typ wyliczeniowy TshirtSize, który może mieć jedną z czterech wartości S, M, L lub XL. Kolejne wartości typu wyliczeniowego oddzielamy przecinkiem.   Konwencja nadawania nazw zaleca aby wartości dla typu enum pisane były drukowanymi literami. Zatem TshirtSize.S jest w porządku, podczas gdy TshirtSize.s już nie.   Proszę spójrz na przykład użycia:   public class Tshirt {     private TshirtSize size;     private String manufacturer;      public Tshirt(TshirtSize size, String manufacturer) {         this.size = size;         this.manufacturer = manufacturer;     }      public static void main(String[] args) {         Tshirt tshirt = new Tshirt(TshirtSize.L, \"Polex\");         System.out.println(tshirt.size);     } }   Jak widzisz w przykładzie wyżej mamy klasę Tshirt, reprezentującą koszulkę, która jako jeden z atrybutów ma właśnie rozmiar, który jest typu TshirtSize.   Do wartości typu wyliczeniowego odnosimy się jak do pól statycznych klasy, zatem w naszym przypadku do rozmiaru L możemy odwołać się jako TshirtSize.L. Dzieję się tak ponieważ w rzeczywistości wartości typu wyliczeniowego mają automatycznie dodane modyfikatory public static final.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Typ wyliczeniowy a blok switch   W jednym z poprzednich artykułów poznałeś konstrukcję switch. W tamtej części wspomniałem o tym, że wewnątrz tej konstrukcji możemy używać liczb całkowitych czy łańcuchów znaków. Pominąłem wówczas jedną z dodatkowych wartości konstrukcji switch. Otóż wewnątrz możemy użyć także typu wyliczeniowego jak w przykładzie poniżej:   switch (tshirt.size) {     case S:         System.out.println(\"Kupiles koszulke w rozmiarze small\");         break;     case M:         System.out.println(\"Kupiles koszulke w rozmiarze medium\");         break;     case L:         System.out.println(\"Kupiles koszulke w rozmiarze large\");         break;     case XL:         System.out.println(\"Kupiles koszulke w rozmiarze extra large\");         break; }   W takim przypadku w zależności od wartości zmiennej size zostanie wywołany odpowiedni blok konstrukcji switch. Proszę zauważ, że w tym przypadku kompilator dokładnie wie jakiego typu są wartości L, M, S czy XL i nie możemy się do nich odwoływać poprzez pełną nazwę TshirtSize.M.   Typ wyliczeniowy to też klasa   Podobnie jak w przypadku normalnych klas tak i w przypadku typów wyliczeniowych może on posiadać atrybuty czy metody. Możesz także stworzyć klasę wyliczeniową, która będzie miała swój własny konstruktor inny od domyślnego. Spójrz na przykład poniżej, w którym nowe wartości typu wyliczeniowego tworzone są przy pomocy własnego konstruktora. Każda z wartości przekazuje do konstruktora trzy parametry:      szerokość klatki piersiowej,   długość koszulki,   długość rękawka.   public enum TshirtSize {     S(48, 71, 36),     M(52, 74, 38),     L(56, 76, 41),     XL(61, 79, 41);       private int chestWidth;     private int shirtLength;     private int sleeveLength;       TshirtSize(int chestWidth, int shirtLength, int sleeveLength) {         this.chestWidth = chestWidth;         this.shirtLength = shirtLength;         this.sleeveLength = sleeveLength;     }          public int getChestWidth() {         return chestWidth;     }       public int getShirtLength() {         return shirtLength;     }       public int getSleeveLength() {         return sleeveLength;     } }   W przykładzie nasz enum został rozszerzony o trzy atrybuty: szerokość klatki piersiowej, długość koszulki i długość rękawa. Dzięki dodaniu atrybutów do typu wyliczeniowego wszystkie potrzebne dane związane z jednym rozmiarem mamy zgrupowane w jednym miejscu.   Każdy typ wyliczeniowy, który napiszesz domyślnie tworzony jest jako typ final. Ograniczone są także modyfikatory dostępu, które możesz użyć, w przypadków enumów dopuszczalny jest wyłącznie modyfikator public lub brak jakiegokolwiek modyfikatora dostępu.   Typ wyliczeniowy nie może określić żadnej nadklasy po której dziedziczy. Dzieje się tak ponieważ każdy enum domyślnie dziedziczy po java.lang.Enum. Dzięki tej nadklasie wszystkie typy wyliczeniowe zyskują kilka dodatkowych metod opisanych w kolejnych akapitach.   Jeśli nasz enum ma także metody czy konstruktory to lista jego wartości musi znajdować się na początku.   Słów kilka o konstruktorze enuma   Mimo tego, że jesteś w stanie utworzyć swój konstruktor dla typu wyliczeniowego to nie możesz go wywołać poza definicją enuma. Każde inne użycie powoduje błąd kompilacji. To ile wartości ma typ wyliczeniowy określasz w kodzie, nie możesz tworzyć nowych instancji w trakcie działania programu. Konstruktor domyślne ma przypisane słowo kluczowe private „dodawane przez kompilator”.   Porównywanie typów wyliczeniowych   Poza konstrukcją switch typy wyliczeniowe możemy także stosować w blokach if. Możemy porównywać ich wartości przy pomocy operatora ==. Oczywiście metoda equals też będzie działała jak się tego spodziewasz. W rzeczywistości wewnątrz metody equals w typie wyliczeniowym do porównania użyty jest właśnie operator ==.   Metody dostępne w każdym typie wyliczeniowym   Dzięki nadklasie Enum, o której wspomniałem w jednym z poprzednich akapitów mamy dostęp do kilku dodatkowych metod.   ordinal, metoda zwraca indeks aktualnej wartości typu wyliczeniowego. Indeks pierwszego elementu to zawsze 0. W związku z tym kolejność definiowania wartości typu wyliczeniowego jest istotna.   Przydatna jest także metoda name, która zwraca nazwę wartości typu wyliczeniowego. W naszym przypadku TshirtSize.L.name() zwróci \"L\".   Wszystkie typy wyliczeniowe mają także przydatne metody statyczne. Jedną z nich jest metoda values. Pozwala ona na iterowanie po wartościach typu wyliczeniowego. Zwraca tablicę wartości typu wyliczeniowego   Dostępna jest także metoda valueOf, która przyjmuje łańcuch znaków i zwraca wartość typu wyliczeniowego. W naszym przypadku TshirtSize.valueOf(\"L\") zwróci TshirtSize.L.   Kiedy i po co używać typów wyliczeniowych   Typów wyliczeniowych/enumów używamy w momencie jeśli jakiś atrybut/zmienna może mieć określoną, ograniczoną listę wartości. Zastosowanie typu wyliczeniowego może pomóc ograniczyć liczbę błędów, na przykład w miejscu gdzie normalnie używalibyśmy łańcucha znaków reprezentującego rozmiar używamy dokładnie zdefiniowanego typu wyliczeniowego.   Dzięki typom wyliczeniowym możemy w jednym miejscu zgrupować wszystkie dopuszczalne wartości. Pozwala to także na łatwe rozszerzanie tej listy.   Metody abstrakcyjne w typie wyliczeniowym   Poza zwykłymi metodami, konstruktorami czy atrybutami enumy mogą posiadać metody abstrakcyjne. Tylko gdzie mielibyśmy je zaimplementować jeśli jedyne instancje typu wyliczeniowego musimy zdefiniować w klasie? Proszę spójrz na przykład poniżej.   public enum Formatter {     CALM {         public String format(String message) {             return \"Here is your message: \" + message;         }     },     NERVOUS {         public String format(String message) {             return \"ARGH! STOP BOTHERING ME WITH YOUR MESSAGE! \" + message + \" I'M NOT GOING TO ACCEPT ANYTHING MORE!\";         }     };       public abstract String format(String message); }   Konstrukcja taka jak na przykładzie powyżej to nic innego jak zdefiniowanie ciała metody format wewnątrz poszczególnych wartości. Dzięki takiemu podejściu metody Formatter.CALM.format() i Formatter.NERVOUS.format() mogą mieć różną implementację.   Materiały dodatkowe   Przygotowałem dla Ciebie zestaw materiałów dodatkowych jeśli chciałbyś poczytać na temat typów wyliczeniowch w innych miejscach.     Inny artykuł na temat typów wyliczeniowych,   Typy wyliczeniowe na YouTube,   Tutorial dotyczący typów wyliczeniowych na stronie Oracle’a,   Dokumentacja klasy Enum,   Rozdział w dokumentacji języka Java dotyczący klas wyliczeniowych,   Tutorial dotyczący klas wyliczeniowych.   Kod źródłowy dla wszystkich przykładów użytych w artykule znajduje się na githubie.   Zadania      Napisz klasę Human, która będzie reprezentowała człowieka. Niech klasa ta posiada atrybuty takie jak imię, wiek, kolor oczu, kolor włosów. Niech te dwa ostatnie atrybuty będą typami wyliczeniowymi. Stwórz instancję takiej klasy.   Napisz typ wyliczeniowy Computation, który będzie reprezentował prosty kalkulator. Niech typ ten posiada następujące wartości MULTIPY, DIVIDE, ADD, SUBTRACT. Niech typ ten posiada metodę public double perform(double x, double y), która zwróci wynik odpowiedniej operacji. Na przykład Computation.ADD.perform(1, -5) powinno zwrócić -4.   Przygotowałem dla Ciebie przykładowe rozwiązania. Proszę jednak abyś spróbował rozwiązać zadania samodzielnie, wówczas najwięcej się nauczysz. Kod rozwiązań znajdziesz w repozytorium na githubie.   Podsumowanie   Po przeczytaniu artykułu i zrobieniu zadań wiesz już wszystko na temat typów wyliczeniowych w Javie. Żadne zakamarki enumów nie są Ci obce :) Na koniec mam do Ciebie prośbę, proszę podziel się informacją o blogu ze swoimi znajomymi, udostępnienie linka do artykułu na facebooku naprawdę pomaga mi dotrzeć do jak największej liczby czytelników a na tym właśnie mi zależy. Jeśli masz jakiekolwiek pytania zadaj je w komentarzach, postaram się pomóc.   A.. zapomniałbym, jeśli chcesz być jako pierwszy informowany o nowościach na stronie zapisz się do mojego newslettera :)   Do następnego razu!  ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/typ-wyliczeniowy-w-jezyku-java/",
        "teaser": "/assets/images/2016/09/09_typ_wyliczeniowy_artykul.jpg"
      },{
        "title": "Adnotacje w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Adnotacja   Czasami mogłeś zobaczyć w kodzie dziwną konstrukcje z @ np. @Override czy @NotNull. To właśnie były adnotacje.   Adnotacje są konstrukcją, która pozwala na przekazywanie dodatkowych informacji na temat kodu. Informacje te mogą być wykorzystane później w kilku miejscach. Każde z tych zastosowań opiszę bardziej szczegółowo w kolejnych akapitach.   Mówi się, że adnotacje służą do przekazywania metadanych. Innymi słowy przekazują one dane o danych – dane o kodzie źródłowym.   “Pod spodem” adnotacja to nic innego jak specjalny rodzaj interfejsu.   Adnotacje a JavaDoc   Chociaż w obu przypadkach możesz zauważyć znak @ musisz wiedzieć, że adnotacje to coś zupełnie innego niż dyrektywy JavaDoc.   JavaDoc to standardowy mechanizm do generowania dokumentacji, która zaszyta jest w kodzie źródłowym. Na przykład we fragmencie kodu poniżej widzisz metodę wraz z dokumentacją. Zwróć proszę uwagę, że JavaDoc znajduje się wewnątrz specjalne sformatowanego komentarza wieloliniowego. który rozpoczyna się od /**, każda linia wewnątrz komentarza rozpoczyna się od *. Wewnątrz komentarza znajdują się specjalne dyrektywy, takie jak @param czy @return. Opisują one odpowiednio parametr oraz wartość zwracaną metody.   /**  * Multipies number by 2  * @param parameter number that should be multipied  * @return parameter multipied by 2  */ public int timesTwo(int parameter) {     return parameter * 2; }   Mogą tam znajdować się również inne dyrektywy takie jak @see, @author czy @version. Na podstawie tak zapisanych informacji o kodzie generowana jest dokumentacja, na przykład dla klasy String.   Adnotacje, w odróżnieniu od dyrektyw JavaDoc, nie są umieszczane wewnątrz komentarzy a poza nimi.   Taka ilość informacji w zupełności wystarczy Ci aby odróżnić adnotacje od dyrektyw JavaDoc, przejdźmy zatem do zastosowania adnotacji.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Zakres adnotacji – dozwolone miejsca gdzie możemy stosować adnotacje   Każda adnotacja określa, w którym miejscu możemy ją stosować. Mamy kilka standardowych miejsc, gdzie możemy wstawić adnotację.     metoda,   klasa,   atrybut klasy,   parametr metody,   zmienna lokalna,   konstruktor,   adnotacja typu (ang. type annotations).   Adnotację umieszczamy zawsze przed konkretnym elementem, na przykład przed klasą.   Zastosowanie adnotacji   Adnotacje mają trzy główne zastosowania. Poniższe sekcje dokładniej opisują każde z nich.   Dodatkowe informacje dla kompilatora   Adnotacje mogą służyć jako dodatkowa informacja dla kompilatora. Za przykład może tu posłużyć adnotacja @Override. Jest to informacja dla kompilatora, że dana metoda przesłania metodę w nadklasie. Adnotacja @Override może też być używana do oznaczania metod interfejsu, które implementujemy.   W przypadku tej adnotacji kompilator może wychwycić więcej błędów w trakcie kompilacji. Spójrz na przykład poniżej:   public class EqualsOverride {     public boolean equal(Object obj) {         return true;     } }   Programista chciał nadpisać metodę equals. Brakujące s na końcu metody sprawia, że w momencie porównywania obiektów tej klasy używamy odziedziczonej metody equals z klasy Object, która ma zupełnie inną implementację.   Jeśli dodalibyśmy adnotację @Override do tej metody, kompilator już na etapie kompilacji znalazłby błąd. Kompilacja nie powiodłaby się ponieważ nasza metoda nie nadpisała żadnej metody z nadklasy. Poniżej przykład metody equals z adnotacją.   @Override public boolean equals(Object obj) {     return true; }   Adnotacje przetwarzane w trakcie kompilacji   W trakcie kompilacji także możemy przetwarzać adnotacje. Dzięki nim możemy na przykład automatycznie generować kod czy dać znać kompilatorowi aby zachowywał się trochę inaczej. Przykładem takiej adnotacji jest @SuppressWarnings z biblioteki standardowej. Adnotacja ta pozwala nam wstrzymać pewne ostrzeżenie kompilatora.   Proszę spójrz na przykład kodu poniżej.   public static void main(String[] args) {     List listOfUndefinedObjects = new ArrayList();     List&lt;Integer&gt; listOfIntegers = (List&lt;Integer&gt;) listOfUndefinedObjects; }   W metodzie main tworzymy zmienną lokalną listOfUndefinedObjects, która jest zwykłą listą. Nie używam tu typów generycznych. Linijkę niżej natomiast rzutuję tę zmienną na typ List&lt;Integer&gt;.   Jeśli w listOfUndefinedObjects mielibyśmy instancję klasy String, wówczas pobranie elementu z nowej listOfIntegers skończyłoby się rzuceniem wyjątku ClassCastException (nie możemy rzutować String na Integer).   Kompilator ostrzega nas o takiej możliwości pokazując ostrzeżenie   Warning:(10, 56) java: unchecked cast required: java.util.List&lt;java.lang.Integer&gt; found: java.util.List   Jeśli jesteśmy pewni, że ta operacja jest poprawna (mamy pewność, że będą tam tylko instancje klasy Integer) i chcemy aby kompilator takich wyjątków nie pokazywał możemy użyć adnotacji @SuppressWarnings   Akurat tę adnotację możemy przypisać do typu, atrybutu, metody, parametru metody, konstruktora czy nawet zmiennej lokalnej, jak zrobiłem to w przykładzie poniżej.   public static void main(String[] args) {     List listOfUndefinedObjects = new ArrayList();     @SuppressWarnings(\"unchecked\")     List&lt;Integer&gt; listOfIntegers = (List&lt;Integer&gt;) listOfUndefinedObjects; }   @SupressWarnings(„unchecked”) mówi aby kompilator nie ostrzegał nas o potencjalnych zagrożeniach typu unchecked przy tej konkretnej zmiennej.   Adnotacje przetwarzane w trakcie uruchomienia programu   Adnotacje mogą być także używane w trakcie działania programu. Służy do tego mechanizm refleksji.   Mechanizm refleksji opiszę w osobnym artykule. Na potrzeby tego artykułu wystarczy, że wiesz o jej istnieniu oraz o tym, że dzięki niej możemy w trakcie działania programu pobierać informacje o skompilowanym kodzie.   Przykładem takiej adnotacji może być @PostConstruct.   Składnia definiowania adnotacji   Java Language Specification definiuje adnotację jako specjalny rodzaj interfejsu. Szczerze mówiąc to porównanie nasuwa się samo jak zobaczysz przykładową definicję adnotacji.   public @interface Override { }   Definicja powyżej to nic innego jak znana Ci już adnotacja @Override. Zauważ znak @ przed słowem kluczowym interface.   Dodatkowo definicja adnotacji powinna także posiadać informację o tym do jakich elementów może być stosowana. Ponadto znajduje się tam także informacja o tym jak długo dane o adnotacji powinny być przetrzymywane – retencja. Czy tylko w trakcie kompilacji czy także w trakcie uruchomienia programu.   Ta ostatnia cecha (ang. retention) jest bardzo istotna gdy chcesz wykorzystywać adnotację w trakcie uruchomienia programu. Pełna definicja adnotacji @Override wraz z tymi informacjami przedstawiona jest w przykładzie poniżej   @Target(ElementType.METHOD) @Retention(RetentionPolicy.SOURCE) public @interface Override { }   Dopuszczalny kontekst użycia adnotacji   Do określenia gdzie możemy użyć adnotację służy inna „meta-adnotacja” @Target. Jeśli ją pominiemy przy definiowaniu nowej adnotacji, możemy jej używać w każdym miejscu. Z jednym małym wyjątkiem – adnotacji typów.   Miejsca gdzie możemy użyć adnotacji określone są przez wartości typu wyliczeniowego ElementType. Spójrz na przykład poniżej.   @Target(ElementType.FIELD) public @interface SampleFieldAnnotation { String id(); }   Nasza @SampleFieldAnnotation może być użyta wyłącznie przy atrybutach klasy, ponieważ przypisaliśmy do niej ElementType.FIELD.   Retencja adnotacji   Adnotacje, które przypiszesz mają swój “cykl życia”. W zależności od typu adnotacji informacja o tym, że była ona przypisana do jakiegoś elementu może (ale nie musi) być “wymazana” przez kompilator w trakcie kompilacji. Zachowanie takie ma sens ponieważ nie potrzebujemy informacji w trakcie uruchomienia programu o adnotacjach, które są wykorzystywane wyłącznie podczas kompilacji. Takie “wymazywanie” adnotacji pozwala na stworzenie bajtkodu (skompilowanej klasy), który ma mniejszą objętość.   Retencję (informacja o tym jak długo informacja o adnotacji powinna być przechowywana) także określamy przy pomocy adnotacji. Służy do tego „meta-adnotacja” @Retention. Informacje o adnotacji mogą być:      usuwane przez kompilator w trakcie kompilacji,   umieszczanie w skompilowanej klasie, ale nie dostępne w trakcie uruchomienia programu,   dostępne w trakcie uruchomienia programu.   Wszystkie trzy sposoby określone są przez typ wyliczeniowy RetentionPolicy.   Jeśli nie określimy retencji naszej własnej adnotacji (nie dodamy @Retention), wówczas przyjmie ona wartość domyślną RetentionPolicy.CLASS. Innymi słowy, jeśli nie określimy inaczej informacje o adnotacji są zapisywane w pliku class jednak nie są dostępne w trakcie uruchomienia programu.   Elementy adnotacji   Zauważ, że niektóre adnotacje posiadają „argumenty”. W kontekście adnotacji argumenty te nazywamy elementami. Na przykład w przypadku adnotacji @SuppressWarnings przekazywaliśmy informację o tym jakiego typu ostrzeżenia kompilatora chcemy pomijać.   Każda adnotacja może mieć elementy, które możemy uzupełnić przy przypisywaniu adnotacji. Możemy je rozumieć jako „parametry” dla adnotacji. Pozwalają one na przekazanie dodatkowych informacji. Spójrz na przykład poniżej:   public @interface Retention {     RetentionPolicy value(); }   Jak widzisz, składnia definiująca elementy adnotacji używa nawiasów (), mogą przypominać one deklaracje metod, co po raz kolejny można skojarzyć z interfejsami.   Adnotacja @Retention posiada jeden element o nazwie value. Nazwa value jest traktowana specjalnie. Jeżeli jest jedyna, możemy ją pomijać gdy używamy danej adnotacji. W przykładzie poniżej oba użycia oznaczają dokładnie to samo.   @Retention(RetentionPolicy.SOURCE) @Retention(value=RetentionPolicy.SOURCE)   Elementy adnotacji będące tablicami   Czasami może zdarzyć się tak, że do adnotacji chcesz przekazać kilka wartości dla danego elementu. Wówczas element adnotacji jest typu tablicowego. Dobrym przykładem tutaj jest adnotacja @Target, którą widziałeś już wyżej:   public @interface Target {     ElementType[] value(); }   Jak widzisz posiada ona element value, który jest tablicą. Podobnie jak w poprzednim przykładzie jedyny element o nazwie value może być pominięty. Przykład poniżej pokazuje cztery różne sposoby użycia adnotacji mające ten sam efekt. Nawiasy {} służą do określenia tablicy wartości, w tym przykładzie jest to tablica jednoelementowa.   @Target(ElementType.FIELD) @Target(value=ElementType.FIELD) @Target({ElementType.FIELD}) @Target(value={ElementType.FIELD})   Wartości domyślne elementów adnotacji   Istnieje możliwość tworzenia adnotacji, które mają wartości domyślne. Używamy do tego słowa kluczowego default. Spójrz na przykład poniżej   @Retention(RetentionPolicy.RUNTIME) @Target({ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD}) public @interface AnnotationWithDefaultValues {     String firstElement() default \"someDefaultValue\";     int [] secondElement() default {1, 2, 3};     float thirdElement(); }   Nasza adnotacja @AnnotationWithDefaultValues posiada trzy elementy, dwa z nich mają wartości domyślne. Adnotację tę możemy stosować do atrybutów klasy, konstruktorów i metod. Informacja o tej adnotacji jest dostępna w trakcie wykonania programu.   Zadanie   Na koniec mam dla Ciebie zadanie. Napisz adnotację @MyDocumentation, która będzie miała elementy author oraz comment. Informacja o tej adnotacji powinna być dostępna w trakcie uruchomienia programu.   Napisałem krótki fragment, kodu używający mechanizmu refleksji, w którym możesz przetestować swoją adnotację. Wstaw adnotację w miejscu komentarza i uruchom program. Używa on mechanizmu refleksji (jej tłumaczenie możemy teraz pominąć).   // TUTAJ DODAJ ADNOTACJE public class AnnotationProcessor {       private static List SKIP_METHODS = Arrays.asList(\"equals\", \"toString\", \"hashCode\", \"annotationType\");       public static void main(String[] args) throws InvocationTargetException, IllegalAccessException {         for (Annotation classAnnotation : AnnotationProcessor.class.getDeclaredAnnotations()) {             printAnnotationDetails(classAnnotation);         }     }       private static void printAnnotationDetails(Annotation annotation) throws InvocationTargetException, IllegalAccessException {         System.out.println(\"Znalazłem adnotacje: \" + annotation);         for (Method method : annotation.annotationType().getMethods()) {             if (SKIP_METHODS.contains(method.getName())) {                 continue;             }             System.out.println(\"Nazwa elementu: \" + method.getName());             System.out.println(\"Wartosc elementu: \" + method.invoke(annotation));             System.out.println(\"Wartosc domyslna elementu: \" + method.getDefaultValue());             System.out.println();         }     } }   Jak zwykle zachęcam Cię do samodzielnego rozwiązania zadania. W przypadku jakichkolwiek wątpliwości przykładowe rozwiązanie umieściłem na githubie.   Dodatkowe materiały do nauki   Oczywiście Jak zwykle zachęcam do przejrzenia standardowej dokumentacji, jak zwykle znajdziesz tam mnóstwo wiedzy.     Rozdział w specyfikacji języka Java dotyczący adnotacji,   Inny artykuł dotyczący adnotacji,   kod źródłowy użyty w artykule.   Podsumowanie   W artykule przeczytałeś o adnotacjach, napisałeś swoją pierwszą adnotację i nawet udało Ci się ją wykryć w trakcie działania programu. Wiesz, kiedy i do czego używamy adnotacji. Dzięki temu artykułowi nie zgubisz się w gąszczu adnotacji Springa czy innych bibliotek :)   Jak zwykle, jeśli masz jakiekolwiek pytania zadaj je w komentarzach, w miarę możliwości postaram się pomóc.   Mam nadzieję, że artykuł Ci się podobał, na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największej liczby czytelników. Możesz mi w tym pomóc udostępniając link do bloga czy artykułu swoim znajomym :) Z góry dziękuję i do następnego razu!  ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/adnotacje-w-jezyku-java/",
        "teaser": "/assets/images/2016/10/03_adnotacje_artykul.jpg"
      },{
        "title": "Klasy wewnętrzne i anonimowe w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Klas wewnętrznych jest wiele…   Na początku pewne zastrzeżenie. W całym artykule posługuję się określeniem „klasy wewnętrzne”. Ważne jest żebyś zdawał sobie sprawę z tego, że równie dobrze możemy mieć do czynienia z wewnętrznym typem wyliczeniowym czy wewnętrznym interfejsem. Poznając klasy wewnętrzne, poznajesz także „interfejsy wewnętrzne” czy „wewnętrzne typy wyliczeniowe”.   Istnieje kilka typów klas wewnętrznych:      (standardowe) klasy wewnętrzne,   statyczne klasy wewnętrzne,   lokalne klasy wewnętrzne,   anonimowe klasy wewnętrzne.   Często mówimy po prostu o klasie wewnętrznej odwołując się do którejkolwiek z powyższych. W kolejnych akapitach postaram się pokazać różnice pomiędzy tymi typami klas.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Klasy wewnętrzne   Standardowe klasy już znasz. Ot zwykłe public class Example {} i już mamy klasę. A czym jest klasa wewnętrzna? Zacznijmy od przykładu:   public class OuterClass {     public class InnerClass {     }      public InnerClass instantiate() {         return new InnerClass();     } }   W naszym przykładzie widzisz dwie klasy. Standardowa klasa OuterClass i klasa wewnętrzna InnerClass.   Podobnie jak w przypadku atrybutów czy metod, klasy wewnętrzne mogą mieć standardowe modyfikatory dostępu public, protected czy private. Brak modyfikatora dostępu także i tutaj jest poprawny.   Modyfikatory dostępu użyte przed definicją klasy wewnętrznej działają identycznie jak w przypadku atrybutów, metod czy konstruktorów. Jeśli chcesz przeczytać o nich więcej osobny akapit na ich temat znajdziesz w artykule o dziedziczeniu. Napisałem też osobny artykuł w pełni poświęcony modyfikatorom dostępu.   Ważne jest także to, że klasa wewnętrzna ma dostęp do wszystkich atrybutów czy metod klasy zewnętrznej, w której została zdefiniowana.   Tworzenie instancji klasy wewnętrznej   Do stworzenia instancji klasy wewnętrznej potrzebujemy instancji klasy zewnętrznej. Proszę spójrz na przykład poniżej.   private static void innerClassInstantiation() {     OuterClass outerClass = new OuterClass();     OuterClass.InnerClass instance1 = outerClass.instantiate();     OuterClass.InnerClass instance2 = outerClass.new InnerClass(); }   Widzisz tam typ OuterClass.InnerClass, to nic innego jak odwołanie się do typu wewnętrznego. W tym fragmencie kodu tworzymy dwie instancje. Pierwsza z nich powstaje w wyniku wywołania metody instantiate z klasy OuterClass. Ciało tej metody możesz zobaczyć w poprzednim fragmencie kodu.   Proszę zwróć uwagę, że wewnątrz metody instantiate nie musimy podawać pełnej nazwy klasy, samo new InnerClass() wystarczy (jest to odpowiednik this.new InnerClass()).   instance2 tworzymy posługując się instancją klasy OuterClass. Taka konstrukcja jest niezbędna w przypadku standardowych klas wewnętrznych.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Statyczne klasy wewnętrzne   W języku Java istnieją także statyczne klasy wewnętrzne. Są to klasy wewnętrzne poprzedzone modyfikatorem static. Proszę spójrz na przykład poniżej.   public class OuterClass2 {     public static class InnerClass2 {     }          private InnerClass2 instantiate() {         return new InnerClass2();     }    }   Jak widzisz przykład ten jest bardzo podobny do pierwszego z tego artykułu. Nowością tutaj jest modyfikator static, reszta pozostaje bez zmian.   Ważna jest natomiast różnica przy tworzeniu instancji statycznej klasy wewnętrznej.   Domyślnie, wszystkie wewnętrzne interfejsy i typy wyliczeniowe są statyczne, modyfikator static jest przed nimi zbędny (możesz spróbować go dodać, IDE powinno zwrócić Ci na to uwagę).   Tworzenie instancji statycznej klasy wewnętrznej   W odróżnieniu od standardowych klas wewnętrznych, nie potrzebujemy instancji klasy zewnętrznej do stworzenia instancji statycznej klasy wewnętrznej. Może się to wydać trochę skomplikowane jednak całość na pewno będzie bardziej zrozumiała gdy popatrzysz na przykład.   private static void staticInnerClassInstantiation() {     OuterClass2 outerClass = new OuterClass2();     OuterClass2.InnerClass2 instance1 = outerClass.instantiate();     OuterClass2.InnerClass2 instance2 = new OuterClass2.InnerClass2(); }   Różnica jest taka, że wystarczy pełne odwołanie się do typu klasy wewnętrznej, aby stworzyć jej instancję. W naszym przypadku jest to new OuterClass2.InnerClass2().   Lokalne klasy wewnętrzne   Jako ostatni typ klas wewnętrznych zostały do omówienia lokalne klasy wewnętrzne. I wiesz co? W sumie poza tym, że możemy je zdefiniować wewnątrz bloku (wewnątrz metody, bloku if itp.) i nie poprzedzają ich modyfikatory dostępu (public, private, protected) niczym szczególnym nie różnią się od pozostałych klas wewnętrznych. Proszę spójrz na przykład:   private static void localClassInstantiation(String[] args) {     class LocalClass {         @Override         public String toString() {             return \"Argumenty metody: \" + Arrays.toString(args);         }     }        LocalClass localClassInstance = new LocalClass();     System.out.println(localClassInstance); }   Tutaj wewnątrz metody tworzymy naszą lokalną klasę wewnętrzną LocalClass. Linijkę później tworzymy jej instancję i wywołujemy na niej metodę.   Głównym ograniczeniem/zaletą klas lokalnych jest ich zasięg. Podobnie jak w przypadku zmiennych lokalnych, dostęp do klas lokalnych jest wyłącznie w bloku, w którym zostały zdefiniowane.   Kiedy używać klas wewnętrznych   Właśnie, po co w ogóle są nam one potrzebne? Mam nadzieję, że przykład ze standardowej biblioteki Javy pomoże Ci to zrozumieć.   W artykule o kolekcjach opisałem mapę i sposób w jaki możemy po niej iterować.   Map&lt;String, Integer&gt; dayInMonths = new HashMap&lt;&gt;(); dayInMonths.put(\"styczen\", 31); dayInMonths.put(\"luty\", 28); dayInMonths.put(\"marzec\", 31);   for(Map.Entry&lt;String, Integer&gt; entry : dayInMonths.entrySet()) {     System.out.println(entry.getKey() + \" ma \" + entry.getValue() + \" dni.\"); }   W naszej mapie trzymamy nazwę miesiąca i odpowiadającą mu liczbę dni. Każda instancja obiektu implementującego interfejs Map posiada metodę entrySet, która zwraca typ Set&lt;Map.Entry&lt;K, V&gt;&gt;.   Rozłóżmy ten typ na części pierwsze. K to nasz klucz (ang. key), V to wartość (ang. value) przechowywana w mapie. Map.Entry&lt;K, V&gt; to typ generyczny, który parametryzowany jest typem klucza i wartości. Set&lt;Map.Entry&lt;K, V&gt;&gt; to zbiór elementów mapy. Każdy element ma klucz i wartość. A czym jest Map.Entry? To nic innego jak interfejs wewnętrzny :) Jest to interfejs Entry zdefiniowany wewnątrz interfejsu Map.   Więc po co używać klas wewnętrznych? Powodów jest kilka. Jak w przykładzie z Map.Entry dobrym pomysłem użycia klas wewnętrznych jest sytuacja, w której klasa wewnętrzna nie ma sensu bez klasy zewnętrznej i jest z nią ściśle związana.   Kolejnym powodem może być lepsza enkapsulacja kodu (ukrywanie szczegółów działania klasy wewnątrz). Dzięki temu, że klasy wewnętrzne mają dostęp nawet do prywatnych zasobów klas otaczających, te drugie możemy bardziej „opakować”. Ukryć więcej szczegółów wewnątrz.   Klasy anonimowe   Zacznijmy od definicji. Klasy anonimowe to klasy definiowane w kodzie, które mają dokładnie jedną instancję1. Definicja klasy anonimowej połączona jest z tworzeniem jej jedynej instancji. Klasy anonimowe zawsze są klasami wewnętrznymi.   Proszę spójrz na przykład poniżej:   public interface GreetingModule {     void sayHello(); }   public void someMethod() {     GreetingModule greeting = new GreetingModule() {         @Override         public void sayHello() {             System.out.println(\"good morning\");         }     }; }   Na początku definicja interfejsu z jedną metodą sayHello. Ciekawsze są jednak ostatnie linijki. To właśnie definicja klasy anonimowej. Wewnątrz someMethod możesz zobaczyć taką konstrukcję:   new TYP([ARGUMENTY]) {     CIAŁO KLASY }   Pozwala ona na stworzenie instancji klasy anonimowej. W powyższym przykładzie kompilator tworzy nową klasę, która implementuje interfejs GreetingModule. W tym samym czasie tworzę jej nową instancję przy pomocy słowa kluczowego new. Upraszczając, można powiedzieć, że powyższy przykład to skrót:   public interface GreetingModule {     void sayHello(); }  public class GreetingModuleImpl implements GreetingModule {     @Override     public void sayHello() {         System.out.println(\"good morning\");     } }  public void someMethod() {     GreetingModule greeting = new GreetingModuleImpl(); }   Wewnątrz definicji klasy anonimowej możemy definiować atrybuty czy metody. W praktyce sprowadza się to przeważnie do zaimplementowania metod interfejsu dla którego tworzymy klasę anonimową.   W większym fragmencie kodu użycie klas anonimowych może wyglądać następująco.   public class AnonymousClasses {     public static class Robot {         private final GreetingModule greetingModule;           public Robot(GreetingModule greetingModule) {             this.greetingModule = greetingModule;         }           public void saySomething() {             greetingModule.sayHello();         }     }       public interface GreetingModule {         void sayHello();     }       public static void main(String[] args) {         Robot jan = new Robot(new GreetingModule() {             @Override             public void sayHello() {                 System.out.println(\"dzien dobry\");             }         });         Robot john = new Robot(new GreetingModule() {             @Override             public void sayHello() {                 System.out.println(\"good morning\");             }         });           jan.saySomething();         john.saySomething();     } }   W naszym przykładzie tworzymy dwie instancje robotów jan i john, które używają innych „modułów powitań”. Każdy z nich jest instancją anonimowej klasy wewnętrznej.   Niektóre z klas anonimowych można zastąpić wyrażeniami lambda.   Klasa anonimowa to nie instancja interfejsu   Ważne jest abyś pamiętał o tym, że klasa anonimowa nie tworzy instancji interfejsu. Kompilator tworzy nową klasę, która implementuje dany interfejs. Klasa stworzona przez kompilator tak naprawdę ma swoją nazwę. Możesz nawet do niej dotrzeć:   public class AnonymousCheating {     private interface SomeInterface {         void doSomethingUseful();     }      public static void main(String[] args) {         SomeInterface anonymousInstance = new SomeInterface() {             @Override             public void doSomethingUseful() {                 System.out.println(\"I'm doing something useful!\");             }         };          anonymousInstance.doSomethingUseful();         System.out.println(anonymousInstance.getClass());     } }   Po uruchomieniu tego programu, na konsoli pokaże się tekst:   I'm doing something useful! class pl.samouczekprogramisty.kursjava.inner.AnonymousCheating$1   Zatem anonymousInstance jest instancją klasy pl.samouczekprogramisty.kursjava.inner.AnonymousCheating$1. Co to za nazwa? Nazwa klasy wewnętrznej oddzielona jest $ od nazwy klasy wewnątrz której została umieszczona. Zatem w tym przypadku kompilator utworzył wewnętrzną klasę o nazwie 1 wewnątrz AnonymousCheating znajdującej się w pakiecie pl.samouczekprogramisty.kursjava.inner.   Jak myślisz, jaką nazwę będzie miała kolejna klasa anonimowa stworzona wewnątrz AnonymousCheating ;) ?   Używanie zmiennych lokalnych w klasach wewnętrznych   Wewnątrz definicji klas wewnętrznych (także klas anonimowych) możemy używać zmiennych lokalnych z otaczającego je kontekstu. Spójrz na przykład poniżej:   public void someMethod() {     final String finalVariable = \"final variable\";     String effectivelyFinalVariable = \"effectively final variable\";     String nonFinalVariable = \"non final variable\";       class InnerClass {                  public void saySomething() {                     System.out.println(finalVariable);             System.out.println(effectivelyFinalVariable);         }        }          InnerClass instance = new InnerClass();     instance.saySomething();                   nonFinalVariable = \"new value\"; }   W metodzie saySomething używamy dwóch zmiennych lokalnych metody otaczającej finalVariable i effectivelyFinalVariable. Jest jednak jedno ograniczenie. Zmienna z “zewnątrz” użyta w klasie wewnętrznej musi być finalna albo „właściwie finalna”.   Zmienna jest finalna jeśli poprzedza ją słowo kluczowe final. Kiedy jest „właściwie finalna”? Kiedy nie zmieniamy jej wartości i kompilator za nas wstawia brakujące słowo final ;).   W związku z tym użycie zmiennej nonFinalVariable nie jest dozwolone ponieważ jej wartość jest zmieniana.   Zadania   Na koniec czekają na Ciebie dwa zadania, w których przećwiczysz zagadnienia omówione w artykule. Przygotowałem też zestaw przykładowych rozwiązań i umieściłem je na githubie. Jak zwykle zachęcam do samodzielnego rozwiązywania zadań, wtedy nauczysz się najwięcej. Samo przeczytanie artykułu nie wystarczy, do dzieła!     Rozszerz przykład z robotami z akapitu o klasach anonimowych o robota witającego się w innym języku np. niemieckim.   Zadanie to będzie wymagało dodatkowej lektury na temat interfejsu Comparator ze standardowej biblioteki Javy. Pobierz od użytkownika 5 wyrazów, zapisz je w List. Użyj metody Collections.sort, przekazując jako argumenty listę oraz klasę anonimową, która posortuje ją na podstawie długości wyrazów (najkrótsze wyrazy powinny być pierwsze). Do sprawdzenia długości słowa możesz użyć metody String.length. Wyświetl zawartość listy przed i po sortowaniu.   Materiały dodatkowe   Przygotowałem też dla Ciebie zestaw materiałów dodatkowych zawierających informacje na temat klas wewnętrznych i anonimowych. Dodatkowo wszystkie przykłady kodu użyte w tym artykule możesz znaleźć na samouczkowym githubie.     Tutorial na stronie Oracle dotyczący klas wewnętrznych i anonimowych,   Fragment książki opisujący klasy wewnętrzne,   Rozdział w JLS na temat klas wewnętrznych,   Rozdział w JLS na temat klas anonimowych.   Podsumowanie   Bardzo się cieszę, że przeczytałeś artykuł do końca. Po lekturze artykułu wiesz czym są klasy wewnętrzne. Wiesz też jakie rodzaje klas wewnętrznych występują. Znasz także klasy anonimowe i wiesz kiedy ich używać. Rozwiązując zadanie przećwiczyłeś całość w praktyce. Innymi słowy kawał solidnej wiedzy :)   Na koniec mam do Ciebie prośbę. Proszę podziel się artykułem ze znajomymi i polub moją stronę na Facebook’u. Zależy mi na dotarciu do jak największej liczby osób, które chcą uczyć się programowania. Z góry dziękuję i do następnego razu.                 Pomijam tutaj mechanizm refleksji. Możesz utworzyć więcej instancji takiej klasy, na samouczkowym githubie możesz znaleźć przykład tego jak można to zrobić. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/klasy-wewnetrzne-i-anonimowe-w-jezyku-java/",
        "teaser": "/assets/images/2016/10/13_klasy_wewnetrzne_anonimowe_artykul.jpg"
      },{
        "title": "Testy jednostkowe z JUnit",
        "excerpt":"Artykuł ten opisuje podstawy testów jednostkowych z wykorzystaniem biblioteki JUnit 4. Jeśli zapoznasz się już z JUnit 4 zapraszam Cię do artykułu na temat testów z JUnit 5.   Po co testujemy oprogramowanie   Oczywista odpowiedź jest prosta – żeby nie było błędów :). Błędy powodują frustrację użytkowników, a to jest coś czego chcemy uniknąć. Ile razy chciałeś rzucić myszką/klawiaturą/laptopem jak coś nie działało jak powinno? Brzmi znajomo? ;)   Wszystkie powody testowania komercyjnego oprogramowania sprowadzają się do pieniędzy. Im wcześniej wykryjemy błąd, tym niższy jest koszt jego naprawienia. Pisanie testów jednostkowych pozwala wykryć błędy w najwcześniejszej możliwej fazie, w trakcie pisania kodu programu. Dlatego każdy porządny programista powinien testować kod, który napisze. Oddając kod do użytku powinien być pewny, że działa jak powinien.   Pojawia się tu jednak pewien problem. Manualne testowanie to żmudna, czasochłonna i mozolna praca. Bardzo tu łatwo o drobne przeoczenie kończące się błędem w programie. Do tego w projektach IT wymagania zmieniają się bardzo często więc takie testy także muszą być bardzo często przeprowadzane.   W związku z tym programiści testują swój kod pisząc testy jednostkowe.   Czym jest test jednostkowy   Test jednostkowy (ang. unit test) to sposób testowania programu, w którym wydzielamy mniejszą jego część, jednostkę i testujemy ją w odosobnieniu. W naszym przypadku taką jednostką do testowania może być pojedyncza klasa czy metoda, którą napiszemy.   Testy jednostkowe można pisać bez bibliotek zewnętrznych jednak jest to uciążliwe. Dodatkowo warto używać istniejących bibliotek ponieważ IDE dobrze się z nimi integrują. W tym artykule użyłem biblioteki JUnit.   Spójrz na fragment kodu poniżej. Klasa ta reprezentuje zakres liczb, ma ona jedną metodę, która sprawdza czy liczba przekazana jako argument należy do danego zakresu.   public class Range {     private final long lowerBound;     private final long upperBound;      public Range(long lowerBound, long upperBound) {         this.lowerBound = lowerBound;         this.upperBound = upperBound;     }      public boolean isInRange(long number) {         return number &gt;= lowerBound &amp;&amp; number &lt;= upperBound;     } }   Poniżej przykład prostego testu jednostkowego, który sprawdza czy, liczba 15 jest w zakresie liczb od 10 do 20.   @Test public void shouldSayThat15rIsInRange() {     Range range = new Range(10, 20);     Assert.assertTrue(range.isInRange(15)); }   Test jednostkowy to metoda testująca naszą jednostkę, metodę w innej klasie z dodaną adnotacją @Test. shouldSayThat15IsInRange jest testem, wewnątrz którego tworzę instancję klasy Range i wywołuję metodę sprawdzającą czy 15 jest wewnątrz zakresu.   Wynik tej metody jest przekazywany do metody Assert.assertTrue(), jest to tak zwana asercja. Asercje to metody dostarczone przez bibliotekę JUnit, które pomagają przy testowaniu.   W naszym przykładzie, jeśli metoda isInRange zwróci false, wówczas asercja assertTrue rzuci wyjątek, który przez IDE zostanie zinterpretowany jak test jednostkowy, który pokazuje błąd działania testowanego kodu. Mówimy wówczas, że „test nie przeszedł”, „wywalił się” :).   Testy jednostkowe łączymy w klasy z testami, bardzo często nazywamy je tak samo jak klasy, które testujemy dodając do nich Test na końcu. W naszym przypadku klasa z testami dla klasy Range nazywa się RangeTest.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Przykłady użycia asercji   Po co używać asercji? Otóż gotowe asercje tworzą komunikaty błędów (w trakcie testów jednostkowych), które ułatwiają znalezienie błędu. Komunikaty te są bardziej czytelne niż standardowy wyjątek AssertionError1.   Asercje w bibliotece JUnit to nic innego jak metody statyczne w klasie Assert. Poniżej przedstawię Ci kilka najczęściej stosowanych asercji2.      assertTrue sprawdza czy przekazany argument to true,   assertFalse sprawdza czy przekazany argument to false,   assertNull sprawdza czy przekazany argument to null,   assertNotNull sprawdza czy przekazany argument nie jest nullem,   assertEquals przyjmuje dwa parametry wartość oczekiwaną i wartość rzeczywistą, jeśli są różne rzuca wyjątek,   assertNotEquals przyjmuje dwa parametry wartość oczekiwaną i wartość rzeczywistą, rzuci wyjątek jeśli są równe.   Importy statyczne   Tutaj drobna dygresja, w języku Java musimy importować klasy z innych pakietów, które chcemy użyć w definicji naszej klasy. Poza standardową konstrukcją ze słowem kluczowym import istnieją także tak zwane importy statyczne.   Import statyczny pozwala na zaimportowanie metody/wszystkich metod statycznych znajdujących się w definicji jakiejś klasy. Proszę spójrz na przykład poniżej.   import static org.junit.Assert.assertFalse; import static org.junit.Assert.*;   W pierwszej linijce importujemy metodę assertFalse z klasy Assert, druga linijka to importowanie wszystkich metod statycznych z tej klasy. Dzięki takim importom później w definicji klasy nie musimy używać nazwy klasy używając danej metody statycznej:   assertFalse(false); assertTrue(true);   Z racji tego, że dużo metod pomocniczych (na przykład asercje) w przypadku pisania testów to metody statyczne, bardzo często używamy tam importów statycznych.   Testowanie metod rzucających wyjątki   Czasami zdarza się, że chcemy przetestować pewną sytuację wyjątkową. Na przykład nie powinniśmy móc utworzyć instancji klasy Range z niepoprawnymi argumentami.   public Range(long lowerBound, long upperBound) {     if (lowerBound &gt; upperBound) {         throw new IllegalArgumentException(\"lowerBound is bigger than upperBound!\");     }     this.lowerBound = lowerBound;     this.upperBound = upperBound; }   Wywołanie konstruktora w teście z niepoprawnymi argumentami kończyłoby się od razu rzuceniem wyjątku, czyli testem jednostkowym, który nie przeszedł.   Z pomocą w takiej sytuacji przychodzi element expected adnotacji @Test. Przykład jego użycia widzisz poniżej:   @Test(expected = IllegalArgumentException.class) public void shouldThrownIllegalArgumentExceptionOnWrongParameters() {     new Range(20, 10); }   Taki test jednostkowy nie przejdzie jeśli wyjątek nie zostanie rzucony. Mimo tego, że w teście nie ma żadnej asercji testuje on właśnie rzucenie wyjątku.   Istnieje też inny sposób. Możesz go użyć jeśli chcesz mieć dostęp do instancji rzuconego wyjątku. Pokazałem go w przykładzie poniżej:   @Test public void shouldHaveProperErrorMessage() {     try {         new Range(20, 10);         fail(\"Exception wasn't thrown!\");     }     catch (IllegalArgumentException exception) {         assertEquals(\"lowerBound is bigger than upperBound!\", exception.getMessage());     } }   Użyta tu statyczna metoda Assert.fail() powoduje zakończenie testu niepowodzeniem. Zostanie ona wywołana wyłącznie jeśli wyjątek nie zostanie rzucony.   Przygotowanie testów i cykl życia testów   Czasami zdarza się, że kilka testów jednostkowych wymaga pewnego „przygotowania”. Na przykład trzeba utworzyć instancję, którą będziemy później testowali. Twórcy biblioteki JUnit przyszli nam z pomocą. Istnieje adnotacja @Before, którą możemy dodać do metody w klasie z testami. Metoda ta zostanie uruchomiona przed każdym testem jednostkowym. Proszę spójrz na przykład poniżej.   public class RangeTest {     private Range range;       @Before     public void setUp() {         range = new Range(10, 20);     }       @Test     public void shouldSayThat15rIsInRange() {         assertTrue(range.isInRange(15));     }       @Test     public void shouldSayThat5IsntInRange() {         assertFalse(range.isInRange(5));     } }   W naszym przykładzie metoda setUp zostanie wywołana przed uruchomieniem każdego z testów. Dzięki temu nie musimy tworzyć instancji wewnątrz testu. Odpowiednie użycie tej adnotacji pomaga pisać krótsze testy jednostkowe.   Cykl życia klasy z testami jednostkowymi   Adnotacja @Before jest jedną z czterech adnotacji, które pozwalają na wykonanie fragmentów kodu przed/po testach. Pozostałe trzy to:     @After – metoda z tą adnotacją uruchamiana po każdym teście jednostkowym, pozwala na „posprzątanie” po teście,   @AfterClass – metoda statyczna z tą adnotacją uruchamiana jest raz po uruchomieniu wszystkich testów z danej klasy,   @BeforeClass – metoda statyczna z tą adnotacją uruchamiana jest raz przed uruchomieniem pierwszego testu z danej klasy.   Proszę spójrz na przykład poniżej:   public class TestLifecycle {     @Before     public void setUp() {         System.out.println(\"set up\");         System.out.flush();     }       @After     public void tearDown() {         System.out.println(\"tear down\");         System.out.flush();     }       @BeforeClass     public static void setUpClass() {         System.out.println(\"set up class\");         System.out.flush();     }       @AfterClass     public static void tearDownClass() {         System.out.println(\"tear down class\");         System.out.flush();     }       @Test     public void test1() {         System.out.println(\"test 1\");         System.out.flush();     }       @Test     public void test2() {         System.out.println(\"test 2\");         System.out.flush();     } }   Jeśli uruchomisz tę klasę na konsoli pojawi się:   set up class set up test 1 tear down set up test 2 tear down tear down class   Testy jednostkowe a testy automatyczne   Testy jednostkowe bardzo często są testami automatycznymi. Test automatyczny to taki, który możemy wykonywać automatycznie :) Zaletą takiego podejścia jest to, że w momencie zmiany kodu możemy raz napisany test uruchomić ponownie wiedząc od razu czy napisany wcześniej fragment działa poprawnie czy nie. Pomagają przy tym wcześniej omówione asercje.   Bardzo często testy jednostkowe uruchamiane są automatycznie podczas pracy nad projektem. Służą do tego osobne środowiska, w których testy te są uruchamiane.   Istnieją także mechanizmy, które w trakcie pracy programisty wykrywają zmiany w części klas i automatycznie uruchamiają dla tych klas testy jednostkowe informując programistę o wynikach. Dzięki temu bardzo szybko jesteśmy w stanie dowiedzieć się czy zmiany, które wprowadziliśmy nie popsuły wcześniejszej funkcjonalności.   Dobre praktyki przy pisaniu testów   Poniżej postaram się zebrać dla Ciebie kilka dobrych praktyk, do których warto się stosować w czasie pisania testów:     Po pierwsze, pisz testy jednostkowe. Koniecznie. Zawsze.   Staraj się pisać testy jednostkowe, które są małe i dotyczą małego wycinka funkcjonalności. Później o wiele łatwiej jest zrozumieć taki test.   Nadawaj metodom z testem nazwy, które pomagają zrozumieć co dany test powinien sprawdzić.   Kolejność testów jednostkowych w klasie nie powinna mieć znaczenia. Innymi słowy nie możemy polegać na tym, że jako pierwszy musi się uruchomić test1 a po nim test2. Testy uruchomione w odwrotnej kolejności także powinny mieć dokładnie taki sam efekt.   Pisz testy jednostkowe tak, żeby nie zależały od Twojej lokalnej konfiguracji. Na przykład test jednostkowy czytający plik z Twojego dysku z katalogu C:\\mój\\katalog\\domowy (czy /home/uzytkownik) nie jest dobrym rozwiązaniem.   Pisz testy jednostkowe niezależne od zewnętrznych systemów. Innymi słowy testuj tylko „jednostkę”, nic ponadto. Jeśli klasa, którą testujesz potrzebuje dostępu np. do bazy danych użyj mocka czy stuba do jej zastąpienia w trakcie testów3 .   Testuj warunki brzegowe i sytuacje wyjątkowe. Załóżmy, że masz metodę, która przyjmuje tablicę, która musi mieć maksymalnie trzy elementy. Napisz kilka testów:            przekazując null zamiast tablicy,       przekazując pustą tablicę,       przekazując tablicę z trzema elementami,       przekazując tablicę z czterema elementami.           Dzięki takim testom będziesz pewien, jak zachowuje się Twoja metoda w sytuacjach wyjątkowych.     Testowany kod nie powinien być w tym samym miejscu, w którym są testy. Sprowadza się to do tego, że kod umieszczamy w katalogu np. src, testy natomiast w katalogu test. Oba katalogi pod spodem mają odpowiednią strukturę odzwierciedlającą pakiety. Jest to ważne ponieważ później przy większych projektach testy nie „mieszają się” z kodem programu.   Staraj się pisać testy, które są szybkie. Przy pierwszych programach nie jest to problemem, jednak przy większych projektach uruchamianie testów może być czasochłonne.   Uruchamiaj testy jednostkowe możliwie często. Uwierz mi, to Ci się opłaci :). Punkt ten jest powiązany z punktem poprzednim – nie będziesz uruchamiał często testów, które trwają długo.   Jeśli zauważysz, że część testów jednostkowych wymaga dokładnie takiego samego „przygotowania” wydziel je do osobnej klasy i użyj metod z adnotacją @Before lub @BeforeClass.   Testy jednostkowe w IntelliJ Idea   Zacznijmy od utworzenia testu jednostkowego dla istniejącej klasy. Z pomocą przychodzi skrót klawiaturowy &lt;Ctrl + Shift + T&gt; – naciśnij tę kombinację na nazwie klasy dla której chcesz utworzyć test. Pokaże się wówczas dialog pomagający utworzyć nową klasę testu.             Tworzenie nowego testu.        IntelliJ jest na tyle mądry, że wykrywa brak biblioteki JUnit w projekcie. W oknie dialogowym widać wówczas przycisk „Fix it”, który automatycznie dodaję tę bibliotekę.             Tworzenie nowego testu.        Kolejnym skrótem klawiaturowym, który może się przydać podczas pisania testów jednostkowych jest &lt;Alt + Insert&gt;, naciśnięcie tego skrótu wewnątrz klasy grupującej testy pozwala nam w łatwy sposób stworzyć kolejny test.             Generowanie kodu w testach.        W końcu kombinacja &lt;Ctrl + Shift + F10&gt; pozwala na uruchomienie testów jednostkowych wewnątrz IDE. W zależności od tego na czym znajduje się nasz kursor myszy, ten skrót klawiaturowy może uruchomić pojedynczą metodę z testem, klasę grupującą testy czy pakiet z kilkoma klasami testowymi.             Testy bez błędów.        Zadanie do rozwiązania   Wykonanie zadania wymaga podstawowej znajomości kolekcji. Jeśli do tej pory nie udało Ci się pracować z kolekcjami zachęcam do przeczytania poświęconego im artykułu.   Napisz program, który będzie reprezentował koszyk w sklepie internetowym. Do koszyka reprezentowanego przez klasę Basket możemy dodawać bądź usuwać kolejne przedmioty. Każdy przedmiot powinien mieć nazwę i cenę jednostkową. Koszyk powinien także pozwalać na dodanie/usunięcie od razu kilku egzemplarzy przedmiotu ze sklepu. Koszyk powinien także być w stanie policzyć sumaryczną wartość zamówienia oraz wyświetlić swoją zawartość. Pamiętaj o poprawnym obsłużeniu sytuacji wyjątkowych np. usunięcie elementów z pustego koszyka czy dodaniu ujemnej liczby przedmiotów.   Napisz zestaw testów jednostkowych potwierdzających poprawne działanie Twojego koszyka z zakupami.   Drobna podpowiedź z przykładowym zestawem klas, które mogą rozwiązać ten problem:      Item, która posiada dwa atrybuty double price4 oraz String name,   Basket, który posiada atrybut Map orderedItems reprezentujący zamówione towary wraz z ich ilością.   Przygotowałem też przykładowe rozwiązanie, znajduje się w repozytorium na githubie wraz z zestawem testów jednostkowych. Zachęcam jednak do samodzielnej próby rozwiązania zadania. Uwierz mi, że wtedy nauczysz się najwięcej :).   Jeśli nie udało Ci się wcześniej poznać klasy StringBuilder zachęcam Cię do rzucenia okiem na artykuł na temat String cache i klasy StringBuilder. Jej znajomość nie jest konieczna, jednak użyłem jej w moim przykładowym rozwiązaniu.   Dodatkowe materiały do nauki      Test jednostkowy na Wikipedii   Strona biblioteki JUnit   Dokumentacja biblioteki JUnit   Kod źródłowy przykładów użytych w artykule   Podsumowanie   W artykule przeczytałeś o testach jednostkowych. Poznałeś zestaw dobrych praktyk dotyczących pisania testów, nauczyłeś się podstaw biblioteki JUnit. Wiesz czym jest test automatyczny i dlaczego takie testy są istotne. Całość przećwiczyłeś w sposób praktyczny rozwiązując zadanie końcowe.   Na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największej liczby czytelników – proszę podziel się linkiem do artykułu ze znajomymi. Jeśli nie chcesz ominąć kolejnych artykułów możesz polubić moją stronę na Facebook’u ;). Do następnego razu!                 W języku Java istnieje także słowo kluczowe assert, po którym musi wystąpić wartość logiczna, jeśli jest ona fałszem kończy się to rzuceniem wyjątku AssertionError – np. assert false rzuci wyjątek. &#8617;                  Pominę tutaj metodę assertThat, którą omówię bardziej szczegółowo w kolejnych artykułach. &#8617;                  O mockach czy stubach przeczytasz w kolejnych artykułach, jeśli jest to Twoja pierwsza styczność z testami możesz ten punkt pominąć. &#8617;                  double nie jest dobrym typem do reprezentowania cen, na potrzeby tego przykładu jednak wystarczy. Dlaczego tak się dzieje przeczytasz w osobnym artykule. &#8617;           ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "/testy-jednostkowe-z-junit/",
        "teaser": "/assets/images/2016/10/29_testy_jednostkowe_junit_artykul.jpg"
      },{
        "title": "Game of Life",
        "excerpt":"Convey’s Game of Life   Gra w życie zakłada, że mamy planszę o nieskończonych wymiarach. Plansza ta podzielona jest na pola, w podobny sposób jak kartka w kratkę. Każda kratka reprezentuje pole. Każde pole ma dokładnie 8 sąsiadów, osiem kratek wokół.   Każde z pól może być w dwóch stanach. Może być żywe bądź martwe.             Żywa komórka (1, 3)        W przykładzie powyżej widzisz wycinek planszy na którym mamy żywą komórkę o współrzędnych (1, 3). Oznaczona jest ona czarnym kwadratem.   Gra sprowadza się do przygotowania kolejnych generacji planszy na podstawie jej aktualnego stanu. Kolejna generacja powstaje na podstawie czterech zasad:      Każda żywa komórka z mniej niż dwoma żywymi sąsiadami umiera w kolejnej generacji z powodu wyludnienia,   każda żywa komórka z dwoma lub trzema żywymi sąsiadami jest w stanie przetrwać do następnej generacji,   każda żywa komórka z więcej niż trzema żywymi sąsiadami umiera w kolejnej genracji z powodu przeludnienia,   każda martwa komórka z dokładnie trzema żywymi sąsiadami staje się żywa w kolejnej generacji.   Zobacz jak te zasady wyglądają na kilku przykładach.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Przykład 1.   W tym przykładzie pierwsza generacja planszy zawiera wyłącznie żywą komórkę na pozycji (1, 3). W kolejnej generacji komórka ta ginie ponieważ nie ma dwóch żywych sąsiadów.             Żywa komórka (1, 3)                  Pusta plansza        Przykład 2.   W tym przykładzie, w pierwszej generacji mamy trzy żywe komórki na pozycjach (1, 2), (2, 2) i (3, 2). W kolejnej generacji dzieje się już trochę więcej:     Komórka (1, 2) i (3, 2) giną ponieważ mają tylko jednego żywego sąsiada,   komórka (2, 2) przeżywa ponieważ ma dokładnie dwóch żywych sąsiadów,   komórki (2, 1) i (2, 3) ożywają ponieważ mają trzech żywych sąsiadów,   pozostałe komórki pozostają martwe.             Figura okresowa                  Figura okresowa        Zauważ, że kolejna generacja prowadzi do kształtu podobnego do poprzedniej. W przypadku tego kształtu i kolejnych generacji okazuje się, że zawsze jakieś żywe komórki powstaną na planszy. Kolejne generacje można pokazać przy pomocy animacji:             Figura okresowa        Kolejne przykłady   Bardziej skomplikowane kształty możesz zobaczyć na filmiku poniżej:     Zadanie do wykonania   Twoim zadaniem jest napisanie gry w życie.   Aby trochę ułatwić wizualizację, nie będziemy implementowali nieskończonej planszy. Zodyfikujemy wymagania dotyczące planszy. W naszym przypadku planszę ograniczymy do kwadratu o boku N, gdzie N będzie parametrem konstruktora planszy. Nie będzie ona nieskończona, a będzie się „zawijała”. Co to oznacza?   Na poniższym obrazku zaznaczyłem sąsiedztwo dla pola (1, 0). Jak widzisz, „zawija się” ono w taki sposób, że obejmuje także ostatni rząd planszy.             Sąsiednie pola dla (1, 0)        Podobnie ma się sytuacja dla narożników. Poniższy obrazek pokazuje sąsiedztwo dla narożnika (0, 0).             Sąsiednie pola dla (0, 0)        Napisz program, który będzie w stanie wygenerować kolejną generację planszy w „grze w życie”. Nie zapominaj o testach jednostkowych dla swojego programu.   Dla przykładu poniżej umieściłem jeden z testów z przykładowego rozwiązania.   @Test public void shouldBeAbleToProvideNextGenerationWithPeriod() {     String boardVisualisation = \"+----+\" + System.lineSeparator() +                                 \"|    |\" + System.lineSeparator() +                                 \"| o  |\" + System.lineSeparator() +                                 \"| o  |\" + System.lineSeparator() +                                 \"| o  |\" + System.lineSeparator() +                                 \"+----+\";     Board board = new Board(4, Cell.live(1, 0), Cell.live(1, 1), Cell.live(1, 2));     assertEquals(boardVisualisation, board.toString());       String expected = \"+----+\" + System.lineSeparator() +                       \"|    |\" + System.lineSeparator() +                       \"|    |\" + System.lineSeparator() +                       \"|ooo |\" + System.lineSeparator() +                       \"|    |\" + System.lineSeparator() +                       \"+----+\";     Board boardNextGeneration = board.nextGeneration();     assertEquals(expected, boardNextGeneration.toString()); }   Przygotowałem też dla Ciebie przykładowe rozwiązanie wraz z testami jednostkowymi. Możesz zajrzeć na samouczkowego githuba.   Materiały dodatkowe      Artykuł na wikipedii na temat gry w życie,   wywiad z autorem Game of Life – John H. Convey opowiada o Grze w Życie :)   Podsumowanie   Mam nadzieję, że udało Ci się napisać grę w życie. Nie jest to duży projekt jednak rozbudowany na tyle, że musisz przećwiczyć podstawowe zagadnienia programowania obiektowego. Niby prosty zestaw zasad, a jaki ciekawy efekt można uzyskać :). Jeśli chciałbyś dostawać informacje o kolejnych artykułach prosto na Twoją skrzynkę zapisz się na mojego newslettera.   Na koniec proszę Cię, żebyś podzielił się informacją o Samouczku ze swoimi znajomymi, którzy też są zainteresowani programowaniem – zależy mi na dotarciu do jak największej liczby czytelników.  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/game-of-life/",
        "teaser": "/assets/images/2016/11/06_zadanie_game_of_life_artykul.jpg"
      },{
        "title": "Test Driven Development na przykładzie",
        "excerpt":"Jeśli tematyka testów, jest dla Ciebie nowa zachęcam Cię do przeczytania poprzedniego artykułu. W artykule tym od postaw opisuję zagadnienie testów jednostkowych.   Czym jest TDD   TDD to podejście do tworzenia oprogramowania. Na taki sposób tworzenia oprogramowania uwagę zwrócił Kent Beck1. Podejście to zakłada, że przed napisaniem właściwej funkcjonalności programista zaczyna od utworzenia testu. Test ten powinien testować funkcjonalność, którą dopiero chcemy napisać.   TDD to podejście, które składa się z trzech faz. Te trzy fazy łączą się w cykl. Cały proces pisania kodu składa się z właśnie takich cykli, które powtarzasz jeden po drugim. Cykl to trzy fazy:      red,   green,   refactor.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Faza Red   Pierwszym krokiem jest napisanie testu. Test ten nie może się powieść, ponieważ sama funkcjonalność jeszcze nie jest zaimplementowana. Możliwe, że nawet po napisaniu takiego testu kod nie będzie się kompilował. Może się tak stać w przypadku, gdy napisałeś test dla metody, która jeszcze nie istnieje.   Sytuacja, w której testy jednostkowe nie przechodzą bardzo często w IDE oznaczana jest kolorem czerwonym.   Faza Green   Kolejnym krokiem jest napisanie kodu, który implementuje brakującą funkcjonalność. W tym momencie istotne jest to aby ten kod nie był „idealny”. Chodzi o możliwe jak najszybszą implementację, która spełnia założenia testu, który był napisany w poprzedniej fazie.   Następnie potwierdzamy to, że nasza implementacja działa jak powinna uruchamiając testy jednostkowe. Jeśli wszystko jest w porządku całość powinna zakończyć się testami jednostkowymi, które przechodzą. IDE sygnalizuje taką sytuację zielonym kolorem. Ważne jest aby w tej fazie uruchamiać wszystkie dotychczas napisane testy jednostkowe.   Faza Refactor   Refaktoryzacja (ang. refactor) to proces, w którym zmieniamy kod w taki sposób, że nie zostaje zmieniona jego funkcjonalność. Mówi się o „oczyszczaniu” kodu, doprowadzaniu go do lepszego stanu. Przykładem refaktoryzacji może być wydzielenie oddzielnej metody, która usuwa powielony kod czy stworzenie zupełnie nowej klasy odpowiedzialnej za pewną część zadań danej klasy.   Jest to ostatnia z trzech faz cyklu TDD. Faza refaktoryzacji jest bardzo istotna. Nawet doświadczeni programiści bardzo często pomijają tę fazę. Jej brak może w dłuższej perspektywie prowadzić do kodu programu, który jest trudny w utrzymaniu. Praca z takim kodem może być wówczas dużo cięższa, proste zmiany mogą zajmować bardzo dużo czasu.   Dzięki testom, które napisałeś w fazie Red czy wcześniejszych cyklach TDD, możesz czuć się swobodnie zmieniając istniejący kod. Z większą pewnością możesz zmieniać kod, po każdej zmianie uruchamiając istniejące testy jednostkowe. Takie podejście pozwala Ci bardzo szybko wychwycić potencjalne błędy, które mógłbyś wprowadzić refaktoryzując kod.   Może się zdarzyć, że faza refaktoryzacji nie zawsze jest konieczna. Usprawnianie dobrego kodu na siłę nie koniecznie może prowadzić do dobrych rezultatów.   Rady praktyczne   Jedną z pierwszych wątpliwości, które mi się nasunęły gdy uczyłem się tego podejścia było – jak „długie” powinny być takie cykle? Jak duży fragment kodu powinienem testować pojedynczym testem?   Na początku byłem zagorzałym fanem wyznawania możliwie jak najkrótszych cykli, wielkiej liczby testów, które testują bardzo mały wycinek kodu (w sumie takie jest jedno z założeń TDD). Takie podejście jest dobre, ma jednak swoje wady. Wymaga od programisty napisania bardzo dużej liczby testów jednostkowych. Dużej liczby cykli red-green-refactor. Nie jest to złe, wręcz przeciwnie. Jednak uważam, że nie możemy popadać w skrajności.   Moim zdaniem cykle powinny być na tyle długie, że Ty jako programista czujesz się swobodnie. Czujesz, że masz kontrolę nad tym co się dzieje. Ogarniasz to co trzeba napisać aby ten test przeszedł. I na końcu ale – powinny być na tyle długie, że programista czuje, że kontroluje całość ale ani trochę dłuższe ;). Innymi słowy, moim zdaniem wraz z doświadczeniem przychodzi swego rodzaju wyczucie jak “duży” powinien być cykl.   Nie możesz zapominać o uruchamianiu wszystkich testów jednostkowych podczas fazy refaktoryzacji. Może się zdarzyć tak, że drobna zmiana może powodować błędy w innej części programu. Uruchamianie wszystkich testów pomaga wykryć taką sytuację.   Pamiętaj też o dobrych praktykach podczas pisania testów, opisałem je w artykule poświęconym tematyce testów jednostkowych. Przy TDD praktyki te jak najbardziej obowiązują.   Jeśli używasz repozytorium kodu, to udostępniaj w nim kod, który jest poprawny. Innymi słowy udostępniaj kod, który jest zakończeniem pełnego cyklu. Kod się kompiluje i wszystkie testy przechodzą. Sytuacja, w której zmieniasz kod innego programisty, który się nie kompiluje lub nie przechodzą w nim testy potrafi być dość frustrująca. Lepiej jest unikać takich sytuacji ;).   W moim przypadku bardzo dobrze sprawdza się praktyka, w której na koniec dnia zostawiam test jednostkowy, który nie przechodzi (nie udostępniając go w repozytorium kodu). Następnego dnia rano dokładnie wiem od czego mam zacząć. Takie podejście pomaga mi w następnym dniu pracy od razu skupić się na funkcjonalności, którą zaplanowałem dzień wcześniej.   Pamiętaj o tym, że faza refaktoringu dotyczy także testów. Czasami testy także można oczyścić wprowadzając odpowiednie metody, czy stałe statyczne. Także tutaj trzeba unikać duplikacji. Może część testów jest niepotrzebna, bo to samo jest testowane w innym miejscu? Jeśli tak, śmiało można usunąć jeden z takich testów.   Skróty klawiaturowe   Zachęcam do przejrzenia skrótów, które opisałem w poprzednim artykule. Tutaj dodam jeszcze Ctrl+F5. Skrót ten uruchamia dokładnie to samo, co poprzednie uruchomienie. Innymi słowy jeśli poprzednio uruchomiłeś testy w pakiecie Ctrl+F5 uruchomi je ponownie. Jeśli uruchomiłeś tylko pojedynczy test jednostkowy skrót ten uruchomi go jeszcze raz.   Jest on bardzo pomocny przy fazie refaktoryzacji. Będąc wewnątrz klasy, którą refaktoryzujesz możesz używać tego skrótu po każdej, najmniejszej zmianie, IDE uruchomi poprzedni zestaw testów automatycznie.   Dodatkowe materiały do nauki   Bez najmniejszego wahania mogę polecić książkę autorstwa Kent’a Beck’a, Test Driven Development by Example2. W książce tej autor na podstawie problemu do rozwiązania pokazuje krok po kroku jak wygląda technika TDD. Chociaż książka nie jest zbyt obszerna, zawiera także sporo informacji związanych z tematyką testów jednostkowych.   Co prawda, nie jest to książka najnowsza, jednak moim zdaniem jak najbardziej warta przeczytania. Mogę powiedzieć, że sam uczyłem się TDD z tej książki :).   Zadanie   Na koniec czeka na Ciebie zadanie praktyczne. Przećwiczysz w nim TDD na przykładzie. Po tym zadaniu będziesz mógł śmiało powiedzieć, że napisałeś program używając TDD :).   Zacznijmy od wymagań, które nasz program ma spełniać. Ma to być program, który przechowuje oceny jednego ucznia. Poniższe punkty opisują wymagania:      Jako nauczyciel chcę dodawać przedmioty do dzienniczka,   jako nauczyciel chcę dodać ocenę dla jednego z przedmiotów,   jako nauczyciel chcę policzyć średnią ocen dla danego przedmiotu,   jako nauczyciel chcę policzyć średnią ocen z wszystkich przedmiotów.   Pisząc ten program użyję dwóch klas GradeBook reprezentującej dzienniczek oraz klasy Subject, która będzie opisywała przedmiot.   Te wymagania podzielę na kilka etapów. Staraj się postępować zgodnie z nimi. W każdym z tych etapów możesz mieć kilka cykli, w których dodawał będziesz kolejne testy jednostkowe:      Utworzenie dzienniczka,   utworzenie przedmiotu,   dodanie przedmiotu do dzienniczka,   pobranie przedmiotu z dzienniczka,   dodanie oceny do przedmiotu,   obliczenie średniej dla przedmiotu,   obliczenie średniej dla dzienniczka.   Przygotowałem też dla Ciebie przykładowe rozwiązanie. Proszę jednak żebyś przed sprawdzeniem rozwiązania przeszedł przez wszystkie kroki samodzielnie. Tak nauczysz się dużo więcej. W rozwiązaniu tym starałem się oddzielać każdy krok tak żeby wszystkie cykle wraz z etapami były widoczne. W prawdziwym projekcie oczywiście nie umieszczaj w repozytorium kodu, który się nie kompiluje ;).   Przykładowe rozwiązanie nie sprawdza niektórych przypadków brzegowych. Czy Twoja wersja poprawnie zareaguje na przykład na liczenie średniej z pustego dziennika?   Podsumowanie   Wiesz czym jest TDD. Jesteś praktykiem TDD, rozwiązałeś zadanie przy użyciu tego sposobu pisania kodu. Wiesz jakie są cykle TDD (i wiesz, że nie wolno zapominać o refaktoryzacji). Skróty klawiaturowe pomagające w pisaniu testów masz w jednym paluszku ;).   Dodam po raz kolejny. Testowanie kodu jest bardzo istotnie, nie zapominaj o nim.   Na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największej liczby czytelników – proszę podziel się linkiem do artykułu ze znajomymi, może ktoś z nich chce poznać TDD od praktycznej strony?. Jeśli nie chcesz ominąć kolejnych artykułów możesz polubić moją stronę na Facebook’u i zapisać się do mojego newslettera ;). Do następnego razu!                 W artykule, w którym wymieniam książki dla programistów jest też pozycja napisana przez tego autora. &#8617;                  To jest link afiliacyjny. Oznacza to tyle, że jeśli kupisz ten produkt pomożesz mi w dalszym prowadzeniu bloga. Nie jest to związane z żadnymi dodatkowymi kosztami dla Ciebie. Dziękuję! :) &#8617;           ","categories": ["Kurs programowania Java","Strefa zadaniowa"],
        "tags": [],
        "url": "/test-driven-development-na-przykladzie/",
        "teaser": "/assets/images/2016/11/21_test_driven_development_artykul.jpg"
      },{
        "title": "Wyrażenia regularne w języku Java",
        "excerpt":"     To jest wprowadzający artykuł na temat wyrażeń regularnych. Część bardziej zaawansowanych zagadnień związanych z wyrażeniami regularnymi opisana jest w drugiej części:      zachłanność wyrażeń regularnych,   alternatywa,   grupy nieprzechwytujące,   grupy nazwane,   ponowne użycie grup,   kotwice.   Zachęcam do przeczytania drugiej części jeśli chciałbyś dowiedzieć się czegoś więcej o punktach wspomnianych powyżej.     Czym są wyrażenia regularne   Słowo wstępu zanim przejdziemy do teorii. W kilku poniższych akapitach pokażę kilka wyrażeń regularnych bez dokładnego ich omawiania. Posłużą one jako przykłady zastosowania wyrażeń. Proszę nie zrażaj się widząc kilka dziwnych znaczków, później dokładnie je opiszę :).   Wyrażenie regularne (ang. regular expression) to „wzorzec”, który opisuje grupę łańcuchów znaków. Możemy powiedzieć, że łańcuch znaków pasuje do wzorca jeśli dane wyrażenie regularne go opisuje. Na przykład wyrażenie regularne \\d{2}-\\d{3} opisuje zbiór kodów pocztowych w Polsce. Wyrażenia regularne składają się ze znaków, część z nich w pewnych kontekstach ma specjalne znaczenie. Znaczenie to interpretowane jest przez tak zwany silnik wyrażeń regularnych.   Istnieje wiele silników wyrażeń regularnych, w związku z tym istnieją też pewne różnice pomiędzy wyrażeniami regularnymi rozumianymi przez te silniki. Mówimy wówczas o dialekcie języka wyrażeń regularnych. Dialekty mogą różnić się między sobą pewnymi niuansami, jednak mają wspólną bazę, zrozumiałą dla pozostałych silników wyrażeń regularnych.   Wyrażenia regularne są mechanizmem uniwersalnym, dostępne są w wielu językach programowania. Ucząc się ich raz, poznajesz język wyrażeń regularnych dostępny także w innych językach programowania. Siłą rzeczy skupię się tutaj na dialekcie wyrażeń regularnych w języku Java.   Wyrażenie regularne to tak zwany wzorzec, który następne jest kompilowany przez silnik wyrażeń regularnych do wewnętrznej postaci. Po tym etapie używana jest „wewnętrzna reprezentacja” wyrażenia regularnego. Jeśli spróbujesz skompilować wzorzec, który nie jest poprawny zostaniesz o tym poinformowany odpowiednim wyjątkiem w trakcie działania programu.   Sam etap kompilacji wyrażenia jest procesem relatywnie długim1. Z tego właśnie powodu zaleca się kompilowanie wyrażeń przed ich pierwszym użyciem. Podobnie sprawa ma się jeśli chodzi o tworzenie nowych instancji klasy wzorca. Im ich mniej tym lepiej. Ma to szczególne znaczenie w sytuacji w której używamy wyrażenia wielokrotnie2.   W wyrażeniach regularnych poza „dziwnymi znaczkami” używa się także zwyczajnych liter. Domyślnie w wyrażeniach regularnych wielkość liter ma znaczenie. Wyrażenie regularne Kawa to nie to samo co kawa.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Kiedy używamy wyrażeń regularnych   No właśnie, do czego używamy wyrażeń regularnych? Ogólnie można powiedzieć, że wyrażeń regularnych używamy do pracy z łańcuchami znaków. Wyszukiwanie, dzielenie, czy modyfikacja łańcuchów znaków, to wszystko można zrobić przy pomocy wyrażeń regularnych.   W praktyce jednym z głównych zastosowań jest weryfikacja czy dany łańcuch znaków pasuje do wzorca. Wzorcem tym jest wyrażenie regularne.   To czy łańcuch znaków pasuje do wzorca wykorzystywane jest w trakcie walidacji danych wejściowych. Dzięki wyrażeniom regularnym możemy sprawdzić, czy dane pochodzące od użytkownika mają poprawny format. Na przykład następujące wyrażenie regularne pozwala sprawdzić czy użytkownik podał poprawne imię [A-Z][a-z]+, czy rzeczywiście adres e-mail może być poprawny .+@.+\\.pl3, czy format daty, który prowadził użytkownik jest w porządku \\d{4}-\\d{2}-\\d{2}.   Ponadto, wyrażeń regularnych możemy używać do „parsowania” łańcuchów znaków. Jeśli mamy większy łańcuch, z którego chcemy wyciągnąć jakąś część wyrażenia regularne mogą nam w tym pomóc. Na przykład jeśli w telefonie zapisujemy znajomych jako “imię (pseudonim) nazwisko”, wyrażenie regularne \\w+ \\((\\w+)\\) \\w+ pomoże nam wyciągnąć pseudonim.   Wyrażenia regularne w języku Java   W języku Java wyrażenia regularne obsługiwane są przez dwie klasy z biblioteki standardowej. Są to Pattern i Matcher. Spójrz na przykład poniżej:   Pattern compiledPattern = Pattern.compile(\"Marcin\"); Matcher matcher = compiledPattern.matcher(\"Nazywam sie Marcin Pietraszek\");  System.out.println(matcher.find()); System.out.println(matcher.matches());   W przykładzie tym w pierwszej linijce kompiluję wyrażenie regularne Marcin uzyskując instancję klasy Pattern. W kolejnej linijce wywołując metodę matcher otrzymuję instancję klasy Matcher. Parametr przekazany w metodzie matcher to łańcuch znaków, na którym używamy wyrażenia regularnego.   Klasa Matcher posiada, między innymi, następujące metody:      find() – metoda zwraca true jeśli w łańcuchu znaków znajduje się coś co pasuje do wyrażenia regularnego,   matches() – metoda zwraca true jeśli łańcuch znaków pasuje w całości do wyrażenia regularnego.   Proszę spójrz na poniższą tabelkę. W nagłówkach kolumn umieściłem łańcuchy znaków, które dopasowywane są do wyrażeń umieszczonych w pierwszej kolumnie.                          Mam na imię Marcin       Marcinkowski       Marcin                       Marcin       find – true matches – false       find – true matches – false       find – true matches – true                 Marcinkowski       find – false matches – false       find – true matches – true       find – false matches – false           Jak widzisz wyrażenia regularne mogą wyglądać jak „normalne” łańcuchy znaków. Jednak takie raczej nie są ciekawe i zbytnio użyteczne. Prawdziwa siła wyrażeń regularnych tkwi w tych wszystkich magicznych znaczkach :). Postaram się je teraz omówić.   Składnia wyrażeń regularnych   Wszystkie przykłady kodu to poprawne testy jednostkowe (więcej o testach przeczytasz w osobnym artykule). Zachęcam do ich skopiowania do IDE i samodzielnego kombinowania :).   Jak już widziałeś w poprzednim przykładzie wyrażenia regularne mogą zawierać zwykłe literały znakowe, na przykład kot czy pies to poprawne wyrażenie regularne. Jednak są znaki, które interpretowane są w specjalny sposób. Wyrażenie takie jak 1 + 2 = 3 zawiera jeden ze znaków specjalnych – znak +. W związku z tym, jeśli znak + chcemy interpretować dosłownie musimy poprzedzić go znakiem \\, wówczas pomijamy jego specjalne znaczenie. W takim przypadku otrzymasz wyrażenie regularne 1 \\+ 2 = 3.   Wyrażenia regularne a typ String   Jednak to nie koniec „kłopotów”. W języku Java wyrażenia regularne zapisujemy używając typu String. Znak \\ jest w literałach znakowych traktowany specjalnie (podobnie jak w samych wyrażeniach regularnych). Na przykład literał znakowy \"\\t\" oznacza znak tabulacji, więc przy zapisie \"1 \\+ 2 = 3\" kompilator Javy doszukiwałby się specjalnego znaczenia dla \"\\+\" (podobnie jak przy \"\\t\") a nie o to nam tutaj chodzi. Dlatego właśnie w języku Java w wyrażeniach regularnych musimy „dublować” każdy ukośnik.   Biorąc pod uwagę powyższe wytłumaczenie nasze wyrażenie regularne, w którym chcemy uciec od specjalnego znaczenia + musimy zapisać jako \"1 \\\\+ 2 = 3.   Mi łatwiej jest to zrozumieć jeśli pomyślę o tym co dzieje się pod spodem:      pierwszy etap interpretacji literału znakowego (\"1 \\\\+ 2 = 3\") to etap w którym kompilator tworzy reprezentację łańcucha znaków zapisanego w definicji klasy, w trakcie tego etapu ukośniki interpretowane są przez kompilator,   kolejny etap to etap interpretacji łańcucha znaków z definicji klasy (1 \\+ 2 = 3) przez silnik wyrażeń regularnych. W tym etapie silnik wyrażeń regularnych interpretuje łańcuch znaków, który zapisał kompilator.   W naszym przykładzie kompilator interpretując literał znakowy \"1 \\\\+ 2 = 3\" w pliku class zawierającym skompilowaną klasę zapisze 1 \\+ 2 = 3. Taka postać zostanie zinterpretowana przez silnik wyrażeń regularnych, który zobaczy, że ma pominąć specjalne znaczenie symbolu +.   Pójdźmy o krok dalej. Ten przykład jest już zakręcony więc trzymaj się mocno ;). Co jeśli chcemy sprawdzić numer mieszkania. Załóżmy, że numer mieszkania to kilka cyfr oddzielonych ukośnikiem od kolejnej grupy cyfr. Przykładowy numer pasujący do tego opisu może wyglądać tak 123\\5.   Jak już wiesz + dla silnika wyrażeń regularnych jest jednym z symboli specjalnych więc jego użycie trzeba poprzedzać \\. W związku z tym sam symbol \\ także jest traktowany w specjalny sposób więc i tu jego dosłowne użycie musi być poprzedzone \\. Więc w tym przypadku nasze wyrażenie regularne wygląda następująco 123\\\\5.   A jak takie wyrażenie zapisać jako literał znakowy? Tak, trzeba zdublować każdy ukośnik, więc wychodzi nam taki potworek \"123\\\\\\\\5\".   W dalszej części artykułu jeśli otoczę wyrażenie regularne \"\" wówczas będzie to poprawny literał (instancja String, z powtórzonymi ukośnikami). Jeśli nie będzie tych znaków, będzie to poprawne wyrażenie regularne (bez powtórzonych ukośników).   Obsługa powtórzeń   W wyrażeniach regularnych istnieje kilka mechanizmów, które pozwalają nam na obsługę powtórzeń, poniżej opiszę wszystkie z nich.   Znak ?   Znak ? oznacza – element znajdujący się wcześniej jest opcjonalny. Innymi słowy to co występuje przed ? może wystąpić raz lub może zostać pominięte. Na przykład do wyrażenia regularnego kr?at pasują zarówno \"krat\" jak i \"kat\" ale nie pasuje \"kot\" czy \"krrat\".   @Test public void testSymbolQuestionMark() {     Pattern pattern = Pattern.compile(\"kr?at\");     assertTrue(pattern.matcher(\"krat\").matches());     assertTrue(pattern.matcher(\"kat\").matches());     assertFalse(pattern.matcher(\"krrat\").matches());     assertFalse(pattern.matcher(\"kot\").matches()); }   Znak *   Znak * oznacza – powtórz dowolną liczbę razy element znajdujący się wcześniej. Dowolna liczba to powtórzenie 0 lub więcej razy. Na przykład wyrażenie regularne uwa*ga jest w stanie dopasować następujące łańcuchy znaków \"uwga\", \"uwaga\", \"uwaaaaaaga\" ale nie pasuje do \"uwagaaa\".   @Test public void testSymbolAsterix() {     Pattern pattern = Pattern.compile(\"uwa*ga\");     assertTrue(pattern.matcher(\"uwga\").matches());     assertTrue(pattern.matcher(\"uwaga\").matches());     assertTrue(pattern.matcher(\"uwaaaaaaga\").matches());     assertFalse(pattern.matcher(\"uwagaaaa\").matches()); }   Znak +   Znak + jest podobny do *. Oznacza on, że występujący przed nim element musi być powtórzony 1 lub więcej razy. Na przykład wyrażenie regularne trampo+lina może dopasować następujące łańcuchy znaków: \"trampolina\", \"trampooolina\" ale nie pasuje do \"tramplina\".   @Test public void testSymbolPlus() {     Pattern pattern = Pattern.compile(\"trampo+lina\");     assertTrue(pattern.matcher(\"trampolina\").matches());     assertTrue(pattern.matcher(\"trampoooolina\").matches());     assertFalse(pattern.matcher(\"tramplina\").matches()); }   Powtórzenia inaczej   Poza znakami ?, + i *, które określają dopuszczalną liczbę powtórzeń możesz też użyć {}. Jednak {} ma większe możliwości:     {x} – oznacza że element poprzedzający musi wystąpić dokładnie x razy,   {x,} – oznacza, że element poprzedzający musi wystąpić co najmniej x razy,   {x,y} – oznacza, że element poprzedzający musi wystąpić od x do y razy.   Zauważ, że symbole ?, * i + możemy zastąpić {}. Na przykład wyrażenia regularne al*a i al{0,}a czy al+a i al{1,}a są sobie równoznaczne. Jednak zapis z ?, + czy * jest krótszy przez co częściej stosowany.   Znak .   Znak oznacza dowolny symbol (poza znakiem nowej linii). Innymi słowy do wyrażenia regularnego ko.ek pasują zarówno \"kotek\" jak i \"korek\" ale nie pasuje \"koek\" czy \"ktek\".   @Test public void testSymbolDot() {     Pattern pattern = Pattern.compile(\"ko.ek\");     assertTrue(pattern.matcher(\"kotek\").matches());     assertTrue(pattern.matcher(\"korek\").matches());     assertFalse(pattern.matcher(\"koek\").matches());     assertFalse(pattern.matcher(\"ktek\").matches()); }   Zauważ, że wszystkie dotychczas omówione znaki możemy ze sobą połączyć uzyskując bardziej zaawansowane wyrażenie regularne. Na przykład k+a.*ta. Rozłóżmy to wyrażenie regularne na czynniki pierwsze:     k+ – oznacza literę k powtórzoną co najmniej raz,   a – litera a,   .* – oznacza dowolny znak (poza znakiem nowej linii) powtórzony 0 lub więcej razy,   ta – litery ta.   Do takiego wyrażenia regularnego pasują następujące łańcuchy znaków \"kata\", \"katapulta\", \"karta\", \"kasia ma kota\" czy \"kkkka#$*&amp;JHDFStatata ale nie pasuje \"ata\" czy \"kta\".   @Test public void testSymbolDotWithOthers() {     Pattern pattern = Pattern.compile(\"k+a.*ta\");     assertTrue(pattern.matcher(\"katapulta\").matches());     assertTrue(pattern.matcher(\"karta\").matches());     assertTrue(pattern.matcher(\"kasia ma kota\").matches());     assertTrue(pattern.matcher(\"kkkka#$*&amp;JHDFSta\").matches());     assertFalse(pattern.matcher(\"ata\").matches());     assertFalse(pattern.matcher(\"kta\").matches()); }     Teraz już wiesz jak można odczytać wyrażenie regularne użyte na początku artykułu do którego mogą pasować poprawne adresy e-mail .+@.+\\.pl. Rozkładając je na czynniki pierwsze mamy:      .+ – dowolny symbol użyty co najmniej raz,   @ – małpka,   .+ – ponownie dowolny symbol użyty co najmniej raz,   \\. – kropka rozumiana dosłownie (nie jako specjalny znak wyrażenia regularnego),   pl – następujące po sobie litery p i l.     Klasy   W wyrażeniach regularnych też istnieją klasy, jednak nie są to klasy jak w języku Java :). W kontekście wyrażeń regularnych klasy oznaczają grupy symboli, klasy oznaczamy przy pomocy nawiasów [ i ]. Na przykład wyrażenie regularne [rtmp]aca opisuje łańcuchy znaków \"raca\", \"taca\", \"maca\" czy \"paca\" ale już nie \"praca\" czy \"pacanów\".   @Test public void testSimpleClasses() {     Pattern pattern = Pattern.compile(\"[rtmp]aca\");     assertTrue(pattern.matcher(\"raca\").matches());     assertTrue(pattern.matcher(\"taca\").matches());     assertTrue(pattern.matcher(\"maca\").matches());     assertTrue(pattern.matcher(\"paca\").matches());     assertFalse(pattern.matcher(\"praca\").matches());     assertFalse(pattern.matcher(\"pacanow\").matches()); }   Zakresy znaków   Aby ułatwić zapisywanie grup znaków klasy pozwalają na definiowanie zakresów. Można to zrobić przy pomocy -. Na przykład do wyrażenia regularnego [a-d]uma pasują łańcuchy znaków \"auma\", \"buma\", \"cuma\" czy \"duma\" ale nie pasuje \"fuma\" czy \"abuma\". W podobnym sposób możemy podawać zakresy cyfr. Do wyrażenia regularnego [0-7]xyz pasują łańcuchy znaków \"0xyz\", \"1xyz\" czy \"7xyz\" ale nie pasuje \"8xyz\" czy \"07xyz\".   @Test public void testClassWithRangeNumber() {     Pattern pattern = Pattern.compile(\"[0-7]xyz\");     assertTrue(pattern.matcher(\"0xyz\").matches());     assertTrue(pattern.matcher(\"1xyz\").matches());     assertTrue(pattern.matcher(\"7xyz\").matches());     assertFalse(pattern.matcher(\"8xyz\").matches());     assertFalse(pattern.matcher(\"07xyz\").matches()); }   Jak widzisz znak - wewnątrz klasy ma specjalne znaczenie, jeśli chcesz aby był interpretowany dosłownie umieść go jako ostatni w klasie [abc-].   Zakresy w klasie znaków można ze sobą łączyć. Na przykład do wyrażenia regularnego [a-cA-C0-3]bum pasują łańcucy znaków \"abum\", \"Bbum\" czy \"0bum\" ale nie pasują już \"dbum\" czy \"aA0bum\".   @Test public void testClassWithMultipleRanges() {     Pattern pattern = Pattern.compile(\"[a-cA-C0-3]bum\");     assertTrue(pattern.matcher(\"abum\").matches());     assertTrue(pattern.matcher(\"Bbum\").matches());     assertTrue(pattern.matcher(\"0bum\").matches());     assertFalse(pattern.matcher(\"dbum\").matches());     assertFalse(pattern.matcher(\"aA0bum\").matches()); }   Negacja klasy   A co jeśli chcę dopasować wszystkie znaki prócz x, y i z? Klasy też na to pozwalają. Służy do tego znak ^ umieszczony jako pierwszy w klasie. Na przykład do wyrażenia regularnego [^xyz]awa pasują słowa \"kawa\", \"pawa\" czy \"Wawa\" ale nie pasują \"zawa\" czy \"yawa\".   @Test public void testClassNegation() {     Pattern pattern = Pattern.compile(\"[^xyz]awa\");     assertTrue(pattern.matcher(\"kawa\").matches());     assertTrue(pattern.matcher(\"pawa\").matches());     assertTrue(pattern.matcher(\"Wawa\").matches());     assertFalse(pattern.matcher(\"zawa\").matches());     assertFalse(pattern.matcher(\"yawa\").matches()); }   Jeśli chcesz aby ^ był rozumiany dosłownie wewnątrz klasy nie umieszczaj go na pierwszy miejscu.     Teraz już wiesz jak można odczytać wyrażenie regularne użyte na początku artykułu do którego pasują imiona: [A-Z][a-z]+. Rozłóżmy je na czynniki pierwszej      [A-Z] – znak z tej klasy znaków, wielka litera,   [a-z]+ – mała litera użyta co najmniej raz.     Predefiniowane klasy znaków   Klasy poznałeś w poprzednich akapitach. Tak się składa, że mechanizm ten jest dość często wykorzystywany w wyrażeniach regularnych. Co więcej, bardzo często zdarzają się klasy, które są częściej używane od innych. Na przykład wszystkie cyfry, czy wszystkie znaki użyte w słowach.   Takie często używane klasy zostały wbudowane w wyrażenia regularne pod postacią predefiniowanych klas. Wszystkie predefiniowane klasy prezentuje lista poniżej:      \\d – jakakolwiek cyfra [0-9],   \\D – jakikolwiek znak, który nie jest cyfrą [^0-9],   \\w – znak używany w słowach [a-zA-Z0-9_] (zauważ, że mamy tu znak _),   \\W – jakikolwiek znak, który nie jest używany w słowach [^a-zA-Z0-9_],   \\s – tak zwane białe znaki czyli znak spacji czy tabulacji [ \\t\\n\\r\\f\\x0B]. Możesz je opisać jako znaki, które nie są widoczne podczas wydruku,   \\S – negacja grupy \\s czyli [^ \\t\\n\\r\\f\\x0B].   Dla przykładu do wyrażenia regularnego \\d\\w\\d pasują łańcuchy znaków \"0_0\" czy \"0X1\" ale nie pasują \"a0b\" czy \"0 0\".   @Test public void testPredefinedClases() {     Pattern pattern = Pattern.compile(\"\\\\d\\\\w\\\\d\");     assertTrue(pattern.matcher(\"0_0\").matches());     assertTrue(pattern.matcher(\"0X1\").matches());     assertFalse(pattern.matcher(\"a0b\").matches());     assertFalse(pattern.matcher(\"0 0\").matches()); }   Pamiętasz o ukośniku? Wyrażenie regularne \\d zapisane jako String w języku Java potrzebuje dodatkowego ukośnika, powstaje nam zatem \"\\\\d\".     Teraz już wiesz, jak można odczytać wyrażenie regularne użyte na początku artykułu, do którego pasują daty: \\d{4}-\\d{2}-\\d{2}:      \\d{4} – cztery cyfry oznaczające rok,   - – minus oddzielający rok od miesiąca,   \\d{2} – dwie cyfry oznaczające miesiąc,   - – minus oddzielający miesiąc od dnia,   \\d{2} – dwie cyfry oznaczające dzień.   Dasz też sobie radę z \\d{2}-\\d{3} opisującym kody pocztowe.     Grupy   Do tej pory poznałeś mechanizmy wyrażeń regularnych które pozwalają na sprawdzenie czy dany łańcuch pasuje do danego wyrażenia regularnego. Teraz przejdziemy do mechanizmu grup, który pozwala na wyłuskanie z łańcucha znaków pewnego fragmentu wewnątrz.   Weźmy za przykład zdanie \"Ala ma kota. Kot ma na imię --Zygmunt--. Kot jest czarny.\". Załóżmy, że chcielibyśmy wyciągnąć z tego zdania imię kota. Dla uproszczenia umieściłem je pomiędzy dwoma minusami. Następujące wyrażenie regularne może nam w tym pomóc: [^-]*--(\\w+)--.*. Rozłóżmy je na czynniki pierwsze:      [^-]* – Jakikolwiek znak tylko nie minus powtórzony dowolną ilość razy,   -- – dwa minusy,   ( – rozpoczęcie grupy,   \\w+ – znak użyty w słowach występujący co najmniej raz,   ) – zamknięcie grupy,   -- – dwa minusy,   .* – dowolny znak występujący 0 lub więcej razy.   W naszym przykładzie imię Zygmunt znajdujące się pomiędzy podwójnymi minusami zostanie przypisane do grupy. Grupowanie oznaczamy nawiasami (). W wyrażeniu regularnym może być kilka grup, numerowane są one zawsze od jedynki.   Jeśli dany łańcuch znaków pasuje do wyrażenia regularnego wówczas domyślnie ląduje on w grupie z numerem 0.   Obiekt klasy Matcher posiada zestaw metod, które operują na grupach. Skupimy się na dwóch z nich:      groupCount() – zwraca liczbę grup w wyrażeniu regularnym (pomijając tę domyślną z indeksem 0),   group(int groupNumber) – zwraca grupę pod konkretnym numerem.   @Test public void testBasicGroups() {     Pattern pattern = Pattern.compile(\"[^-]*--(\\\\w+)--.*\");     Matcher matcher = pattern.matcher(\"Ala ma kota. Kota ma na imie --Zygmunt--. Kot jest czarny.\");     matcher.matches();     assertEquals(\"Zygmunt\", matcher.group(1)); }   W przykładzie powyżej widzisz, kod który używa grupowania do pobrania imienia kota ze zdania.   Operatory powtórzeń można stosować do grup. Wyrażenie regularne (\\w+ ){3} pasuje do trzech słów, które mogą być oddzielone spacją.     Teraz już wiesz, jak można odczytać wyrażenie regularne użyte na początku artykułu, do odczytywania pseudonimu z książki adresowej \\w+ \\((\\w+)\\) \\w+. Rozkładając wyrażenie na czynniki pierwsze otrzymujemy:      \\w+ – cyfry, litery lub podkreślnik użyte co najmniej raz,   \\( – znak nawiasów użyty dosłownie,   (\\w+) – ponownie cyfry, litery lub podkreślnik użyte co najmniej raz ale tym razem złapane w grupę,   \\) – znak nawiasów użyty dosłownie,   \\w+ – po raz kolejny fragment pasujący tym razem do nazwiska.     IDE pomaga   IntelliJ Idea ma dość przydatną funkcję, która pomaga przy pracy z wyrażeniami regularnymi. Naciskając &lt;Alt + Enter&gt; na wyrażeniu regularnym i klikając na „Check RegExp” pokaże się okienko, w którym na żywo możesz sprawdzić działanie wyrażenia regularnego.             Check RegExp menu.                  Check RegExp dialog.        Wady wyrażeń regularnych i praktyczne wskazówki   Wyrażenia regularne to bardzo wszechstronne i skomplikowane narzędzie. Narzędzie, które ma dużo możliwości. Jednak niestety ma też swoje wady.   Używanie wyrażeń regularnych gdzie zwykła manipulacja łańcuchami znaków jest możliwa nie zawsze jest dobrym rozwiązaniem. Jeśli można to zrobić prostymi metodami używaj ich zamiast wyrażeń regularnych.   Wyrażenia regularne są wolne. Kompilacja wyrażenia i później ciężka praca silnika wyrażeń regularnych zajmuje więcej czasu niż zwykłe pobranie części łańcucha znaków na przykład od trzeciego do dziesiątego znaku włącznie.   Skomplikowane wyrażenie regularne są ciężkie w utrzymaniu i zrozumieniu. Nadziubać potworka każdy może, gorzej jest później ze zrozumieniem takiego fragmentu miesiąc czy trzy miesiące później. Jeśli to możliwe, lepiej upraszczać je maksymalnie jak się da.   Wyrażenia regularne nie zawsze są w stanie sprawdzić wszystko. Bo jak na przykład napisać wyrażenie regularne, które ze stuprocentową pewnością powie, że data jest poprawna? Podejmujesz się napisania takiego wyrażenia? :) Czy na przykład data 2015-02-29 jest poprawna? Na pierwszy rzut oka wszystko jest z nią w porządku prawda? Napisać wyrażenie regularne, które „udowodni”, że jest ona błędna jest nie lada sztuką, ja bym się chyba takiego zadania nie podjął ;).   Jeśli w Twoim wyrażeniu regularnym jest dużo * zastanów się jeszcze raz czy aby na pewno + nie będzie w tym przypadku wystarczający. Rzadko kiedy zależy nam na „zerowej liczbie znaków”.   Zadania do wykonania   Twoim dzisiejszym zadaniem będzie napisanie kilku wyrażeń regularnych, które będą potrafiły walidować przykładowe dane pochodzące od użytkownika. Napisz wyrażenie regularne, które:     Sprawdza czy liczba zmiennoprzecinkowa podana przez użytkownika ma poprawny format. Na przykład liczba 123,2341515132135 czy -10 są poprawne ale 18-12 czy 123, już nie,   sprawdza czy numer domu jest w formacie numer\\numer. Poprawnym numerem jest 123\\2A, 24B\\3 czy 12\\5, ale już numer abc\\cba nie,   sprawdza czy użytkownik wprowadził poprawną nazwę miasta. Na przykład Wrocław, Zielona Gora czy Bielsko-Biala jest ok, jednak Ptysiow123 już nie. Dla uproszczenia załóżmy, że żadna nazwa miejscowości nie zawiera polskich znaków.   Rozwiązania jak zwykle są na githubie jednak zachęcam do samodzielnej pracy. Próbując rozwiązać zadania samodzielnie nauczysz się najwięcej.   Dodatkowe materiały do nauki   Poniżej przygotowałem dla Ciebie kilka dodatkowych linków, które zawierają materiały związane z wyrażeniami regularnymi.     Rubular - narzędzie pozwalające na sprawdzenie wyrażenia regularnego. Co prawda dotyczy wyrażeń regularnych dla języka Ruby jednak w przypadku Javy też znajduje zastosowanie,   Regexr - kolejne narzędzie pomagające w testowaniu wyrażeń regularnych.   Regex101 - jak wyżej :),   http://www.regular-expressions.info - bezsprzecznie najlepszy materiał w sieci jaki znalazłem na temat wyrażeń regularnych. Zawiera szczegółowy opis zarówno tych podstawowych jak i zaawansowanych technik. Sam bardzo często korzystam z tego źródła,   artykuł na temat wyrażeń regularnych na Wikipedii,   dokumentacja dla klasy Pattern,   dokumentacja dla klasy Matcher,   tutorial dotyczący wyrażeń regularnych na stronie Oracle,   kod źródłowy przykładów użytych w artykule.   Podsumowanie   Mimo, że artykuł zawiera dość sporą ilość informacji na temat wyrażeń regularnych nie mówi o wszystkich możliwościach. Pominąłem tu celowo na przykład kwestie tak zwanego backtrackingu, zachłanności, alternatyw, nazwanych grup, ponownego użycia grup w wyrażeniu, flag, kotwic itd. Te zagadnienia opisuję w drugiej części.   Tymczasem dzięki za lekturę i na koniec mam do Ciebie prośbę. Proszę podziel się linkiem do artykułu ze swoimi znajomymi, zależy mi na dotarciu do jak największej grupy czytelników i możesz mi w tym pomóc, z góry dziękuję!                 Mówię to o długim w kontekście innych operacji takich jak dodawanie czy pobranie trzeciej litery z łańcucha znaków. &#8617;                  Co prawda w języku Java każda instancja klasy Pattern kompilowana jest dokładnie raz jednak warto zapamiętać tę regułę w przypadku innych języków programowania. &#8617;                  Oczywiście to wyrażenie regularne można “oszukać”. Nawet jeśli łańcuch znaków pasuje do wzorca nie musi być poprawnym adresem e-mail. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/wyrazenia-regularne-w-jezyku-java/",
        "teaser": "/assets/images/2016/11/28_wyrazenia_regularne_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 1",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/1   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Zadania celowo publikuję z opóźnieniem, aby rozwiązania nie miały wpływu na zabawę innych. Dodatkowo każdego dnia na stronie Advent of Code publikowane są dwa zadania. Drugie dostępne jest po rozwiązaniu pierwszego. Przykładowe rozwiązanie zawiera oba rozwiązania jednak prezentuję treść tylko pierwszego z nich.   Mam nadzieję, że uda mi się rozwiązać wszystkie zadania, chociaż kto wie. Może jak pojawią się trudniejsze problemy algorytmiczne będę potrzebował pomocy? Zobaczymy :).   Zarys historii   Sanie Świętego Mikołaja potrzebują zegara o bardzo wysokiej dokładności do wskazywania kierunku, oscylator zegara regulowany jest przez gwiazdy. Niestety, gwiazdy zostały ukradzione przez Króliczka Wielkanocnego. Aby ocalić Święta Wielki Mikołaj musi odzyskać wszystkie 50 gwiazdek do 25 grudnia.   Zbieraj gwiazdki rozwiązując zadania, każdego dnia udostępnione będą dwa zadania w kalendarzu adwentowym, drugie zadanie jest dostępne po ukończeniu pierwszego. Za rozwiązanie zadania otrzymujesz gwiazdkę. Powodzenia!   Dzień 1 zadanie 1   Wylądowałeś niedaleko Kwatery Głównej Króliczka Wielkanocnego. Niestety „niedaleko”, nie oznacza w Kwaterze Głównej. Instrukcje na Dokumentach Rekrutacyjnych Króliczka Wielkanocnego pomagające w dotarciu do Kwater rozpracowały Elfy. Zaczynają się one od miejsca zrzutu, nikt nie miał czasu rozpracować ich do końca aby uzyskać dokładny adres Kwatery.   Dokumenty mówią, że powinieneś rozpocząć swoją podróż do Kwatery w punkcie w którym wylądowałeś i zwrócić się na północ. Następnie powinieneś podążać zgodnie ze wskazówkami – skręcić w lewo (L) lub w prawo (R) o 90 stopni i iść prosto zadaną liczbę bloków kończąc na nowym skrzyżowaniu.   Nie masz czasu na podążanie za tak absurdalnymi instrukcjami na pieszo, zanim ruszysz wolisz poznać dokładne współrzędne celu. Zakładając, że możesz poruszać się wyłącznie ulicami miasta jak długa jest najkrótsza droga do celu?   Na przykład:      Podążając za instrukcjami R2, L3 kończysz 2 bloki na wschód i 3 bloki na północ, lub 5 bloków od pozycji startowej,   podążając za R2, R2, R2 kończysz 2 bloki na południe od pozycji startowej,   podążając za R5, L5, R5, R3 kończysz 10 bloków na wschód i 2 bloki na północ, lub 12 bloków od pozycji startowej.   Jak daleko od pozycji lądowania znajduje się Kwatera Główna Króliczka Wielkanocnego?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-1/",
        "teaser": "/assets/images/2016/12/advent_of_code_2016_01_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 2",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/2   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 2 zadanie 1   Docierasz do Kwatery Głównej Króliczka Wielkanocnego pod osłoną nocy. Zrzut odbył się w takim pośpiechu, że zapomniałeś skorzystać z toalety! Odjechane budynki, takie jak Kwatera Główna Króliczka Wielkanocnego, wejścia do toalet przeważnie mają chronione kodem. Zaczynasz szukać recepcji z nadzieją, że tam znajdziesz kod.   Znalazłeś dokument, zaczynasz czytać “W celu poprawienia bezpieczeństwa kody do toalet nie będą już zapisywane na kartkach. Proszę je zapamiętać i podążać za instrukcjami poniżej aby dostać się do toalety.”.   Dokument wyjaśnia, że każdy znak kodu, który ma być naciśnięty może być odnaleziony zaczynając od poprzedniego znaku. Ruch polega na poruszaniu się po sąsiadujących przyciskach według instrukcji:      U do góry,   D w dół,   L w lewo,   R w prawo.   Każda linijka z instrukcjami odpowiada jednemu znakowi na klawiaturze. Każda kolejna instrukcja rozpoczyna od znaku, na którym skończyłeś poprzednio. Dla pierwszej linii zakładamy, że pozycją początkową jest “5”. Jeśli ruch “wychodzi” poza klawiaturę zignoruj go.   Powoli nie możesz już wytrzymać więc decydujesz się odgadnąć kod w drodze do toalety. Wyobrażasz sobie klawiaturę w postaci:   1 2 3 4 5 6 7 8 9   Zakładając, że instrukcje są następujące:   ULL RRDDD LURDL UUUUD      Zaczynasz na 5, idziesz do góry (2), w lewo (1) i w lewo (nie możesz wykonać tego ruchu więc zostajesz na 1), pierwszą cyfrą kodu jest 1,   Zaczynając z poprzedniego przycisku (1), poruszasz się w prawo dwa razy (3) i trzy razy w dół (9) (zatrzymujesz się na 9 po dwóch ruchach, ignorując trzeci), drugą cyfrą kodu jest 9,   Idąc dalej z 9 idziesz w lewo (8), do góry (5), w prawo (6), w dół (9) i w lewo (8), trzecią cyfrą kodu jest 8,   W końcu, z 8 idziesz do góry cztery razy (zatrzymując się na 2) i raz w dół kończąc na 5.   W tym przypadku kod do toalety to 1985. Jaki jest kod do toalety jeśli instrukcje są jak w pliku day02_input.txt?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-2/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_02_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 3",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/3   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 3 zadanie 1   Po przygodach z wczorajszego dnia w końcu możesz się skupić i czysto myśleć. Zagłębiłeś się w labirynt korytarzy i boksów biurowych, które wypełniają tę część Kwatery Głównej Króliczka Wielkanocnego. To musi być dział projektantów graficznych, ściany pokryte są specyfikacjami dla trójkątów.   Hmm, czy aby na pewno?   Dokumenty z projektami pokazują długości boków każdego z trójkątów, ale… 5 10 25? Niektóre z nich nie są trójkątami. Musisz odrzucić te niepoprawne.   W poprawnym trójkącie suma dwóch boków musi być krótsza od najdłuższego boku. Na przykład nie można zbudować trójkąta z odcinków o długościach 5, 10 i 25. 5 + 10 nie jest większe niż 25.   Jak dużo poprawnych trójkątów znajduje się w pliku wejściowym?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-3/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_03_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 4",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/4   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 4 zadanie 1   Twoja pomoc z problemem trójkątów z wczoraj pozwoliła dotrzeć do automatu informacyjnego z listą pokoi. Oczywiście lista jest zaszyfrowana i pełna nieprawdziwych danych mających wprowadzić Cię w błąd. Całe szczęście udało Ci się znaleźć ledwo ukryte instrukcje jak dekodować te dane. Zacznij jednak od usunięcia danych, które są niepoprawne.   Każdy pokój składa się z zaszyfrowanej nazwy (małe litery oddzielone minusami), po której jest minus, identyfikator sektora i suma kontrolna w nawiasach kwadratowych.   Nazwa pokoju jest prawdziwa jeśli suma kontrolna to pięć najczęściej spotykanych liter w zaszyfrowanej nazwie pokoju. Litery powinny być ułożone w porządku malejącym według liczby wystąpień. Jeśli kilka liter ma taką samą liczbę wystąpień, to powinny być one posortowane alfabetycznie. Dla przykładu:      aaaaa-bbb-z-y-x-123[abxyz] jest poprawną nazwą pokoju ponieważ najczęściej występującymi literami są a (5), b (3). x, y i z mające po jednym wystąpieniu posortowane są alfabetycznie,   a-b-c-d-e-f-g-h-987[abcde] jest poprawną nazwą pokoju, chociaż wszystkie litery występują dokładnie taka samą liczbę razy suma kontrolna zawiera pierwszą piątkę posortowaną alfabetycznie,   not-a-real-room-404[oarel] jest poprawną nazwą pokoju,   totally-real-room-200[decoy] jest błędną nazwą pokoju – suma kontrolna nie jest poprawna.   Biorąc pod uwagę prawdziwe nazwy pokoi z powyższej listy suma ich sektorów wynosi 1514.   Jaka jest suma sektorów prawdziwych pokoi z listy tej listy?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-4/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_04_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 5",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/5   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 5 zadanie 1   Dzięki temu, że wczoraj znalazłeś poprawny pokój, dzisiaj stoisz przed drzwiami bezpieczeństwa opracowanymi przez inżynierów Króliczka Wielkanocnego. Wydaje się, że większość swojej wiedzy o bezpieczeństwie wyciągnęli oglądając filmy o hakerach.   Hasło chroniące drzwi o długości ośmiu znaków wygenerowane jest znak po znaku znajdując odpowiednią sumę MD5. Suma ta generowana jest na podstawie identyfikatora drzwi i numeru. Numer przy każdej iteracji zwiększamy o jeden zaczynając od 0.   Hash zawiera kolejny symbol kodu jeśli jego heksadecymalna reprezentacja zaczyna się pięcioma zerami. Jeśli tak jest, szósty znak w sumie jest kolejnym znakiem hasła do drzwi.   Dla przykładu, jeśli identyfikator drzwi to abc:      Pierwszy numer, przy którym otrzymamy sumę zaczynającą się od pięciu zer to 3231929. Tę sumę MD5 znajdziemy dla łańcucha abc3231929. Szósty znak otrzymanej sumy kontrolnej, jest kolejnym znakiem hasła. W tym przypadku szósty znak to 1 i jest pierwszy znakiem hasła,   przy 5017308 otrzymamy kolejną interesującą nas sumę kontrolną, zaczyna się ona od 000008f82, więc drugim znakiem hasła jest 8 (szósty znak w sumie),   trzecią suma zaczynająca się od pięciu zer otrzymamy dla łańcucha abc5278568, odnajdując kolejny znak hasła f.   W tym przykładzie, kontynuując poszukiwania aż odnajdziemy osiem znaków hasło jakie otrzymamy to 18f47a30.   Jakie będzie hasło jeśli identyfikator drzwi to abbhdwsy?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-5/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_05_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 6",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/6   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 6 zadanie 1   Wczorajsze złamanie kodu do drzwi pomogło Ci dostać się do odpowiedniego pokoju z prezentami. Dzisiaj próbujesz skontaktować się ze Świętym Mikołajem. Coś się jednak zacina. Na szczęście sygnał nie jest w pełni zakłócony i instrukcja w sytuacjach jak ta zaleca przełączenie się do kodu z powtórzeniami żeby przesłać wiadomość poprawnie.   W tym modelu wiadomość wysyłana jest kilkukrotnie. Zachowałeś wszystkie otrzymane do tej pory sygnały, jednak dane wydają się być dość mocno zakłócone. Prawie niemożliwe do odzyskania. Prawie robi wielką różnicę :).   Jedyne co musisz zrobić to odnaleźć, która litera powtarza się największą liczbę razy na każdej pozycji. Na przykład, zakładając, że otrzymałeś następujące sygnały:   eedadn drvtee eandsr raavrd atevrs tsrnev sdttsa rasrtv nssdts ntnada svetve tesnvt vntsnd vrdear dvrsen enarar   Najczęściej pojawiającą się literą na pierwszej pozycji jest e, na drugiej a na trzeciej s i tak dalej. Łącząc te litery ze sobą otrzymasz prawdziwy sygnał bez zakłóceń, easter.   Zakładając, że wszystkie przychodzące komunikaty zostały zapisane w tym pliku, jaka wiadomość (po oczyszczeniu zakłóceń) była rzeczywiście wysłana?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-6/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_06_artykul.jpg"
      },{
        "title": "Advent of Code dzień 7",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/7   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 7 zadanie 1   Wczoraj odebrałeś tajny kod od Świętego Mikołaja. Dzisiaj nadszedł czas na inwigilację sieci w Kwaterze Głównej Króliczka Wielkanocnego. W trakcie podsłuchiwania ruchu zebrałeś listę adresów IP (oczywiście są to adresy IPv71, IPv6 jest zbyt ograniczony…). Chciałbyś dowiedzieć się, które z tych adresów wspierają TLS.   Adres IPv7 wspiera TLS jeśli zawiera sekwencję ABBA wewnątrz standardowych części adresu IP. Sekwencja ABBA to czteroznakowa sekwencja, które zawiera parę dwóch różnych znaków, po której znajduje się ta sama para ale odwrócona. Na przykład xyyx czy abba. Jednak aby adres IPv7 wspierał TLS, sekwencja ABBA nie może znajdować się w żadnej części “hypernet” adresu IP. Części “hypernet” znajdują się między nawiasami [].   Na przykład:      abba[mnop]qrst wspiera TLS, sekwencja ABBA abba znajduje się poza nawiasami [],   abcd[bddb]xyyx chociaż sekwencja ABBA xyyx jest poza nawiasami, adres ten nie wspiera TLS, sekwencja ABBA znajduje się także wewnątrz nawiasów bddb,   aaaa[qwer]tyui nie wspiera TLS, aaaa nie jest poprawną sekwencją ABBA,   ioxxoj[asdfgh]zxcvbn wspiera TLS, sekwencja ABBA oxxo znajduje się poza nawiasami (nie ma znaczenia to, że znajduje się wewnątrz dłuższego łańcucha).   Zakładając, że wszystkie adresy IP, które udało Ci się podsłuchać znajdują się na tej liście, ile z nich wspiera TLS?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!                 IPv7 w tym momencie nie istnieje. &#8617;           ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-7/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_07_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 8",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/8   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 8 zadanie 1   Dzięki Twoje pomocy poprzednio udało się znaleźć wszystkie adresy w Kwaterze Głównej Króliczka Wielkanocnego wspierające TLS. Dzisiaj czeka na Ciebie inne zadanie.   Trafiłeś na drzwi. Wydaje się, że drzwi implementują coś w rodzaju uwierzytelniania dwuskładnikowego. Aby przez nie przejść na początku musisz użyć karty magnetycznej (z tym nie ma problemu, jedną znalazłeś na pobliskim biurku). Następnie, na malutkim ekranie pokazywany jest kod, który musisz wklepać na klawiaturze przy drzwiach. Później można tylko zakładać, że drzwi się otworzą.   Niestety, wyświetlacz, na którym pokazywany jest kod jest rozbity. Po kilku minutach i rozłożeniu wszystkiego na części dowiedziałeś się dokładnie jak on działa. Teraz nie zostało już nic innego jak tylko dojść do tego co pokazałby wyświetlacz.   Pasek magnetyczny na karcie, której możesz użyć do otworzenia drzwi zawiera sekwencje instrukcji dla wyświetlacza. Te instrukcje są także wejściem do zadania, które musisz rozwiązać. Ekran ma 50 pikseli szerokości i 6 pikseli wysokości. Wszystkie piksele na początku są wyłączone. Sam ekran jest w stanie wykonać trzy specyficzne polecenia:      rect AxB włącza wszystkie piksele w prostokącie w lewym górnym rogu ekranu. Prostokąt jest szeroki na A pikseli i wysoki na B pikseli,   rotate row y=A by B przesuwa wszystkie piksele w rzędzie A (gdzie 0 to pierwszy wiersz od góry) w prawo o B pikseli. Piksele, które “wypadłyby” za ekran pokazują się po lewej stronie ekranu,   rotate column x=A by B przesuwa wszystkie piksele w kolumnie A (gdzie 0 to pierwsza kolumna od lewej strony) w dół o B pikseli. Piksele, które “wypadłyby za ekran pokazują się na górze kolumny.   Dla przykładu poniższa sekwencja pokazuje operacje dla mniejszego ekranu o wymiarach 7 na 3 pikseli:     rect 3x2 tworzy mały prostokąt w lewym górnym rogu,   ###.... ###.... .......      rotate column x=1 by 1 przesuwa kolumnę 1 w dół o 1 piksel,   #.#.... ###.... .#.....      rotate row y=0 by 4 przesuwa wiersz 0 w prawo o 4 piksele,   ....#.# ###.... .#.....      rotate column x=1 by 1 ponownie przesuwa kolumnę 1 w dół o 1 piksel. Tym razem piksel z ostatniego rzędu pojawia się w pierwszym rzędzie,   .#..#.# #.#.... .#.....   Jak widzisz, ta technologia obsługi ekranów ma niesamowite możliwości i niedługo zdominuje rynek małych wyświetlaczy. Przynajmniej tak twierdzi naklejka reklamowa z tyłu wyświetlacza.   Twoim zadaniem jest policzenie pikseli, które będą świeciły się na ekranie po wprowadzeniu sekwencji komend z pliku wejściowego.   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-8/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_08_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 9",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/9   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 9 zadanie 1   Wczoraj, dzięki Twojej pomocy udało odczytać to co powinno być wyświetlone na zniszczonym wyświetlaczu. Dzięki temu dostałeś się do chronionej części Kwatery Głównej. Przechadzając się po korytarzach natknąłeś się na port, dzięki któremu możesz dostać się do pozostałej części sieci. Pobieżnie przeskanowałeś interesujące pliki, jeden z nich szczególnie przykuł Twoją uwagę. Plik ten jest skompresowany w pewnym eksperymentalnym formacie. Na szczęście dokumentacja tego formatu znajdowała się niedaleko.   Format kompresuje sekwencje znaków. Białe znaki (spacje, znaki nowej linii itp.) są ignorowane. Aby zaznaczyć, że jakaś sekwencja powinna być powtórzona, umieszcza się przed nią odpowiedni znacznik, na przykład (10x2). Aby zdekompresować następującą po nim sekwencję należy wziąć kolejne 10 znaków i powtórzyć je dwa razy. Następnie należy kontynuować czytanie skompresowanej zawartości po powtórzonej sekwencji. Sam znacznik nie jest dołączany do zdekompresowanego wyjścia.   Jeśli nawiasy, czy inne znaki wystąpią wewnątrz sekwencji, która powinna być powtórzona – wszystko jest w porządku. Należy traktować je jak normalne dane, nie znacznik i kontynuować poszukiwanie znaczników po sekcji, która została powtórzona.   Dla przykładu:      ADVENT nie zawiera żadnych znaczników, więc po dekompresji otrzymamy ADVENT bez żadnych zmian, wynik po dekompresji ma długość 6,   A(1x5)BC powtarza tylko B pięć razy, finalnie otrzymujemy ABBBBBC o długości 7,   (3x3)XYZ po dekompresji otrzymujemy XYZXYZXYZ o długości 9,   A(2x2)BCD(2x2)EFG, powtarzamy znaki BC i EF, otrzymujemy ABCBCDEFEFG o długości 11 znaków,   (6xa)(1x3)A po dekompresji otrzymujemy (1x3)A, chociaż (1x3) wygląda jak znacznik nie jest przetwarzany bo znajdował się wewnątrz zakresu obsługiwanego przez (6x1), podobnie jak A nie jest traktowany specjalnie. Finalnie otrzymujemy łańcuch o długości 6,   X(8x2)(3x3)ABCY po dekompresji otrzymujemy X(3x3)ABC(3x3)ABCY o długości 18 znaków.   Jaka jest długość zdekompresowanej sekwencji jeśli skompresowane dane zapisane są w tym pliku?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-9/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_09_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 10",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/10   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 10 zadanie 1   Dzięki Twojej pomocy przy wczorajszym zadaniu udało się zdekompresować kilka interesujących plików.   Doszedłeś do fabryki w której małe latające robociki przekazują sobie mikrochipy. Po dokładniejszym przyjrzeniu się zauważyłeś, że każdy robot przekazuje cokolwiek dalej tylko jeśli ma dwa mikrochipy. Jeśli już je ma, przekazuje je innemu robotowi lub wrzuca je do jednego z koszy oznaczających “wyjście”. Czasami roboty pobierają mikrochipy z koszy oznaczonych napisem “wejście”.   Patrząc na jeden z mikrochipów wydaje się, że zawierają one pojedynczy, unikalny numer. Roboty używają pewnej logiki aby zdecydować co zrobić z każdym z chipów. Dostałeś się do lokalnego komputera i udało Ci się ściągnąć instrukcje sterujące robotami (wejście do zadania).   Niektóre z instrukcji określają, że mikrochip o konkretnej wartości powinien być przekazany konkretnemu robotowi. Reszta instrukcji określa co każdy robot powinien zrobić z mikrochipami które posiada. Instrukcja ta mówi o tym co robot powinien zrobić z chipem o niższej i o wyższej wartości.   Na przykład, biorąc pod uwagę poniższy zestaw instrukcji:   value 5 goes to bot 2 bot 2 gives low to bot 1 and high to bot 0 value 3 goes to bot 1 bot 1 gives low to output 1 and high to bot 0 bot 0 gives low to output 2 and high to output 0 value 2 goes to bot 2   Początkowo, robot 1 zaczyna z chipem o wartości 3 a robot 2 zaczyna z chipami o wartości 2 i 5. Ponieważ robot 2 ma dwa mikrochipy przekazuje ten o mniejszej wartości (2) do robota 1 a ten o większej wartości (5) do robota 0.   Po tych instrukcjach robot 1 ma dwa chipy. Mikrochip o wartości 2 umieszcza w koszu wyjściowym o numerze 1 i przekazuje mikrochip o wartości 3 do robota 0. Jako ostatni robot 0 mający dwa mikrochipy przekazuje ten o mniejszej wartości (3) do wyjścia 2 a ten o większej wartości (5) do kosza 0.   Na końcu:      kosz wyjściowy 0 zawiera mikrochip o wartości 5,   kosz wyjściowy 1 zawiera mikrochip o wartości 2,   kosz wyjściowy 2 zawiera mikrochip o wartości 3.   W tej konfiguracji robot numer 2 był odpowiedzialny za porównywanie wartości mikrochipów o wartości 5 i 2.   Bazując na instrukcjach dla robotów umieszczonych w tym pliku, robot o którym numerze odpowiedzialny jest za porównywanie mikrochipów o wartościach 61 i 17?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-10/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_10_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 11",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/11   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 11 zadanie 1   Wczoraj, dzięki Twojej pomocy udało się poprawnie sterować dronami, dziś czeka na Ciebie dużo trudniejsze zadanie. Nie zrażaj się jeśli coś nie będzie szło po Twojej myśli, nie jest to trywialny problem :).   Dzisiaj doszedłeś do miejsca gdzie cztery piętra, poza małym korytarzem, zostały zupełnie odseparowane od reszty budynku. Przechodząc przez niego widzisz znaki ostrzegające o promieniowaniu i wielki znak na którym widnieje napis “Dział Badania Cząstek Radioaktywnych”.   Według konsoli pokazującej status cząstek ten obiekt jest aktualnie wykorzystywany do eksperymentowania z generatorami radioizotopów z przetwornikami termoelektrycznymi (ang. Radioisotope Thermoelectic Generators) zwanymi także RTG lub generatorami. Generatory są zaprojektowane tak aby mogły być sparowane ze specjalnie przygotowanymi mikrochipami. Sam generator jest wysoce radioaktywnym kamieniem, który generuje energię elektryczną odzyskiwaną z ciepła.   Niestety eksperymentalne RTG mają słabą ochronę przeciwko promieniowaniu. Przez tę wadę są radioaktywne i niebezpieczne. Mikrochipy jako prototypy nie mają normalnej osłony przeciwko promieniowaniu ale mają możliwość generowania pola elektromagnetycznego, które chroni przez promieniowaniem. Aby móc wydzielić tę osłonę mikrochipy muszą być zasilane. Niestety mogą one być zasilone wyłącznie przez odpowiadające im RTG. RTG zasilające dany mikrochip jest nadal niebezpieczny dla innych mikrochipów.   Innymi słowy, jeśli mikrochip jest pozostawiony w tym samym obszarze co inny RTG i nie jest połączony do swojego własnego RTG, usmaży się. Zakłada się więc, że będziesz postępował zgodnie z procedurą i trzymał mikrochipy podłączone do odpowiadających im RTG i z dala od RTG dla innych mikrochipów.   Mikrochipy wydają się być bardzo interesujące i przydatne do Twoich aktualnych planów, chciałbyś je zdobyć dla własnych celów. Na 4 piętrze znajduje się maszyna, która jest w stanie złożyć komputer z mikrochipów i generatorów, który będziesz mógł bezpiecznie zabrać ze sobą. Oczywiście aby działał musisz dostarczyć na 4 piętro wszystkie mikrochipy wraz z odpowiadającymi im generatorami.   Wewnątrz części budynku osłoniętej przed promieniowaniem (gdzie bezpiecznie jest przechowywać niezłożone RTG), jest winda, która może poruszać się pomiędzy czterema piętrami. Winda maksymalnie może przewozić Ciebie i dwa urządzenia (generatory czy mikrochipy). Jako środek bezpieczeństwa, winda działa wyłącznie jeśli przewozi co najmniej jeden generator lub mikrochip. Winda zawsze zatrzymuje się na każdym piętrze aby doładować swoje baterie. Ładowanie zajmuje tak dużo czasu, że elementy w windzie i elementy na piętrze oddziałują na siebie.   Zrobiłeś notatki dotyczące położenia każdego z elementów (wejście do programu). Zanim założysz strój chroniący przed promieniowaniem i zaczniesz przenosić elementy warto opracować plan w jakiej kolejności należy przenosić poszczególne części.   Gdy wchodzisz do strefy zagrożonej wraz z windą znajdujecie się na pierwszym piętrze.   Dla przykłady, załóżmy, że komponenty w odizolowanej strefie rozłożone są następująco:      Pierwsze piętro zawiera mikrochip hydrogen i mikrochip lithium,   drugie piętro zawiera generator hydrogen,   trzecie piętro zawiera generator lithium,   czwarte piętro jest puste.   Początkowy układ możemy zapisać jako (F# oznacza numer piętra, E windę (ang. elevator), H hydrogen, L lithium, M mikrochip i G generator)   F4 .  .  .  .  . F3 .  .  .  LG . F2 .  HG .  .  . F1 E  .  HM .  LM   Aby przewieźć wszystko na górę do maszyny składającej na 4 piętrze możesz postępować według następujących kroków:     Zabrać mikrochip hydrogen na drugie piętro (jest to bezpieczne ponieważ znajduje się tam odpowiadający generator),   F4 .  .  .  .  . F3 .  .  .  LG . F2 E  HG HM .  . F1 .  .  .  .  LM      zabrać mikrochip hydrogen razem z odpowiadającym generatorem na trzecie piętro (jest to bezpiecznie ponieważ HM ma HG),   F4 .  .  .  .  . F3 E  HG HM LG . F2 .  .  .  .  . F1 .  .  .  .  LM      zostawić generator hydrogen na trzecim piętrze i zjechać z mikrochipem hydrogen na drugie piętro (musisz mieć coś ze sobą, żeby winda ruszyła),   F4 .  .  .  .  . F3 .  HG .  LG . F2 E  .  HM .  . F1 .  .  .  .  LM      zjechać na pierwsze piętro (jest to bezpieczne, mikrochipy nie oddziałują na siebie),   F4 .  .  .  .  . F3 .  HG .  LG . F2 .  .  .  .  . F1 E  .  HM .  LM      zabrać oba mikrochipy na drugie piętro (ponownie, nie ma tu żadnego generatora, który by je usmażył),   F4 .  .  .  .  . F3 .  HG .  LG . F2 E  .  HM .  LM F1 .  .  .  .  .      ponownie zabrać oba mikrochipy wyżej, na trzecie piętro (tym razem każdy z nich ma odpowiadający generator, który chroni je od usmażenia),   F4 .  .  .  .  . F3 E HG HM LG LM F2 .  .  .  .  . F1 .  .  .  .  .      zabrać oba mikrochipy na czwarte piętro,   F4 E  .  HM .  LM F3 .  HG .  LG . F2 .  .  .  .  . F1 .  .  .  .  .      zostawić mikrochip lithium na czwartym piętrze i zabrać mikrochip hydrogen na trzecie piętro (musisz coś zabrać, żeby winda działa, na trzecim piętrze będziesz bezpieczny, chociaż jest tam generator lithium, jest też generator hydrogen, który chroni odpowiadający mu mikrochip),   F4 .  .  .  .  LM F3 E  HG HM LG . F2 .  .  .  .  . F1 .  .  .  .  .      zabrać oba generatory na czwarte piętro (jest to bezpieczne bo mikrochip lithium będzie chroniony przez generator lithium),   F4 E  HG .  LG LM F3 .  .  HM .  . F2 .  .  .  .  . F1 .  .  .  .  .      zjechać w dół z mikrochipem lithium (musisz coś zabrać, żeby winda działała),   F4 .  HG .  LG . F3 E  .  HM .  LM F2 .  .  .  .  . F1 .  .  .  .  .      zabrać na górę generator i mikrochip lithium   F4 E HG HM LG LM F3 .  .  .  .  . F2 .  .  .  .  . F1 .  .  .  .  .   Przy takim podejściu potrzeba 11 kroków aby zebrać wszystkie elementy na czwartym piętrze aby móc je złożyć w jedną całość. Każde zatrzymanie się windy liczone jest jako jeden krok, nawet jeśli nic nie jest dodane czy usunięte z windy.   Jaka jest minimalna liczba kroków potrzebna do przeniesienia wszystkich elementów jeśli ich układ opisany jest w tym pliku?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-11/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_11_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 12",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/12   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 12 zadanie 1   W końcu udało Ci się dotrzeć na ostatnie piętro budynku. Piękny ogród ze skośnym szklanym sufitem. Siedząc na ławce pomiędzy liliami odszyfrowałeś kilka plików, które udało Ci się wykraść z serwera piętro niżej.   Według tych dokumentów Kwatera Główna Królicza Wielkanocnego nie jest jednym budynkiem. Jest kompleksem budynków w okolicy. Wszystkie z nich połączone są kolejką i jeden z nich znajduje się całkiem niedaleko! Niestety, w nocy kolejka nie jeździ.   Udało Ci się zdalnie połączyć do systemu sterującego kolejką i odkryłeś, że sekwencja początkowa wymaga hasła. Logika sprawdzająca hasło (wejście dla Twojego programu) jest łatwa do pozyskania, jednak kod jest dość dziwny. Używa on specjalnego języka assembunny zaprojektowanego dla komputera, który złożyłeś wczoraj. Musisz wywołać kod, żeby uzyskać hasło.   Kod assembunny, który udało Ci się zdobyć operuje na czterech rejestrach (a, b, c i d), które przechowują wartość początkową 0 i mogą trzymać dowolną liczbę całkowitą. Wygląda na to, że wykorzystywany jest dość ubogi zestaw instrukcji:      cpy x y kopiuje x (zawartość rejestru albo liczbę) do rejestru y,   inc x zwiększa wartość rejestru x o jeden,   dec x zmniejsza wartość rejestru x o jeden,   jnz x y skacze do instrukcji oddalonej o y (dodatnie wartości oznaczają skok do przodu, ujemne do tyłu) jeśli x (liczba lub zawartość rejestru) nie jest zerem.   Instrukcja jnz przesuwa się relatywnie względem siebie, skok o -1 oznacza skok do poprzedniej instrukcji, skok o 2 przeskoczy następną instrukcję.   Mając na przykład następujący zestaw instrukcji:   cpy 41 a inc a inc a dec a jnz a 2 dec a   Powyższy kod ustawi rejestr a na wartość 41, zwiększy wartość rejestru o 1 dwukrotnie, zmniejszy wartość rejestru o 1 i następnie przeskoczy ostatnią instrukcję (ponieważ wartość rejestru a != 0). Ostateczna wartość rejestru a to 42. Program kończy się kiedy przejdzie za ostatnią instrukcję.   Zakładając, że kod assembunny znajduje się w tym pliku, jaka będzie wartość rejestru a na koniec programu?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-12/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_12_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 13",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/13   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 13 zadanie 1   Dzięki Twojej pomocy przy wczorajszych instrukcjach assemblera udało się uruchomić kolejkę. Dotarłeś do pierwszego piętra nowego budynku. Niestety hall jest dużo mniej przyjazny niż świecące wnętrza w poprzednim budynku. Zamiast tego trafiłeś do plątaniny korytarzy i małych pomieszczeń.   Każde pomieszczenie w tym rejonie może być zidentyfikowane przez parę nieujemnych liczb całkowitych (x, y). Każda taka współrzędna odpowiada albo ścianie albo otwartej przestrzeni. Nie możesz poruszać się na ukos. Labirynt zaczyna się na współrzędnych (0, 0) i wydaje się dążyć do nieskończoności dodatnich wartości x i y. Ujemne wartości są niepoprawne, przedstawiają położenie poza budynkiem. Znajdujesz się w małej poczekalni, która znajduje się na współrzędnych (1, 1).   Wszystko wydaje się bardzo chaotyczne, jednak plakat znajdujący się na ścianie przekonuje Cię, że całość jest dość logiczna. Możesz stwierdzić czy dana pozycja (x, y) to ściana czy otwarta przestrzeń używając prostego systemu:binarną reprezentację      Oblicz wartość równania x*x + 3*x + 2*x*y + y + y*y,   dodaj ulubiony numer projektanta biura (wejście do programu),   znajdź binarną reprezentację tej sumy, policzyć ile bitów w tej reprezentacji to 1,   jeśli liczba bitów 1 jest parzysta (x, y) reprezentuje otwartą przestrzeń,   jeśli liczba bitów 1 jest nieparzysta (x, y) reprezentuje ścianę.   Na przykład, jeśli ulubionym numerem projektanta biura jest 10, poniżej widzisz układ biura gdzie ściany pokazane są jako # a otwarta przestrzeń jako .. Narożnik budynku wygląda tak:     0123456789 0 .#.####.## 1 ..#..#...# 2 #....##... 3 ###.#.###. 4 .##..#..#. 5 ..##....#. 6 #...##.###   Załóżmy, że chciałbyś dotrzeć do pozycji (7, 4). Najkrótsza droga, którą mógłbyś obrać oznaczona jest O:     0123456789 0 .#.####.## 1 .O#..#...# 2 #OOO.##... 3 ###O#.###. 4 .##OO#OO#. 5 ..##OOO.#. 6 #...##.###   Więc dotarcie do punktu (7, 4) wymaga 11 kroków (zaczynając od pozycji (1, 1)).   Zakładając, że ulubionym numerem projektanta biura jest 1362, jaka jest minimalna liczba kroków potrzebna do dotarcia do punku (31, 39)?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-13/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_13_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 14",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/14   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 14 zadanie 1   Po udanej przeprawie przez labirynt chciałbyś przesłać wiadomość do Świętego Mikołaja. Żeby bezpiecznie połączyć się ze Świętym Mikołajem w trakcie misji używałeś haseł jednorazowych. Generowałeś je używając algorytmu, który został wcześniej zatwierdzony. Niestety hasła, które miałeś wygenerowane już się skończyły. Musisz wygenerować kolejne.   Do wygenerowania haseł potrzebujesz strumienia danych losowych. Strumień ten uzyskasz licząc sumę MD5 z odpowiednio przygotowanego łańcucha znaków. Łańcuch ten składa się z dwóch części. Pierwsza z nich jest stała (wejście do twojego programu), druga to zwiększająca się o 1 liczba całkowita zapisana dziesiętnie. Suma MD5 z takiego łańcucha powinna być przestawiona w postaci heksadecymalnej.   Niestety, nie wszystkie takie sumy MD5 to hasła a Ty potrzebujesz kolejnych 64 do dalszej komunikacji z Mikołajem. Suma MD5 jest hasłem jeśli:      Zawiera trzy takie same znaki pod rząd, na przykład 777, weź pod uwagę wyłącznie pierwszą trójkę w sumie,   w kolejnych 1000 sum ten sam znak powtórzony jest pięć razy pod rząd, na przykład 77777.   Jeśli jakaś suma zawiera pięć znaków pod rząd także powinieneś ją traktować jako potencjalne hasło (mając pięć powtórzonych znaków, oczywiście suma ma też trzy powtórzone znaki).   Na przykład, jeśli wejściem do programu jest abc:      Pierwszy indeks, w którym suma MD5 zawiera potrojony znak to 18. Suma MD5 z abc18 zawiera ...cc38887a5.... Mimo to, indeks 18 nie liczy się jako poprawne hasło, ponieważ żadna z kolejnych 1000 sum (indeksy 19 do 1018 włącznie) nie zawiera 88888,   kolejny indeks, który zawiera potrojony znak to 39. Suma MD5 z abc39 zawiera eee. Jest to także pierwsze poprawne hasło, ponieważ jedna z kolejnych 1000 sum (ta z indeksem 816) zawiera eeeee,   żadna z kolejnych sześciu trójek występująca w kolejnych sumach nie jest hasłem, jednak kolejna już tak. Suma z indeksu 92 zawiera 999 a indeks 200 zawiera 99999.   w końcu indeks 22728 spełnia wszystkie wymagania i produkuje sześćdziesiąte czwarte hasło.   Więc w naszym przykładzie, jeśli wejściem do programu jest abc, indeks 22728 produkuje sześćdziesiąte czwarte hasło jednorazowe.   Jeśli wejściem do Twojego programu jest yjdafjpo który indeks generuje sześćdziesiąte czwarte hasło?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-14/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_14_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 15",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/15   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 15 zadanie 1   Poprzedni udało Ci się wygenerować listę haseł jednorazowych. Po czym zacząłeś zwiedzać pozostałą część Kwatery Głównej. Wielki korytarz prowadzi do placu umieszczonego wewnątrz budynku. Na środku placu znajduje się ruchoma rzeźba. Rzeźba zamknięta jest pod przeźroczystą kopułą, wewnątrz niej krążą nieduże kapsuły. Kapsuły są przenoszone na górę rzeźby i spadają swobodnie odbijając się od kręcących się elementów rzeźby.   Część rzeźby jest nawet interaktywna. Kiedy naciśniesz przycisk kapsuła spuszczana jest w dół i próbuje przelecieć przez dziury w zestawie obracających się dysków. Jeśli przeleci przez nie wszystkie wypada przez niewielką dziurę na dole rzeźby. Jeśli którykolwiek z otworów nie jest “zgrany” z kapsułą kiedy ta opada, kapsuła odbija się od niego i wznosi się z powrotem na górę rzeźby. Chcesz mieć jedną z tych kapsuł :).   Dyski zatrzymują się co sekundę, każdy z nich ma inny rozmiar. Każdy z dysków ma określoną liczbę pozycji, na których się zatrzymuje. Pozycja z dziurą na dysku oznaczona jest numerem 0, na kolejnych pozycjach nie ma dziur przez które może przelecieć kapsuła.   Dyski są oddalone od siebie. Kiedy naciśniesz przycisk potrzeba jednej sekundy zanim kapsuła osiągnie pierwszy dysk, kolejna sekunda mija kiedy kapsuła przemieszcza się od jednego dysku do kolejnego pod spodem. Więc jeśli przyciśniesz przycisk w czasie 100, wtedy kapsuła dotrze do pierwszego dysku o czasie 101, do drugiego o czasie 102, do trzeciego o czasie 103 i tak dalej.   Przycisk wypuści kapsułę tylko o pełnych sekundach, nie można wypuścić jej w połowie sekundy.   Załóżmy, że w czasie 0 widzisz następujący układ dysków:      Dysk #1 ma 5 pozycji, w czasie 0 jest na pozycji 4,   dysk #2 ma 2 pozycje, w czasie 0 jest na pozycji 1.   Jeśli naciśniesz przycisk o czasie 0, kapsuła zacznie opadać. Dotrze do pierwszego dysku o czasie 1. Jako, że dysk #1 w czasie 0 był na pozycji 4, o czasie 1 przemieścił o jedną pozycję do przodu. Jako dysk z pięcioma pozycjami, kolejną pozycją jest 0 więc kapsuła swobodnie przelatuje przez otwór.   Następnie o czasie 2 kapsuła dociera do drugiego dysku. Drugi dysk przesunął się do przodu o dwie pozycje. Zaczął na pozycji 1, przesunął się do 0 i ostatecznie ponownie przemieścił się do pozycji 1. Ponieważ w każdym dysku jest tylko jeden otwór kapsuła nie może przelecieć przez dysk #2.   Jeśli jednak poczekasz z naciśnięciem przycisku do czasu 5, wtedy kapsuła może przelecieć swobodnie przez wszystkie dyski. Pierwszy dysk przesunie się w tym czasie 5 + 1 = 6 razy (do pozycji 0), drugi dysk przesunie się 5 + 2 = 7 razy, także do pozycji 0.   Twoja sytuacja jest bardziej skomplikowana, rzeźba ma więcej niż 2 dyski. Kiedy najszybciej możesz nacisnąć przycisk żeby kapsuła wypadła z rzeźby jeśli układ dysków opisany jest w tym pliku?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-15/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_15_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 16",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/16   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 16 zadanie 1   Wczoraj wyciągnąłeś kapsułę z ruchomej rzeźby, dzisiaj czeka na Ciebie zupełnie inne zadanie. Wróciłeś do skanowania sieci w Kwaterze Głównej Króliczka Wielkanocnego, niestety tym razem zostawiłeś ślady, które mogą Cię zdradzić. Musisz nadpisać część dysków z danymi, które wyglądają jak losowe żeby zatrzeć ślady i zaktualizować lokalny system bezpieczeństwa sumą kontrolną tych danych.   Aby te wygenerowane dane nie wyglądały podejrzanie muszą spełniać kilka warunków. Czysto losowe dane zostaną wykryte. Aby wygenerować odpowiednią sekwencję danych, które oszukają mechanizmy wykrywania intruzów musisz użyć zmodyfikowanego fraktala “smoka Heighwaya”.   Zacznij od stanu początkowego (wejście do Twojego programu). Następnie, do momentu kiedy nie będziesz miał wystarczającej ilości danych do wypełnienia dysku powtarzaj następujące kroki:      Nazwij dane, które masz na tym etapie jako “a”,   zrób kopię “a”, nazywając ją “b”,   odwróć kolejność znaków w “b”,   zamień wszystkie 0 na 1 i wszystkie 1 na 0,   połącz ze sobą “a” i “b” wstawiając 0 pomiędzy nimi.   Na przykład, po jednym kroku takiego algorytmu:     1 zamienia się w 100,   0 zamienia się w 001,   11111 zamienia się w 11111000000,   111100001010 zamienia się w 1111000010100101011110000.   Powtarzaj te kroki dopóki nie będziesz miał wystarczającej ilości danych żeby wypełnić dysk.   Kiedy już wygenerujesz dane, musisz także policzyć sumę kontrolną dla tych danych. Do liczenia sumy użyj wyłącznie tych danych, które zmieszczą się na dysku, nawet jeśli w ostatnim kroku wygenerowałeś więcej danych.   Suma kontrolna danych jest stworzona na podstawie każdej nie nakładającej się pary znaków w danych. Jeśli oba znaki są takie same (00 lub 11), kolejny numer sumy kontrolnej to 1. Jeśli znaki są różne (01 lub 10), następny numer sumy kontrolnej to 0. Ten proces powinien stworzyć nowy łańcuch znaków, który będzie krótszy dokładnie o połowę. Jeśli długość sumy kontrolnej jest parzysta powtórz ten proces tak długo dopóki nie otrzymasz sumy kontrolnej z nieparzystą liczbą znaków.   Na przykład, załóżmy, że chcemy wypełnić dysk danymi o długości 12 znaków. Po wygenerowaniu danych pierwsze 12 znaków to 110010110100. Aby wygenerować sumę kontrolną:      Weź pod uwagę każdą parę: 11, 00, 10, 11, 01, 00,   pary odpowiednio mają identyczne, identyczne, różne, identyczne, różne i identyczne numery, w wyniku czego uzyskujemy 110101,   suma ma długość parzystą więc powtarzamy proces,   pary tym razem to 11 (identyczne), 01 (różne) i 01 (różne),   tym razem suma kontrolna 100 ma nieparzystą długość co kończy proces.   Więc w naszym przypadku, suma kontrolna dla 110010110100 to 100.   Łącząc te wszystkie kroki ze sobą, załóżmy, że chcesz wypełnić dysk o długości 20 znaków używając danych wejściowych 10000:      ponieważ 10000 jest za krótkie, musimy wygenerować więcej danych,   po pierwszej rundzie algorytmu uzyskujemy 10000011110 (11 znaków), nadal za mało,   po drugiej rundzie algorytmu uzyskujemy 10000011110010000111110 (23 znaki), wystarczy,   ponieważ potrzebujemy 20 znaków a wygenerowaliśmy 23 pozbywamy się trzech ostatnich uzyskując 10000011110010000111,   następnie liczymy sumę kontrolną, po pierwszej rundzie mamy 0111110101, suma ma 10 znaków więc kontynuujemy,   po dwóch rundach suma kontrolna to 01100, ponieważ długość sumy kontrolnej jest nieparzysta przerywamy algorytm.   W tym przypadku poprawna suma kontrolna to 01100.   Zakładając, że dysk, który chcesz wypełnić ma 272 znaki i sekwencja początkowa to 10011111011011001 jaka jest poprawna suma kontrolna?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-16/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_16_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 17",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/17   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 17 zadanie 1   Wczoraj udało Ci się wygenerować sumę kontrolną, która pozwoliła oszukać system bezpieczeństwa. Dzisiaj próbujesz dostać się do sejfu, znajdującego się na końcu małego zbioru pokoi. Pokoje ułożone są w czterech rzędach i kolumnach. Pomiędzy pokojami znajdują się drzwi. Zaczynasz w pokoju w lewym górnym rogu (oznaczonym S), do sejfu możesz się dostać jeśli dojdziesz do pokoju, który znajduje się w prawym dolnym rogu (oznaczonym literą V).   ######### #S| | | # #-#-#-#-# # | | | # #-#-#-#-# # | | | # #-#-#-#-# # | | |V# #########   Mury przez które nie możesz przejść oznaczone są #, drzwi natomiast - lub |.   Drzwi w aktualnym pokoju są otwarte lub zamknięte. To w jakim są stanie zależy od heksadecymalnej sumy z hasła (wejście do programu) z dołączoną sekwencją wielkich liter reprezentujących ścieżkę, którą obrałeś do tej pory:      U jeśli poszedłeś do góry,   D jeśli poszedłeś w dół,   L jeśli poszedłeś w lewo,   R jeśli poszedłeś w prawo.   Tylko pierwsze cztery znaki sumy kontrolnej są wykorzystywane. Przedstawiają one odpowiednio drzwi z góry, z dołu z lewej i z prawej strony względem Twojej aktualnej pozycji. Którakolwiek z liter b, c, d, e czy f oznaczają, że odpowiadające im drzwi są otwarte. Każdy inny znak (numer czy a) znaczy, że drzwi są zamknięte i nie możesz ich otworzyć.   Aby dotrzeć do sejfu, jedyne co musisz zrobić to dotrzeć do pokoju w prawym dolnym rogu. Dotarcie do tego pokoju otwiera sejf i wszystkie pozostałe drzwi w labiryncie.   Dla przykładu załóżmy, że hasło to hijkl. Początkowo, nie ruszyłeś się do żadnego pokoju więc aktualna ścieżka jest pusta. Po prostu znajdujesz sumę kontrolną MD5 z hijkl. Pierwsze cztery znaki tej sumy to ced9. Oznacza to, że góra jest otwarta (c), dół jest otwarty (e), lewa strona jest otwarta (d) i prawa strona jest zamknięta (9). Ponieważ zaczynasz w lewym górnym rogu nie ma drzwi u góry ani po lewej stronie więc możesz pójść tylko w dół.   Następnie po jednym kroku (w dół), znajdujesz sumę kontrolną dla hijklD. Otrzymujesz sumę kontrolną f2bc, co oznacza, że możesz pójść z powrotem do góry, w lewo (tylko tam znów jest mur) lub w prawo. Pójście w prawo oznacza znajdowanie sumy z hijklDR, otrzymasz wtedy 5745 – wszystkie drzwi są zamknięte. Jednak gdy wrócisz do góry sytuacja wygląda inaczej. Mimo tego, że już w tym pokoju byłeś, teraz Twoja ścieżka jest inna, suma kontrolna też będzie inna więc też i inne drzwi mogą zostać otwarte.   Po udaniu się DU (i policzeniu sumy kontrolnej z hijklDU aby otrzymać 528e), tylko prawe drzwi są otwarte. Po udaniu się w prawo i policzeniu sumy kontrolne wszystkie drzwi są zamknięte… Na szczęście Twoje hasło to nie hijkl :).   Wszystkie kody użyte przez Ochronę Sejfu Króliczka Wielkanocnego pozwalają na dotarcie do sejfu jeśli znasz poprawną ścieżkę. Na przykład:      jeśli hasło to ihgpwlah najkrótsza ścieżka to DDRRRD,   jeśli hasło to kglvqrro najkrótsza ścieżka to DDUDRLRRUDRD,   jeśli hasło to ulqzkmiv najkrótsza ścieżka to DRURDRUDDLLDLUURRDULRLDUUDDDRR.   Zakładając, że Twoje hasło to udskfozm jaka jest najkrótsza ścieżka, która pozwala dotrzeć do sejfu?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-17/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_17_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 18",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/18   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 18 zadanie 1   Rozwiązanie poprzedniego zadania pozwoliło Ci dostać się do sejfu. W sejfie były tylko wskazówki jak dotrzeć do pewnego pokoju, był nieźle ukryty. Jak tylko wszedłeś do pokoju usłyszałeś głośne kliknięcie. Okazuje się, że część kafli na podłodze to pułapki. Ta, którą właśnie wyzwoliłeś wystrzeliła, cudem udało Ci się uniknąć tego co miała z Tobą zrobić. Następnym razem nie będziesz miał tyle szczęścia…   Po dokładniejszym przyjrzeniu się, ułożenie pułapek i bezpiecznych kafli w pokoju wydaje się pasować do pewnego wzoru. Kafle ułożone są w rzędach o tej samej szerokości. Znalazłeś karteczkę z zapisem bezpiecznych kafli (.) i pułapek (^) w pierwszym rzędzie (wejście do programu).   Rodzaj kafla (pułapka czy normalne, bezpieczne pole) w każdym rzędzie bazuje na typach kafli w rzędzie poprzednim. Z poprzedniego rzędu istotne są kafel w poprzedniej kolumnie, w tej samej kolumnie i w następnej kolumnie. Jeśli kafel jest w pierwszej lub ostatnie kolumnie jego odpowiedniki w poprzednim rzędzie znajdujące się “w ścianie” uznawane są za bezpieczne.   Na przykład, załóżmy, że znasz pierwszy rząd (oznaczony literami) i chciałbyś dowiedzieć się o kaflach w następnym rzędzie (oznaczonym liczbami):   ABCDE 12345   Rodzaj kafla 2 zależy od rodzaju kafli A, B i C. Rodzaj kafla 5 zależy od kafli D, E i “bezpiecznego kafla w ścianie”. Nazwijmy kafle z poprzedniego rzędu lewym, środkowy i prawym. Wówczas kafel jest pułapką wtedy i tylko wtedy gdy spełniona jest jedna z poniższych sytuacji:     lewy i środkowy kafel są pułapkami, prawy kafel jest bezpieczny,   środkowy i prawy kafel są pułapkami, lewy kafel jest bezpieczny,   tylko lewy kafel jest pułapką,   tylko prawy kafel jest pułapką.   Każda inna sytuacja oznacza, że kafel jest bezpieczny.   Załóżmy, że pierwszy rząd to ..^^., stosując reguły przedstawione powyżej możesz poznać kafle w kolejnych rzędach:      Pierwszy kafel w następnym rzędzie bierze pod uwagę “nieistniejący kafel ze ściany”, środkowy (pierwsza . oznaczająca bezpieczny kafel) i prawy (druga ., także bezpieczny) kafel z poprzedniego rządu. Ponieważ żadna z reguł określająca pułapkę nie została spełniona, kafel jest bezpieczny,   kolejny kafel w następnym rzędzie bierze pod uwagę lewy (.), środkowy (.) i prawy (^) kafel z poprzedniego rzędu. Taki układ pasuje do czwartej reguły więc ten kafel to pułapka,   trzeci kafel bierze pod uwagę .^^, taki układ pasuje do drugiej reguły, ten kafel to także pułapka,   ostatnie dwa kafle pasują odpowiedni do pierwszej i trzeciej reguły dla pułapek – oba kafle to pułapki.   Po zastosowaniu tych kroków poznałeś kolejny rząd kafli w pokoju .^^^^. Następnie używając tych samych reguł możesz poznać trzeci rząd ^^..^. Układ kafli w pierwszych trzech rzędach wygląda następująco:   ..^^. .^^^^ ^^..^   Poniżej jest przykład z trochę większego pokoju o dziesięciu rzędach i kolumnach:   .^^.^.^^^^ ^^^...^..^ ^.^^.^.^^. ..^^...^^^ .^^^^.^^.^ ^^..^.^^.. ^^^^..^^^. ^..^^^^.^^ .^^^..^.^^ ^^.^^^..^^   W powyższym przykładzie, w dziesięciu rzędach jest 38 bezpiecznych kafli.   Zakładając, że pierwszy rząd dla pokoju, w którym się znajdujesz jest w tym pliku – ile jest bezpiecznych kafli w pierwszych 40 rzędach (wliczając podany)?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-18/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_18_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 19",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/19   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 19 zadanie 1   Wczoraj przeszedłeś przez pokój pełen pułapek. Dzisiaj przydałyby się pomoc przy znalezieniu elfa, który został se wszystkimi prezentami. Elfy kontaktują się z Tobą przez bardzo bezpieczny kanał bezpieczeństwa. Pogubiły się w zabawie z prezentami.   Każdy elf ma prezent. Wszystkie elfy siedzą w kółku na ponumerowanych krzesłach. Numery zaczynają się od 1. Pierwszy elf zabiera wszystkie prezenty od elfa, który siedzi po jego lewej stronie, elf bez prezentów odchodzi z kółka i nie bierze udziału w dalszej grze.   Na przykład, jeśli w kółku byłoby 5 elfów:      1 5     2  4   3      Elf 1 bierze prezent drugiego elfa,   elf 2 nie ma prezentów więc wypada z gry,   elf 3 bierze prezent czwartego elfa,   elf 4 nie ma prezentów więc wypada z gry,   elf 5 bierze prezenty elfa pierwszego,   ani elf 1 ani elf 2 nie mają już prezentów więc nie są brane pod uwagę,   elf 3 zabiera prezenty piątego elfa.   Więc, gdy w kółku siedzi pięć elfów, ten na pozycji 3 zostanie ze wszystkimi prezentami.   Zakładając, że kółku siedzi 3014603 elfów, który z nich zostanie ze wszystkimi prezentami?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-19/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_19_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 20",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/20   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 20 zadanie 1   Dzięki Tobie wczoraj udało się znaleźć Elfa, który ma wszystkie prezenty. Dzisiaj chciałbyś wpiąć do sieci swój mały mikroprocesor żeby mieć dostęp do sieci później. Jednak firewall w Kwaterze Głównej pozwala tylko na komunikację z kilkoma zewnętrznymi adresami IP.   Udało Ci się dostać do listy blokowanych adresów IP, jednak lista jest strasznie słabo utrzymana. Wszystkie IP są pomieszane i nie jest jasne które adresy IP są dozwolone. Ponadto, adresy nie są zapisane w standardowej notacji a jako zwykłe liczby całkowite, które mogą mieć wartość od 0 do 4294967295 włącznie.   Na przykład, załóżmy, że tylko wartości od 0 do 9 były poprawne i udało Ci się wyciągnąć następującą listę zablokowanych adresów:   5-8 0-2 4-7   Lista określa zakresy adresów IP, zarówno startowa jak i końcowa wartość są zabronione. W takim przypadku wyłącznie adresy IP 3 i 9 są dozwolone, jako jedyne nie są w żadnym z zablokowanych zakresów.   Zakładając, że lista zablokowanych adresów znajduje się w tym pliku, jaka jest najniższa wartość IP, który nie jest zablokowany?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-20/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_20_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 21",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/21   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 21 zadanie 1   Wczoraj znalazłeś adres IP komputera, który nie jest blokowany przez firewall. Komputer, do którego systemu próbujesz się włamać używa dziwnego mechanizmu mieszającego do przechowywania haseł. Mimo to, nie powinno nastręczyć Ci żadnych trudności utworzenie samemu takiego hasła, które możesz dodać do systemu. Wystarczy, że zaimplementujesz odpowiednie przekształcenia.   Operacja mieszająca składa się z serii operacji (dokładna ich lista jest wejściem do programu). Zaczynając od hasła, które ma być pomieszane aplikujesz każdą operację kolejno. Pojedyncze operacje opisane są poniżej:      swap position X with position Y oznacza, że litery pod indeksami X i Y (zaczynając od 0) powinny być zamienione,   swap letter X with letter Y oznacza, że litery X i Y powinny być zamienione (niezależnie na jakich pozycjach się znajdują),   rotate left/right X step(s) oznacza, że cały łańcuch znaków powinien być “przesunięty” w lewo lub prawo o X znaków, na przykład przesunięcie łańcucha abcd o jedną literę w prawo da Ci dabc,   rotate based on position of letter X oznacza, że cały łańcuch znaków powinien być “przesunięty” w prawo. To o ile powinien być przesunięty zależy od indeksu litery X zanim łańcuch będzie przesunięty. Jak poznasz indeks litery X przesuń łańcuch znaków o jedną pozycję w prawo, dodatkowo przesuń łańcuch w prawo o indeks na którym znajduje się litera X. Jeśli indeks był równy bądź większy 4 przesuń łańcuch o jeszcze jedną pozycję w prawo,   reverse positions X through Y oznacza, że zakres pomiędzy X i Y (włączając oba indeksy) powinien być odwrócony,   move position X to position Y oznacza, że litera, która jest pod indeksem X powinna być usunięta z łańcucha i włożona pod indeks Y.   Na przykład, zakładając, że hasło początkowe to abcde i chcesz przeprowadzić następującą serię przekształceń:     swap position 4 with position 0 zamienia pierwszą i ostatnią literę, otrzymujesz ebcda, wynik ten jest wejściem do kolejnego kroku,   swap letter d with letter b zamienia literę d z literą b, w wyniku czego otrzymasz edcba,   reverse positions 0 through 4 sprawia, że cały łańcuch znaków jest odwrócony produkując abcde,   rotate left 1 step przesuwa w lewo cały łańcuch o jedną literę, w wyniku tego przekształcenia pierwsza litera ląduje na końcu bcdea,   move position 1 to position 4 usuwa literę na pozycji 1 (c), wkładając ją na pozycję 4 (na koniec łańcucha): bdeac,   move position 3 to position 0 usuwa literę z pozycji 3 (a), wkładając ją na pozycję 0 (początek łańcucha): abdec,   rotate based on position of letter b znajduje indeks litery b (1), później rotuje cały łańcuch o 1 plus indeks litery (2): ecabd,   rotate based on position of letter d znajduje indeks litery d (4), później rotuje cały łańcuch o 1 plus indeks litery (4), dodając dodatkową jedynkę ponieważ indeks był większy bądź równy 4, finalnie rotuje łańcuch o 6 pozycji: decab.   Po tych wszystkich krokach, hasło to decab.   Teraz Twoja kolej. Musisz wygenerować hasło, którego użyjesz aby dostać się do systemu. Zakładając, że lista przekształceń znajduje się w tym pliku, a hasło początkowe to abcdefgh jakie będzie hasło po przekształceniach?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-21/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_21_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 22",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/22   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 22 zadanie 1   Dzięki Twojej pomocy poprzednio udało się utworzyć odpowiednie hasło. Hasło to pozwoliło Ci się dostać do potężnego klastra maszyn. Każdy komputer w tym klastrze połączony jest maksymalnie z czterema najbliższymi maszynami (trzema jeśli jest na krawędzi lub dwoma jeśli jest w rogu).   Bezpośrednio możesz dostać się tylko do maszyny /dev/grid/node-x0-y0, ale możesz także przeprowadzić pewne, ograniczone operacje na pozostałych maszynach w klastrze:      możesz dostać informacje na temat zużycia dysku (dzięki df), wynik tego polecenia jest wejściem do programu,   możesz poinstruować maszynę aby przeniosła całe dane na sąsiednią maszynę (oczywiście jeśli maszyna docelowa ma wystarczająco dużo miejsca do przyjęcia danych). Maszyna z której przenosisz dane zostaje pusta w wyniku takiej operacji.   Maszyny mają nazwy, które pozwalają poznać ich położenie w klastrze. Na przykład maszyna o nazwie node-x10-y10 sąsiaduje z maszynami node-x9-y10, node-x11-y10, node-x10-y9 i node-x10-y11.   Zanim zaczniesz kombinować z klastrem musisz zrozumieć ułożenie danych na maszynach w klastrze. Chociaż możesz tylko przenosić dane pomiędzy sąsiadującymi maszynami będziesz potrzebował przenieść sporo danych aby dostać się do tych, które potrzebujesz. Aby to zrobić musisz dowiedzieć się jak możesz przenosić dane pomiędzy maszynami.   Aby to zrobić, musisz poznać liczbę poprawnych par maszyn, między którymi możesz kopiować dane. Poprawna para maszyn (A, B) niezależnie od tego czy są bezpośrednio połączone czy nie, to para, w której:      maszyna A nie jest pusta (kolumna Used nie zawiera 0),   maszyny A i B nie są tą samą maszyną,   dane na maszynie A (kolumna Used) zmieszczą się na maszynie B (kolumna Avail).   Zakładając, że lista opisująca maszyny w klastrze znajduje się w tym pliku, ile poprawnych par maszyn jest w klastrze?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-22/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_22_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 23",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/23   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 23 zadanie 1   Dzięki Twojej pomocy wczoraj udało się znaleźć odpowiednie pary maszyn w klastrze. Znajdujesz się na jednym z górnych pięter najwyższego budynku w Kwaterze Głównej Króliczka Wielkanocnego. Prywatne biuro Króliczka znajduje się właśnie tutaj, wraz z sejfem ukrytym za obrazem. Kto nie schowałby cennych dokumentów w sejfie ukrytym właśnie tam?   Sejf ma wyświetlacz cyfrowy i klawiaturę, na której trzeba wpisać odpowiedni kod. Żółta karteczka przyczepiona do sejfu daje wskazówkę dotyczącą hasła: “jajka”. Na obrazie z dużym królikiem malującym jajka, doliczyłeś się 7 jajek.   Kiedy próbujesz wpisać kod nic nie pojawia się na ekranie. Zamiast tego klawiatura rozpada się w Twoich rękach. Najwyraźniej została wcześniej zniszczona. Pod spodem ma swego rodzaju gniazdo, takie do którego pasuje Twój prototypowy komputer. Rozmontowując roztrzaskaną klawiaturę wyciągasz układ logiczny ze środka, podłączasz go do swojego komputera, który następie podłączasz do sejfu.   Teraz musisz tylko dowiedzieć się jakie wyjście wyprodukowałaby klawiatura po naciśnięciu odpowiedniego klawisza. Wyciągasz kod assembunny z chipa (wejście do programu).   Kod wygląda, prawie dokładnie jak ten, który użyty był poprzednio do sterowania kolejką! Powinieneś być w stanie użyć tego samego interpretera, którego użyłeś poprzednio. Wymagał on będzie jednak drobnego rozszerzenia o jedną nową instrukcję:      tgl x przełącza instrukcję znajdującą się x pozycji dalej, x wskazuje na instrukcje podobnie jak jnz. Dodatnia wartość oznacza instrukcję z przodu, ujemna z tyłu.   Instrukcja tgl działa w następujący sposób:     dla jednoargumentowych instrukcji, inc staje się dec, każda inna jednoargumentowa instrukcja staje się inc,   dla dwuargumentowych instrukcji, jnz staje się cpy, każda inna dwuargumentowa instrukcja staje się jnz,   argumenty przełączanej instrukcji nie są zmieniane,   jeśli tgl próbuje przełączyć instrukcję znajdującą się poza programem, nic się nie dzieje,   jeśli tgl wyprodukuje niepoprawną instrukcje (na przykład cpy 1 2) i później interpreter spróbuje wywołać taką instrukcję, powinien ją ominąć,   jeśli tgl przełącza samą siebie (na przykład jeśli a ma wartość 0, tgl a przełączy się na inc a), wynikowa instrukcja nie jest wywołana dopóki interpreter nie dotrze do niej po raz kolejny.   Na przykład jeśli pod uwagę weźmiesz taki program:   cpy 2 a tgl a tgl a tgl a cpy 1 a dec a dec a      cpy 2 a inicjalizuje rejestr a wartością 2,   pierwsza instrukcja tgl a przełącza instrukcję odległą o wartość rejestru a (2), w wyniku czego zmienia trzecią instrukcję tgl a na inc a,   druga instrukcja tgl a także zmienia instrukcje oddaloną o 2, co zmienia cpy 1 a na jnz 1 a,   czwarta linia, która teraz jest inc a zwiększa o jeden a do wartości 3,   ostatecznie piąta linia, która jest teraz jnz 1 a skacze o a (3) instrukcji do przodu przeskakując obie instrukcje dec a.   W tym przykładzie ostateczna wartość rejestru a to 3.   Pozostała część układu scalonego zdaje się ustawiać wartość rejestru a na wejście z klawiatury (liczbę jajek z obrazu, 7), uruchamia kod i przesyła wynikową wartość rejestru a do sejfu.   Zakładając, że lista poleceń znajduje się w tym pliku, jaka wartość zostanie przesłana do sejfu?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-23/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_23_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 24",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/24   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 24 zadanie 1   W końcu udało Ci się przezwyciężyć klawiaturę z sejfu. Dzięki dokumentom, które tam znalazłeś dotarłeś do drzwi prowadzących na dach. Niestety są zamknięte na głucho, nie możesz się nawet to nich dostać, widzisz je za szybą kuloodporną. Jednak, robot, który czyści kanały wentylacyjne może.   Niestety nie jest to szybki robot, możesz go przekonfigurować tak, że będzie mógł połączyć się z kablami prowadzonymi z sytemu HVAC (ogrzewanie, wentylacja, klimatyzacja). Jeśli będziesz w stanie pokierować go tak, żeby dotarł do kilku miejsc będziesz mógł ominąć system bezpieczeństwa chroniący drzwi.   Udało Ci się zdobyć plany kanałów wentylacyjnych, na których zaznaczone są istotne miejsca na mapie (wejście do programu). 0 to Twoja aktualna pozycja, z której robot czyszczący zaczyna się poruszać. Pozostałe numery (kolejność nie ma znaczenia) oznaczają miejsca, które robot musi odwiedzić co najmniej raz. Mury oznaczone są # a kanały, po których może się poruszać robot .. Numery oznaczające miejsca to także miejsca dostępne dla robota.   Na przykład, zakładając, że mapa kanałów wentylacyjnych wygląda następująco:   ########### #0.1.....2# #.#######.# #4.......3# ###########   Aby dotrzeć do wszystkich istotnych miejsc tak szybko jak to możliwe robot wybrał następującą ścieżkę:     od miejsca startowego do 4 (2 kroki),   od miejsca 4 do 1 (4 kroki, robot nie może poruszać się na ukos),   od miejsca 1 do miejsca 2 (6 kroków),   od miejsca 2 do miejsca 3 (2 kroki).   Z racji tego, że robot jest raczej powolny musisz znaleźć najkrótszą drogę. Przykład pokazuje najkrótszą możliwą drogę (14 kroków) wymaganych do odwiedzenia wszystkich istotnych punktów co najmniej raz.   Zakładając, że mapa kanałów wentylacyjnych znajduje się w tym pliku i że robot zaczyna z pozycji 0, jaka jest najmniejsza liczba kroków potrzebna aby odwiedzić wszystkie miejsca oznaczone numerami co najmniej raz?   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-24/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_24_artykul.jpg"
      },{
        "title": "Advent of Code 2016 dzień 25",
        "excerpt":"Wprowadzenie   Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/25   Advent of Code to inicjatywa, w której codziennie w trakcie adwentu publikowane są zadania dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkującym programistom. W tej serii artykułów pokazuję zadania opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dzień 25 zadanie 1   Dzięki robocikowi sprzątającemu udało Ci się obejść zabezpieczenia. Otwierasz drzwi prowadzące na dach, wielkie miasto ciągnie się aż po horyzont.   Nie zostało dużo czasu, to już Boże Narodzenie1 a Ty bynajmniej nie jesteś blisko Mikołaja. Może olbrzymia antena na dachu pomoże Ci nawiązać łączność? Podłączasz swój prototypowy komputer do anteny i zaczynasz transmisję. Niestety nic się nie dzieje.   Dzwonisz pod numer serwisanta znajdujący się z boku anteny i szybko opisujesz problem, mimo świąt serwisant odpowiada “nie jestem pewien jaki sprzęt podłączyłeś do tej anteny, ale potrzebuje on odpowiedniego sygnału zegara”. Tak, tak odpowiadasz zegar dał już sygnał, to już najwyższy czas. W słuchawce słyszysz odpowiedź “nie o taki sygnał chodzi, potrzebny jest sygnał zegara dla komputera anteny, taki który mówi kiedy powinien czytać dane, które chcesz wysłać. Nieskończony naprzemienny wzór z 0, 1, 0, 1, 0, 1, 0, 1…   Pytasz czy antena obsłuży sygnał zegara o częstotliwości Twojego prototypowego komputera. “Nie ma szans! Jedyna antena, która potrafi to obsłużyć znajduje się na szczycie budynku w Kwaterze Króliczka Wielkanocnego a Ty na pewno nie jesteś”, odłożyłeś słuchawkę.   Udało Ci się wyciągnąć kod assembunny anteny odpowiedzialny za generowanie sygnału zegara (wejście do programu). Wygląda na to, że jest w większości kompatybilny z kodem, który obsługiwałeś poprzednio. Dodatkową instrukcją, którą używa antena jest:      out x wysyła x (będący liczbą lub wartością rejestru) jako następną wartość sygnału zegara.   Kod pobiera pewną wartość (przechowywaną w rejestrze a), która opisuje sygnał, który powinien być wygenerowany ale nie jesteś pewien jak ta wartość jest użyta. Musisz znaleźć poprawną wartość rejestru eksperymentując.   Jaka jest najniższa dodatnia wartość rejestru a, która może być użyta do zainicjalizowania programu, która spowoduje, że wyjście do zegara będzie nieskończonym ciągiem 0, 1, 0, 1…? Program dla anteny znajduje się w tym pliku.   Podsumowanie   Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności.   Na koniec mam do Ciebie prośbę – podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na Facebooku. Do następnego razu!                 W oryginalnym Advent of Code to zadanie było opublikowane 25 grudnia. &#8617;           ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "/advent-of-code-2016-dzien-25/",
        "teaser": "/assets/images/2016/12/aoc_2016_dzien_25_artykul.jpg"
      },{
        "title": "Wyrażenia regularne część 2",
        "excerpt":"     To jest drugi artykuł na temat wyrażeń regularnych. Część zagadnień związanych z wyrażeniami regularnymi opisana jest w pierwszej części:      czym są wyrażenia regularne,   kiedy używamy wyrażeń regularnych, praktyczne wskazówki,   API wyrażeń regularnych w języku Java,   obsługa powtórzeń (+, *, ?, {}),   klasy znaków (., [], \\d, \\w, itd.),   grupy (()),   wsparcie IDE dla wyrażeń regularnych.   Zachęcam do przeczytania pierwszej części jeśli chciałbyś dowiedzieć się czegoś więcej o punktach wspomnianych powyżej. Tutaj bez zbędnego wstępu przejdę do konkretów. Na pierwszy ogień idzie zachłanność wyrażeń regularnych.     Zachłanność wyrażeń regularnych   Wyrażenia regularne są zachłanne. Oznacza to tyle, że wyrażenie regularne dopasuje największą możliwą część łańcucha znaków, która pasuje do wzorca. Najłatwiej będzie to zobaczyć na przykładzie.   @Test public void shouldBeGreedy() {     Pattern pattern = Pattern.compile(\"&lt;(.+)&gt;\");     Matcher matcher = pattern.matcher(\"&lt;em&gt;some emphasized text&lt;/em&gt;\");     assertTrue(matcher.find());     assertEquals(\"em&gt;some emphasized text&lt;/em\", matcher.group(1)); }   Powyżej widzisz standardowy przykład wykorzystywany do pokazania tej właściwości wyrażeń regularnych. Tekst, który chcemy dopasować jest kodem HTML zawierającym znacznik &lt;em&gt;1. Załóżmy, że chciałbyś wyciągnąć nazwę znacznika znajdującego się pomiędzy &lt; i &gt;.   Okazuje się, że wyrażenie regularne użyte w przykładzie powyżej nie zadziała tak jakbyś tego chciał. Zgodnie z tym co opisałem wcześniej dopasuje najwięcej tekstu jak to tylko możliwe zatem w grupie (.+) znajdzie się em&gt;some emphasized text&lt;/em.   Istnieje standardowy sposób na obejście tego typu zachowania, możesz zastosować tutaj negację grupy znaków. Wyrażenie regularne &lt;([^&gt;]+)&gt; dopasuje wszystko co znajduje się pomiędzy &lt; &gt; i nie jest znakiem &gt;.   @Test public void shouldBeAbleToCheatGreadiness() {     Pattern pattern = Pattern.compile(\"&lt;([^&gt;]+)&gt;\");     Matcher matcher = pattern.matcher(\"&lt;em&gt;some emphasized text&lt;/em&gt;\");     assertTrue(matcher.find());     assertEquals(\"em\", matcher.group(1)); }   Wyrażenia regularne działają w ten sposób, ponieważ mechanizm do obsługi powtórzeń jest zachłanny. Symbole powtórzeń {}, ?, * czy + dopasowują zawsze najwięcej jak tylko się da.   Istnieje jednak przełącznik, który zmienia to zachowanie. Jest to znak ?. Znów najlepiej będzie przeanalizować całość na przykładzie:   @Test public void shouldTurnOffGreedinessForPlus() {     Pattern pattern = Pattern.compile(\"&lt;(.+?)&gt;\");     Matcher matcher = pattern.matcher(\"&lt;em&gt;some emphasized text&lt;/em&gt;\");     assertTrue(matcher.find());     assertEquals(\"em\", matcher.group(1)); }   Jak widzisz, tym razem .+ nie pochłonął nam prawie całego łańcucha. Grupa zawiera najmniej tekstu jak to możliwe. W podobny sposób ? wyłącza zachłanność dla *:   @Test public void shouldTurnOffGreedinessForAsterix() {     Pattern pattern = Pattern.compile(\"&lt;(.*?)&gt;\");     Matcher matcher = pattern.matcher(\"&lt;em&gt;some emphasized text&lt;/em&gt;\");     assertTrue(matcher.find());     assertEquals(\"em\", matcher.group(1)); }   Z kolei w przykładzie poniżej pokazałem jak ? wpływa na {}. Chociaż wyrażenie mogłoby dopasować cały łańcuch znaków, w grupie znajdują się wyłącznie pierwsze trzy znaki (ponieważ {} nie jest tu zachłanny).   @Test public void shouldTurnOffGreadinessForCurlyBraces() {     Pattern pattern = Pattern.compile(\"(.{3,5}?)\");     Matcher matcher = pattern.matcher(\"12345\");     assertTrue(matcher.find());     assertEquals(\"123\", matcher.group(1)); }       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Alternatywa   Załóżmy, że program, który piszesz musi przetworzyć zestaw instrukcji dla samochodu, którym kieruje. Niektóre z instrukcji mówią w którą stronę należy skręcić     skręć w prawo,   skręć w lewo.   Aby przy pomocy jednego wyrażenia regularnego dopasować obie instrukcje możesz użyć alternatywy. Spójrz na przykład poniżej:   @Test public void shouldParseAlternative() {     Pattern pattern = Pattern.compile(\"skręć w (prawo|lewo)\");     Matcher matcher = pattern.matcher(\"skręć w lewo\");     assertTrue(matcher.find());     assertEquals(\"lewo\", matcher.group(1));      matcher = pattern.matcher(\"skręć w prawo\");     assertTrue(matcher.find());     assertEquals(\"prawo\", matcher.group(1)); }   Jak widzisz, wewnątrz grupy użyłem tam znaku |. Znak ten jest jednym ze znaków specjalnych. Jeśli występuje wewnątrz wyrażenia regularnego oznacza, że łańcuch znaków pasuje do wyrażenia regularnego jeśli pasuje do części znajdującej się przed znakiem | lub do części znajdującej się po znaku |.   Jeśli chcesz ograniczyć zakres alternatywy użyj nawiasów jak w przykładzie powyżej, w takim przypadku alternatywa dopasuje to co znajduje się po lewej stronie znaku | do (, lub po prawej stronie znaku | do ).   Możesz też użyć alternatywy do dopasowania więcej niż dwóch elementów oddzielając każdy z nich znakiem | jak w przykładzie poniżej:   @Test public void shouldPickOneFromMultipleAlternatives() {     Pattern pattern = Pattern.compile(\"pies|kot|lew\");     Matcher matcher = pattern.matcher(\"lew\");     assertTrue(matcher.matches());     assertEquals(\"lew\", matcher.group()); }   Grupy nieprzechwytujące   Mechanizm wyrażeń regularnych domyślnie zapamiętuje grupy, które zostały użyte w wyrażeniu regularnym. Tak zapamiętane grupy są później dostępne za pośrednictwem metody group. W większości przypadków jest to pożądane zachowanie, jednak czasami to co wyląduje w grupie nie jest dla Ciebie interesujące.   W takich przypadkach możesz użyć grupy, która nie zostanie zapamiętana. Grupa nie będzie przechwytująca jeśli pierwszymi znakami wewnątrz grupy będą ?:. Proszę spójrz na przykład poniżej:   @Test public void shouldUseNonCapturingGroups() {     Pattern pattern = Pattern.compile(\"(?:Ala|Ola) ma (kota|psa)\");     Matcher matcher = pattern.matcher(\"Ola ma psa\");     assertTrue(matcher.matches());     assertEquals(\"psa\", matcher.group(1)); }   W przykładzie tym nie interesuje nas właścicielka zwierzaka. Za to sam zwierzak jest ważny. W wyrażeniu tym użyte są dwie grupy, pierwsza nieprzechwytująca i druga, która zawiera zwierzaka.   Grupy nazwane   Grupy, których użyjemy w wyrażeniu regularnym możemy też nazwać. W takim przypadku do zawartości takiej grupy możemy odwoływać się w standardowy sposób, czyli używając indeksu, który już znasz lub poprzez nazwę. Spójrz na przykład poniżej, w którym poszczególne elementy daty zapamiętane są w nazwanych grupach:   @Test public void shouldUseNamedGroups() {     Pattern pattern = Pattern.compile(\"(?&lt;day&gt;\\\\d{2})\\.(?&lt;month&gt;\\\\d{2})\\\\.(?&lt;year&gt;\\\\d{4})\");     Matcher matcher = pattern.matcher(\"04.01.2017\");     assertTrue(matcher.matches());     assertEquals(\"04\", matcher.group(\"day\"));     assertEquals(\"04\", matcher.group(1));     assertEquals(\"2017\", matcher.group(\"year\"));     assertEquals(\"2017\", matcher.group(3)); }   Jak widziałeś w przykładzie grupy nazwane mają ?&lt;nazwa&gt; wewnątrz grupy. Następnie używając nazwa możemy dostać się do zawartości danej grupy używając metody group.   Ponowne użycie grup w wyrażeniu   Tutaj ponownie posłużę się przykładem znaczników HTML. Załóżmy, że mamy następujący kod HTML &lt;p&gt;Some paragraph &lt;em&gt;emphasized&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Other paragraph&lt;/p&gt;. Jak mógłbyś wyciągnąć tekst znajdujący się wewnątrz pary znaczników? Na przykład to co znajduje się wewnątrz pierwszej pary &lt;p&gt; i &lt;/p&gt;?   Z pomocą przychodzi tu mechanizm ponownego użycia grup wewnątrz wyrażenia regularnego. Spójrz proszę na przykład:   @Test public void shouldReuseGroupsInsideRegexp() {     Pattern pattern = Pattern.compile(\"&lt;(.+?)&gt;(.+?)&lt;/\\\\1&gt;\");     Matcher matcher = pattern.matcher(\"&lt;p&gt;Some paragraph &lt;em&gt;emphasized&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Other paragraph&lt;/p&gt;\");     assertTrue(matcher.find());     assertEquals(\"p\", matcher.group(1));     assertEquals(\"Some paragraph &lt;em&gt;emphasized&lt;/em&gt;\", matcher.group(2)); }   Jak widzisz, na samym końcu wyrażenia znajduje się \\1. Jest to nic innego jak odwołanie się do pierwszej grupy, która została dopasowana. W naszym przypadku jest to p. Podobnie możesz używać kolejnych grup używając kolejnych indeksów.   Kotwice   Nadszedł czas na kotwice. Kotwice to znaki specjalne w wyrażeniach regularnych. Kotwice służą do przekazania informacji o tym gdzie chcemy szukać dopasowania w danym łańcuchu znaków.   Na przykład do wyrażenia regularnego c$ pasują łańcuchy znaków abc czy bac ale nie pasuje cab. Innymi słowy c$ mówi, że „c powinno wystąpić na końcu łańcucha znaków”. Istnieje kilka kotwic, poniżej pokażę Ci te dwie najczęściej używane:      ^ oznacza początek łańcucha znaków,   $ oznacza koniec łańcucha znaków.   Kotwice są bardzo często używane w przypadku walidacji danych wejściowych od użytkownika. Na przykład jeśli chcemy mieć pewność, że użytkownik wprowadził tylko liczby możemy użyć wyrażenia z ^ i $.   Oczywiście można też wykorzystać metodę matches zamiast find. Różnicę pomiędzy zachowaniem tych metod wraz z użyciem kotwic pokazałem w przykładzie poniżej:   @Test public void shouldShowDifferenceBetweenFindAndMatches() {     Pattern pattern = Pattern.compile(\"\\\\d+\");     Matcher matcher = pattern.matcher(\"abc123def\");     assertTrue(matcher.find());     assertFalse(matcher.matches()); }  @Test public void shouldShowDifferenceBetweenFindAndMatchesWithAncors() {     Pattern pattern = Pattern.compile(\"^\\\\d+$\");     Matcher matcher = pattern.matcher(\"abc123def\");     assertFalse(matcher.find());     assertFalse(matcher.matches()); }   Zadanie do wykonania   W ramach zadania do wykonania aby przećwiczyć wyrażenia regularne w praktyce odeślę Cię do zadań z Advent of Code 2016. Poniżej jest lista zadań, w których możesz użyć wyrażeń regularnych. Są tam zadania o różnym poziomie trudności, na pewno znajdziesz coś dla siebie. Każde z tych zadań zawiera także przykładowe rozwiązanie:     dzień 4,   dzień 8,   dzień 10,   dzień 12,   dzień 21.   Dodatkowe materiały do nauki   Zbiór linków z dodatkowymi materiałami do nauki zebrałem w pierwszej części artykułu, jeśli chcesz dowiedzieć się więcej na temat wyrażeń regularnych zapraszam do tamtego zbioru. Jeśli chcesz, możesz także przeglądać kod źródłowy przykładów z tego artykułu, wszystkie przykłady dostępne są na githubie.   Podsumowanie   Po obu artykułach na temat wyrażeń regularnych i rozwiązaniu zadań możesz śmiało powiedzieć, że używałeś wyrażeń regularnych w praktyce :). Poznałeś większość mechanizmów dostępnych w wyrażeniach regularnych. Jednak musisz wiedzieć, że to nadal nie wszystko. Znajomość wyrażeń regularnych na poziomie opisanym w obu artykułach w zupełności wystarczy Ci do codziennej pracy.   Mam nadzieję, że ta dwuczęściowa seria przypadła Ci do gustu. Jeśli tak proszę podziel się artykułem ze znajomymi. Zależy mi na dotarciu do jak największej liczby czytelników, możesz mi w tym pomóc. Jeśli nie chcesz pominąć kolejnych artykułów zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu!                 Znacznik ten służy do wyróżnienia tekstu na stronie www. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/wyrazenia-regularne-czesc-2/",
        "teaser": "/assets/images/2017/01/06_wyrazenia_regularne_2_artykul.jpg"
      },{
        "title": "Wstęp do Gradle",
        "excerpt":"Czym jest Gradle   Starając się opisać Gradle jednym zdaniem powiedziałbym, że Gradle jest narzędziem służącym do budowania projektów1. Pozwala ono na zautomatyzowanie tego procesu. Używa się do tego tak zwanego języka domenowego – DSL (ang. Domain Specific Language), który ułatwia wykonywanie standardowych zadań związanych z budowaniem projektu.   Jeśli do tej pory miałeś styczność wyłącznie z niezbyt dużymi projektami, nad którymi pracowałeś samodzielnie prawdopodobnie nie odczuwałeś potrzeby używania narzędzi tego typu. Jednak przy większych projektach narzędzie, które pozwala na zautomatyzowanie tego procesu jest bardzo pomocne.   Inne narzędzia do budowania projektów   Oczywiście Gradle nie jest jedynym narzędziem, które pomaga przy budowaniu projektów. Wymienić tu trzeba byłoby kilka innych jak Ant, Maven, Ivy, Make czy Buildr. Oczywiście nie jest to kompletna lista.   Dodatkowo problem budowania projektu występuje w każdym języku programowania, więc analogiczne narzędzia występują także dla innych języków.   Instalacja Gradle   Gradle sam w sobie jest programem, abyś mógł go używać musisz „zainstalować” go na swoim komputerze. Najnowszą wersję Gradle możesz ściągnąć z tej strony. Następnie rozpakuj ściągnięty plik, ustaw zmienną środowiskową GRADLE_HOME, która będzie wskazywała na katalog, w którym rozpakowałeś wcześniej ściągniętą paczkę.   Następnie zmodyfikuj zmienną PATH (linux/macos) lub Path (windows), tak żeby zawierała katalog bin znajdujący się wewnątrz wcześniej ustawionego GRADLE_HOME.   Tutaj znajdziesz krótki filmik, pokazujący jak zmodyfikować zmienną Path w systemie Windows, w podobny sposób możesz dodać zmienną GRADLE_HOME.   Po takim zestawie ustawień i ponownym uruchomieniu terminala powinieneś móc wywołać polecenie gradle --version, które wypisze na konsolę informacje o Twojej wersji Gradle.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        W czym może pomóc Gradle   Jak wspomniałem wcześniej Gradle służy do budowania projektów. Pod pojęciem budowania projektów tak naprawdę kryje się cała masa drobnych czynności. Zaczynając od najbardziej podstawowych, takich jak kompilowanie kodu źródłowego czy tworzenie pliku ze skompilowanymi klasami, na przykład pliku JAR (ang. Java Archive)2.   Jednak to nie koniec, dobrze byłoby uruchomić wszystkie testy, które sprawdzają poprawność działania kodu przed utworzeniem pliku JAR. W tym także pomoże Ci Gradle. Gradle pomoże też przy zarządzaniu zależnościami projektu.   Zarządzanie zależnościami   Większe projekty bazują na zewnętrznych bibliotekach. Przykładem takich zewnętrznych bibliotek jest na przykład Hibernate, Spring czy Guava.   Zewnętrzne biblioteki dostępne są jako skompilowane klasy spakowane w pliki JAR. Można je ściągnąć z tak zwanych repozytoriów. Jednym z najczęściej używanych repozytoriów jest centralne repozytorium Maven’a.   Tak samo jak Twój projekt może zależeć od innych bibliotek, podobnie może być z tymi bibliotekami, też mogą mieć swoje zależności. Innymi słowy Twój projekt może mieć tak zwane zależności pośrednie/przechodnie. Jeśli Twój projekt wymaga wielu dodatkowych bibliotek, zarządzanie wszystkimi zależnościami (pośrednimi i bezpośrednimi) nie jest takim łatwym zadaniem.   Gradle pobiera zależności, które wskażesz (w odpowiedni sposób), zajmując się także zależnościami pośrednimi.   Konwencje   Programując w Javie (i nie tylko) dobrze jest stosować do pewnych przyjętych konwencji, które możemy spotkać w wielu projektach. Takie podejście pomaga w pracy nad różnymi projektami, wprowadza swego rodzaju porządek. Gradle także używa takich konwencji, poniżej opiszę dwie z nich, strukturę katalogów w projekcie i sposób identyfikowania projektu. Pomogą one w zrozumieniu podstaw DSL, które znajdą się w kolejnych akapitach.   Struktura projektu   Przy prostych projektach, nie ma potrzeby używania specjalnej struktury dla projektu. Jednak przy tych bardziej zaawansowanych pewna konwencja ułatwia zrozumienie tego co w danym projekcie się dzieje. Gdzie szukać plików z testami, w którym miejscu mogą znajdować się pliki z kodem źródłowym, gdzie może znajdować się plik JAR, który powstał po zbudowaniu projektu. To wszystko można osiągnąć, dzięki pewnej konwencji, która jest powszechnie stosowana w świecie projektów Java.   Proszę spójrz na przykład poniżej, pokazuje on strukturę katalogów w projekcie 01_witaj_swiecie, który stworzyłem na potrzeby tego artykułu (użyłem tu programu tree) do pokazania struktury katalogów):   $ tree . . ├── build.gradle └── src     ├── main     │   ├── java     │   │   └── pl     │   │       └── samouczekprogramisty     │   │           └── Hello.java     │   └── resources     │       └── log4j.ini     └── test         ├── java         │   └── pl         │       └── samouczekprogramisty         │           └── HelloTest.java         └── resources             └── log4j.ini   Projekt ten zawiera jedną klasę Hello, znajdującą się w pakiecie pl.samouczekprogramisty i odpowiadający jest test znajdujący się w pliku HelloTest.java. Proszę zauważ, że oba te pliki znajdują się w zupełnie różnych katalogach, odpowiednio src/main/java i src/test/java. Tego typu podejście pozwala na oddzielenie kodu aplikacji od testów.   Na produkcyjnym środowisku nie potrzebujemy testów, potrzebne są wyłącznie klasy, które zapewniają poprawne działanie aplikacji. Taki podział pozwala osiągnąć ten cel w bardzo prosty sposób.   Dodatkowo w tej strukturze znajdują się także katalogi src/main/resources i src/test/resources, zawierają one odpowiednio konfigurację dla właściwej aplikacji i konfigurację dla testów.   Bezpośrednio w katalogu projektu znajduje się plik build.gradle, który zawiera informacje jak budować taki projekt.   Unikalna identyfikacja projektu   Przed powstaniem Gradle do budowania projektu używałem między innymi Maven’a. Wraz z Maven’em używanym na szerszą skalę rozpowszechniło się pewne standardowe nazewnictwo, które pozwala jednoznacznie zidentyfikować projekt. Służy do tego trójka:     groupId,   artifactId,   version.   Gradle także używa tej trójki, jednak pod troszkę innymi nazwami, są to odpowiednio group, name i version.   group to pierwszy identyfikator. Konwencja zakłada, że zaczynał się on będzie od odwróconej domeny, podobnie jak package w klasach. Do odwróconej domeny można dołączyć dodatkowe człony, które dokładniej specyfikują „grupę” projektu. W przypadku samouczka może to być pl.samouczekprogramisty czy pl.samouczekprogramisty.kursjava.   name to drugi identyfikator, jest on częścią finalnej nazwy pliku JAR ze skompilowanymi klasami. W przypadku projektu, z przykładami do kursu Java na Samouczku name może mieć wartość examples czy code-samples.   version określa wersję projektu. Standardowo wersję określa się przez trójkę liczb oddzielonych kropkami na przykład 1.0.0 czy 5.0.12. Dodatkowo jeśli jest to wersja deweloperska można do niej dołączyć -SNAPSHOT uzyskując 1.0.0-SNAPSHOT.   Finalnie nazwa pliku JAR ze skompilowanymi klasami będzie składała się z name i version oddzielonych minusem, na przykład code-samples-1.0.0-SNAPSHOT.jar, czy examples-5.0.12.jar.   Podstawy Gradle DSL   Gradle do działania potrzebuje konfiguracji. Domyślnie konfigurację umieszcza się w pliku build.gradle. Wewnątrz tego pliku możemy umieszczać komendy, które następnie zostaną wykonane przez gradle. Poniżej pokażę kilka podstawowych konstrukcji dostępnych w DSL dostarczonym przez Gradle.   Zadania   Gradle działa w oparciu o zadania. Wewnątrz nich definiujemy co tak naprawdę gradle powinien zrobić. Na przykład zadaniem może być utworzenie pliku JAR czy uruchomienie testów. Zadania te definiujemy wewnątrz pliku build.gradle. Poniższy przykład pokazuje prosty plik, który zawiera wyłącznie jedno zadanie buildJar, wypisujące na konsolę odpowiedni komunikat:   task buildJar {     println 'now I am building JAR file, in theory' }   Jeśli następnie uruchomisz gradle poleceniem gradle -q buildJar na konsoli pokaże się napis now I am building JAR file, in theory. Gratuluję, właśnie uruchomiłeś swój pierwszy plik konfigurujący budowanie projektu, co prawda niewiele on jeszcze robi, ale od czegoś trzeba zacząć :).   Zależności między zadaniami   Gradle pozwala także na wprowadzanie zależności pomiędzy zadaniami. Dzięki temu mechanizmowi możemy określić kolejność, w której zadania powinny być uruchamiane. Na przykład przed zbudowaniem pliku JAR uruchom testy jednostkowe.   Proszę spójrz na przykład poniżej, który rozbudowuje poprzedni fragment:   task runAllTests {     println 'now I am checking if all tests are passing, in theory' }  task buildJar(dependsOn: runAllTests) {     println 'now I am building JAR file, in theory' }   Uruchamiając gradle poleceniem gradle -q buildJar na konsoli pokaże się   now I am checking if all tests are passing, in theory now I am building JAR file, in theory   Program gradle   Teraz trochę wyjaśnień, gradle -q buildJar, uruchamia zadanie buildJar zdefiniowane w pliku build.gradle. Przełącznik -q (lub --quiet) wyłącza część informacji wypisywanych na konsolę. Teraz przeanalizuję wyjście komendy z przełącznikiem --console=verbose, który pokazuje trochę więcej informacji:   $ gradle buildJar --console=verbose  &gt; Configure project : now I am checking if all tests are passing, in theory now I am building JAR file, in theory  &gt; Task :runAllTests UP-TO-DATE &gt; Task :buildJar UP-TO-DATE  BUILD SUCCESSFUL in 0s   Pierwsza linijka informuje o przygotowaniu gradle do pracy. Kolejne dwie to komunikaty, które znasz. Pod spodem pokazana jest informacja o stanie dwóch uruchomionych zadań. Zauważ, że Gradle uwzględnił zależności pomiędzy zadaniami – uruchomił runAllTests przed buildJar, tak jak było to zdefiniowane w build.gradle. Ostatnia linijka informują o tym, że proces budowania się powiódł i ile trwał.   Wtyczki   Gradle wspiera tak zwane wtyczki. Zawierają one zestaw gotowych zadań, które możesz uruchamiać. Przykładem takiej wtyczki jest java, która zawiera zestaw zadań przydatnych przy projektach. Wtyczki dodajemy w pliku build.gradle w następujący sposób:   apply plugin: 'java'   Można też je dodać stosując trochę inny zapis:   plugins {     id 'java' }   Załóżmy, że plik build.gradle zawiera wyłącznie tę linijkę. Zobacz co zostanie wypisane na konsolę po uruchomieniu gradle build --console=verbose (build jest jednym z zadań udostępnionych przez wtyczkę):   $ gradle build --console=verbose &gt; Task :compileJava NO-SOURCE &gt; Task :processResources NO-SOURCE &gt; Task :classes UP-TO-DATE &gt; Task :jar UP-TO-DATE &gt; Task :assemble UP-TO-DATE &gt; Task :compileTestJava NO-SOURCE &gt; Task :processTestResources NO-SOURCE &gt; Task :testClasses UP-TO-DATE &gt; Task :test NO-SOURCE &gt; Task :check UP-TO-DATE &gt; Task :build UP-TO-DATE  BUILD SUCCESSFUL in 0s 1 actionable task: 1 up-to-date   Widzisz jakie zadania zostały uruchomione? Cała masa ;). Na przykład kompilowanie kodu (:compileJava), kompilowania testów (:compileTestJava), uruchomienia testów (:test) czy budowanie pliku JAR (:jar).   Także w tym przypadku widać jak Gradle rozstrzyga zależności pomiędzy zadaniami zdefiniowanymi przez wtyczkę. Mimo tego, że uruchomiłem zadanie build, wcześniej uruchomiona została seria zadań, od których zależy build.   Zależności   Wspomniałem o tym, że Gradle pomaga w zarządzaniu zależnościami – tym razem chodzi o zależności od innych projektów. Tutaj także z pomocą przychodzi wtyczka java.   Pozwala ona na określenie repozytoriów z których powinny być ściągane zależności. Na przykład poniższy fragment poinstruuje gradle aby użył domyślnego repozytorium Maven’a:   repositories {     mavenCentral() }   Następnie możemy już opisywać zależności jak w przykładzie poniżej:   dependencies {     compile group: 'com.google.guava', name: 'guava', version: '27.0-jre' }   Powyższa sekcja mówi, że nasz kod potrzebuje w trakcie kompilacji innej biblioteki. W tym przypadku jest to biblioteka guava w wersji 27.0-jre. Gradle pozwala też na troszkę krótszy zapis. Poniższy przykład da dokładnie ten sam efekt co poprzedni:   dependencies {     compile 'com.google.guava:guava:27.0-jre' }   Słówko compile w powyższych przykładach mówi o tym, w jakiej sytuacji będziemy potrzebowali tej zależności. Mówimy w tym przypadku o obszarze (ang. scope) gdzie dana zależność będzie używana. Na początku wystarczy abyś wiedział, że istnieje wiele takich obszarów, najczęściej używane z nich to compile i testCompile. Ten drugi określa zależności używane i dostępne wyłącznie w trakcie testów. W bardziej zaawansowanych przypadkach gradle pozwala na tworzenie swoich własnych obszarów.   Poniższy przykład pokazuje jak może wyglądać przykładowy plik build.gradle z wieloma zależnościami:   apply plugin: 'java'  repositories {     mavenCentral() }  dependencies {     compile 'com.google.guava:guava:27.0-jre'     testCompile 'junit:junit:4.12' }   Program gradle pozwala na wypisane wszystkich zależności możesz to zrobić uruchamiając gradle dependencies.   Wiesz, że poznałeś właśnie nowy język?   Tak naprawdę, Gradle w pliku konfiguracyjnym do projektu używa języka skryptowego Groovy. Język domenowy, którego używa się w pliku build.gradle jest na tyle rozbudowany, że w większości przypadków nie będzie potrzeby używania języka Groovy, jednak pamiętaj o tym, kiedy będziesz chciał zrobić coś nietypowego (na przykład wysłać SMS-a do siebie jeśli testy nie będą przechodziły, chociaż jak znam życie, ktoś już napisał wtyczkę, która to robi i możesz jej użyć bazując wyłącznie na DSL udostępnionym przez tę wtyczkę). W rzeczywistości sam DSL także jest poprawnym kodem Groovy ;).   Od wersji 5.0 Gradle pozwala także na użycie języka Kotlin do pisania skryptów budowania.   Projekty Gradle w IntelliJ IDEA.   IntelliJ IDEA domyślnie wspiera projekty budowane przy pomocy Gradle. Poniżej pokazuję sposób w jaki możesz założyć przykładowy projekt. Aby to zrobić wybierz z menu File, New i następnie Project. Pokaże Ci się się następujące okienko.             Gradle nowy projekt IntelliJ IDEA        Zaznaczasz gradle i klikasz next. Kolejne okienko, to nic innego jak uzupełnienie wcześniej omówionych groupId, artifactId i version, które będą identyfikowały Twój projekt:             Gradle nowy projekt IntelliJ IDEA        Kolejny ekran to informacja dla IntelliJ IDEA jak powinien nazywać się projekt, domyślnie uzupełnia to pole wartością artifactId oraz gdzie na dysku projekt, powinien być utworzony.             Gradle nowy projekt IntelliJ IDEA        Po przejściu przez tę serię kroków IntelliJ IDEA utworzy pusty projekt wraz z plikiem build.gradle. Warto jest rzucić okiem na to co się w nim znajduje.   Plik build.gradle utworzony przez IntelliJ IDEA   Poniżej znajduje się plik build.gradle, który utworzył za mnie IntelliJ IDEA.   plugins {     id 'java' }  group 'pl.samouczekprogramisty' version '1.0-SNAPSHOT'  sourceCompatibility = 1.8  repositories {     mavenCentral() }  dependencies {     testCompile group: 'junit', name: 'junit', version: '4.12' }   Pierwszy blok włącza wtyczkę do obsługi Javy.   Kolejne dwie linijki informują o grupie i wersji – dwóch komponentach pozwalających na unikalną identyfikację projektu. Atrybut name został pominięty, przyjmuje on wartość domyślną czyli nazwę katalogu, w którym znajduje się projekt.   Ta linijka wymaga trochę szerszego omówienia. Java ewoluowała, na przestrzeni lat pojawiały się kolejne wersje. Wersje te wprowadzały pewne konstrukcje językowe, które nie były dostępne wcześniej. sourceCompatibility informuje kompilator javac (poprzez przełącznik -source) jakiej wersji Javy trzeba użyć do kompilowania klas z kodem.   Kolejny blok mówi o repozytoriach, z których powinny być ściągane zależności. Jak widzisz IntelliJ IDEA domyślnie zakłada, że korzystali będziemy z centralnego repozytorium Maven’a.   Ostatni blok specyfikuje zależności, domyślnie występuje tylko jedna zależność dostępna w trakcie kompilowania testów (testCompile), jest to biblioteka JUnit w wersji 4.12.   Podsumowanie   Po przeczytaniu artykułu dowiedziałeś się podstaw o Gradle. Wiesz już czym są zadania, jak łączyć je między sobą. Utworzyłeś swój pierwszy projekt w Gradle w IntelliJ IDEA. Przeczytałeś o konwencjach stosowanych w większych projektach programistycznych.   Temat bynajmniej nie jest wyczerpany. W kolejnych artykułach, bez wstępu, któremu poświęcony jest ten artykuł skupię się na omawianiu bardziej zaawansowanych możliwości Gradle. Możesz na przykład zajrzeć do artykułu opisującego pierwszy projekt z Gradle.   Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do mojego newslettera i polub Samouczka na Facebook’u.   Na koniec mam do Ciebie standardową prośbę, podziel się linkiem do artykułu ze znajomymi, zależy mi na dotarciu do jak największej liczby zapaleńców chcących uczyć się i doskonalić w programowaniu :). Do następnego razu!                 Oczywiście z racji swoje elastyczności Gradle może być użyte także w wielu innych przypadkach, jednak to budowanie projektów jest tym standardowym. &#8617;                  Programy, które napiszemy pakowane są w paczki, tego typu paczki używane są do uruchamiania programów w środowisku produkcyjnym. &#8617;           ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "/wstep-do-gradle/",
        "teaser": "/assets/images/2017/01/19_wstep_do_gradle_artykul.jpg"
      },{
        "title": "XML dla początkujących",
        "excerpt":"Czym jest XML   XML (ang. Extensible Markup Language) to specyfikacja zapisu danych, która została opracowana w 1998 roku przez W3C (ang. World Wide Web Consortium). Jest to format tekstowy, który pozwana na zapisywanie danych w postaci, która jest łatwa do odczytu zarówno przez maszyny jak i przez ludzi1.   Aby dane w formacie XML uważano za poprawne muszą one mieć pewną strukturę, proszę spójrz na przykład poniżej, który pokazuje poprawne dane w formacie XML:   &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; &lt;kurs-java&gt;     &lt;artykul publikacja=”2017-03-01”&gt;         &lt;tytul&gt;Wprowadzenie do XML w Javie&lt;/tytul&gt;         &lt;autor&gt;Marcin Pietraszek&lt;/autor&gt;      &lt;/artykul&gt;      &lt;artykul&gt;          &lt;!-- do uzupelnienia --&gt;      &lt;/artykul&gt;     &lt;opis status=”do uzupelnienia”/&gt;     &lt;wydawca:opis&gt;Zestaw artykułów dotyczących programowania w języku Java&lt;/wydawca:opis&gt; &lt;/kurs-java&gt;   Przykładowy dokument powyżej może służyć do opisu kursu programowania Java znajdującego się na Samouczku. Równie dobrze możesz stworzyć plik, który zawierał będzie informacje na temat pogody, stopni w szkole czy jakiegokolwiek innego tematu.   Opis formatu XML   Dokument XML składa się z zagnieżdżonych elementów. Są one zapisywane jako znaczniki w postaci &lt;znacznik&gt;&lt;/znacznik&gt;.   Na początek drobna dygresja na temat węzłów i elementów. Czytając inne źródła po polsku na temat XML natkniesz się na nazwę węzeł. Sam próbując znaleźć poprawny odpowiednik w języku polskim nie znalazłem zbyt wielu wzmianek o węzłach (ang. node) w specyfikacji. Specyfikacja opisuje elementy (ang. element). Dlatego w tym artykule posługiwał będę się wyłącznie określeniem element. Z racji tego, że XML ma strukturę drzewiastą, a w “pracy z drzewami” mówi się o węzłach często też ten termin używany jest w odniesieniu do elementów dokumentu XML.   Element główny   Każdy poprawny dokument XML musi mieć wyłącznie jeden element główny (ang. root element). W przykładzie powyżej jest to element &lt;kurs-java&gt;.   Zawartość elementów   Elementy wewnątrz mogą zawierać treść. Na przykład wewnątrz elementu &lt;tytul&gt; znajduje się treść Wprowadzenie do XML w Javie.   Elementy wewnątrz mogą zawierać kolejne elementy. Na przykład element &lt;artykul&gt; zawiera wewnątrz elementy &lt;tytul&gt; i &lt;autor&gt;. Można to porównać do drzewa gdzie z jednego pnia (elementu głównego) wyrasta kilka gałęzi (elementów zagnieżdżonych), zakończonych liśćmi. W praktyce mówiąc o liściach dokumentu XML mamy na myśli właśnie te najbardziej zagnieżdżone elementy. W naszym przykładzie będą to na przykład &lt;tytul&gt; czy &lt;autor&gt;.   Atrybuty   Elementy mogą posiadać dowolną liczbę atrybutów. Za przykład mogą posłużyć tu element &lt;artykul&gt; zawierający atrybut publikacja. Zawartość atrybutu to zwykły tekst. W przeciwieństwie do elementów nie możemy stosować “zagnieżdżania” – wewnątrz atrybutu nie możemy umieścić niczego poza jego wartością.   Przestrzenie nazw   Nazwy elementów elementów i atrybutów mogą zawierać tak zwaną “przestrzeń nazw” (ang. namespace). Do oddzielenia nazwy elementu czy atrybutu od przestrzeni nazw używa się dwukropka. W przykładzie powyżej element &lt;wydawca:opis&gt; pochodzi z przestrzeni nazw wydawca.   Przestrzenie nazw stosuje się aby móc odróżnić znaczenie elementów o tej samej nazwie. W przykładzie elementy &lt;opis&gt; i &lt;wydawca:opis&gt; mogą zawierać zupełnie różne dane – różne rodzaje opisów.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Komentarze   Wewnątrz dokumentu XML możesz umieszczać komentarze. W przykładzie powyżej komentarz to &lt;!-- do uzupelnienia --&gt;. Wszystko co znajduje się pomiędzy &lt;!-- i --&gt; uważane jest jako komentarz.   Prolog   Dokument XML powinien zawierać prolog. Częścią prologu jest deklaracja &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; zawiera ona informację o wersji XML, której używamy. Może także wskazać kodowanie znaków jakie zostało użyte w danym dokumencie. Wewnątrz prologu mogą znajdować się także deklaracje DTD (ang. Document Type Declaration) opisujące dany dokument. W opisie tym możemy na przykład określić, że element &lt;artykul&gt; powinien zawsze zawierac element &lt;autor&gt;.   Pozostałe wymagania dotyczące formatu   Każdy element musi się poprawnie zamykać. Na przykład &lt;autor&gt;Marcin Pietraszek&lt;/autor&gt;. Jeśli element nie ma treści, bądź innych zagnieżdżonych elementów zamyka się go w następujący sposób &lt;opis status=\"do uzupelnienia\"/&gt;.   Elementy powinny być poprawnie zagnieżdżone. Łatwiej będzie mi to wytłumaczyć na przykładzie. Poniżej możesz zobaczyć niepoprawny fragment dokumentu XML:   &lt;artykul&gt;    &lt;tytul&gt;        &lt;autor&gt;    &lt;/tytul&gt;        &lt;/autor&gt; &lt;/artykul&gt;   Zauważ, że element tytul zamknięty jest przed elementem autor. Jest to niepoprawny sposób zagnieżdżania elementów. Możemy powiedzieć, że elementy, które nie są poprawnie zagnieżdżone “nachodzą” na siebie.   Białe znaki pomiędzy elementami są ignorowane. W praktyce często używa się znaków tabulacji czy spacji do robienia “wcięć”. Dzięki temu tak sformatowane dokumenty są bardziej czytelne.   Rodzice, dzieci i rodzeństwo a XML   W przypadku poprawnie sformatowanych dokumentów XML możemy mówić o pewnych relacjach pomiędzy elementami. Specyfikacja XML mówi o rodzicach (ang. parent) i dzieciach (ang. child). W praktyce używa się także określenia rodzeństwo (ang. sibling).   Element może mieć wiele dzieci, na przykład element &lt;kurs-java&gt; ma czworo dzieci – dwa elementy &lt;artykul&gt;, element &lt;opis&gt; i element &lt;wydawca:opis&gt;.   Każdy element, poza elementem głównym, posiada dokładne jednego rodzica. Na przykład element &lt;tytul&gt; ma rodzica &lt;artykul&gt;.   Każdy element, poza elementem głównym, może mieć rodzeństwo. Na przykład rodzeństwem dla elementu &lt;artykul&gt; jest kolejny element &lt;artykul&gt;, &lt;opis&gt; i &lt;wydawca:opis&gt;.   Walidacja dokumentów XML   Jak widzisz w dokumencie XML możemy zawrzeć praktycznie wszystko. Liczba dostępnych formatów jest nieskończona. W związku z tym istnieją różne mechanizmy pozwalające na sprawdzenie poprawności dokumentów XML.   Za przykład mogą tu posłużyć wspomniane wcześniej elementy DTD (ang. Document Type Definition) znajdujace się wewnątrz dokumentu XML.   Innym sposobem na sprawdzenie poprawnej struktury dokumentu XML jest używanie XSD (ang. XML Schema Definition). Jest to zewnętrzny plik, który także jest w formacie XML. Wewnątrz tego pliku możemy dokładnie określić strukturę jaką powinien mieć inny dokument XML.   Dzięki takiej walidacji możemy na przykład zastrzec, że zawsze wewnątrz elementu &lt;artykul&gt; musi znajdować się element &lt;tytul&gt; a element &lt;autor&gt; jest opcjonalny.   Wady i zalety formatu XML   Główną zaletą pracy z dokumentami XML jest to, że istnieje mnóstwo narzędzi pozwalających na ich przetwarzanie. Dokumenty te są w miarę czytelne dla człowieka. Z łatwością format ten może służyć do wymiany informacji pomiędzy różnymi programami.   Niestety nie jest to format idealny. Przy pracy z dużymi plikami XML przekonasz się, że wcześniej wspomniana czytelność nie jest już tak oczywista. Ponadto pliki XML są dość “rozwlekłe”. Z racji konieczności zamykania każdego elementu, znaczników w dokumencie XML jest dużo i często to one znacząco zwiększają ostateczną wielkość dokumentu.   Ponadto dokumenty bardziej czytelne dla człowieka automatycznie zajmują więcej miejsca. To człowiek potrzebuje wcięć w dokumencie XML, dla programu używającego plików XML takie wcięcia są zbędne.   Zastosowanie dokumentów w formacie XML   Z racji swojej dobrze zdefiniowanej struktury i ogromnego zestawu narzędzi dokumenty w formacie XML są bardzo popularne. Dedykowane narzędzia do pracy z XML dostępne są w wielu językach programowania. Dokumenty w formacie XML świetnie nadają się do zapisywania wszelkiego rodzaju ustawień.   Poniżej pokażę Ci kilka przykładowych zastosowań dokumentów w formacie XML:      “poprzednik” opisanego przeze mnie Gradle’a – Maven używa XML w swoich plikach konfiguracyjnych - na przykład settings.xml, profiles.xml czy plugin-registry.xml. Główny plik konfiguracyjny dla projektu to także dokument XML – pom.xml,   w jednym z banków, w którym pracowałem dokumenty XML wraz z XSLT służyły do generowania wszystkich drukowanych dokumentów,   każda aplikacja na system Android używa plików XML. W uproszczeniu można powiedzieć, że opisują one wygląd ekranu aplikacji,   dokumenty ODT (format używany na przykład przez Open Office), czy DOCX (format używany przez Microsoft Word) to tak naprawdę pliki zip, które wewnątrz zawierają dokumenty XML opisujące zawartość pliku, rozpakuj je a sam się przekonasz :)   Na XML świat się nie kończy   Oczywiście dokumenty XML nie są jedynym formatem, który może pomóc w wymianie danych. Poniżej wspominam o kilku innych formatach, które mogą być także użyte w tym celu.     CSV – (ang. Comma Separated Values) zwykły plik tekstowy, w którym każdy wiersz zawiera dane oddzielone przecinkami2. Z racji tego, że jest to plik tekstowy można go z łatwością odczytać używając edytora tekstu.   YAML – (ang. Yet Another Markup Language lub YAML Ain’t Markup Language) tekstowy format, w którym możemy zapisywać bardziej złożone struktury czy kolekcje.   JSON – (ang. JavaScript Object Notation) podobnie jak YAML jest w stanie opisać listę elementów czy kolekcję par klucz-wartość. Format ten, jak jego nazwa wskazuje, powstał na potrzeby JavaScript, jednak obecne jest szeroko stosowany także w innych językach. Jest to format tekstowy.   Oczywiście poza formatami tekstowymi istnieją też formaty binarne:     ProtocolBuffers – binarny format opracowany przez Google. Pozwala na zapisanie praktycznie dowolnych struktur. Z racji tego, że jest to format binarny jest bardziej “zwięzły” od wspomnianych powyżej. Oczywiście nie można odczytać tego formatu bez odpowiedniego “dekodowania” zawartości,   Avro – binarny format serializacji danych, podobnie jak ProtoclBuffers zapewnia dużo bardziej zwięzłą reprezentację danych. Ma wbudowany mechanizm kompresji co pozwala na jeszcze większe zmniejszenie objętości dokumentów.   Bynajmniej nie są to wszystkie dostępne formaty wymiany danych. Wspomniałem o tych kilku aby pokazać Ci, że na XML świat się nie kończy :) Każdy z tych formatów dorobił się szerokiego wsparcia w różnych językach programowania.   Inne specyfikacje i narzędzia związane z XML   XML jako dość dojrzały format zapisu danych “dorobił się” zestawu narzędzi i specyfikacji. Na początek ten zestaw może okazać się przytłaczający, ale spokojnie – nie wszystkich tych narzędzi używa się w każdym projekcie. W większości przypadków wystarczy wiedza o poprawnym formacie dokumentu XML i znajomość jednego z narzędzi do tworzenia/czytania plików XML.   Lista poniżej to specyfikacje/narzędzia pozwalające na parsowanie i tworzenie plików w formacie XML:      DOM (ang. Document Object Model),   SAX (ang. Simple API for XML),   StAX (ang. Streaming API for XML),   JAXB (ang. Java Architecture for XML Binding).   W jednym z klejnych artykułów skupię się na praktycznym wykorzystaniu powyższych narzędzi.   Dodatkowo możesz też zainteresować się następującymi specyfikacjami związanymi z XML. Przydają się one w bardziej zaawansowanej pracy z dokumentami XML:      XSD (ang. XML Schema Definition) – wcześniej wspomniana specyfikacja pomagająca w sprawdzeniu poprawności dokumentów XML,   XPath (ang XML Path Language) – język pozwalający na wskazywanie elementów czy atrybutów w dokumencie XML, przy jego pomocy możesz na przykład określić “zwróć mi wszystkie elementy X, które mają atrybut Y o wartości Z”,   XSLT (ang. Extensible Stylesheet Language Transformations) – język służący do tranformowania dokumentów XML. Przy jego pomocy można przekształcić dokument XML do innych formatów, na przykład do pliku PDF.   Podsumowanie   Po przeczytaniu artykułu wiesz już czym jest XML. Poznałeś część dozwolonych konstrukcji, wiesz czym są elementy i jak wygląda poprawnie sformatowany dokument XML. Potrafisz wskazać praktyczne zastosowania tego formatu, znasz też kilka jego zalet i wad. Przed Tobą użycie XML w praktyce, ale to już temat na kolejny artykuł :).   Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do mojego newslettera i polub Samouczka na facebooku.   Na koniec mam do Ciebie standardową prośbę, podziel się linkiem do artykułu ze znajomymi, zależy mi na dotarciu do jak największej liczby samouków, którzy chcą pogłębiać swoją wiedzę. Do następnego razu!                 Moim zdaniem skomplikowane pliki XML w cale nie są czytelne dla ludzi, ale to już temat na osobną dyskusję ;). &#8617;                  Istnieją też inne wersje gdzie przecinek zastąpiony jest średnikiem czy znakiem tabulacji. &#8617;           ","categories": ["Wiedza ogólna","DSP2017"],
        "tags": [],
        "url": "/xml-dla-poczatkujacych/",
        "teaser": "/assets/images/2017/03/02_xml_dla_poczatkujacych_artykul.jpg"
      },{
        "title": "Projekt Pogodynka – wprowadzenie",
        "excerpt":"Opis architektury   Więc pracę nad Pogodynką czas zacząć. Zacznę od tego, że przybliżę Ci moje plany dotyczące zakresu projektu.   Hardware   Stare Raspberry PI (nazwijmy je Malinką ;)) wygrzebane gdzieś z szafy ma posłużyć jako “mini komputer”, do którego podłączę czujnik temperatury. Czujnik ten będę musiał sam oprogramować – kupiłem go jakiś czas temu w sklepie dla elektroników.             Pogodynka – Raspberry Pi        Jak widzisz czujnik jest całkiem drobny.             Czujnik temperatury        Całość na początku połączę kabelkami, może jak starczy czasu pobawię sę w lutowanie a może nawet w wytrwawienie swojej płytki. Czas pokaże :)       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Software   Kolejnym krokiem będzie napisanie prostego programu, który będzie odpalany na Malince. Nazwijmy go Termometrem. Zadaniem programu będzie pobieranie odczytu czujnika – odczytanie aktualnego poziomu temperatury. Następnie to wskazanie chcę wysłać do aplikacji webowej, która doda dany odczyt do bazy.   Ta sama aplikacja webowa odpowiedzialna będzie za udostępnienie dodatkowego interfejsu. Interfejs ten będzie udostępniał historię wskazań temperatury.Więc na tym etapie mamy dwie osobne aplikacje. Pierwsza z nich to Termometr uruchamiany z linii poleceń, bez żadnego interfejsu graficznego. Druga z nich to aplikacja webowa, która udostępni interfejs dodawania wskazania temperatury oraz pobrania historii odczytów. Tu także nie będzie żadnego interfejsu graficznego.   Ostatnim etapem będzie interfejs użytkownika, który będzie prezentował historyczne odczyty w formie grafów. Tu też pojawią się trudności – ten etap to aplikacja napisana w JavaScript, za którym niestety nie przepadam ;)   Składając te klocki w całość projekt można pokazać na takim uproszczonym diagramie.             Pogodynka – diagram architektury        Wymyśliłem taką architekturę, ponieważ nie mam publicznego IP i nie mógłbym aplikacji webowej “wystawić na świat” jeśli uruchomiona byłaby na Malince.   Tutaj drobna dygresja dla początkujących. Każda strona internetowa, na przykład www.samouczekprogramisty.pl utrzymywana jest na serwerze. Serwer ten ma tak zwany adres IP. Upraszczając możemy powiedzieć, że jest to jakaś liczba. Istnieje mechanizm, który pozwala na “tłumaczenie” adresu strony internetowej na adres IP, nazywa się on DNS (ang. Domain Name System). Dzięki temu nie musimy zapamiętywać liczb żeby zobaczyć stronę internetową. Wystarczy, że pamiętamy jej adres. Publiczny adres IP to nic innego jak taki numer, który jest stały. Dzięki temu, że adres IP się nie zmienia mapowanie adresu strony na adres IP zawsze jest poprawne.   Baza danych   Nasze dane to nic innego jak standardowe szeregi czasowe (ang. time series). Istnieją dedykowane bazy danych, które bardzo dobrze dają sobie radę z danymi tego typu. Jednak żeby niepotrzebnie nie komplikować samej aplikacji dane będą zapisywane w najzwyklejszej relacyjnej bazie danych. Zdaję sobie sprawę, że z czasem danych może być sporo – jednak baza relacyjna powinna dać sobie z taką ilością bez problemu radę.   Zakładając odczyty temperatury co 5 minut dopiero po prawie dziesięciu latach dojdziemy do miliona rekordów ;). Oczywiście interfejs zwracający historię, będzie musiał dokonywać pewnego rodzaju agregacji, ale o tym będę decydował później.   Postęp prac   Cały postęp prac nad projektem wraz z zadaniami, które będę realizował możesz śledzić w Trello: https://trello.com/b/yqZHTqSN/pogodynka. Jest to proste narzędzie pomagające w śledzeniu zadań. W “prawdziwych” projektach programistycznych też używa się takich narzędzi, czasami dużo bardziej rozbudowanych.   Zacząłem od tego, że pół nocy spędziłem na próbie zmuszenia Malinki do współpracy, oczywiście się to nie udało ;). Więc żeby pchnąć całość do przodu zacząłem od innego komponentu – Termometru.   Jeśli jesteś zainteresowany postępem prac nad kodem zachęcam do zajrzenia do repozytorium: https://github.com/SamouczekProgramisty/Pogodynka. Aktualnie znajduje się tam zestaw kilku obiektów, które reprezentują pomiar temperatury. Pomiar ten jest transformowany do formatu JSON i wysyłany jako żądanie HTTP.   Testy   Do testowania całego rozwiązania, poza testami jednostkowymi, użyłem usługi http://requestb.in, która pozwala na sprawdzanie wysyłanych żądań. Wygląda na to, że całość działa. Brakuje tu oczywiście warstwy uwierzytelniania. Nie chcę, żeby każdy mógł wysłać żądanie na adres, który będzie akceptował odczyty temperatury.   Podsumowanie   Na koniec możesz zadać sobie pytanie. Do czego jest MI to potrzebne? Po co mam czytać tę serię artykułów? Pytania są jak najbardziej zasadne. Wydaje mi się, że mam też na te pytania dobrą odpowiedź ;). Moim zdaniem nie ma lepszego sposobu nauki programowania, niż na rzeczywistych problemach, które pojawiają się właśnie w takich projektach. Poza tym każdy programista w swoim życiu więcej kodu czyta niż pisze :).   Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do mojego newslettera i polub Samouczka na facebooku.   Na koniec mam do Ciebie standardową prośbę, podziel się linkiem do artykułu ze znajomymi, zależy mi na dotarciu do jak największej liczby samouków, którzy chcą pogłębiać swoją wiedzę. Do następnego razu!  ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/projekt-pogodynka-wprowadzenie/",
        "teaser": "/assets/images/2017/03/04_pogodynka_01_artykul.jpeg"
      },{
        "title": "Java z linii poleceń",
        "excerpt":"Java z poziomu linii poleceń   Dzisiaj na przekór moim wszystkim radom, proszę Cie nie korzystaj z IDE. Wyłącz IntelliJ Idea czy Eclipse. Przejdź przez cały artykuł używając wyłącznie podstawowego edytora tekstu. Moim celem jest przeprowadzenie Cię przez cały proces pisania kodu w Javie używając podstawowych narzędzi.   Moim zdaniem takie podejście pozwoli Ci zrozumieć te podstawy, na których opiera się cała reszta. W moim przypadku, dużo łatwiej jest mi pojąć bardziej skomplikowane rzeczy jeśli dokładnie wiem jak działają podstawowe klocki, których używa się do budowania tych bardziej skomplikowanych elementów.   Dzisiaj używał będę programu gedit, pracując w systemie Windows możesz użyć standardowego systemowego notatnika. Istotne jest to, aby program ten był w stanie utworzyć zwykły plik tekstowy, któremu nadasz rozszerzenie java.   Narzędzia dostępne w JDK   O tym czym jest JDK i czym różni się od JRE pisałem w jednym z pierwszych artykułów na blogu – o przygotowaniu środowiska programisty. Dowiesz się też tam jak zainstalować JDK. Dzisiaj będą dla Ciebie istotne trzy programy. java dostarczana jest wraz z JRE, javac i jar dostępne są wyłącznie w JDK:     java uruchamia maszynę wirtualną, wywołując metodę main w odpowiedniej klasie,   javac to kompilator, który jest w stanie utworzyć plik class z pliku java,   jar to narzędzie, które jest w stanie tworzyć pliki jar.         Programy javac, java czy jar dostępne są w katalogu, w którym jest zainstalowane JDK. W zależności od systemu operacyjnego katalog ten może być różny. W niektórych systemach operacyjnych po instalacji programy te od razu dostępne są na ścieżce przeszukiwania. Innymi słowy dostępne są w jednym z katalogów wskazanych przez zmienną środowiskową PATH.   Jeśli w Twoim przypadku katalog gdzie zainstalowałeś JDK nie znajduje się w zmiennej środowiskowej PATH wówczas każdy z tych programów będziesz musiał poprzedzać pełną ścieżką. Na przykład:      C:\\Program Files\\Java\\jdk1.8.0_16\\bin\\javac   /home/mapi/custom/path/jdk/bin/javac   Na dłuższą metę wygodniej jest ustawić odpowiednią wartość zmiennej PATH. Szczegółową instrukcję jak to zrobić znajdziesz pod tym adresem.     Pierwsza klasa w notatniku   Zacznijmy od początku, od programu wyświetlającego Twoje imię na konsoli. Będzie to zwykła klasa o nazwie DisplayName w pakiecie domyślnym, która będzie miała metodę public static void main(String ... args). Wewnątrz tej metody wpisz instrukcję, która wypisze Twoje imię. Spróbuj napisać ten program bez IDE i zapisz go w pliku z rozszerzeniem java.   Dla mnie takie ćwiczenia na początku były dość trudne, pokazywały jak ważne i pomocne jest IDE w codziennej pracy. Mam nadzieję, że Tobie też pomoże to uświadomić.   Po tym wszystkim powinieneś mieć plik DisplayName.java, który będzie wyglądał podobnie do przykładu poniżej:   public class DisplayName {     public static void main(String ... args) {         System.out.println(“Marcin”);     } }   javac – skompiluj swoją klasę   I teraz dochodzimy do sedna sprawy, jak uruchomić taki program? Otóż trzeba go na początku skompilować. Do tego celu służy jedno z podstawowych i najczęściej używanych narzędzi dostarczonych wraz z JDK – kompilator języka Java. Jest to program javac. Wpisując w konsoli polecenie javac -help pokaże Ci się taka lista opcji (tutaj pokazałem wyłącznie kilka pierwszych linijek):   $ javac -help Usage: javac &lt;options&gt; &lt;source files&gt; where possible options include:   -g                         Generate all debugging info   -g:none                    Generate no debugging info   -g:{lines,vars,source}     Generate only some debugging info   -nowarn                    Generate no warnings   -verbose                   Output messages about what the compiler is doing   -deprecation               Output source locations where deprecated APIs are used   -classpath &lt;path&gt;          Specify where to find user class files and annotation processors   -cp &lt;path&gt;                 Specify where to find user class files and annotation processors ...   Więc skompilujmy tę pierwszą klasę :). Aby to zrobić należy uruchomić komendę javac DisplayName.java. Po jej uruchomieniu kompilator powinien utworzyć plik binarny z rozszerzeniem class – DisplayName.class. Plik ten zawiera instrukcje, które są zrozumiałe dla wirtualnej maszyny Javy.   A oto jak wygląda katalog, w którym aktualnie znajduje się kod źródłowy razem ze skompilowaną klasą:   $ tree . . ├── DisplayName.class └── DisplayName.java  0 directories, 2 files       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        java – uruchom swoją klasę   Skoro mamy już kod, mamy też skompilowaną klasę przydałoby się ją jakoś uruchomić :). Z pomocą przychodzi kolejny bardzo ważny program – java. Program ten uruchamia wirtualną maszynę Javy. Wpisując w konsoli java -help ponownie pokażą się dostępne opcje (skróciłem je także tutaj):   $ java -help Usage: java [-options] class [args...]            (to execute a class)    or  java [-options] -jar jarfile [args...]            (to execute a jar file) where options include:     ...     -server      to select the \"server\" VM                   The default VM is server,                   because you are running on a server-class machine.     -cp &lt;class search path of directories and zip/jar files&gt;     -classpath &lt;class search path of directories and zip/jar files&gt;                   A : separated list of directories, JAR archives,                   and ZIP archives to search for class files.     ...   Teraz masz już wszystkie potrzebne składniki do uruchomienia programu. Możesz to zrobić wpisując java DisplayName:   $ java DisplayName Marcin   Pracowity skrzat, IDE   Niby prosty program, a do jego uruchomienia trzeba użyć dwóch magicznych programów. Takie właśnie czynności robi za nas IDE. Za każdym razem1 gdy w IntelliJ użyjesz klawiszy Ctr+Schift+F10 (uruchom program) IntelliJ Idea robi podobne rzeczy. Kompiluje kod używając do tego programu javac a następnie uruchamia w odpowiedni sposób JRE używając programu java.   Pakiety   A teraz zrób krok do przodu – utwórz tę samą klasę w pakiecie pl.samouczekprogramisty.commandline i skompiluj ją przy pomocy javac. Przykład poniżej pokazuje poprawna strukturę katalogów dla klasy w takim pakiecie:   $ tree . . └── pl     └── samouczekprogramisty         └── commandline             └── DisplayName.java  3 directories, 2 files   Aby to zrobić musisz utworzyć plik ze źródłem w odpowiednim folderze, oczywiście wtedy deklaracja package na początku pliku powinna odzwierciedlać tę ścieżkę. W moim przypadku plik wygląda następująco:   package pl.samouczekprogramisty.commandline;  public class DisplayName {     public static void main(String ... args) {         System.out.println(\"Marcin pakiet\");     } }   Następinie używając programów javac i java mogę skompilować i uruchomić odpowiednią klasę używając poleceń:   javac pl/samouczekprogramisty/commandline/DisplayName.java java pl.samouczekprogramisty.commandline.DisplayName   W przypadku systemów z rodziny Windows katalogi w ścieżce do klasy, którą kompilujesz oddzielone są znakiem \\ a nie / jak w przykładzie.   Jak widzisz javac przyjmuje jako parametr ścieżkę do pliku, który chcesz skompilować. Program java natomiast przyjmuje pełną nazwę klasy (wraz z pakietem) wewnątrz której znajduje się metoda main. W moim przypadku oba programy uruchomiłem z katalogu, w którym jest katalog pl. Katalog pl odpowiada pierwszemu członowi pakietu.   Dochodzimy tutaj do pewnej istotnej rzeczy, gdzie program java ma “szukać” tej klasy? Odpowiedzią na to pytanie jest classpath. Po polsku będę to nazywał ścieżką przeszukiwania.   Czym jest classpath   No właśnie, czym jest classpath, magiczna ścieżka przeszukiwania? Wyjaśniając to pojęcie w jednym zdaniu – classpath to ścieżka, gdzie program java szuka klas, które potrzebne są w trakcie uruchomienia programu.   Możesz zatem zapytać “dlaczego poprzednio java DisplayName działało?” Działało, ponieważ jeśli nie ustawisz żadnej wartości, ścieżka przeszukiwania przyjmuje wartość domyślną – .. Ta kropka oznacza katalog, w którym aktualnie się znajdujesz.   Jako ćwiczenie możesz spróbować przejść do innego katalogu i uruchomić to samo polecenie, przykład poniżej pokazuje zachowanie jakie możesz uzyskać:   $ tree . . └── pl     └── samouczekprogramisty         └── commandline             ├── DisplayName.class             └── DisplayName.java   3 directories, 2 files ~$ java pl.samouczekprogramisty.commandline.DisplayName Marcin pakiet ~$ cd pl ~/pl$ java pl.samouczekprogramisty.commandline.DisplayName Error: Could not find or load main class pl.samouczekprogramisty.commandline.DisplayName   Jak widzisz w ostatniej linii program java wyświetlił błąd informujący, że nie może znaleźć klasy pl.samouczekprogramisty.commandline.DisplayName na aktualnej ścieżce przeszukiwania. Program szukał struktury pakietów pl/samouczekrogramisty/commandline, a w katalogu pl był jedynie katalog samouczekprogramisty, nie było katalogu pl.   Ścieżka przeszukiwania to lista katalogów oddzielonych odpowiednim znakiem gdzie program java powinien szukać klas. Na tej ścieżce poza katalogami mogą znajdować się też pliki zip czy pliki jar2. Przykład poniżej pokazuje ścieżkę przeszukiwania na której znajdują się trzy elementy:   some/path:.:other/path/file.jar   W przypadku sytemów z rodziny Windows do rozdzielenia elementów na ścieżce przeszukiwania używa się znaku ;. W pozostałych znanych mi systemach jest to znak : jak widzisz w przykładzie powyżej.   Pierwszy z nich to katalog some/path. Drugi z nich to katalog bieżący oznaczony znakiem .. Ostatni to ścieżka do pliku jar, wewnątrz którego znajdują się skompilowane klasy.   Jak ustawić classpath   Ścieżka przeszukiwania może być ustalona na dwa sposoby. Pierwszym z nich jest użycie argumentu linii poleceń -cp lub -classpath. Drugim jest ustawienie zmiennej środowiskowej CLASSPATH.   Jeśli nie użyjesz żadnej z tych metod, ścieżka przeszukiwania przyjmie wspomnianą już domyślną wartość.   Classpath w trakcie kompilacji   Nie tylko program java używa ścieżki przeszukiwania. Jest ona także używana w trakcie kompilacji. Wyobraź sobie swoją klasę, która zależy od innych klas. Na przykład używasz biblioteki Apache Commons Lang i klasy StringUtils.   Załóżmy, że chcesz użyć metody StringUtils.containsIgnoreCase. Spróbuj napisać kod w notatniku, bez pomocy IDE, który pobierze od użytkownika łańcuch znaków. Następnie sprawdzi (ignorując wielkość liter), czy w tym łańcuchu znajduje się Twoje imię.   Zdaję sobie sprawę, że jest to trudne ćwiczenie, jednak spróbuj wykonać je samodzielnie. Do wykonania tego ćwiczenia możesz użyć klasy java.util.Scanner i wspomnianej klasy StringUtils. Nie zapomnij o odpowiednich deklaracjach import. Prawdopodobnie bez dostępu do IDE nie zrobisz tego zadania bezbłędnie za pierwszym razem. Nie przejmuj się, to właśnie przy poprawianiu błędów nauczysz się najwięcej.   Plik JAR z tą biblioteką możesz pobrać z repozytorium Mavena (jeśli nie wiesz czym jest takie repozytorium odsyłam Cię do artykułu Wstęp do Gradle).   Kod, który napisałeś mógłby wyglądać jak w przykładzie poniżej:   package pl.samouczekprogramisty.commandline;   import java.util.Scanner; import org.apache.commons.lang3.StringUtils;   public class CheckName {     public static void main(String ... args) {         System.out.println(\"Podaj zdanie\");         Scanner scanner = new Scanner(System.in);         String sentence = scanner.nextLine();           if (StringUtils.containsIgnoreCase(sentence, \"Marcin\")) {             System.out.println(\"To zdanie zawiera moje imie!\");         }         else {             System.out.println(\"To zdanie nie zawiera mojego imienia!\");         }     } }   Jak widzisz, użyłem tu wcześniej wspomnianej klasy Scanner i StringUtils. Pierwsza z nich znajduje się w bibliotece standardowej Javy. Jest ona domyślnie dostępna w trakcie uruchomienia i kompilacji. Jednak w przypadku klasy StringUtils jest inaczej.   Jest to klasa zewnętrza więc musi być dostarczona zarówno w trakcie kompilacji jak i uruchomienia programu. Spójrz proszę na komendy użyte do kompilacji i uruchomienia programu:   javac -cp commons-lang3-3.5.jar pl/samouczekprogramisty/commandline/CheckName.java java -cp .:commons-lang3-3.5.jar pl.samouczekprogramisty.commandline.CheckName   W pierwszej linii jako ścieżkę przeszukiwania ustawiamy plik jar zawierający klasę StringUtils. To wywołanie kompiluje klasę CheckName. Dzięki temu uzyskamy plik CheckName.class, który chcemy uruchomić.   Kolejna linijka to właśnie to uruchomienie. Zauważ, że w tym przypadku ścieżka przeszukiwania zawiera zarówno aktualny katalog jak i plik jar. Aktualny katalog jest niezbędny żeby znaleźć klasę CheckName. Plik jar natomiast jest wymagany do odnalezienia klasy StringUtils.   Teraz czas na Twoje eksperymenty. Co się stanie jeśli uruchomisz swój program bez -cp? :)   Pliki JAR   No dobrze, a co jeśli chcemy w łatwy sposób przekazać komuś skompilowany kod? Bardzo dobrze do tego celu nadają się pliki JAR. JAR (ang. Java Archive) to nic innego jak plik zip, wewnątrz którego znajduje się zestaw plików class ze skompilowanymi klasami3.   Klasy wewnątrz archiwum znajdują się w odpowiednich katalogach, które odzwierciedlają strukturę pakietów. Spróbujmy teraz przygotować Twój pierwszy plik jar z linii poleceń.   Tworzenie pliku JAR jest dość proste. Wystarczy podać odpowiedni zestaw parametrów jak w przykładzie poniżej:   jar cf &lt;nazwa pliku wyjściowego&gt; &lt;lista katalogów, klas do umieszczenia w pliku JAR&gt;   Program jar ma także inne zastosowania. Na przykład przy jego pomocy możesz wyświetlić zawartość istniejącego pliku JAR. Służy do tego komenda pokazana poniżej:   jar tf &lt;ścieżka pliku JAR&gt;   W przypadku przykładu używanego poprzednio cały zestaw komend wyglądałby następująco:   tree . . └── pl     └── samouczekprogramisty         └── commandline             ├── CheckName.class             ├── CheckName.java             ├── DisplayName.class             └── DisplayName.java   3 directories, 4 files $ jar cf JavaCommandline.jar . $ jar tf JavaCommandline.jar META-INF/ META-INF/MANIFEST.MF pl/ pl/samouczekprogramisty/ pl/samouczekprogramisty/commandline/ pl/samouczekprogramisty/commandline/DisplayName.java pl/samouczekprogramisty/commandline/DisplayName.class pl/samouczekprogramisty/commandline/CheckName.class pl/samouczekprogramisty/commandline/CheckName.java   Jak widzisz, pliki znajdujące się w katalogu zostały dodane do pliku JAR. Program tutaj nie przeprowadził żadnego filtrowania – umieścił w archiwum także pliki java. Dlatego właśnie bardzo często pliki class umieszczamy w zupełnie innym katalogu niż pliki źródłowe.   Dodatkowo wewnątrz pliku JAR znajduje się też plik MANIFEST.MF, który zawiera metadane na temat tego archiwum. Wewnątrz tego pliku możemy skonfigurować na przykład domyślną klasę, która powinna być uruchamiana podczas wykonania polecenia   java -jar &lt;ścieżka do pliku JAR&gt;   Odpowiedni wpis w tym pliku może zostać utworzony4 automatycznie w trakcie tworzenia pliku jar. Możesz to tego użyć przełącznika e:   jar cfe &lt;nazwa pliku wyjściowego&gt; &lt;klasa z metodą main&gt; &lt;lista katalogów, klas do umieszczenia w pliku JAR&gt;   Na przykład aby utworzyć plik output.jar, który będzie zawierał wszystkie pliki z aktualnego katalogu i wskaże pl.samouczekprogramisty.commandline.MainClass jako klasę z metodą main możesz wywołać taką komendę:   jar cfe output.jar pl.samouczekprogramisty.commandline.MainClass .   Dodatkowe materiały do nauki   Ten artykuł był wybitnie praktyczny. Zależało mi na tym żeby krok po kroku pozwolił Ci realizować poszczególne etapy. Jeśli tego nie zrobiłeś, bardzo proszę spróbuj. Jeśli chciałbyś dowiedzieć się więcej o narzędziach, które opisałem w artykule mam dla Ciebie zestaw kilku dodatkowych dokumentów:     dokumentacja programu java,   dokumentacja programu javac,   dokumentacja programu jar,   specyfikacja plików jar,   kod źródłowy przykładów użytych w artykule.   Podsumowanie   Mam nadzieję, że taki praktyczny przewodnik krok po krodu po podstawowych narzędziach dostepnych z JRE i JDK przypadł Ci do gustu. Daj znać w komentarzach jak Ci poszło z przerobieniem ćwiczeń z treści artykułu :).   Po przeczytaniu tekstu znasz podstawowe narzędzia używane przy programowaniu w języku Java. Jesteś w stanie stworzyć swój plik jar i uruchomić klasy, które skmpilujesz podstawowymi narzędziami. Dzięki temu lepiej rozumiesz “magię”, którą na codzień robi IDE. Wiesz jak bardzo upraszcza ono Twoją pracę z kodem.   Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do mojego newslettera i polub Samouczka na facebooku.   Na koniec mam do Ciebie standardową prośbę, podziel się linkiem do artykułu ze znajomymi, zależy mi na dotarciu do jak największej liczby samouków, którzy chcą pogłębiać swoją wiedzę. Do następnego razu!                 Jak zwykle są wyjątki, ale nie są one istotne w tym przypadku. &#8617;                  Tak naprawdę plik jar to plik zip z innym rozszerzeniem. &#8617;                  Oczywiście pliki jar mogą zawierać także pliki innego rodzaju, jednak na tym etapie wystarczy wiedza o class i pliku tekstowym Manifest. &#8617;                  Bądź nadpisany, jeśli plik MANIFEST.MF miał już określoną klasę z metodą main. &#8617;           ","categories": ["Kurs programowania Java","DSP2017"],
        "tags": [],
        "url": "/java-z-linii-polecen/",
        "teaser": "/assets/images/2017/03/08_java_z_linii_polecen_artykul.jpg"
      },{
        "title": "Pogodynka – naiwny termometr",
        "excerpt":"Malinka padła   Niestety poprzedni tydzień minął pod znakiem kolejnych nieudanych prób wskrzeszenia mojej Malinki. Leżała ona już prawie 5 lat w szafie, przerzucana z miejsca na miejsce. Miała prawo “wysiąść”. Idę na łatwiznę – nie próbuję jej teraz naprawić. Wczoraj kupiłem nowszą wersję płytki, tym razem jest to Rasperry Pi 3 B, więc jest to już dużo mocniejszy układ, niż poprzedni. Ta nowa wersja ma też więcej portów USB, czego przyznam brakowało mi w wersji poprzedniej (jeszcze 5 lat temu jak płytka działała…). Używa też wbudowanego modułu do komunikacji WiFi co też jest sporym ułatwieniem.   Przesyłka jest już w drodze, więc jeśli wszystko dobrze pójdzie powinienem mieć nową malinkę w poniedziałek u siebie.   Termometr   Pchnąłem do przodu moduł termometru. Kilka nowych linijek kodu się pojawiło, jednak “serce” czyli właściwe odczytywanie temperatury nie działa, z oczywistych względów. Aktualnie działa “naiwny” termometr, który zwraca aktualną godzinę jako wskazanie temperatury ;).   Przy okazji tego wpisu przybliżę Ci trochę narzędzia, które są niezbędne do realizacji tej części projektu. Zacznę od crontab'a.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        crontab   W systemach operacyjnych są programy, które działają w tle. Programy tego typu nazywa się serwisami lub demonami. Jednym z takich demonów w systemach z rodziny Linux jest cron. Jest to demon, który odpowiada za uruchamianie poleceń zdefiniowanych przez użytkownika z odpowiednią częstotliwością.   Dzięki temu demonowi możesz na przykład sprawdzić aktualną temperaturę co pięć minut :). Idealne zastosowanie dla mojej pogodynki. crontab używa specyficznej składni, która pozwana na określenie kiedy dana komenda powinna być uruchamiana:   ┌───────────── minuta (0 - 59) │ ┌───────────── godzina (0 - 23) │ │ ┌───────────── dzień miesiąca (1 - 31) │ │ │ ┌───────────── miesiąc (1 - 12) │ │ │ │ ┌───────────── dzień tygodnia (0 - 6) (0 - niedziela, 6 - sobota) │ │ │ │ │ │ │ │ │ │ │ │ │ │ │ * * * * * &lt;polecenie do wykonania&gt;   Kilka przykładów, powinno pomóc Ci lepiej zrozumieć ustawienia crontab’a:     * * * * * &lt;komenda&gt; – uruchom komendę co minutę,   * 0 * * * &lt;komenda&gt; – uruchom komendę co minutę w trakcie godziny 0,   30 17 * * * &lt;komenda&gt; – uruchom komendę codziennie o 17:30,   15 4 ? * 0 &lt;komenda&gt; – uruchom komendę co sobotę o 4:15,   0-15 * * * * &lt;komenda&gt; – uruchom komendę co minutę w pierwszych 16 minutach każdej godziny,   0,5,10 * * * * &lt;komenda&gt; – uruchom komendę w zerowej, piątek i dziesiątej minucie każdej godziny,   */5 * * * * &lt;komenda&gt; – uruchom komendę co pięć minut,   Właśnie ta ostatnia linijka przyda się w przypadku pogodynki – co 5 minut będę chciał pobierać aktualne wskazanie temperatury.   Monitorowanie programu   W związku z tym, że zadanie sprawdzania temperatury będzie się odbywało w regularnych odstępach i będzie działo się automatycznie potrzebuję mechanizmu do monitorowania żeby zapewnić poprawnie i ciągłe działanie termometru.   Z doświadczenia wiem, że tego typu zadania dość często płatają figle i nie wykonują się poprawnie. Postanowiłem użyć serwisu https://healthchecks.io. Jest to darmowy serwis, który umożliwia wysyłanie stanu programu1 na skonfigurowany adres URL. Serwis ten monitoruje czy takie zapytanie jest wysyłanie z odpowiednią częstotliwością.   Jak widzisz na obrazku poniżej pokazuję przykładowe ustawienia healthchecks             Interfejs healthchecks        Następnie healthchecks poinformuje mnie mailem o tym, że termometr nie mierzył temperatury z częstotliwością, którą skonfigurowałem.   Logowanie   Załóżmy, ze coś poszło nie tak. Dostałem maila z informacją o tym, że temperatura nie jest mierzona. Co teraz? :) Z pomocą przychodzą logi. Logi, czyli informacje, które zapisywane są do pliku w trakcie działania programu. W pliku z logami zapisuje się różne informacje, zaczynając od “stanu programu” na rzuconych wyjątkach kończąc. Właśnie na podstawie takich plików będzie można później dojść co poszło “nie tak”.   W tym tygodniu zaimplementowałem właśnie logowanie, zapraszam do rzucenia okiem na kod źródłowy. Do logowania używam standardowych bibliotek dosępnych dla Javy SL4J i LOG4J.   Logi będą generowane cały czas. Program w końcu ma uruchamiać się co 5 minut. Naturalne jest więc, że po pewnym czasie plików z logami będzie sporo. Mogą też one zajmować dużo miejsca. Z pomocą po raz kolejny przychodzi crontab. Raz dziennie będę usuwał logi, które będą starsze niż tydzień.   Komenda do mierzenia temperatury   Z artykułu, w którym opisywałem Javę w linii poleceń wiesz jak zbudować plik jar i jak uruchomić program z linii poleceń. Właśnie tę wiedzę potrzebujesz to wpisania programu uruchamianego cyklicznie do cron’a. W moim przypadku będzie to polecenie   java -jar /opt/pogodynka/thermometer-1.0-SNAPHSOT.jar   Aby nie wypisywać długiej listy zależności i nie dodawać ich do classpath przy uruchomieniu programu użyłem tu pewnej sztuczki. Wszystkie zależności programu zostały zapakowane do jednego pliku jar. Tego typu zachowanie skonfigurowałem w pliku thermometer.gradle. O podstawach Gradle przeczytasz w osobnym artykule.   Przekazywanie parametrów   Aby nie musieć kompilować kodu za każdym razem istotne ustawienia przekazywane będą jako parametry linii poleceń. Użytkownik, jego hasło czy adres gdzie ma być wysłane aktualny odczyt temperatury przekazane będą jako argumenty. “Parsowaniem” tych argumentów zajmuje się osobna klasa Arguments.   Monitorowanie   Dodatkowo “zintegruję” to z wcześniej opisanym serwisem healthchecks. Z pomocą przyjdzie operator &amp;&amp; w bashu, który wykonuje to co jest po prawej stronie jeśli kod zakończenia komendy po lewej stronie jest równy 0.   Zatem finalnie komenda w crontab będzie wyglądała następująco:   java -jar /opt/pogodynka/thermometer-1.0-SNAPSHOT.jar dummyUsername dummyPassword \\ https://www.samouczekprogramisty.pl/getrealaddress &amp;&amp; \\ curl -fsS --retry 3 https://hchk.io/89941a75-5e1a-4b0b-a864-59d584e579a8   Magiczna część po &amp;&amp; odpowiada za wysłanie zapytania do healtchecks. Całość opakowałem w drobny skrypt w bash’u, który automatyzuje dodanie wpisu do cron’a. Skrypt dostępny jest na githubie. Tak oto wygląda crontab po uruchomieniu tego skryptu:   $ crontab -l */5 * * * * java -jar /opt/pogodynka/thermometer-1.0-SNAPSHOT.jar dummyUsername dummyPassword https://www.samouczekprogramisty.pl/getrealaddress &amp;&amp; curl -fsS --retry 3 https://hchk.io/89941a75-5e1a-4b0b-a864-59d584e579a8 1 0 * * * find /var/log/pogodynka/*.log -mtime +7 -exec rm {} \\;   Efekt finalny   Aktualnie moduł termometru jest popchnięty najdalej jak tylko mogłem. Teraz czas na pozostałe elementy o czym przeczytasz za tydzień. W przyszłym tygodniu skupię się na kolejnym elemencie – aplikacji webowej, która będzie przyjmowała odczyt temperatury.   Podsumowanie   Zachęcam Cię do śledzenia zadań, które wykonuję w ramach realizacji tego projektu. Możesz je zobaczyć na trello. Najnowszą wersję kodu źródłowego zawsze znajdziesz na githubie.   Zapisz się do mojego newslettera i polub stronę na facebooku jeśli nie chcesz pominąć kolejnych artykułów. Do następnego razu!                 W sumie nie jest to stan, a jedynie “ping”, co w zupełności spełnia wymagania. &#8617;           ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-naiwny-termometr/",
        "teaser": "/assets/images/2017/03/11_pogodynka_02_artykul.jpeg"
      },{
        "title": "Wprowadzenie do aplikacji webowych",
        "excerpt":"Z przeglądarką czy bez?   Używając przeglądarki czy programów z pakietu Office1 używasz aplikacji zainstalowanych na komputerze. Potocznie o takich programach czy aplikacjach mówi się “aplikacje desktopowe”.   Możesz je zainstalować pobierając odpowiednie pliki z internetu lub z innego nośnika jak na przykład płyta CD. Podczas takiej instalacji pliki niezbędne do działania aplikacji zapisywane są na dysku komputera.   Aplikacje webowe, to zupełnie oddzielna grupa aplikacji. Nie są one instalowane na Twoim komputerze. Można powiedzieć, że są zainstalowane na serwerze, a Ty dostajesz się do nich za pośrednictwem internetu. Otwierając przeglądarkę internetową i wchodząc na stronę dostajesz się do aplikacji webowej. Jak już wspomniałem do działania takiej aplikacji potrzebny jest ów “magiczny” serwer.   Czym jest serwer   Słowo serwer ma wiele znaczeń. Jednym ze znaczeń tego słowa jest określenie maszyny, komputera. Serwerem możemy także nazywać aplikację, która jest na takim komputerze zainstalowana. Przykładem takich serwerów są Apache HTTP Server czy nginx.   Wymienione wyżej serwery to serwery HTTP (ang. Hypertext Transfer Protocol), ich zadaniem jest serwowanie stron internetowych.   Wpisując adres www.samouczekprogramisty.pl w okienku przeglądarki wysyłasz zapytanie HTTP do serwera firmy, w której wykupiłem taką usługę. Serwer ten widząc twoje zapytanie odpowiada treścią, która jest zrozumiała dla przeglądarki. Przeglądarka wyświetla następnie tę treść w formie strony internetowej.   W najprostszym przykładzie jakim jest serwer HTTP, serwer (aplikacja) w odpowiedzi wysyła zawartość plików znajdujących się na dysku serwera (komputera). W takim przypadku możemy mówić o serwowaniu plików statycznych.   Aplikacje webowe pokazują zawartość, która jest zmienna. Nie można jej uzyskać wyłącznie z plików statycznych znajdujących się na dysku serwera. Przykładem takiej aplikacji może być ten blog – masz wpływ na zawartość strony na przykład przez dodawanie komentarzy.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Język aplikacji webowej   Aplikacje webowe mogą być napisane w wielu językach. Może to być Ruby, Python, PHP czy Java. Bynajmniej nie jest to kompletna lista :). Języków jest bardzo dużo, jednak mechanizm działania jest zawsze ten sam.   Aplikacja webowa napisana w języku X interpretuje żądanie wysłane przez przeglądarkę użytkownika do serwera i odpowiada na nie generując odpowiednią zawartość. Zawartość to plik generowany dynamicznie, który jest zrozumiały przez przeglądarkę internetową.   Zauważ, że taki sposób komunikacji pozwala na zastosowanie praktycznie dowolnego języka. W takiej sytuacji mówimy o protokole komunikacji. Protokole czyli zbiorze reguł, których przestrzeganie pozwoli się “dogadać” :).   Protokół ten używany jest w komunikacji pomiędzy klientem a serwerem. W tym przypadku klientem jest przeglądarka internetowa a serwerem jest aplikacja, która przetwarza żądanie wysłane przez klienta. W takim przypadku często też mówimy o aplikacjach typu klient-serwer.   Język, który rozumie przeglądarka   W dużym uproszczeniu przeglądarka internetowa to program, który wyświetla strony internetowe. Strony internetowe składają się z plików. Pliki te tworzone są przy pomocy różnych “języków”:     HTML (ang. Hypertext Markup Language) – język znaczników, można powiedzieć, że jest podzbiorem języka XML (wprowadzenie do XML). Znaczniki te opisują strukturę strony, to z jakich elementów się składa,   CSS (ang. Cascading Style Sheets) – język stylów, który pozwala na opisanie wyglądu strony internetowej. W połączeniu z HTML pozwala na tworzenie stron internetowych “przyjaznych dla oka”,   JavaScript – język programowania. Kod JavaScript jest interpretowany przez przeglądarkę. Pozwala na uruchamianie skryptów po stronie przeglądarki. Bardzo często animacje widoczne na stronach to właśnie wynik działania skryptów JavaScript.   Aplikacje webowe w Javie   Aplikacje webowe w języku Java można tworzyć dzięki specyfikacji JEE (ang. Java Enterprise Edition). Jest to właściwie zbiór innych specyfikacji opisujących różne mechanizmy wykorzystywane przy budowaniu aplikacji webowych.   Podobnie jak w przypadku innych języków tak i w Javie potrzebny jest odpowiedni serwer. W przypadku Javy możemy mówić o serwerze aplikacji jeśli implementuje on funkcjonalności opisane w specyfikacji JEE. Z racji tego, że specyfikacja ta jest rozległa dostępne są “prostsze serwery”. W takim przypadku mówimy o kontenerze serwletów. Jest to “uproszczony serwer aplikacji”, który implementuje jedynie część specyfikacji JEE.   Częścią specyfikacji JEE jest specyfikacja serwletów.   Serwlety w aplikacjach webowych   Serwlet to serce aplikacji webowych napisanych w Javie. Serwlet to klasa, która wie w jaki sposób obsłużyć zapytanie wysłane do serwera. Potrafi też odpowiedzieć na to zapytanie.   W artykule opisującym Javę z linii poleceń mogłeś przeczytać o plikach JAR. W przypadku aplikacji webowych wprowadzono dodatkowy plik, plik WAR (ang. Web Archive). Wewnątrz tego pliku znajduje się kod (skompilowane klasy) potrzebny do uruchomienia aplikacji webowej. Między innymi są to serwlety. Dodatkowo wewnątrz pliku WAR znajdować się mogą pliki JAR zawierające zależności niezbędne do działania aplikacji webowej.   Plik war instaluje się w kontenerze serwletów (ang. deploy). Kontener serwletów pośredniczy w obsłudze zapytań. Jak to wygląda w praktyce pokaże Ci profesjonalny diagram poniżej :), pokazuje on w dużym uproszczeniu obsługę żądań do aplikacji webowej:             Obsługa żądania w aplikacji webowej           wysłanie żądania z przeglądarki do serwera (maszyny)   przekazanie żądania do kontenera serwletów/serwera aplikacji   przetworzenie żądania przez serwlet/aplikację webową   przekazanie odpowiedzi z kontenera serwletów do serwera   wysłanie odpowiedzi do klienta (przeglądarki internetowej)   Istnieje wiele serwerów aplikacji i kontenerów serwletów. Te najpopularniejsze z nich znajdziesz poniżej:     Tomcat   Jetty   Glassfish   WildFly   Weblogic   Zalety aplikacji webowych   Główną zaletą aplikacji webowych jest to, że nie trzeba instalować ich na komputerze użytkownika. Aby korzystać z takiej aplikacji wystarczy przeglądarka z dostępem do internetu. Dzięki temu użytkownik może korzystać z takiej aplikacji praktycznie na dowolnym komputerze.   Nie bez znaczenia jest też dostępność aplikacji webowej na różnych typach urządzeń. Część aplikacji webowych można używać zarówno na komputerze, tablecie czy telefonie.   Równie istotna jest łatwość poprawiania błędów. W aplikacjach desktopowych jest to utrudnione, ponieważ w jakiś sposób aktualizacja musi być dostarczona do użytkownika. W przypadku aplikacji webowych taka aktualizacja może być dla użytkownika niewidoczna. Dzięki temu poprawki błędów czy nowe funkcjonalności są szybciej dostępne dla użytkowników.   Podsumowanie   Aplikacje webowe to coś dzięki czemu moim zdaniem Java zyskała tak dużą popularność. Ogromna większość ofert pracy na rynku związana z technologią Java dotyczy aplikacji webowych. Artykuł ten jedynie musnął ich tematykę. Mam nadzieję, że po jego lekturze będzie Ci łatwiej zrozumieć zasadę działania tego typu aplikacji.   Zapisz się do mojego newslettera i polub stronę na Facebooku jeśli nie chcesz pominąć kolejnych artykułów. Jeśli masz jakiekolwiek pytania proszę zadaj je w komentarzu :).   Do następnego razu!                 Chodzi mi to o tę “instalowalną” część pakietu, a nie tę dostępną online ;). &#8617;           ","categories": ["Kurs aplikacji webowych","DSP2017"],
        "tags": [],
        "url": "/wprowadzenie-do-aplikacji-webowych/",
        "teaser": "/assets/images/2017/03/17_wprowadzenie_do_aplikacji_webowych_artykul.jpg"
      },{
        "title": "Pogodynka – działający termometr",
        "excerpt":"Postęp w module Thermometer   Mogę powiedzieć, że pierwszy moduł całej aplikacji jest “gotowy”. Podłączyłem czujnik temperatury do Malinki, udało mi się nawet odczytać wskazania temperatury. Klasa FromFileThermometer jest w stanie przeczytać zawartość takiego pliku i odpowiednio ją zinterpretować, udowadnia to test jednostkowy FromFileThermometerTest.   Praca z czujnikiem DS18B20 na Malince   Czujnik temperatury DS18B20 można połączyć bezpośrednio pod wyjścia GPIO (ang. General Purpose Input Output). Wystarczy do tego sam czujnik i opornik 4.7k. W moim przypadku na zdjęciu poniżej widać to połączenie:             Podpięcie czujnika temperatury.        U siebie zastosowałem opornik 4.6k (akurat taki udało mi się dostać w sklepie).   Jeśli wszystko działa poprawnie Malinka wykryje czujnik i w katalogu /sys/bus/w1/devices znajdzie się katalog o nazwie 28-00000xxxxxx. xxxxxx może być różne i jest unikalnym identyfikatorem danego czujnika. Wewnątrz tego katalogu znajduje się plik w1_slave, który zawiera aktualne wskazanie czujnika.             Wskazanie czujnika temperatury.        Odczytanie temperatury sprowadza się do poprawnego parsowania zawartości tego pliku. Przykład realizacji możesz znaleźć we wcześniej wspomnianej klasie FromFileThermometer.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Zmiany w Gradle   Sporo też zmieniło się w samej strukturze projektu. Od teraz pogodynka to projekt, który składa się z wielu modułów. Jest to możliwe dzięki dodaniu pliku settings.gradle, który opisuje strukturę takiego projektu.   Jeden z modułów już znasz thermometer. Nowy, który się pojawił to datavault. Dla przypomnienia jest to moduł, który odpowiedzialny będzie za zapisywanie wskazań temperatury w bazie. Udostępniał też będzie usługi, które używane będą przez interfejs użytkownika w przeglądarce internetowej.   Całość na prostym diagramie wygląda następująco:             Diagram aplikacji Pogodynka        Jeśli chcesz poznać podstawy Gradle zapraszam do osobnego artykułu.   Szablon aplikacji webowej   Moduł datavault będzie aplikacją webową. Aplikacja ta nie będzie posiadała żadnego interfejsu graficznego. Wystawi jedynie usługi, które będą realizowały całą funkcjonalność:     zapis aktualnej temperatury,   odczyt temperatur z N ostatnich dni.   Jeśli wcześniej nie miałeś do czynienia z aplikacjami tego typu zachęcam do przeczytania wprowadzenia do aplikacji webowych.   Aktualnie moduł datavault to pusty szablon aplikacji webowej. Całość sprowadza się do pliku datavault.gradle, który definiuje aplikację tego typu:   apply plugin: 'war' apply from: 'https://raw.github.com/akhikhl/gretty/master/pluginScripts/gretty.plugin'   dependencies {     providedCompile group: 'javax.servlet', name: 'javax.servlet-api', version: '3.1.0' }   W pierwszej linijce dodaję rozszerzenie war, dzięki któremu Gradle wie, że jest to aplikacja webowa. Druga linijka dodaje rozszerzenie, które pozwala na wygodne uruchamianie kontenerów aplikacji/serwletów. Dzięki wtyczce gretty w prosty sposób możemy uruchomić taki kontener.   Zachęcam to tego żebyś pobrał kod z repozytorium i sam spróbował:   $ ./gradlew appRun :datavault:prepareInplaceWebAppFolder UP-TO-DATE :datavault:createInplaceWebAppFolder UP-TO-DATE :datavault:compileJava NO-SOURCE :datavault:processResources NO-SOURCE :datavault:classes UP-TO-DATE :datavault:prepareInplaceWebAppClasses UP-TO-DATE :datavault:prepareInplaceWebApp UP-TO-DATE :datavault:appRun 18:48:10 INFO Jetty 9.2.15.v20160210 started and listening on port 8080 18:48:10 INFO datavault runs at: 18:48:10 INFO http://localhost:8080/datavault Press any key to stop the server. &gt; Building 87% &gt; :datavault:appRun   Następnie otworzenie w przeglądarce adresu http://localhost:8080/datavault powinno zadziałać :).   Podsumowanie   Powoli, ale skutecznie idę do przodu :). Jeden z modułów jest gotowy, pozostałe dwa czekają na swoją kolej. Datavautl wezmę na tapet w kolejnych tygodniach. Na dzisiaj to wszystko z frontu, do następnego razu! :)  ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-dzialajacy-termometr/",
        "teaser": "/assets/images/2017/03/19_pogodynka_03_artykul.jpg"
      },{
        "title": "Serwlety w aplikacjach webowych",
        "excerpt":"       Chociaż artykuł ten pisany jest z myślą o początkujących, do jego pełnego zrozumienia przyda się wiedza, którą zawarłem w kliku innych artykułach. Zachęcam do zapoznania się z nimi przed podejściem do tego artykułu:      Wstęp do aplikacji webowych   Wstęp do Gradle   Java z linii poleceń     Artykuł ten bazuje na specyfikacji serwletów w wersji 3.1, która jest częścią specyfikacji Java Enterprise Edition 7. Planowany termin wydania specyfikacji Java Enterprise Edition 8 to koniec 2017 roku, w ramach tej specyfikacji wydana ma być także nowa specyfikacja serwletów w wersji 4.0.   Wprowadzenie do protokołu HTTP   Napisałem osobny artykuł na temat protokołu HTTP. Tutaj przedstawię jedynie niezbędne podstawy.   Aby zacząć poważnie myśleć o tworzeniu aplikacji webowych niezbędna jest wiedza dotycząca protokołu HTTP (ang. Hypertext Transfer Protocol). Poniżej znajdziesz kilka podstawowych informacji, które będą Ci potrzebne w pracy z aplikacją webową.     Protokół HTTP jest oparty na komunikacji pomiędzy klientem a serwerem. Klientem może być na przykład przeglądarka internetowa. Serwer to aplikacja, która odpowiada na żądania klienta.   Komunikacja pomiędzy klientem a serwerem oparta jest na żądaniach (ang. request) i odpowiedziach (ang. response). Klient wysyła żądanie, na które serwer udziela odpowiedzi.   Zarówno żądania, jak i odpowiedzi mogą zawierać nagłówki i treść. Nagłówki służą do przekazania części informacji. W nagłówku na przykład zawarte mogą być informacje o przeglądarce, z której wysłano żądanie. Treścią odpowiedzi może być na przykład zawartość strony internetowej.   Protokół HTTP oparty jest o tak zwane “czasowniki HTTP”. Można powiedzieć, że czasownik ten określa rodzaj żądania jakie wysyła klient. Wszystkich czasowników jest 9, podstawowe rodzaje żądań to GET, POST, PUT, DELETE.   W większości przypadków używane są żądania typu GET i POST. Na przykład do wysłania informacji, które uzupełniłeś w formularzu używa się żądania typu POST. Natomiast zwykłe otworzenie strony, wpisanie adresu strony w przeglądarce to żądanie typu GET.   Adres URL   Każde z żądań dotyczy jakiegoś zasobu. Na przykład otwierając stronę www.samouczekprogramisty.pl w przeglądarce wysyłasz żądanie GET http://www.samouczekprogramisty.pl. Ta część po GET to nic innego jak URL (ang. Uniform Resource Locator). Innymi słowy adres strony www.   Adres URL może składać się z kilku części   (scheme://)(user:password@)host(:port)(/)(path)(?query)(#fragment) https://marcin:tajnehaslo@www.samouczekprogramisty.pl:80/kurs-programowania-java?parametr=wartosc&amp;innyParametr=wartosc#xxx   W ogromnej większości przypadków część z użytkownikiem i hasłem jest pomijana. Używana jest ona do uwierzytelniania, jednak metoda ta nie jest powszechnie używana. Port także jest pomijany. Pomijamy go ponieważ dla protokołu http domyślny port to właśnie 80 więc nie ma potrzeby go dodawać. Odrzucając rzadziej używane elementy adres url wygląda następująco   https://www.samouczekprogramisty.pl:80/kurs-programowania-java?parametr=wartosc&amp;innyParametr=wartosc   Mamy tutaj informację o protokole (https), serwerze (www.samouczekprogramisty.pl), ścieżce (/kurs-programowania-java) i parametrach (parametr=wartosc&amp;innyParametr=wartosc).       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Czym jest serwlet   Serwlet to klasa, która implementuje interfejs Servlet. Instancje tej klasy tworzone są przez kontener serwletów (na przykład Jetty). Instancje te wiedzą jak odpowiadać na żądania, które dostają od klienta.   Do obsługi żądania klienta służy metoda service. Metoda ta przyjmuje jako parametry żądanie i odpowiedź. Na podstawie parametrów żądania odpowiednio modyfikuje przekazany argument odpowiedzi.   Szczerze mówiąc do tej pory ani razu nie napisałem klasy, która bezpośrednio implementuje ten interfejs. Używa się do tego klas, które upraszczają tworzenie serwletów. Są to klasy GenericServlet i HttpServlet.   Chociaż specyfikacja serwletów, nie wymaga użycia serwletów z protokołem HTTP w praktyce nie spotkałem się z innym zastosowaniem. Zatem z dwóch wyżej wspomnianych klas powinieneś zapamiętać HttpServlet1.   Interfejs serwletów   Wcześniej wspomniałem Ci już o metodzie service. Metodę tę musiałbyś zaimplementować jeśli utworzyłbyś klasę, która implementuje interfejs Servlet bezpośrednio. W przypadku klasy, która dziedziczy po HttpServlet wystarczy nadpisanie odpowiedniej metody. Na przykład, jeśli twój serwlet ma obsłużyć żądania typu GET musisz zaimplementować metodę doGet. Istnieją też metody dla pozostałych “czasowników”, na przykład doPost czy doPut.   W interfejsie serwletów znajdują się też metody, które są wykorzystywane w trakcie cyklu życia serwletu. Jak wspomniałem wyżej kontener odpowiedzialny jest za tworzenie instancji serwletu. Ponadto kontener zarządza cyklem życia serwletu używając metod z tego interfejsu.   Cykl życia serwletu   Każda instancja serwletu ma swój cykl życia. Jest to jasno zdefiniowana lista etapów, przez które przechodzi każdy serwelt. Lista ta wygląda następująco:   Utworzenie instancji serwletu   Kontener wyszukuje klas serwletów i następnie tworzy jedną instancję serwletu2.   Inicjalizacja serwletu   Z racji tego, że to kontener serwletów odpowiedzialny jest za tworzenie instancji klasy serwletu nie ma możliwości przekazania odpowiednich parametrów do konstruktora. Do inicjalizacji stanu serwletu służy metoda init i jest ona wywoływana przez kontener przed rozpoczęciem obsługi żądań przez dany serwlet.   Obsługa żądań   W trakcie tego etapu kontener serwletów może wielokrotnie użyć tej samej instancji to obsługi wielu żądań. Pociąga to za sobą dość poważne konsekwencje. Możliwa jest sytuacja, w której w tym samym czasie instancja serwletu będzie obsługiwała kilka żądań jednocześnie. Na przykład jest to możliwe, gdy kilku użytkowników wejdzie na ten sam adres. Obsługa każdego żądania to wywołanie przez kontener metody service.   Zniszczenie serwletu   Kontener może usunąć daną instancję serwletu. Przed zniszczeniem instancji wywołana zostanie metoda destroy. Dzięki temu wewnątrz serweltu masz szansę na “posprzątanie”. Metoda ta może na przykład służyć do zamknięcia połączenia z bazą danych. Nie masz pewności jak długo serwlet będzie żył, o tym decyduje kontener.   Kontener serwletów   Z poprzednich paragrafów dowiedziałeś się już, że kontener serwletów zarządza cyklem życia serwletów. Nie jest to jedyna odpowiedzialność kontenera. Kontener serwletów odpowiedzialny jest za “wyszukanie” klas odpowiedzialnych za działanie aplikacji.   W pierwszych wersjach specyfikacji niezbędny był do tego plik web.xml (tak zwany deskryptor wdrożenia), teraz aplikację webową można skonfigurować przy pomocy adnotacji. Dalej jednak to kontener musi “znaleźć” te klasy.   Poza serwletami istnieją też inne komponenty aplikacji webowej opisane w specyfikacji serlwetów. Na przykład filtry czy “listnenery” (ang. listener) (ma ktoś z was pomysł jak przetłumaczyć to słowo na polski :)?). Także i tutaj kontener serwletów pełni kluczową rolę. Kontener zarządza cyklem życia tych elementów.   Przy konstruowaniu odpowiedzi na żądania pomocne są pliki typu JSP (ang. Java Server Pages). Powtórzę się – kontener zarządza cyklem życia takich plików.   W przypadku aplikacji webowych możemy mówić o kilku kontekstach. Możemy wyróżnić na przykład kontekst żądania czy kontekst aplikacji. Także tutaj kontener serwletów za nie odpowiada.   Jest jeszcze wiele innych aspektów, za które odpowiada kontener wybiegają jednak poza zakres tego artykułu. Napiszę jeszcze o jednym z nich. Kontener także odpowiedzialny jest za instalowanie aplikacji webowej, wiąże się to z “czytaniem” zawartości pliku war, w którym znajduje się aplikacja webowa.   Plik war   W artykule opisującym Javę z linii poleceń możesz przeczytać o plikach jar. W przypadku aplikacji webowych plik war pełni kluczową rolę.   W skład aplikacji webowej mogą wchodzić:      serwlety,   strony jsp,   inne klasy Java,   zależności aplikacji webowej,   statyczne pliki (na przykład html czy css),   pliki konfiguracyjne opisujące aplikację webową.   Wszystkie te pliki pakowane są w odpowiednią strukturę wewnątrz pliku war.   Struktura aplikacji webowej   Podobnie jak w przypadku pliku jar jest to zwykłe archiwum zip ze zmienionym rozszerzeniem (war a nie zip). Buduje się go przy pomocy tych samych narzędzi jak plik jar . Struktura przykładowego pliku war jest następująca:   struktura_pliku.war ├── index.html ├── publiczny_katalog │   └── strona.html ├── style.css └── WEB-INF     ├── classes     │   └── pl     │   └── samouczekprogramisty     │   └── SomeServlet.class     ├── lib     │   └── some-jar-file.jar     └── web.xml   Pliki takie jak index.html, publiczny_ktalog/strona.html czy style.css są publicznie dostępne. Oznacza to tyle, że kontener serwletów może serwować te pliki.   Sprawa wygląda zupełnie inaczej w przypadku katalogu WEB-INF. Jest to katalog, który zawiera dane, które nigdy nie mogą być bezpośrednio “serwowane” przez kontener. Wewnątrz WEB-INF znajdują się inne katalogi:      classes – zawiera on skompilowane klasy aplikacji webowej,   lib – zawiera on spakowane pliki jar potrzebne do działania aplikacji webowej.   Dodatkowo aplikacja webowa może zawierać tak zwany deskryptor wdrożenia (ang. deployment descriptor). Jest to plik web.xml, który konfiguruje działanie aplikacji webowej. W przypadku prostych aplikacji nie jest on wymagany, całą konfigurację można dostarczyć przy pomocy adnotacji.   Sekret działania Spring MVC   W codziennej pracy z aplikacjami webowymi programiści bardzo rzadko (wcale?) tworzą swoje serwlety. W ogromnej większości przypadków to biblioteka pomagająca przybudowaniu aplikacji webowych zawiera “główny serwlet”.   Ten serwlet pośredniczy przy wszystkich zapytaniach do danej aplikacji webowej. Następnie w zależności od ścieżki, której dotyczy dane żądanie przekazuje je do odpowiedniej klasy. I to właśnie te klasy pisane są przez programistów.   Dla przykładu w Spring MVC takim “głównym serwletem” jest DispatcherServlet. Zachęcam do zajrzenia do źródeł tego serwletu. Zobaczyć możesz tam jakie mechanizmy użyte są do przekazania żądania dalej.   Jak przeszukasz DispatcherServlet i klasy po których dziedziczy dogrzebiesz się do dobrze znanych metod, takich jak service czy doGet.   Pierwsza aplikacja webowa   Nadszedł czas, żeby wykorzystać tę wiedzę w praktyce. Proszę spójrz na przykład poniżej:   @WebServlet(\"/date\") public class DateServlet extends HttpServlet {     @Override     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {         DateTime now = DateTime.now();         PrintWriter responseOutput = response.getWriter();         responseOutput.append(\"&lt;html&gt;&lt;body&gt;\" + now.toString() + \"&lt;/body&gt;&lt;/html&gt;\");     } }   DateServlet to serwlet, który odpowiada na żądania typu GET wysłane na adres /date. Oczywiście w produkcyjnych aplikacjach w inny sposób konstruuje się odpowiedzi, jednak przykład ten pokazuje ogólną zasadę działania.   response.getWriter() zwraca instancję klasy PrintWriter. Należy traktować ją jako zawartość pliku, która zostanie wysłana w odpowiedzi na żądanie. Jeśli użyjemy tej metody odpowiedź, którą wygenerujemy musi być tekstowa (nie binarna). Ostatnia linijka metody doGet to właśnie generowanie treści odpowiedzi, gdzie odpowiadamy aktualną datą umieszczoną wewnątrz podstawowych znaczników html.   Taką klasę serwletu umieszczamy w projekcie. W moim przypadku jego struktura wygląda następująco:   . ├── 01_serwlety │   ├── build │   ├── build.gradle │   └── src │   └── main │   ├── java │   │   └── pl │   │   └── samouczekprogramisty │   │   └── kursaplikacjewebowe │   │   └── serwlety │   │   └── DateServlet.java │   └── webapp ├── build.gradle ├── gradle │   └── wrapper │   ├── gradle-wrapper.jar │   └── gradle-wrapper.properties ├── gradlew ├── gradlew.bat └── settings.gradle   Na tym etapie proszę użyj przykładowych plików umieszczonych w repozytorium kodu. W osobnym artykule wytłumaczę zasadę działania Gradle w przypadku aplikacji webowych. Bazowy plik build.gradle i plik 01_serwlety/build.gradle pozwalają na uruchomienie tak utworzonej aplikacji webowej:   KursAplikacjeWebowe$ ./gradlew appRun :01_serwlety:prepareInplaceWebAppFolder NO-SOURCE :01_serwlety:createInplaceWebAppFolder UP-TO-DATE :01_serwlety:compileJava UP-TO-DATE :01_serwlety:processResources NO-SOURCE :01_serwlety:classes UP-TO-DATE :01_serwlety:prepareInplaceWebAppClasses UP-TO-DATE :01_serwlety:prepareInplaceWebApp UP-TO-DATE :01_serwlety:appRun 10:19:57 INFO Jetty 9.2.15.v20160210 started and listening on port 8080 10:19:57 INFO 01_serwlety runs at: 10:19:57 INFO http://localhost:8080/01_serwlety Press any key to stop the server. &gt; Building 87% &gt; :01_serwlety:appRun   Następnie uruchomienie przeglądarki i wpisanie adresu http://localhost:8080/01_serwlety/date powinno pokazać działającą aplikację, która wyświetla datę:             Odpowiedź z DataServlet        Ćwiczenie do wykonania   Na podstawie przykładowej aplikacji napisz serwlet, który wyświetli liczbę sekund, od dnia Twojego urodzenia. Po wejściu na stronę, którą obsługuje dany serwlet powinna pokazać się liczba sekund, od Twoich urodzin.  Dodatkowe materiały do nauki   Poniżej przygotowałem dla Ciebie kilka dodatkowych linków, które pomogą Ci rozszerzyć wiedzę z tego artykułu:     Protokół HTTP   Specyfikacja serwletów wersja 3.1   Specyfikacje Java EE 7   Przykłady użyte w tym artykule   Podsumowanie   Gratulacje! Udało Ci się przeczytać cały artykuł, a nie należał on do najkrótszych ;). Po jego przeczytaniu wiesz czym jest serwlet. Poznałeś strukturę pliku war, znasz podstawowy zakres odpowiedzialności kontenera serwletów. Poznałeś też część magii, która kryje się pod spodem biblioteki Spring MVC. No i oczywiście utworzyłeś swoją pierwszą dynamiczną aplikację webowową!   Mimo objętości artykułu nie wyczerpałem tematu aplikacji webowych, jest to jeden z serii artykułów opisujących podstawy aplikacji webowych w Javie. Jeśli nie chcesz pominąć kolejnych artykułów polub Samouczka na facebooku i zapisz się do newslettera.   Do następnego razu!                 Prawda jest taka, że używając bibliotek pomagających tworzyć aplikacje webowe sam nie będziesz pisał serwletów. Będą to zwykłe klasy, które będą przez bibliotekę wywoływane. Biblioteka dostarczy “główny” serwlet, który będzie przekazywał żądania dalej. &#8617;                  Chodzi o zachowanie domyślne, kontener może utworzyć kilka instancji jeśli zaimplementujesz interfejs SingleThreadedModel. Takie podejście nie jest jednak polecane. &#8617;           ","categories": ["DSP2017","Kurs aplikacji webowych"],
        "tags": [],
        "url": "/serwlety-w-aplikacjach-webowych/",
        "teaser": "/assets/images/2017/03/25_serwlety_w_aplikacjach_webowych_artykul.jpeg"
      },{
        "title": "Pogodynka – szkielet aplikacji webowej",
        "excerpt":"W tym tygodniu przygotowałem dla Was dość obszerny wpis dotyczący serwletów w aplikacjach Java. Jego przygotowanie zajęło mi sporo czasu więc automatycznie zostało go mniej na samą Pogodynkę.   Jednak i tutaj udało się pchnąć sprawy do przodu. W tym momencie datavault jest już “działającą” aplikacją webową opartą o Spring MVC. Uparłem się i całą konfigurację zrobiłem bez użycia Spring Boot i plików XML. Chcę to zrobić w ten sposób, aby pokazać Wam przykład takich właśnie aplikacji.   W tym momencie obsługiwane są żądania typu POST i GET, które będą odpowiednio dodawały nowy wpis dotyczący temperatury i pobierały listę temperatur.   Warstwa widoku   W pierwotnej wersji zakładałem, że napiszę osobną aplikację w Java Script, która będzie odpowiadała za generowanie widoku. Coraz bardziej się nad tym zastanawiam. Widzę pewną wartość w zrobieniu tego w “stary” sposób.   W “stary”, czyli z wykorzystaniem plików JSP. Dzięki temu będę miał dla Was przykład aplikacji używającej właśnie takiego podejścia do kolejnych artykułów, a artykuł o JSP na pewno powstanie.   Spring MVC   Aktualnie aplikacja używa Spring MVC. Konfiguracja w większości używa ustawień domyślnych, które włączone są przy pomocy kilku “springowych” adnotacji:     @Configuration   @EnableWebMvc   @ComponentScan   Przykład ich użycia możesz zobaczyć w klasie WebAppConfiguration. Klasa ta jest użyta jako bazowy “applicationContext”, włącza obsługę Spring MVC oraz wskazuje pakiety, w których Spring szuka klas, którymi zarządza (potocznie mówi się tu o bean’ach).   Kolejną istotną klasą jest DatavaultInitializer, która konfiguruje instancję DispatcherServlet obsługującego aplikację (o tym jak to ustrojstwo magicznie działa możesz przeczytać we wcześniej wspomnianym artykule o serwletach),   Przygotowałem też naiwną implementację klasy odpowiedzialnej za zarządzanie temperaturami TemperatureServiceImpl, w obecnym kształcie nie robi ona jeszcze nic użytecznego.   Podsumowanie   Kodu w tym tygodniu nie pojawiło się za wiele, jednak “szkielet” aplikacji webowej już jest i czeka na lepsze czasy ;). Jak zwykle całość kodu dostępna jest w repozytorium. Do następnego razu!  ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-szkielet-aplikacji-webowej/",
        "teaser": "/assets/images/2017/03/26_pogodynka_04_artykul.jpg"
      },{
        "title": "Nagłówki, sesje i ciasteczka",
        "excerpt":"Wprowadzenie   Zacznijmy od żądań i odpowiedzi. Wiesz już, o hierarchii dziedziczenia serwletów Servlet, GenericServlet i HttpServlet. W przypadku klasy opakowującej żądanie i odpowiedź sytuacja wygląda podobnie. Istnieją bazowe interfejsy ServletRequest i ServletResponse.   W przypadku serwletów opartych o protokół HTTP interfejsy te są rozszerzane przez HttpServletRequest i HttpServletResponse. Rozszerzone interfejsy zawierają metody specyficzne dla protokołu HTTP.   Zauważ, że piszę tu wyłącznie o interfejsach. Są to interfejsy określone przez specyfikację serwletów. Kontener serwletów, który implementuję tę specyfikację dostarcza także konkretnych implementacji. To właśnie kontener odpowiedzialny jest za tworzenie instancji klas, które implementują te interfejsy.   Z poprzedniego artykułu opisującego serwlety wiesz już z jakich elementów składa się adres URL. Klasy opakowujące żądanie pozwalają na pracę z poszczególnymi elementami adresu URL. Jedą z części tego adresu są parametry.   W artykule i przykładach używam bardzo prostego mechanizmu do generowania widoków. Nie jest to sposób “poprawny”. To są jedynie przykłady, które mają wprowadzić Cię w “świat aplikacji webowych”. W kolejnych artykułach poznasz lepszą metodę na generowanie stron HTML.   HTTPServletRequest   Parametry URL   Jedną z części adresu URL są parametry. Są one dostępne po znaku ?. Parametry zapisane są w formie klucz=wartość, z tym że jeden parametr może wystąpić wiele razy. Poszczególne pary klucz=wartość rozdzielone są znakami &amp;.   W interfejsie HttpServletRequest istnieje kilka metod, które pozwalają na pracę z parametrami. Proszę spójrz na przykład poniżej.   @WebServlet(\"/parameters\") public class ParametersServlet extends HttpServlet {     @Override     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {         PrintWriter responseWriter = resp.getWriter();         responseWriter.write(\"&lt;html&gt;&lt;body&gt;\");         for (Map.Entry&lt;String, String[]&gt; entry : req.getParameterMap().entrySet()) {             responseWriter.write(\"&lt;p&gt;\" + entry.getKey() + \": \" + Arrays.toString(entry.getValue()) +\"&lt;/p&gt;\");         }         responseWriter.write(\"&lt;/body&gt;&lt;/html&gt;\");     } }   W przykładzie tym widzisz serwlet, który w odpowiedzi wypisuje wszystkie parametry z adresu URL żądania. Poza metodą getParameterMap możesz użyć także kilku innych:     getParameter()   getParameterNames()   getParameterValues()   Po uruchomieniu aplikacji, która posiada taki serwlet i wpisaniu w przeglądarce adresu   http://localhost:8080/02_serwlety/parameters?parameter1=value1&amp;parameter2=value2&amp;parameter1=value11   Powinna wyświetlić się strona zawierająca dwie linijki:   parameter2: [value2] parameter1: [value1, value11]   Żądania POST a parametry   Powyżej opisałem sytuację, w której parametry przesyłane są jako fragment adresu URL żądania. Dzieje się tak w przypadku żądań typu GET. W przypadku wysyłania formularzy (zazwyczaj zapytania typu POST), parametry te przesyłane są w ciele żądania. Nie są one częścią adresu.   Mimo tego, że parametry przesyłane są w inny sposób możesz z nimi pracować używając tego samego zestawu metod.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Adres URL   Obiekt opakowujący żądanie pozwala także na pracę z adresem URL, którego żądanie dotyczy. Zestaw metod pozwala na pobranie informacji na temat adresu żądania:     getContextPath() zwraca fragment ścieżki, która jest “podstawą” wszystkich ścieżek obsługiwanych przez daną aplikację. W przypadku prostego instalowania aplikacji przy pomocy gradle będzie to nazwa pliku war,   getServletPath() zwraca fragment ścieżki, która została użyta w konfiguracji serwletu,   getRequestURL() metoda zwraca adres URL żądania bez parametrów zawartych w adresie,   getRequestURI() zwraca adres URI (ang. Uniform Resource Identifier). Od aresu URL różni się on tym, że nie zawiera protokołu, serwera i portu.   Zakładając, że nasz sewlet obsługuje ścieżkę /path wówczas wywołanie powyższych metod po żądaniu   http://localhost:8080/02_serwlety/path?xxx=yyy   Powinno zwrócić następujące wartości:     getContextPath() /02_serwlety   getServletPath() /path   getRequestURI() /02_serwlety/path   getRequestURL() http://localhost:8080/02_serwlety/path   Przykładowy serwlet, który używa tych metod możesz znaleźć na samouczkowym githubie.  HttpServletResponse   Obiekt, implementujący ten interfejs także tworzony jest przez kontener serwletów. Służy on do przygotowania odpowiedzi na żądanie wysłane do serwera. W przypadku obiektu odpowiedzi musisz wiedzieć o następujących metodach     getOutputStream() zwraca instancję ServletOutputStream, która służy do tworzenia odpowiedzi zawierającej dane binarne,   getWriter() zwraca instancję PrintWriter, która służy do tworzenia odpowiedzi zawierającej tekst.   Ważne jest aby pamiętać, że w trakcie obsługi żądania możemy posługiwać się wyłącznie jedną z tych metod.  Nagłówki   Specyfikacja protokołu HTTP definiuje tak zwane nagłówki. Nagłówki dołączane są zarówno do żądań jak i odpowiedzi. Nagłówki to nic innego jak pary klucz-wartość, które zapisane są w formacie nazwa nagłówka: treść nagłówka. Na przykład   Content-Type: text/html; charset=utf-8 Content-Length: 13358   Przeglądarki internetowe posiadają wbudowane “narzędzia developerskie”, które pozwalają na podejrzenie nagłówków. Jeśli chcesz dowiedzieć się więcej o tych narzędziach zachęcam do odwiedzenia strony dedykowanej dla Twojej przeglądarki     Firefox   Chrome   Opera   Internet Explorer             Narzędzia developerskie – nagłówki        Obiekty HttpServletResponse i HttpServletRequest pozwalają na pracę z nagłówkami przy pomocy metod:      setHeader()   addHeader()   Pierwsza z nich ustawia wartość nagłówka, druga dodaje nową wartość nagłówka (i tworzy go jeśli wcześniej nie był ustawiony). W rzeczywistości nagłówek mający wiele wartości to dalej jedna para klucz-wartość. W tym przypadku wartość zawiera kilka elementów oddzielonych przecinkami.   Nagłówki możesz pobierać z obiektu żądania używając metod:      getHeaderNames()   getHeader()   getHeaders()   Poniższy serwlet używa tych metod aby ustawić kilka nagłówków. W odpowiedzi na żądanie tworzy stronę, która zawiera listę ustawionych nagłówków. Jak zwykle mocno zachęcam do eksperymentowania, sam zobacz jak taki serwlet działa.   @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {     PrintWriter responseWriter = resp.getWriter();       responseWriter.write(\"&lt;html&gt;&lt;body&gt;\");     Enumeration&lt;String&gt; headerNames = req.getHeaderNames();     while (headerNames.hasMoreElements()) {         String headerName = headerNames.nextElement();         Enumeration&lt;String&gt; headerValues = req.getHeaders(headerName);         while (headerValues.hasMoreElements()) {             String headerValue = headerValues.nextElement();             responseWriter.write(\"&lt;p&gt;\" + headerName + \": \" + headerValue + \"&lt;/p&gt;\");         }     }       resp.addHeader(\"my-custom-header\", \"value1\");     resp.addHeader(\"my-custom-header\", \"value2\");     resp.setIntHeader(\"my-custom-int-header\", 123);       responseWriter.write(\"&lt;/body&gt;&lt;/html&gt;\"); }   Zastosowanie nagłówków   Nagłówki jako część protokołu HTTP pełnią bardzo istotną rolę. Dla przykładu poniżej pokazuję zestaw nagłówków wysyłanych wraz z każdą odpowiedzią dla adresu www.samouczekprogramisty.pl:   $ curl -I www.samouczekprogramisty.pl HTTP/1.1 200 OK Set-Cookie: PHPSESSID=xxxxxxxxxxxxxxxxxxxxxx; path=/ Expires: Thu, 19 Nov 1981 08:52:00 GMT Cache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0 Pragma: no-cache Content-Type: text/html; charset=UTF-8 Link: &lt;https://www.samouczekprogramisty.pl/wp-json/&gt;; rel=\"https://api.w.org/\" Date: Sun, 02 Apr 2017 10:46:08 GMT Accept-Ranges: bytes Server: LiteSpeed Connection: Keep-Alive   Użyłem do tego programu curl, który pozwala na wysyłanie żądań HTTP z linii poleceń. Fragment powyżej powoduje wysłanie żądania typu HEAD, które zwraca wyłącznie nagłówki (bez właściwej zawartości strony). Przykładowe zastosowanie nagłówków:     Pozwalają na ustawianie ciasteczek (przeczytasz o nich w kolejnym akapicie) (Set-Cookie),   Pozwalają na określenie zawartości strony. To dzięki nim przeglądarka wie jak interpretować odpowiedź, którą dostanie. To nagłówek określa czy w odpowiedzi znajduje się plik HTML (Content-Type: text/html; charset=UTF-8). Czy może są dane binarne reprezentujące obrazek do wyświetlenia (Content-Type: image/jpeg),   Mogą przyspieszyć ładowanie strony w przeglądarce. Jeśli odwiedziłeś już jakąś stronę to przeglądarka mogła zapisać część danych, które wyświetliła (w tym część nagłówków). Następnym razem nie wyśle żądania typu GET (aby pobrać całą zawartość) a jedynie HEAD (aby pobrać nagłówki). Po sprawdzeniu nagłówków stwierdzi, że dane się nie zmieniły i wyświetli poprzednio zapamiętaną zawartość (Cache-Control: public, max-age=63115200, Last-Modified: Thu, 16 Mar 2017 17:12:14 GMT).   Takie sprawdzenie może odbyć się też w inny sposób. Przeglądarka może wysłać zapytanie typu GET dołączając odpowiednie nagłówki. Później żądanie z nagłówkami interpretowane jest przez serwer. Jeśli serwer stwierdzi, że przeglądarka ma aktualną treść (potwierdza to nagłówek), wówczas wysyła odpowiedź informującą przeglądarkę, że jej kopia treści jest najnowsza. W takim przypadku zamiast przesyłać przez sieć obrazek o wielkości 400kB wysyła odpowiedź, która ma dużo mniej danych – kilka kilobajtów (ETag: \"9db5f14aeaa00872\",   Nagłówki to metadane (dane o danych). Zdarza się, że są wykorzystywane do przesyłania dodatkowych informacji na temat danego żądania/odpowiedzi.   Mimo tego, że nagłówki są powszechnie stosowane w codziennej pracy z aplikacjami webowymi (szczególnie na początku) nie są one “kluczowe”. Większość z nich ustawiają za nas biblioteki zewnętrzne. Niemniej jednak dobrze jest wiedzieć o tym, że istnieją i do czego służą.   Ciasteczka   Ciasteczka to mechanizm opisany w specyfikacji protokołu HTTP. W uproszczeniu można powiedzieć, że ciasteczka to informacje, które dołączane są do żądania i mogą być ustawiane w odpowiedzi. Ciasteczka połączone są z adresem, pod który wysyłane jest żądanie. Przeglądarka internetowa wysyłając żądanie pod adres www.samouczekprogramisty.pl wyszukuje jakie ciasteczka ma zapisane dla tej domeny i dołącza je automatycznie do każdego żądania.             Ciasteczka – diagram        Po stronie serwera, w odpowiedzi można ustawiać ciasteczka. Można to robić przy pomocy nagłówka Set-Cookie. Z racji tego, że jest to bardzo popularny mechanizm istnieje osobny zestaw metod, które pomagają pracować z ciasteczkami:      addCookie()   getCookies()   Samo ciasteczko reprezentowane jest przez klasę Cookie. Podstawowymi atrybutami ciasteczka jest jego nazwa i wartość.   Dodatkowo możesz ustawić też inne atrybuty, takie jak czas życia ciasteczka. Jeśli jest on ustawiony, wówczas przeglądarka dołącza ciasteczka do żądań tak długo jak są one “ważne”.   Przykładowy serwlet poniżej w odpowiedzi generuje stronę, która wyświetla wszystkie dostępne ciasteczka. Ustawia też jedno ciasteczko o nazwie custom-cookie, jego czas życia ustawiony jest na 10 sekund.   @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {     PrintWriter responseWriter = resp.getWriter();       responseWriter.write(\"&lt;html&gt;&lt;body&gt;\");     for (Cookie cookie : Optional.ofNullable(req.getCookies()).orElse(new Cookie[0])) {         responseWriter.write(\"&lt;p&gt;\" + cookie.getName() + \" \" + cookie.getValue() + \"&lt;/p&gt;\");     }       Cookie cookie = new Cookie(\"custom-cookie\", \"bum bum cyk cyk\");     cookie.setMaxAge(10);     resp.addCookie(cookie);       responseWriter.write(\"&lt;/body&gt;&lt;/html&gt;\"); }   Przy drugim otworzeniu strony generowanej przez ten serwlet1 zobaczysz ciasteczko custom-cookie   Wcześniej opisane narzędzia developerskie dostępne w przeglądarkach internetowych pozwalają na podejrzenie zawartości ciasteczek.             Narzędzia developerskie – ciasteczka        Zastosowanie ciasteczek   Jak wiesz z poprzedniego artykułu protokół HTTP jest bezstanowy. Ciasteczka pomagają obejść tę właściwość. Bardzo często ciasteczka wykorzystywane są do zapisania informacji czy użytkownik jest zalogowany w aplikacji. Aplikacja sprawdza czy takie ciasteczko istnieje, jeśli tak udostępnia użytkownikowi jakieś dane. Jeśli ciasteczka brakuje wówczas przekierowuje go na stronę logowania.   Po zalogowaniu aplikacja ustawia ciasteczko, które następnie dołączane jest do kolejnych żądań automatycznie.   Użytkownik ma możliwość ustawienia przeglądarki internetowej w ten sposób aby nie zapamiętywała ciasteczek. Nie jest to popularne, ale warto wiedzieć, że jest taka możliwość.   Podobnie jak w przypadku nagłówków – w codziennej pracy z aplikacjami webowymi często nie używa się ciasteczek bezpośrednio. Dzieje się to niejako “pod spodem” - zewnętrzne biblioteki wykorzystują ten mechanizm.   Sesja   Można powiedzieć, że sesja to połączenie kilku żądań/odpowiedzi w jedną całość. Dzięki temu aplikacja webowa może powiązać te żądania z jednym użytkownikiem. Sesje najczęściej zaimplementowane są przy pomocy ciasteczek. Specyfikacja serwletów określa nawet domyślną nazwę takiego ciasteczka – jest to JSESSIONID.   Innym mechanizmem, na którym może być oparta sesja jest przepisywanie adresu URL (ang. URL rewriting). Polega ono na dołączaniu identyfikatora sesji do adresu. W takim przypadku adres może wyglądać następująco https://www.samouczekprogramisty.pl/kurs-programowania-java;jsessionid=1234. To kontener serwletów decyduje o metodzie, która powinna być użyta do “podtrzymywania” sesji.   Podobnie jak w przypadku ciasteczek sesja ma swój dedykowany obiekt. Po stronie serwera sesja reprezentowana jest przez HttpSession.   Czas trwania sesji   Sesja nie jest trzymana wiecznie. To jak długo powinna być utrzymywana przez kontener serwletów określone jest przez parametr metody setMaxInactiveInterval. Określa on w sekundach jak długo pomiędzy żądaniami klienta sesjsa powinna być utrzymywana.   Atrybuty sesji   Sesję można porównać do mapy, w której przechowujemy pary klucz-wartość. Są to atrybuty sesji. Dzięki nim mamy możliwość przekazywania informacji wewnątrz aplikacji webowej pomiędzy żądaniami klienta. Poniższy zestaw metod pozwala na pracę z atrybutami sesji:     getAttributeNames()   getAttribute()   removeAttribute()   setAttribute()   Wartościami atrybutów są obiekty, jednak musisz pamiętać o tym aby nie były one “duże”. Atrybuty sesji powinny być także serializowalne. Jeśli nie miałeś do czynienia z serializacją zapraszam do artykułu poświęconemu serializacji w języku Java.   Mechanizm przechowywania sesji   Sesje mogą być przechowywane w pamięci kontenera serwletów. Nie jest to jedyna metoda ich przechowywania. Naiwny mechanizm może być oparty o ciasteczka, w takim przypadku wszystkie atrybuty sesji byłyby ciasteczkami.   Kontener serwletów do zapisywania sesji może użyć standardowych plików. Sesja może być także zapisana w różnych bazach danych. To w jaki sposób będzie to realizowane zależy od konfiguracji kontenera serwletów. W podstawowych przypadkach nie musisz się przejmować tą konfiguracją.   @WebServlet(\"/session\") public class SessionServlet extends HttpServlet {       public static final String VISIT_COUNTER_ATTR = \"visitCounter\";       @Override     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {         PrintWriter responseWriter = resp.getWriter();           responseWriter.write(\"&lt;html&gt;&lt;body&gt;\");           HttpSession session = req.getSession();         Enumeration&lt;String&gt; attributeNames = session.getAttributeNames();         while (attributeNames.hasMoreElements()) {             String attributeName = attributeNames.nextElement();             responseWriter.write(\"&lt;p&gt;\" + attributeName + \": \" + session.getAttribute(attributeName) + \"&lt;/p&gt;\");         }         responseWriter.write(\"&lt;/body&gt;&lt;/html&gt;\");         increaseVisitCounter(session);     }       private void increaseVisitCounter(HttpSession session) {         Object counter = session.getAttribute(VISIT_COUNTER_ATTR);         Integer numberOfVisits;         if (counter != null) {             numberOfVisits = (Integer) counter + 1;         }         else {             numberOfVisits = 1;         }         session.setAttribute(VISIT_COUNTER_ATTR, numberOfVisits);     } }   Ćwiczenie do wykonania   Napisz serwlet, który pobierze wartość wszystkich parametrów przekazanych w adresie. Pobierze wszystkie parametry, których wartości są liczbami całkowitymi, następnie sumę tych parametrów wyświetli na ekranie. Serwlet ten powinien dodatkowo w sesji zapamiętać sumaryczną wartość wszystkich takich operacji. Ta całkowita suma także powinna być wyświetlona   Na przykład, pierwsze żądanie pod adres /serwlet?parametr=123&amp;inny-parametr=abc&amp;test=-3 powinno wyświetlić stronę:   requestSum: 120 totalSum: 120   Kolejne żądanie pod adres /serwlet?parametr=336 powinno wyświetlić stornę   requestSum: 336 totalSum: 456   W przypadku jakichkolwiek problemów z wykonaniem ćwiczenia możesz rzucić okiem na przykładowe rozwiązanie.   Dodatkowe materiały do nauki      Artykuł na wikipedi na temat ciasteczek,   Lista standardowych nagłówków HTTP,   Specyfikacja serwletów,   Specyfikacja protokołu HTTP/1.1,   Kod źródłowy przykładów użytych w artykule.   Podsumowanie   Po lekturze tego artykułu znasz już zestaw podstawowych klocków, z których buduje się aplikacje webowe. Wiesz już czym są parametry adresu URL i jak z nimi pracować. Znasz mechanizm nagłówków. Potrafisz powiedzieć czym jest ciasteczko i sesja. Po wykonaniu ćwiczenia znasz te zagadnienia także od praktycznej strony. Innymi słowy kawał wiedzy ;).   Na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największego grona Samouków takich jak Ty. Podziel się proszę linkiem do artykułu ze swoimi znajomymi. Mam nadzieję, że im także spodoba się artykuł.   Jeśli nie chcesz ominąć kolejnych artykułów dopisz się do samouczkowego newslettera i polub stronę na facebooku. Do następnego razu!                 Jeśli zrobisz to szybciej niż 10 sekund po pierwszym wywołaniu. &#8617;           ","categories": ["DSP2017","Kurs aplikacji webowych"],
        "tags": [],
        "url": "/naglowki-sesje-i-ciasteczka/",
        "teaser": "/assets/images/2017/04/01_naglowki_ciasteczka_sesje_artykul.jpeg"
      },{
        "title": "Filtry w aplikacjach webowych",
        "excerpt":"     Artykuł ten zakłada, że wiesz czym są serwlety i adnotacje. Pownieneś potrafić już napisać serwlet i używać adnotacji. Powinieneś wiedzieć czym są parametry URL i jak z nimi pracować. Jeśli chcesz uzupełnić wiedzę z tego zakresu zapraszam do artykułów:      serwlety w aplikacjach internetowych,   parametry URL, ciasteczka, nagłówki i sesje,   adnotacje w języku Java.     Czym jest filtr   Filtry to nic innego jak klasy, które są wywoływane przed uruchomieniem właściwego serwletu. Po wykonaniu serwletu odpowiedź wraca przez ten sam filtr do klienta, który wysłał żądanie. Przed serwletem może być wywołanych wiele filtrów.   Poniższy rysunek pokazuje zapytanie od klienta, które przechodzi przez dwa filtry. Następnie uruchamiany jest serwlet. Przed przekazaniem odpowiedzi wracamy do tych samych filtrów w odwrotnej kolejności.             Łańcuch wywołania filtrów.        Filtry oznacza się adnotacją @WebFilter1. Podobnie jak wszystkie inne elementy specyfikacji serwletów także filtry mają swój cykl życia.   Cykl życia filtrów   Każdy z filtrów ma swój cykl życia. Podobnie jak w serwletach mamy tu metody init i destroy. Właściwa praca serwletu odbywa się wewnątrz metody doFilter.     init – metoda odpowiedzialna za inicjalizację serwletu. Musi się powieść aby kontener serwletów używał tego filtra,   doFilter – tu odbywa się właściwa praca filtra. Metoda ta wywołana jest przed przekazaniem żądania do klasy serwletu,   destroy – metoda, w które filtr ma szansę “posprzątać” po sobie :)       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Mapowanie filtrów   Adnotacja @WebFilter posiada kilka elementów. Opiszę te, które pozwalają na przypisywanie filtrów do poszczególnych serwletów/zasobów:     urlPatterns – lista szablonów adresów URL do których filtr powinien być zaaplikowany,   servletNames – lista nazw serwletów. Każdy serwlet może mieć nazwę, którą możesz ustawić za pomocą elementu name adnotacji @WebServlet,   value – domyślny element, stosowany zamiennie z urlPatterns.   Szablony adresów URL pozwalają na mapowanie filtrów do adresów URL. Wewnątrz tych szablonów możesz używać znaku *, który pozwala na dopasowanie większej liczby adresów URL. Spójrz na kilka przykładów:     /some/url/address – szablon pasuje tylko do jednego adresu URL - /some/url/address,   /some/other/resource.* – szablon pasuje do wielu adresów URL różniących się rozszerzeniami. Na przykład /some/other/resource.html czy /some/other/resource.jpeg,   /some/*/address – szablon pasuje do wielu adresów URL. Na przykład /some/url/address czy /some/picture/addresss,   * – szablon pasuje do wszystkich adresów URL. Jeśli stworzysz filtr, który będzie miał taki szablon będzie on aplikowany do wszystkich zapytań.   Kilka przykładów z użyciem adnotacji:     @WebFilter(\"/chainingServlet\") – filtr będzie zaaplikowany wyłącznie do żądań dotyczących adresu /chainingServlet,   @WebFilter(urlPatterns = \"/chainingServlet\", servletNames = \"someRandomServletName\") – filtr będzie zaaplikowany do żądań dotyczących adresu /chainingServlet i żądań obsługiwanych przez serwlet o nazwie someRandomServletName   @WebFilter(urlPatterns = {\"/some/*/thing\", \"/other/*/thing\"}) – filtr będzie zaaplikowany do żądań dotyczących wielu adresów pasujących do jednego z wzorców.   Łańcuch filtrów  Na diagramie pokazanym wyżej widziałeś dwa filtry. Filtrów uruchomionych przed właściwym serwletem może być wiele. Tworzą one tak zwany łańcuch filtrów (ang. filter chain). Łańcuch ten reprezentowany jest przez instancję klasy implementującej interfejs FilterChain. Instancja ta przekazana jest jako parametr do metody doFilter wewnątrz filtra.   Interfejs ten zawiera wyłącznie jedną metodę doFilter, która wykonuje kolejny filtr w łańcuchu. Jeśli filtr był ostatnim spowoduje to wywołanie właściwego serwletu.   Pociąga to za sobą ważną konsekwencję. Jeśli wewnątrz filtra nie wywołasz tej metody właściwe żądanie nigdy nie dotrze do serwletu.   Przykłady użycia filtrów   Zacznijmy od definicji prostego serwletu. Serwlet w odpowiedzi wyświetla wszystkie atrybuty żądania. Jeśli żaden atrybut nie jest ustawiony, w odpowiedzi wysłana zostanie pusta strona HTML.   @WebServlet(urlPatterns = \"/simpleServlet\", name = \"simpleServletName\") public class SimpleServlet extends HttpServlet {       @Override     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {         PrintWriter responseWriter = resp.getWriter();           responseWriter.write(\"&lt;html&gt;&lt;body&gt;\");         Enumeration&lt;String&gt; attributeNames = req.getAttributeNames();         while (attributeNames.hasMoreElements()) {             String attributeName = attributeNames.nextElement();             Object attributeValue = req.getAttribute(attributeName);             responseWriter.write(\"&lt;p&gt;\" + attributeName + \": \" + attributeValue + \"&lt;/p&gt;\");         }         responseWriter.write(\"&lt;/html&gt;&lt;/body&gt;\");     } }   Następnie filtr, który dodaje jeden atrybut wewnątrz metody doFilter:   @WebFilter(servletNames = \"simpleServletName\") public class SimpleFilter implements Filter {       @Override     public void init(FilterConfig filterConfig) throws ServletException {     }       @Override     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {         System.out.println(\"before\");         request.setAttribute(\"simpleServletAttribute\", \"simpleServlet\");         chain.doFilter(request, response);         System.out.println(\"after\");     }       @Override     public void destroy() {     } }   Po uruchomieniu takiej aplikacji i wysłaniu żądania na adres /simpleServlet powinieneś zobaczyć jeden atrybut dodany prez filtr.   Kolejność wykonywania filtrów   Wiesz już, że do jednego zasobu/serwletu można aplikować wiele filtrów. Bardzo często kolejność ich wykonania jest bardzo istotna. Na przykład nie ma potrzeby kompresowania odpowiedzi jeśli użytkownik nie ma prawa do wykonania danego żądania. Równie ważne jest logowanie wszystkich żądań, niezależnie od tego czy użytkownik ma do nich prawo czy nie.   Mając zatem trzy filtry:      loggingFilter – loguje podstawowe informacje o żądaniu,   authenticationFilter – weryfikuje tożsamość użytkownika,   compressionFilter – kompresuje odpowiedź.   Muszą one być uruchomione w dokładnej tej kolejności: loggingFilter, authenticationFilter, compressionFilter, aby aplikacja działa poprawnie.   Tutaj mam dla Ciebie smutną wiadomość. Używając adnotacji, bez pliku web.xml (nazywanego deskryptorem wdrożenia) nie mamy nad tym kontroli. Specyfikacja serwletów nie definiuje kolejności filtrów definiowanych wyłącznie przy pomocy adnotacji @WebFilter. Co za tym idzie kolejność ta może być różna w różnych implementacjach i nie powinieneś na niej polegać.   Sprawa wygląda zupełnie inaczej w przypadku użycia pliku web.xml. W tym przypadku kolejność jest dobrze zedfiniowana:      wszystkie filtry pasujące do danego żądania używające urlPattern według kolejności w pliku web.xml,   wszystkie filtry pasujące do danego żądania używające servletName według kolejności w pliku web.xml.   Na tym etapie ważne jest żebyś wiedział o tym ograniczaniu. Sam plik web.xml opiszę w osobnym artykule, wtedy też dowiesz się jak dokładnie określać kolejność wykonania filtrów.   Zastosowanie filtrów   Teraz jak już wiesz jak wyglądają filtry musisz dowiedzieć się o ich zastosowaniu. Filtry pozwalają na uniknięcie duplikacji kodu. Najczęściej to właśnie dzięki filtrom realizowane są następujące funkcjonalności:     uwierzytelnianie – sprawdzenie czy użytkownik ma prawo do uzyskania odpowiedzi na dane żądanie. Innymi słowy, sprawdzenie czy jest zalogowany,   logowanie, audyt – tworzenie logów aplikacji webowej, część informacji (na przykład URL żądania) można logować już na etapie filtrów,   kompresja – filtry kompresują odpowiedź. Dzięki zmniejszonej objętości przeglądarka szybciej dostaje odpowiedź,   cache – czasami przez uruchomieniem serwletu można stwierdzić, że odpowiedź się nie zmieniła.   Poplularny Spring MVC także używa filtrów. Kilka z nich znajduje się w osobnym pakiecie. Na przykład:     CharacterEncodingFilter ustawia kodowanie znaków użyte w żadaniu, odpowiedzi2,   CommonsRequestLoggingFilter logowanie, filtr loguje informacje o przychodzących żądaniach.   Ćwiczenia   Na koniec czekają na Ciebie dwa ćwiczenia, w których przećwiczysz wiedzę dotyczącą filtrów w praktyce.     Napisz serwlet, który wyświetli wszystkie atrybuty żądania. Serwlet powinien być poprzedzony dwoma filtrami, każdy z nich powinien ustawić co najmniej jeden atrybut żądania,   Napisz filtr, który zablokuje wykonanie serwletu jeśli w adresie URL występuje jakikolwiek parametr o wartości “blokuj”.   Jak zwykle, pytaj jeśli ukniesz na którymś etapie. W ostateczności możesz rzucić okiem na przykładowe rozwiązanie. Zachęcam jednak do samodzielnego rozwiązania ćwiczeń, wtedy nauczysz się najwięcej.   Podsumowanie   Filtry w aplikacjach webowych pełnią bardzo ważną rolę. Dzisiaj udało Ci się tę rolę poznać. Wiesz czym jest filtr, wiesz także jak używać łańcuch filtrów. Poznałeś przykłady filtrów w Spring MVC. Przykładowe ćwiczenia pozwoliły Ci utrwalić materiał. Innymi słowy poznałeś kolejny klocek niezbędny do budowy aplikacji webowych. Gratulacje! Pochwal się o tym znajomym przesyłając im link do tego artykułu ;).   Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę dopisz się do samouczkowego newslettera i polub stronę na facebooku. Do następnego razu!                 Do tej pory nie wspomniałem Ci jeszcze o pliku web.xml, w którym także można filtry konfigurować. Aby niepotrzebnie nie komplikować plik ten opiszę w osobnym artykule. &#8617;                  Upraszczając, kodowanie znaków to sposób w jaki reprezentujemy tekst. To dzięki niemu wiadomo jak interpretować polskie znaki. Jeśli używa się błędnego kodowania mogą pojawić się “krzaki”. &#8617;           ","categories": ["DSP2017","Kurs aplikacji webowych"],
        "tags": [],
        "url": "/filtry-w-aplikacjach-webowych/",
        "teaser": "/assets/images/2017/04/15_filtry_artykul.jpeg"
      },{
        "title": "Pogodynka - JSON i walidacja",
        "excerpt":"Zabawa z JSONem   Nie mogę powiedzieć, że zrobiłem to “w tym tygodniu”. Nad pogodynką pracowałem wyłącznie dzisiaj :). Pierwszym problemem, który musiałem rozwiązać była serializacja i deserializacja obiektów klasy DateTime z biblioteki Joda.   Okazuje się, że biblioteka Gson, którą wybrałem domyślnie robi to w “dziwaczny sposób”. Jako proste i przejrzyste rozwiązanie zaimplementowałem swój własny konwerter DateTime -&gt; String -&gt; DateTime. Data przekazywana jest jako łańcuch znaków zapisany w formacie ISO8601.   Na tym etapie funkcjonalność testowałem wyłącznie z linii poleceń używając programu curl. Przykładowe zapytanie, które wysyła pomiar temperatury do komponentu Data Vault może wyglądać następująco:   $ curl -H 'Content-Type: application/json' http://localhost:8080/datavault/temperatures -d '{\"temperature\": 123, \"whenMeasured\": \"2017-04-16T17:06:36.652+02:00\"}' -v * Trying 127.0.0.1... * Connected to localhost (127.0.0.1) port 8080 (#0) &gt; POST /datavault/temperatures HTTP/1.1 &gt; Host: localhost:8080 &gt; User-Agent: curl/7.47.0 &gt; Accept: */* &gt; Content-Type: application/json &gt; Content-Length: 69 &gt; * upload completely sent off: 69 out of 69 bytes &lt; HTTP/1.1 201 Created &lt; Date: Sun, 16 Apr 2017 18:32:07 GMT &lt; Content-Type: application/json;charset=UTF-8 &lt; Content-Length: 30 &lt; Server: Jetty(9.2.15.v20160210) &lt; * Connection #0 to host localhost left intact {\"result\":\"Temperature added\"}   W wyniku widzimy “piękną” odpowiedź w formacie JSON. Oczywiście sama temperatura jeszcze się nigdzie nie zapisuje – nie podłączyłem do tego bazy danych. Zajmę się tym w najbliższym tygodniu.   Cała konwersja możliwa jest dzięki klasie CustomDateTimeAdapter. Następnie do automatycznego mechanizmu konwersji Springa dodaję to właśnie rozszerzenie. Dzięki takiej konfiguracji obiekty zawierające instancję DateTime poprawnie tworzone są na podstawie zapytań zawierających dane w formacie JSON.   Walidacja danych wejściowych   Nie można ufać użytkownikom. Nawet jeśli jedynym użytkownikiem w trym przypadku jest aplikacja, którą ja napisałem. Zakrawa to trochę o schizofrenię, ale takie są “dobre praktyki” pisania aplikacji. Dane wejściowe trzeba walidować, koniec i kropka.   Specyfikacja Bean Validation 1.0 doczekała się swojego następcy Bean Validation 1.1 i Bean Validation 2.0. Aktualnie wersja 1.1 jest “obowiązującą”. Jako implementację walidatora wybrałem Hibernate.   Proste dołączenie biblioteki w pliku datavault.gradle wraz z użyciem adnotacji @NotNull i @Valid pokazuje siłę Springa:   curl -H 'Content-Type: application/json' http://localhost:8080/datavault/temperatures -d '{\"temperature\": 123}' -v * Trying 127.0.0.1... * Connected to localhost (127.0.0.1) port 8080 (#0) &gt; POST /datavault/temperatures HTTP/1.1 &gt; Host: localhost:8080 &gt; User-Agent: curl/7.47.0 &gt; Accept: */* &gt; Content-Type: application/json &gt; Content-Length: 20 &gt; * upload completely sent off: 20 out of 20 bytes &lt; HTTP/1.1 400 Bad Request &lt; Date: Sun, 16 Apr 2017 18:46:30 GMT &lt; Content-Type: application/json;charset=UTF-8 &lt; Content-Length: 52 &lt; Server: Jetty(9.2.15.v20160210) &lt; * Connection #0 to host localhost left intact {\"errors\":[\"Field whenMeasured must not be empty!\"]}   Kontroler – serce aplikacji   Ta aplikacja to w praktyce jeden kontroller. Dodatkowo aplikacja zawiera drobną konfigurację rozszerzającą domyślne ustawienia.   @Controller @RequestMapping(\"/temperatures\") public class TemperatureController {      private static final Logger LOG = LoggerFactory.getLogger(TemperatureController.class);      private final TemperatureService temperatureService;      private final MessageSource messageSource;      @Autowired     public TemperatureController(TemperatureService temperatureService, MessageSource messageSource) {         this.messageSource = messageSource;         this.temperatureService = temperatureService;     }      @PostMapping(consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)     @ResponseBody     public ResponseEntity addTemperature(@Valid @RequestBody TemperatureMeasurement temperature, Errors errors) {         if (errors.hasErrors()) {             List&lt;String&gt; errorMessages = errors.getAllErrors().stream()                 .map(e -&gt; messageSource.getMessage(e.getCode(), e.getArguments(), null))                 .collect(Collectors.toList());             return new ResponseEntity&lt;&gt;(Collections.singletonMap(\"errors\", errorMessages), HttpStatus.BAD_REQUEST);         }          temperatureService.addTemperature(temperature);          return new ResponseEntity&lt;&gt;(Collections.singletonMap(\"result\", \"Temperature added\"), HttpStatus.CREATED);     }      @GetMapping(produces = MediaType.APPLICATION_JSON_UTF8_VALUE)     @ResponseBody     public Map&lt;String, List&lt;TemperatureMeasurement&gt;&gt; listTemperatures() {         LOG.debug(\"Listing all temperatures\");         List&lt;TemperatureMeasurement&gt; temperatures = temperatureService.getTemperatures();         Map&lt;String, List&lt;TemperatureMeasurement&gt;&gt; responseMap = new HashMap&lt;&gt;();         responseMap.put(\"temperatures\", temperatures);         return responseMap;     } }   Podsumowanie   Czasu już dużo nie zostało. Teraz zamierzam pracować nad pogodynką także w tygodniu, nie tylko w weekendy jak do tej pory. Trzymajcie za mnie kciuki ;)  ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-json-i-walidacja/",
        "teaser": "/assets/images/2017/04/16_pogodynka_05_artykul.jpg"
      },{
        "title": "Kontekst serwletu i obiekty nasłuchujące w aplikacjach webowych",
        "excerpt":"ServletContext   Obiekt implementujący ServletContext tworzony jest przez kontener serwletów. Istnieje tylko jeden taki obiekt dla każdej aplikacji webowej1. Służy on głównie do współdzielenia informacji w ramach aplikacji internetowej.   Czytając poprzednie artykuły z serii:      serwlety w aplikacjach webowych,   nagłówki, sesje i ciasteczka w aplikacjach webowych,   filtry w aplikacjach webowych,   poznałeś inne konteksty/zakresy. Na przykład kontekst zapytania i kontekst sesji HTTP. W każdym z tych kontekstów mogłeś ustawić zestaw atrybutów. Atrybuty te “żyły” tak długo, jak aktywny był dany kontekst.   Podobnie jest tutaj. Z tym, że kontekst serwletu jest tylko jeden i aktywny jest przez cały czas “życia” aplikacji webowej. Podobnie jak w poprzednich przypadkach możesz w nim ustawiać atrybuty.   Atrybuty kontekstu   Podobnie jak Servlet czy HttpRequest mają atrybuty, tak samo jest z ServletContext. Możesz ustawiać dowolne atrybuty w kontekście. Dzięki temu, że istnieje jeden kontekst dla całej aplikacji możesz w ten sposób przekazywać informacje pomiędzy serwletami.   Do pracy z atrybutami przechowywanymi w obiekcie implementującym ServletContext służą metody:      setAttribute,   getAttribute,   getAttributeNames,   removeAttribute.   Instancję implementującą ten interfejs możemy uzyskać wywołując metodę getServletContext znajdującą się w interfejsie ServletRequest.   Dzięki dostępowi do kontekstu serwletów możesz przekazywać atrybuty pomiędzy poszczególnymi serwletami. Przykładowy serwlet poniżej wyświetla wszystkie atrybuty kontekstu ustawiając wcześniej wartość jednego z nich.   @WebServlet(\"/servlet1\") public class Servlet1 extends HttpServlet {      @Override     protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {         PrintWriter writer = resp.getWriter();         writer.write(\"&lt;html&gt;&lt;body&gt;\");          ServletContext context = req.getServletContext();         context.setAttribute(\"pl.samouczekprogramisty.servlet1\", \"servlet1 attribute\");          Enumeration&lt;String&gt; attributeNames = context.getAttributeNames();         while (attributeNames.hasMoreElements()) {             String attributeName = attributeNames.nextElement();             writer.write(\"&lt;p&gt;\" + attributeName + \": \" + context.getAttribute(attributeName) + \"&lt;p&gt;\");         }         writer.write(\"&lt;/body&gt;&lt;/html&gt;\");     } }   Spróbuj uruchomić aplikację, która ma taki serwlet. Wpisując adres serwletu w przeglądarce zobaczysz wszystkie atrybuty kontekstu. Poza atrybutem ustawionym przez serwlet zobaczysz także inne, część z nich jest ustawiona przez sam kontener serwletów.   Dokumentacja zaleca aby nazwy atrybutów były zapisane w podobnej konwencji jak pakiety. Innymi słowy nazwy powinny wyglądać jak “odwrócone adresy www”, na przykład pl.samouczekprogramisty.servelet1.   Dynamiczna konfiguracja   Ponadto twórcy bibliotek dzięki dostępowi do obiektu ServletContext mogą dynamicznie tworzyć serwlety, filtry czy obiekty nasłuchujące zdarzenia (ang. listener). Funkcjonalność ta raczej nie jest wykorzystywana w innych przypadkach.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Obiekty nasłuchujące   Szczerze mówiąc miałem tu problem z tłumaczeniem :). Chodzi tu o obiekty, które potocznie nazywamy “listenerami”. Obiekty nasłuchujące nie są specyficzne dla aplikacji webowych. Koncept tego typu używany jest także w innych miejscach. Jest to jeden z szeroko znanych wzorców projektowych. Wzorzec ten nazywany jest obserwatorem (ang. observer).   Kontener serwletów ma informację o wystąpieniu pewnych zdarzeń. Ty jako programista możesz chcieć być informowany o tych zdarzeniach. Na przykład chcesz dostać informację kiedy obiekt ServletContext zostanie utworzony. Aby to zrobić tworzysz własną instancję obiektu nasłuchującego, który implementuje interfejs ServletContextListener. Dodatkowo tę implementację oznaczasz adnotacją @WebListener. Dzięki temu kontener serwletów wie o twojej klasie. Wie, że musi ją powiadomić o takim zdarzeniu.   Poniższy diagram pokazuje jak te komponenty układają się w całość:             Wzorzec obserwator.        Kontener przechowuje listę obiektów implementujących interfejs ServletContextListener. Jedną z implementacji może być klasa MyOwnImplementation pokazana na diagramie. Następnie w każdym momencie kiedy wystąpi zdarzenie, którym interesuje się nasza implementacja kontener uruchamia odpowiednie metody. Metody te są zdefiniowane w iterfejsie ServletContextListener.   Zdarzenia dotyczące kontekstu nie są jedynymi. W trakcie działania aplikacji webowej występuje wiele zdarzeń. Zdarzenia te związane są z cyklem życia poszczególnych elementów aplikacji. Na przykład możesz być poinformowany o tym, że została utworzona sesja HTTP, albo o tym, że jakieś zapytanie zostało wysłane do aplikacji.   Poniżej znajduje się lista kilka przykładowych interfejsów obiektów nasłuchujących:      ServletContextListener,   ServletContextAttributeListener,   ServletRequestListener,   ServletRequestAttributeListener,   HttpSessionListener,   HttpSessionAttributeListener.   Na przykład, obiekt implementujący interfejs ServletContextAttributeListener zostanie poinformowany o wszystkich operacjach na atrybutach kontekstu serwletu.   Aby kontener serwletów wiedział o obiekcie nasłuchującym trzeba go odpowiednio skonfigurować. Każdy z obiektów nasłuchujących powinien być dekorowany wspomnianą adnotacją @WebListener2.   Poniżej znajduje się przykładowa implementacja interfejsu ServletContextListener, która dodaje dodatkowy atrybut w momencie utworzenia kontekstu serwletu:   @WebListener public class MyServletContextListener implements ServletContextListener {      @Override     public void contextInitialized(ServletContextEvent sce) {         sce.getServletContext().setAttribute(\"pl.samouczekprogramisty.listener\", \"listener value\");     }      @Override     public void contextDestroyed(ServletContextEvent sce) {         // do nothing     } }   Praktyczne wykorzystanie   W poprzednich artykułach opisujących elementy specyfikacji serwletów odwoływałem się do Spring MVC. Nie inaczej będzie i tym razem. Przykładowym obiektem nasłuchującym zaimplementowanym w Spring MVC może być WebAppRootListener. Obiekt ten reaguje na utworzenie/zniszczenie kontekstu serwletów. Zachęcam Cię do przeszukania kodu źródłowego Spring MVC pod kątem innych obiektów, które reagują na zdarzenia w aplikacji webowej.   Implementacja odpowiednich interfejsów, które pozwalają reagować na zdarzenia umożliwia konfigurację Spring MVC. W praktyce “magiczny Spring” nie robi nic innego jak wykorzystuje elementy specyfikacji serwletów.   Ćwiczenie do wykonania   Napisz serwlet, który wyświetli wszystkie atrybuty kontekstu. Dodatkowo niech serwlet ten dodaje parametry przekazane w adresie URL jako atrybuty kontekstu. Na przykład żądanie na adres .../serwlet?pl.parametr=xxx powinno utworzyć atrybut kontekstu o nazwie pl.parametr z wartością xxx.   Uzupełnij tę aplikację o implementację interfejsu ServletContextAttributeListener. Niech twój słuchacz w momencie dodawania nowego atrybuty kontekstu doda kolejny atrybut z datą jego dodania. Na przykład jeśli dodamy atrybut o nazwie pl.parametr to automatycznie powinien zostać dodany atrybut pl.parametr.when. Wartością nowego atrybutu powinna być data dodania atrybutu.   Pamiętaj żeby zabepieczyć się przed “nieskończoną pętlą” – twój obiekt zostanie także powiadomiony o dodaniu atrybutu pl.parametr.when i wtedy spróbuje dodać kolejny pl.pamrater.when.when, o którym także byłby powiadomiony.   Jeśli będziesz miał problem z rozwiązaniem zadania możesz rzucić okiem na przykładowe rozwiązanie. Jak zwykle jednak zachęcam do samodzielego rozwiązania zadania. Wtedy nauczysz się najwięcej.   Dodatkowe materiały do nauki      Specyfikacja serwletów,   Artykuł dotyczący wzorca projektowego obserwator,   Kod źródłowy przykładów użytych w artykule.   Podsumowanie   Wiesz już czym jest ServletContext i do czego może być używany. Poznałeś przykłady obiektów nasłuchujących zdarzeń w aplikacjach webowych. Znasz przykłady praktycznego ich wykorzystania. Po wykonaniu ćwiczenia potrafisz zastosować tę wiedzę w praktyce. Innymi słowy poznałeś mechanizmy, pozwalające na działanie aplikacji webowych :).   Mam nadzieję, ze artykuł Ci się podobał. Jeśli nie chcesz pominąć kolejnych zapisz się do samouczkowego newslettera i polub stronę na facebooku.   Na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największego grona czytelników. Możesz mi w tym pomóc przekazując link do artykułu swoim znajomym. Z góry dziękuję i do następnego razu!                 Właściwie to, istnieje tylko jeden taki obiekt dla każdej wirtualnej maszyny Java. Jeśli twoja aplikacja webowa jest rozproszona wówczas obiektów implementujących ten interfejs jest tyle, ile instancji JVM. &#8617;                  Może też być zdefiniowany w pliku web.xml, web-fragment.xml czy dodany dynamicznie przez metody dostępne w ServletContext, jednak te sposoby wykraczają poza zakres tego artykułu. &#8617;           ","categories": ["DSP2017","Kurs aplikacji webowych"],
        "tags": [],
        "url": "/kontekst-serwletu-i-obiekty-nasluchujace-w-aplikacjach-webowych/",
        "teaser": "/assets/images/2017/04/21_listener_kontekst_servlet_context_artykul.jpeg"
      },{
        "title": "Pogodynka – JPA i Spring Data",
        "excerpt":"Baza danych   Dla celów testowych i na “środowisku developerskim” (czytaj moim własnym komputerze) używam prostej bazy danych. Mam tu na myśli HyperSQL. Jest to baza danych, której zawartość może być trzymana wyłącznie w pamięci.   Tego typu rozwiązanie idealnie nadaje się do pracy na środowisku programistycznym. Często też bazy danych tego typu używane są w trakcie testów integracyjnych. W trakcie takich testów możliwe jest testowanie właściwej integracji z bazą danych.   Dostęp do tej bazy danych możliwy jest po dodaniu jednej linijki do konfiguracji Gradle   compile group: 'org.hsqldb', name: 'hsqldb', version: '2.4.0'   Jeśli chcesz dowiedzieć się czegoś więcej o samym Gradle zachęcam do przeczytania wprowadzenia do Gradle.   JPA i ORM   I tu wchodzą nam dwie wielkie kobyły ;). JPA czyli Java Persistence API i ORM czyli Object-Relational Mapping. JPA to specyfikacja, która została włączona do specyfikacji EJB (ang. Enterprise Java Beans). Specyfikacja ta określa mechanizmy, które pozwalają na “proste” zarządzanie zawartością bazy danych przez obiekty w Java.   Innymi słowy instancje klas odpowiadają wierszom w bazie danych. Mapowanie zawartości bazy danych na obiekty Javy to “mapowanie obiektowo-relacyjne” – ORM. Najszerzej stosowaną implementacją JPA jest Hibernate. To właśnie tę implementację użyłem w Pogodynce. Aby uzyskać wsparcie Hibernate niezbędne są następujące zależności:   compile group: 'org.hibernate', name: 'hibernate-entitymanager', version: '5.2.10.Final' compile group: 'org.hibernate', name: 'hibernate-core', version: '5.2.10.Final'   ORM   Nie wchodząc w szczegóły samego JPA i Hibernate opiszę co udało mi się osiągnąć. Przy pomocy odpowiednich adnotacji w kodzie Javy mapuję obiekty klasy TemperatureMeasurement na wiersze w tabeli temperature_measurements. Całość wymagała kilku adnotacji w kodzie oraz dodatkowej konfiguracji, która pozwoliła na mapowanie typu DateTime na odpowiedni typ w bazie danych.   Jedyny obiekt modelu, który aktualnie jest dostępny wygląda następująco:   @Entity @Table(name = \"temperature_measurements\",        indexes = @Index(name = \"idx_temperature_measurements_when_meaasured\",                         columnList = \"when_measured\")) public class TemperatureMeasurement {       @Id     @SequenceGenerator(name = \"measurements_sequence\", allocationSize = 5, sequenceName = \"temperature_measurements_seq\")     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"measurements_sequence\")     private Long id;       private BigDecimal temperature;       @Column(name = \"when_measured\")     private DateTime whenMeasured;       public TemperatureMeasurement() {     }       public TemperatureMeasurement(BigDecimal temperature, DateTime whenMeasured) {         this.temperature = temperature;         this.whenMeasured = whenMeasured     }       @NotNull     public BigDecimal getTemperature() {         return temperature;     }       @NotNull     public DateTime getWhenMeasured() {         return whenMeasured;     } }   Warstwa dostępu do danych   Warstwa DAO (ang. Data Access Object) jest automatycznie generowana. Są to obiekty pośredniczące zarządzane przez Spring. Interfejs DAO, którym posługuję się w aplikacji sprowadza się do kilku linijek:   @Repository public interface TemperatureMeasurementDAO extends CrudRepository&lt;TemperatureMeasurement, Long&gt; { }   Taka “magia” dostępna jest dzięki użyciu Spring Data:   compile group: 'org.springframework.data', name: 'spring-data-jpa', version: '1.11.3.RELEASE   Magiczna konfiguracja Spring   Całość konfiguracji to jeden nowy plik. Tworzy on odpowiednie obiekty, które wymagane są przez specyfikację JPA   @Configuration @EnableTransactionManagement @EnableJpaRepositories(basePackages = \"pl.samouczekprogramisty.pogodynka.datavault.model\") public class JPAConfigration {       @Bean     public DataSource getDataSource() {         DriverManagerDataSource dataSource = new DriverManagerDataSource();         dataSource.setDriverClassName(\"org.hsqldb.jdbc.JDBCDriver\");         dataSource.setUrl(\"jdbc:hsqldb:mem:datavault_test\");         dataSource.setUsername(\"datavault_test\");         dataSource.setPassword(\"datavault_test\");         return dataSource;     }       @Bean     public LocalContainerEntityManagerFactoryBean entityManagerFactory() {         LocalContainerEntityManagerFactoryBean entityManager = new LocalContainerEntityManagerFactoryBean();         entityManager.setDataSource(getDataSource());         entityManager.setJpaVendorAdapter(new HibernateJpaVendorAdapter());         entityManager.setPackagesToScan(\"pl.samouczekprogramisty.pogodynka.datavault.model\");           Properties jpaProperties = new Properties();         jpaProperties.setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.HSQLDialect\");         jpaProperties.setProperty(\"hibernate.show_sql\", \"true\");         jpaProperties.setProperty(\"hibernate.format_sql\", \"true\");         jpaProperties.setProperty(\"hibernate.hbm2ddl.auto\", \"create-drop\");         jpaProperties.setProperty(\"jadira.usertype.autoRegisterUserTypes\", \"true\");           entityManager.setJpaProperties(jpaProperties);           return entityManager;     }       @Bean     public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {         JpaTransactionManager transactionManager = new JpaTransactionManager();         transactionManager.setEntityManagerFactory(entityManagerFactory);           return transactionManager;     }       @Bean     public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {         return new PersistenceExceptionTranslationPostProcessor();     } }   Podsumowanie   Dzisiaj mam “gotową” aplikację webową, która wystawia dwa adresy URL. Pozwalają one na utworzenie nowej instancji pomiaru temperatury i pobrania wszystkich istniejących pomiarów. Kolejnym krokiem będzie zaimplementowanie “logowania” użytkowników i wystawienia takiej aplikacji na świat. Następnie będę mógł zintegrować czujnik z tak działającą aplikacją.   Po kilku dniach działania aplikacji będę miał wystarczająco dużo rzeczywistych pomiarów temperatury, które pozwolą mi na pracę nad interfejsem użytkownika.   Jeśli chcesz zobaczyć aktualną wersję aplikacji możesz ją znaleźć na samouczkowym githubie. Trzymaj się i do następnego razu!  ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-jpa-i-spring-data/",
        "teaser": "/assets/images/2017/04/23_pogodynka_06_artykul.jpeg"
      },{
        "title": "Deskryptor wdrożenia w aplikacjach webowych",
        "excerpt":"Deskryptor wdrożenia   Plik web.xml nazywany jest deskryptorem wdrożenia. W starszych wersjach specyfikacji serwletów tylko przy jego pomocy można było konfigurować aplikacje webowe.   Aktualnie plik web.xml nie jest wymagany, praktycznie wszystkie elementy można skonfigurować przy pomocy adnotacji. Jednak nadal zdarzają się aplikacje gdzie taki plik jest wykorzystywany. W związku z tym dobrze jest wiedzieć o jego istnieniu.   Oczywiście zawartością deskryptora wdrożenia są znaczniki XML, jeśli nie miałeś wcześniej styczności z tym formatem zapraszam do osobnego artykułu ze wstępem do formatu XML.   Plik web.xml powinien znajdować się bezpośrednio w katalogu WEB-INF wewnątrz pliku war. Struktura przykładowego pliku war może wyglądać następująco:   $ unzip -l build/libs/05_webxml-1.0-SNAPSHOT.war  Archive:  build/libs/05_webxml-1.0-SNAPSHOT.war   Length      Date    Time    Name ---------  ---------- -----   ----         0  2017-04-27 20:15   META-INF/        25  2017-04-27 20:12   META-INF/MANIFEST.MF         0  2017-04-27 20:15   WEB-INF/         0  2017-04-27 20:15   WEB-INF/classes/         0  2017-04-26 21:36   WEB-INF/classes/pl/         0  2017-04-26 21:36   WEB-INF/classes/pl/samouczekprogramisty/         0  2017-04-26 21:36   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/         0  2017-04-27 20:15   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/webxml/         0  2017-04-27 20:15   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/webxml/xml/      1073  2017-04-27 20:15   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/webxml/xml/XMLConfiguredListener.class      3045  2017-04-27 20:15   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/webxml/xml/XMLConfiguredServlet.class      1330  2017-04-27 20:15   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/webxml/xml/XMLConfiguredFilter.class      1227  2017-04-26 21:40   WEB-INF/web.xml ---------                     -------      6700                     13 files   Strukturę aplikacji webowej opisywałem szczegółowo w pierwszym artykule wprowadzającym.   Szablon web.xml   Plik web.xml informuje kontener serwletów o wersji specyfikacji serwletów. Dla każdej wersji specyfikacji plik ten różni się nagłówkiem. Dla wersji 3.1 szablon pliku wygląda następująco   &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee          http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"          version=\"3.1\"&gt;     &lt;!-- tutaj są znaczniki do konfiguracji --&gt; &lt;/web-app&gt;   Jak widzisz w głównym węzłem deskryptora wdrożenia jest &lt;web-app&gt;. Wewnątrz tego znacznika znajduje się właściwe elementy konfigurujące aplikację webową.   W kolejnej części artykułu zobaczysz porównanie konfiguracji przy pomocy znaczników XML z konfiguracją zapisaną w postaci adnotacji. W obu przypadkach pokazywał będę prostą aplikację, która zawiera serwlet, obiekt nasłuchujący i filtr. Przykładowy deskryptor wdrożenia możesz zobaczyć na samouczkowym githubie. Zawiera on wszystkie elementy omówione poniżej.   Konfiguracja serwletu   Podstawowa konfiguracja serwletu sprowadza się do nadania mu nazwy i podpięcia go pod odpowiedni adres URL. Zobacz jak taki efekt można osiągnąć przy pomocy znaczników XML i adnotacji.   Znaczniki XML   &lt;servlet&gt;     &lt;servlet-name&gt;my-servlet&lt;/servlet-name&gt;     &lt;servlet-class&gt;pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredServlet&lt;/servlet-class&gt; &lt;/servlet&gt;  &lt;servlet-mapping&gt;     &lt;servlet-name&gt;my-servlet&lt;/servlet-name&gt;     &lt;url-pattern&gt;/servlet-url-xml&lt;/url-pattern&gt; &lt;/servlet-mapping&gt;   Powyższy fragment xml zawiera kilka znaczników. Pierwszy z nich &lt;servlet&gt; informuje kontener serwletów o tym, ze w klasie pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredServlet znajduje się serwlet. Nadałem mu nazwę my-servlet. Następnie wewnątrz &lt;servlet-mapping&gt;, posługując się wcześniej nadaną nazwą podpinam serwlet pod adres URL /servlet-url-xml.   Adnotacje   @WebServlet(name = \"my-servlet\", urlPatterns = \"/servlet-url-annotations\") public class AnnotationConfiguredServlet extends HttpServlet   W przypadku adnotacji sprawa jest prostsza. Tutaj nie muszę podawać dokładnej nazwy klasy wraz z pakietem. Adnotacja znajduje się właśnie w nad tą klasą.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Konfiguracja filtra   Aby skonfigurować podstawowy filtr należy nadać mu nazwę i podpiąć go pod serwlet czy adres URL. Poniżej możesz porównać oba sposoby konfiguracji.   Znaczniki XML   &lt;filter&gt;     &lt;filter-name&gt;my-filter&lt;/filter-name&gt;     &lt;filter-class&gt;pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredFilter&lt;/filter-class&gt; &lt;/filter&gt;   &lt;filter-mapping&gt;     &lt;filter-name&gt;my-filter&lt;/filter-name&gt;     &lt;url-pattern&gt;/servlet-url-xml&lt;/url-pattern&gt; &lt;/filter-mapping&gt;   &lt;filter-mapping&gt;     &lt;filter-name&gt;my-filter&lt;/filter-name&gt;     &lt;servlet-name&gt;my-servlet&lt;/servlet-name&gt; &lt;/filter-mapping&gt;   Podobnie jak w przypadku serwletu pierwszy znacznik &lt;filter&gt; tworzy filtr o nazwie my-filter podpinając klasę pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredFilte. Kolejne dwie grupy znaczników &lt;filter-mapping&gt; posługują się nazwą filtra. Pierwsza używa &lt;url-pattern&gt; aby podpiąć filtr pod konkretny adres URL. Wewnątrz drugiego znacznika &lt;filter-mapping&gt; użyłem &lt;servlet-name&gt; aby podpiąć filtr pod konkretny serwlet.   Adnotacje   @WebFilter(filterName = \"my-filter\", servletNames = \"my-servlet\", urlPatterns = \"/servlet-url-annotations\") public class AnnotationConfiguredFilter implements Filter   Konfiguracja obiektu nasłuchującego   W tym przypadku sprawa jest prosta. Cała konfiguracja sprowadza się do poinformowania kontenera serwletów o istnieniu takiego obiektu.   Znacznik XML   &lt;listener&gt;     &lt;listener-class&gt;pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredListener&lt;/listener-class&gt; &lt;/listener&gt;   Adnotacje   @WebListener public class AnnotationConfiguredListener implements ServletRequestListener   Dodatkowe informacje   Kiedy plik web.xml jest niezbędny   Są sytuacje w których plik web.xml jest niezbędny. W przypadku kiedy istotna jest kolejność wykonania filtrów, obiektów nasłuchujących czy przypisania serwletów do adresów URL plik web.xml jest niezbędny. Specyfikacja serwletów jasno mówi o tym, że bez tego pliku kolejność wywołania tych elementów nie jest jasno określona.   Modułowość konfiguracji   Konfigurację podobną do tej z pliku web.xml można zawrzeć w plikach web-fragment.xml. Taki plik może znajdować się w każdym pliku jar, który znajduje się wewnątrz pliku war (ponownie odsyłam do artykułu opisującego strukturę aplikacji webowej). Konkretnie w katalogu META-INF wewnątrz pliku jar.   Wewnątrz pliku web-fragment.xml możemy użyć tych samych znaczników jak pliku web.xml. Różnicą jest tutaj znacznik główny. W tym przypadku jest to &lt;web-fragment&gt; a nie &lt;web-app&gt;.   Ostatnie słowo ma web.xml   Chociaż dla niektórych osób adnotacje czy pliki web-fragment.xml mogą być preferowanym wyborem to web.xml ma ostatnie słowo. Mam tu na myśli atrybut metadata-complete. Atrybut ten można ustawić na znaczniku &lt;web-app&gt;. Jeśli przyjmie on wartość true, wówczas adnotacje i pliki web-fragment.xml będą ignorowane. W takim przypadku cała konfiguracja aplikacji webowej musi znajdować się w pliku web.xml.   &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"          xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"          xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee          http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"          version=\"3.1\"          metadata-complete=”true”&gt;       &lt;!-- tutaj są znaczniki do konfiguracji --&gt;   &lt;/web-app&gt;   Przykładowe aplikacje   Na potrzeby tego artykułu napisałem dwie proste aplikacje. Jedna z nich skonfigurowana jest wyłączni przy użyciu znaczników xml, druga tylko adnotacji. Zachęcam do zajrzenia do kodu, który umieściłem na githubie:     Aplikacja konfigurowana wyłącznie przy pomocy XML,   Aplikacja konfigurowana wyłącznie przy pomocy adnotacji.   Podsumowanie   Przedstawiłem tutaj wyłącznie podstawowe znaczniki stosowane wewnątrz pliku web.xml. Zależało mi na tym abyś sam mógł zobaczyć różnicę pomiędzy tymi podejściami. Nie oceniam, które z nich jest lepsze, które gorsze. Każde z nich ma swoje wady i zalety. Wybierz ten sposób, który bardziej Ci odpowiada i konsekwentnie się go trzymaj.   Z jednej strony posiadanie całej konfiguracji w pliku xml jest wygodne. Jednak z drugiej strony w przypadku adnotacji edytując kod od razu masz informacje o konfiguracji. Ciekawy jestem Twojego zdania. Które podejście bardziej Ci odpowiada i dlaczego?  ","categories": ["DSP2017","Kurs aplikacji webowych"],
        "tags": [],
        "url": "/deskryptor-wdrozenia-w-aplikacjach-webowych/",
        "teaser": "/assets/images/2017/04/27_deskryptor_wdrozenia_artykul.jpeg"
      },{
        "title": "Pogodynka – konfiguracja serwera",
        "excerpt":"Konfiguracja maszyny produkcyjnej   Chociaż do konfiguracji produkcyjnej daleko, będę tutaj pisał o “serwerze produkcyjnym”. Mam tu na myśli VPS (ang. Virtual Private Server), na którym uruchomiona będzie baza danych oraz Tomcat. To właśnie do tej maszyny Malinka wysyłała będzie informacje o odczytach temperatury. Ta sama maszyna posłuży do uruchomienia aplikacji webowej pokazującej interfejs użytkownika.   Namiastka produkcji   Konfiguracja ta nijak nie przypomina “produkcji z prawdziwego zdarzenia”. Nie ma tu mowy o sensownym monitorowaniu czy zapewnieniu niezawodności. Mam świadomość tych niedociągnięć :). Jak na hobbystyczny projekt konfiguracja tego typu powinna być wystarczająco dobra. Oczywiście przy takiej konfiguracji nie zapewnię dostępności na poziomie pięciu dziewiątek (nawet, chyba dwóch nie dałbym rady ;)).   Aby poprawić tę konfigurację musiałbym poświęcić na nią więcej czasu i zapłacić więcej za utrzymanie finalnego środowiska. “Budżetu” na Pogodynkę, nie chciałbym powiększać, więc zostanę przy aktualnych ustawieniach. Akceptuję te niedociągnięcia z racji tego, że projekt ten nie jest krytyczny.   Zarządzanie konfiguracją   Mógłbym skonfigurować maszynę ręcznie. Na pewno byłoby to szybsze niż zabawa, którą zaraz opiszę. Jednak tego typu podejście prowadzi do sytuacji, w której odtworzenie konfiguracji jest ciężkie. Chciałbym tego uniknąć.   Konfiguracja maszyny produkcyjnej zarządzana jest przy pomocy Puppet’a. Całość trzymana jest w repozytorium razem z kodem. Dzięki takiemu podejściu wiem dokładnie co, jak i kiedy zostało zmienione. A co najważniejsze mogę tę konfigurację szybko odtworzyć.   Czym jest Puppet   Puppet to narzędzie, które pomaga zarządzać konfiguracją maszyn. Puppet używa tak zwanych manifestów, które określają konfigurację danej maszyny. Wewnątrz manifestów używany jest DSL (ang. Domain Specific Language), który ułatwia tę konfigurację.   Przy pomocy tego narzędzia i odpowiednich manifestów możemy na przykład zainstalować bazę danych, odpowiednią wersję Javy czy Tomcat’a.   Manifesty z konfiguracją pakowane są w tak zwane moduły. W moim przypadku używam na przykład modułów do instalacji Tomcat’a czy zarządzania regułami firewalla. Mogę śmiało powiedzieć, że konfiguracja większości standardowych rzeczy dostępna jest w odpowiednim module.   Kod odpowiedzialny za konfigurację   Aby niepotrzebnie nie komplikować sprawy uruchamiam Puppeta w trybie “samodzielnym”. Nie ma tutaj standardowej maszyny, z której pobierana jest konfiguracja (“puppet mastera”). Jest to uproszczenie, które w tym przypadku jest akceptowalne.   Cały katalog modułów trzymam w repozytorium git. Zewnętrzne moduły puppeta dodałem do repozytorium jako submoduły git’a.   $ git submodule status  3f6863ac4c97f834bebc811852452b073d202682 puppet/modules/apt (2.4.0)  5c4a9141d08a7b23dcada029d23b82590632d0f4 puppet/modules/concat (2.2.1)  23016934d23c5c2f3f3edbc2ec8279f8faac2457 puppet/modules/firewall (1.8.2)  5b01b42e2228d9c979f7fcbdfac5b926f25f5dea puppet/modules/postgresql (4.9.0)  ec1ce78c1ec0c82d440cb5d1b98a065c858d3c0e puppet/modules/staging (0.4.1)  1ae06c50acc89be4dea28b6e85b5a23f479f584e puppet/modules/stdlib (4.16.0)  e545ac740122c9a873aec66b24148a43dd65f9ef puppet/modules/tomcat (1.6.1)   Dzięki takiemu podejściu zawsze (jak tylko github i repozytoria modułów są dostępne ;)) mam dostęp do całości konfiguracji.   Konfiguracja przy pomocy Puppet’a   Wykupiłem VPS w jednej z firm. Zainstalowałem tam obraz z Debianem Jessie. W tym miejscu zaczyna się zabawa ;).   Instalacja Javy   Zacznijmy od Javy. Instalacja Javy 8 na Debianie 8 nie jest trywialna :). Chodzi mi tu o Javę od Oracle. OpenJDK można zainstalować z “backports”. Po zabawie z kluczami do apt udało mi się Javę zainstalować:   class pogodynka::java {   $package = \"oracle-java8-installer\"   $responsefile = \"/var/cache/debconf/${package}.preseed\"      file {     'java-apt-list':       path    =&gt; '/etc/apt/sources.list.d/webupd8team-java.list',       content =&gt; \"deb http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main deb-src http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main\";          'java-apt-key':       path   =&gt; '/etc/apt/trusted.gpg.d/webupd8.gpg',       source =&gt; 'puppet:///modules/pogodynka/webupd8.gpg';        $responsefile:       ensure  =&gt; 'present',           content =&gt; \"${package} shared/accepted-oracle-license-v1-1 select true\";   }             package {            'oracle-java8-installer':       ensure       =&gt; 'latest',       responsefile =&gt; $responsefile,       require      =&gt; [File['java-apt-list'], File['java-apt-key'], Class['apt::update']];          'oracle-java8-set-default':       ensure  =&gt; 'latest',       require =&gt; Package['oracle-java8-installer'];   } }   Tomcat   Podobnie jak w przypadku firewalla użyłem istniejącego modułu.   Cała konfiguracja sprowadza się do kilku linijek:   $catalina_home = '/opt/tomcat8.5' $catalina_base = \"${catalina_home}/production\"   tomcat::install {   '/opt/tomcat8.5':     source_url =&gt; 'http://mirror.23media.de/apache/tomcat/tomcat-8/v8.5.14/bin/apache-tomcat-8.5.14.tar.gz'; }   tomcat::instance {   'tomcat8.5-production':     catalina_home =&gt; $catalina_home,     catalina_base =&gt; $catalina_base; }   Sam Tomcat uruchamiany jest z poziomu użytkownika tomcat. Z tego powodu nie mogę uruchomić go tak aby nasłuchiwał na domyślnym porcie HTTP. Tomcat słucha na 8080.   Firewall   Podobnie jak w przypadku Tomcat’a użyłem istniejącego modułu. Oczywiście nie chcę otwierać na świat serwera produkcyjnego. Sytuacja, w której na przykład baza danych była dostępna z zewnątrz jest zła. Domyślnie chcę mieć otwarty mały podzbiór portów. Oczywiście standardowy port 80 dla HTTP i 22 dla SSH potrzebuję, resztę trzeba wyciąć.   To się musiało stać, w trakcie zabawy z konfiguracją firewall odciąłem sobie dostęp po SSH. Skończyło się to reinstalacją Debiana na nowo. Całe szczęście cała konfiguracja trzymana jest w repozytorium więc odtworzenie poprzedniego stanu sprowadziło się do kilku komend:   wget https://raw.githubusercontent.com/SamouczekProgramisty/Pogodynka/master/puppet/bootstrap.sh chmod +x bootstrap.sh ./bootstrap.sh   Poza wycięciem portów za pomocą konfiguracji firewalla będę musiał zrobić przekierowanie ruchu z portu 80 na 8080. Ta część jeszcze przede mną ;).   Podsumowanie   Konfiguracja jeszcze nie jest gotowa. Jeśli chcesz zobaczyć jej aktualną wersję możesz rzucić okiem na samouczkowego githuba. Jeszcze męczę się z dopięciem niektórych elementów. W każdym razie postęp, mały bo mały, jest. Do końca projektu zostały jeszcze trzy tygodnie. Trzymaj za mnie kciuki ;). Do następnego razu!  ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-konfiguracja-serwera/",
        "teaser": "/assets/images/2017/04/30_konfiguracja_puppet_artykul.jpeg"
      },{
        "title": "`String` cache i `StringBuilder` w praktyce",
        "excerpt":"Literał znakowy   Na początku powtórka podstaw. Literał znakowy to ciąg znaków otoczony cudzysłowami. Jest to instancja klasy String, jednak tworzona jest bez udziału słówka kluczowego new. Przykład poniżej pokazuje literał znakowy przypisany do zmiennej:   String someLiteral = “some constant value”;   Jak działa klasa String   Instancje klasy String reprezentują łańcuchy znaków. Wewnętrznie znaki te przetrzymywane są w tablicy znaków. Tablica ta ma typ char[]. Implementacja klasy String chowa przed programistą mechanizmy operowania na tej tablicy.   Instancje klasy String są niemutowalne. Oznacza to tyle, że po stworzeniu instancji nie ma możliwości jej modyfikacji. Kilka metod wymienionych poniżej zwraca nowe instancje, pozostawiając tę na której zostały wywołane bez zmian:      replace – podmienia znak w łańcuchu znaków,   substring – zwraca pewną część łańcucha znaków określoną indeksami,   toLowerCase – zamienia wielkie litery na małe w nowej instancji,   toUpperCase – zamienia łańcuch znaków na wielkie litery,   trim – zwraca nową instancję bez początkowych i końcowych białych znaków.   Co jeśli String nie ma metody, której potrzebuję?   Chociaż klasa String zawiera spory zestaw metod, nie jest to lista kompletna. Jeśli trafisz na taki przypadek nie próbuj wynaleźć koła na nowo. Lepiej rzuć okiem na istniejące biblioteki. Na przykład na commons-lang . Biblioteka ta zawiera klasę StringUtils, w której znajdziesz masę przydatnych metod operujących na łańcuchach znaków.  Konkatenacja łańcuchów znaków   Najprostszym sposobem otrzymania łańcucha znaków jaki nas interesuje jest złożenie go z wielu części. Służy do tego operator +. Operacja ta nazywana jest konkatenacją.   System.out.println(\"some\" + \" \" + \"string\" + \" \" + \"literal\");   W przypadku konkatenacji każdy z elementów konwertowany jest do typu String używając metody toString1:   int x = 10; Object y = new Object(); System.out.println(\"some\" + \" \" + x + \" \" + \"literal\" + \" \" + y);   Używanie operatora + może być bardzo wygodne jednak czasami może prowadzić do zaskakujących (na początku) rezultatów. Proszę porównaj dwie poniższe linijki kodu:   System.out.println(1 + 2 + \"test\"); // 3test System.out.println(\"test\" + 1 + 2); // test12   Pierwsza z nich na początku doda dwie liczby uzyskując 3 a następnie dołączy do niej łańcuch znaków. Druga do łańcucha znaków dołączy dwie kolejne liczby. Dzieje się tak ponieważ operator + jest lewostronnie łączny. Oznacza to tyle, że w tym przypadku wyrażenie to wykonywane jest od lewej do prawej strony.   W pierwszym przypadku do liczby 1 dodajemy liczbę 2, następnie “dodajemy” do niej łańcuch znaków. W drugim przypadku do łańcucha znaków dodajemy kolejno dwie liczby.   Klasa String posiada także metodę concat, która działa w podobny sposób do operatora +2.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Wydajność a konkatenacja   Wiesz już, że instancje klasy String są niemutowalne. Wszystkie metody znajdujące się w klasie String, modyfikują łańcuch znaków tak naprawdę tworzą jego nową instancję.   Nie inaczej jest z konkatenacją. Proszę spójrz na przykład poniżej:   String some = \"some\"; String space = \" \"; String random = \"random\"; String string = \"string\";   String someString = some + space + random + space + string;   Tak na prawdę, zanim powstałaby finalna instancja klasy String potrzebne byłoby aż trzy “tymczasowe” obiekty3. Dopiero piąty obiekt byłby tym, który mógłby być przypisany do zmiennej someString. Dlaczego aż cztery? Wynika to z niemutowalności instancji klasy String. Nie możemy, posługując się wyłącznie instancjami klasy String od razu stworzyć finalnej wersji. Tworzone są obiekty “pośrednie”:      “some “ (zwróć uwagę na spację na końcu),   “some random”,   “some random “ (ponownie ze spacją).   Tworzenie takich nowych tymczasowych instancji nie jest wydajne. Można to zrobić lepiej. Z pomocą przychodzą klasy StringBuilder i StringBuffer4.   Jak używać klasy StringBuilder   Klasa StringBuilder podobnie jak String jest opakowaniem tablicy znaków typu char[]. StringBuilder jednak jest typem mutowalnym. Instancje tego typu w można konwertować do typu String używając metody toString.   Najprostszym sposobem utworzenia instancji klasy StringBuilder jest użycie konstruktora bezparametrowego. Następnie możesz modyfikować ten obiekt używając dostępnych metod.   Bardzo przydatną metodą z tej klasy jest przeciążona metoda append. Pozwala ona na wydajne łączenie łańcuchów znaków. Proszę spójrz na przykład poniżej pokazujący sposób użycia klasy:   public void compilerConcatenationFiddling() {     String some = \"some\";     String space = \" \";     String random = \"random\";     String string = \"string\";       StringBuilder someSttringBuilder = new StringBuilder();     someSttringBuilder.append(some);     someSttringBuilder.append(space);     someSttringBuilder.append(random);     someSttringBuilder.append(space);     someSttringBuilder.append(string);       String someString = someSttringBuilder.toString(); }   Różnica pomiędzy StringBuilder a StringBuffer   Istnieje też inna implementacja tej samej funkcjonalności. Jest to klasa StringBuffer. Jeśli masz przed sobą rozmowę kwalifikacyjną dobrze jest znać różnicę między tymi klasami. Jest to jedno ze “sztampowych” pytań rekrutacyjnych ;).   Główną różnicą jest to, że instancję klasy StringBuffer można bezpiecznie używać nawet w aplikacjach wielowątkowych. Instancje klasy StringBuilder nie powinny być współdzielone pomiędzy wątkami. Cecha ta ma jedną ważną konsekwencję. Ze względu na brak synchronizacji instancje klasy StringBuilder są nieznacznie szybsze od StringBuffer.   Dodatkowo możesz zapoznać się też z klasą StringJoiner, która oferuje podobną funkcjonalność. Jest ona wykorzystywana na przykład podczas łączenia strumieni.   Optymalizacja konkatenacji przez kompilator   Mamy dwa elementy układanki. Klasę StringBuilder, która dużo lepiej się sprawdza przy pracy z łączeniem znaków. Konkatenację, która nie jest wydajnym sposobem łączenia łańcuchów znaków.   Mamy też metodę append, którą już poznałeś. Jest ona odpowiednikiem + w konkatenacji. Nie można czegoś z tym zrobić?   Oczywiście, że można! I to właśnie jest robione przez kompilator. Tak naprawdę, pisząc kod:   String some = \"some\"; String space = \" \"; String random = \"random\"; String string = \"string\";   String someString = some + space + random + space + string;   Kompilator kompiluje go do postaci, która wygląda podobnie do fragmentu niżej:   String some = \"some\"; String space = \" \"; String random = \"random\"; String string = \"string\";   StringBuilder x = new StringBuilder(); x.append(some); x.append(space); x.append(random); x.append(space); x.append(string);   String someString = x.toString();   Innymi słowy kompilator optymalizuje za nas kod. Czy ta optymalizacja zawsze działa? Niestety nie, są przypadki kiedy nawet taka optymalizacja nie daje rady. Proszę spójrz na przykład poniżej. Jest to pętla, która dołącza aktualny stan licznika do łańcucha znaków.   String finalString = \"\"; for (int counter = 0; counter &lt; 1000000; counter++) {     finalString = finalString + \" \" + counter; }   Jak zoptymalizuje to kompilator? Będzie to kod podobny do tego:   String finalString = \"\"; for (int counter = 0; counter &lt; 1000000; counter++) {     StringBuilder x = new StringBuilder();     x.append(finalString);     x.append(\" \");     x.append(counter);     finalString = x.toString(); }   Niestety mimo optymalizacji wewnątrz pętli dalej musimy tworzyć blisko milion obiektów tymczasowych. To jest czasochłonne. Lepszym rozwiązaniem jest poniższy fragment kodu:   StringBuilder finalStringBuilder = new StringBuilder(); for (int counter = 0; counter &lt; 1000000; counter++) {     finalStringBuilder.append(\" \");     finalStringBuilder.append(counter); } String finalString = finalStringBuilder.toString();   W tym przypadku sam tworzę instancję klasy StringBuilder i używam jej wewnątrz pętli.   Literały i cache   Specyfikacja języka Java narzuca pewne wymagania związane z optymalizacją pracy z łańcuchami znaków. Każdy łańcuch znaków, który jest literałem umieszczany jest w cache’u.     Tutaj drobna dygresja. Cache to mechanizm, który pozwala na przetrzymywanie wartości jakiegoś typu. Przeważnie uzyskanie tej wartości jest czasochłonne. Założeniem tego mechanizmu jest pozwolenie na szybsze dotarcie do tych wartości w późniejszym czasie. Dodatkowo pozwala on na optymalizację zajmowanego miejsca. Elementy znajdujące się w cache’u przeważnie się nie powtarzają.   Cache może być zrealizowany na wiele sposobów, najprostszą implementacją może być zwykła instancja HashMap. W bardziej zaawansowanych zastosowaniach używa się osobnych programów/baz danych, które zapewniają tę funkcjonalność, na przykład memcached.     Oznacza to tyle, że poniższe dwie zmienne są referencjami na dokładnie ten sam obiekt na stercie. Dzieje się tak, ponieważ są one literałami o tej samej zawartości:   Poniższe fragmenty kodu są testami jednostkowymi. Jeśli chcesz przeczytać więcej na ten temat zapraszam do artykułu poświęconemu testom jednostkowym w Javie. Możesz też przeczytać kolejny artykuł poświęcony Test Driven Development.   @Test public void twoLiterals() {     String someVariable = \"samouczek programisty\";     String otherVariable = \"samouczek programisty\";       assertEquals(someVariable, otherVariable);     assertSame(someVariable, otherVariable); }   Pierwsze porównanie, sprawdza “zawartość” łańcucha znaków. Drugie porównuje adresy obiektów na stercie.   W przypadku utworzenia nowej instancji przy pomocy wywołania konstruktora, zawsze tworzone są nowe obiekty. Proszę porównaj poprzedni fragment kodu z tym poniżej:   @Test public void twoNewObjects() {     String someVariable = new String(\"samouczek programisty\");     String otherVariable = new String(\"samouczek programisty\");      assertEquals(someVariable, otherVariable);     assertNotSame(someVariable, otherVariable); }   W tym przypadku mamy do czynienia z dwoma osobnymi obiektami. W tym przypadku adresy obiektów są różne.   Metoda String.intern   Istnieje sposób aby zachować wartość łańcucha znaków w cache (lub pobrać go z cache). Dzięki tej metodzie w cache’u możemy zachować nawet instancje utworzone przy pomocy konstruktora. Służy do tego metoda intern. Wywołanie tej metody zachowuje w cache’u dany łańcuch znaków i zwraca instancję, która jest w cache’u zachowana. Jeśli ten literał istnieje już w cache’u, będzie tam zachowany wyłącznie raz.   Proszę spójrz na przykład poniżej   @Test public void literalAndInternedObject() {     String someVariable = \"samouczek programisty\";     String otherVariable = new String(\"samouczek programisty\").intern();       assertEquals(someVariable, otherVariable);     assertSame(someVariable, otherVariable); }   W tym przypadku oba porównania zwrócą wartość true.   Dodatkowe materiały do nauki   Poniżej przygotowałem dla Ciebie zestaw odnośników, które mogą pomóc w rozwijaniu wiedzy związanej z pracą z łańcuchami znaków:     Java Language Specification o konkatenacji,   dokumentacja klasy StringUtils,   dokumentacja klasy StringBuilder,   dokumentacja klasy StringBuffer,   dokumentacja klasy StringJoiner,   kod źródłowy przykładów użytych w artykule.   Podsumowanie   Po lekturze tego artykułu sporo wiesz o pracy z łańcuchami znaków. Poznałeś jedną z optymalizacji, które wprowadza kompilator. Umiesz odpowiedzieć na jedno ze sztampowych pytań rekrutacyjnych ;). Znasz sposób pracy z klasą StringBuilder. Dowiedziałeś się też o przydatnych metodach operujących na instancjach klasy String znajdujących się w bibliotece commons-lang.   Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć żadnego postu polub stronę na Facebooku i dopisz się do samouczkowego newslettera. Do następnego razu!                 Nie jest to do końca prawda, na przykład w przypadku typów prymitywnych stosowany jest inny mechanizm, zależny od typu zmiennej. &#8617;                  Istnieją oczywiście drobne różnice, na przykład zachowanie w odniesieniu do zmiennych o wartości null. &#8617;                  Piszę “potrzebne byłby” ponieważ kompilator wprowadza tu pewne optymalizacje, o których przeczytasz niżej. &#8617;                  Prawda jest taka, że kompilator Java w trakcie kompilacji wykrywa taką konkatenacją i zastępuje ją właśnie wywołaniem odpowiednich metod na instancji klasy StringBuilder. Więc w prostych przypadkach tragedii nie ma, gorzej jeśli w grę wchodzą pętle ;). &#8617;           ","categories": ["Kurs programowania Java","DSP2017"],
        "tags": [],
        "url": "/string-cache-i-stringbuilder-w-praktyce/",
        "teaser": "/assets/images/2017/05/06_string_cache_string_builder_artykul.jpeg"
      },{
        "title": "Pogodynka – konfiguracja bazy danych",
        "excerpt":"Niestety moje plany kontynuacji konfiguracji od początku tygodnia spełzły na niczym. Założyłem, że to co zostało to już “pikuś” i powinno pójść prosto… O tym, jak strasznie się myliłem przeczytasz poniżej ;).   Na początku chciałbym zastrzec, że nie jestem administratorem, więc jeśli masz jakiekolwiek uwagi mogące poprawić ustawienie środowiska bardzo proszę o informację w komentarzu.   Baza danych   Jako produkcyjną bazę danych wybrałem PostgreSQL. W przypadku tej aplikacji silnik bazy danych nie ma większego znaczenia. Nie będzie to “hurtownia danych” z olbrzymim zbiorem a raczej kilka (jedna?) prostych tabel.   W poprzednim tygodniu znalazłem moduł puppeta, który pomaga w konfiguracji instancji postgresql na serwerze. Ujarzmienie tego modułu trochę mi zajęło.   Okazało się, że serwer bazy danych nie mógł poprawnie wystartować ponieważ w na serwerze, nie wszystkie informacje o lokalizacji były dostępne:   root@debian:~# locale LANG=en_US.UTF-8 LANGUAGE= LC_CTYPE=\"en_US.UTF-8\" LC_NUMERIC=pl_PL.UTF-8 LC_TIME=pl_PL.UTF-8 LC_COLLATE=\"en_US.UTF-8\" LC_MONETARY=pl_PL.UTF-8 LC_MESSAGES=\"en_US.UTF-8\" LC_PAPER=pl_PL.UTF-8 LC_NAME=pl_PL.UTF-8 LC_ADDRESS=pl_PL.UTF-8 LC_TELEPHONE=pl_PL.UTF-8 LC_MEASUREMENT=pl_PL.UTF-8 LC_IDENTIFICATION=pl_PL.UTF-8 LC_ALL=   Jak widać tutaj używane były dwie lokalizacje en_US.UTF-8 i pl_PL.UTF-8. W pliku /etc/locale.gen dostępna byłą tylko jedna z nich. Dodanie obu lokalizacji do tego pliku pozwoliło utworzyć klaster i uruchomić serwer bazy danych. Po zmianie zawartości tego pliku konfiguracyjnego niezbędne jest uruchomienie polecenia locale-gen.   # grep -v '#' /etc/locale.gen pl_PL.UTF-8 UTF-8 en_US.UTF-8 UTF-8   Firewall   W poprzednim odcinku wspominałem o konfiguracji firewalla, niestety dalej nie udało mi się zrobić poprawnego przekierowania ruchu z portu 80 na port 8080. Muszę jeszcze nad tym popracować. Próbowałem znaleźć odpowiedź na to pytanie na StackOverflow, niestety z marnym rezultatem :(.   Przechowywanie haseł   Jednym z mechanizmów dostępnych w Puppecie jest hiera. Jest to swego rodzaju hierarchiczna konfiguracja dostępna dla manifestów puppeta. W moim przypadku nie używam hierarchii plików a jedynie jednego pliku passwords.yaml.   Plik ten zawiera wszystkie hasła, które nie powinny być dostępne na Githubie ;). Na przykład zawarte jest tam hasło dla głównego użytkownika bazy danych. Dzięki takiemu podejściu mogę dzielić się z Tobą konfiguracją, zachowując jednocześnie odpowiedni poziom bezpieczeństwa1.   Przykładowe użycie w manifeście wygląda następująco   hiera(‘variable_name’)   Wówczas puppet wyszukuje wartości zmiennej variable_name i wstawia ją w odpowiednie miejsce w manifeście. Przykładowe użycie możesz znaleźć w konfiguracji bazy danych. Same hasła są losowymi ciągami o długości 64 znaków generowanymi przy pomocy komendy pwgen.   Podsumowanie   Zostało coraz mniej czasu, deadline coraz bliżej a tu końca nie widać ;). Mam nadzieję, że w przyszłym tygodniu uda mi się już rozwiązać definitywnie problemy z konfiguracją. Na dzisiaj to tyle, trzymaj się i do następnego razu! ;)                 Jak na moją wiedzę z tego zakresu ;). &#8617;           ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-konfiguracja-bazy-danych/",
        "teaser": "/assets/images/2017/05/07_konfiguracja_puppet_artykul.jpeg"
      },{
        "title": "Formatter – formatowanie łańcuchów znaków",
        "excerpt":"Formatowanie   Wyobraź sobie, że chcesz pokazać użytkownikowi pewne zestawienie. Dane tego typu wygodnie jest prezentować w formie tabelarycznej. Tak dochodzimy do problemu formatowania. W jaki sposób można taki format uzyskać?   Problem ten można rozwiązać posługując się klasą Formatter. Instancje właśnie tej klasy użyte są w wielu innych miejscach. Na przykład:      PrintWriter.format Wewnątrz tej metody użyty jest Formatter. System.out to instancja klasy PrintWriter. Dzięki temu w bardzo wygodny sposób możesz formatować tekst wypisując go na konsoli używając metody System.out.format,   String.format statyczna metoda w klasie String, która pozwala na formatowanie łańcucha znaków. Jej implementacja także bazuje na klasie Formatter.   Zasada działania formattera   Formatter działa w oparciu o specjalny łańcuch znaków. Ten łańcuch opisuje sam format w jakim dane powinny być sformatowane. Może on wyglądać następująco:   %2$08.3f %3$(,08.3f %s   Nie przeraź się tym przykładem, po przeczytaniu tego artykułu będziesz dokładnie wiedział co ten magiczny wzorek oznacza. Jest on celowo skomplikowany, żeby pokazać Ci możliwości klasy Formatter.   Łańcuch formatujący   Zacznijmy od prostego przykładu:   Formatter formatter = new Formatter(); formatter.format(\"Samouczek Programisty istnieje od %d roku. Wszystkie artykuły pisze %s.\", 2015, \"Marcin\"); String formattedString = formatter.toString(); System.out.println(formattedString);   Po uruchomieniu tego fragmentu kodu na konsoli pokaże się:   Samouczek Programisty istnieje od 2015. Wszystkie artykuły pisze Marcin.   Powyższy fragment kodu to nic innego jak utworzenie nowej instancji klasy Formatter. Następnie na tej instancji wywołana jest metoda format. Jako pierwszy argument przyjmuje ona łańcuch formatujący. Następnie może przyjąć zmienną liczbę argumentów, które wykorzystywane są do uzupełniania formatu.   W naszym przypadku łańcuchem formatującym jest Samouczek Programisty istnieje od %d roku. Wszystkie artykuły pisze %s.. Natomiast dwa parametry służące do uzupełniania formatu to literały 2015 i Marcin.   Powyższy fragment można uprościć używając wcześniej wspomnianej metody PrintWriter.format:   System.out.format(\"Samouczek Programisty istnieje od %d roku. Wszystkie artykuły pisze %s.%n\", 2015, \"Marcin\")   W dalszej części artykułu posługiwał będę się tą uproszczoną wersją. Ważne jest żebyś miał jednak świadomość, że pod spodem używana jest instancja klasy Formatter.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Znaczniki konwersji   Wcześniej użyty łańcuch formatujący to zwykły String, wewnątrz którego znajdują się sekwencje interpretowane w specjalny sposób. Sekwencje te zawsze mają format:   %[indeks argumentu$][flagi][szerokość][.precyzja]konwersja   Wszystkie elementy otoczone nawiasami [] są opcjonalne więc w najprostszej wersji znacznik konwersji może mieć format %konwersja. Zwróć jeszcze raz uwagę na łańcuch formatujący   Samouczek Programisty istnieje od %d roku. Wszystkie artykuły pisze %s.   Jak widzisz znajdują się w nim dwa znaczniki konwersji. Są to %d i %s. Odnoszą się one do kolejnych argumentów metody format. W naszym przypadku są to literały 2015 i Marcin.   Znaczniki konwersji informują instancję klasy Formatter w jaki sposób dodatkowe parametry powinny być sformatowane. Występuje wiele znaczników konwersji, te najczęściej używane podsumowane są w tabeli poniżej:                  Znacznik       Typ argumentu       Działanie                       %b       dowolny       interpretuje argument jako wartość logiczną                 %s       dowolny       interpretuje argument jako łańcuch znaków                 %d       liczba całkowita       interpretuje argument jako liczbę całkowitą                 %o       liczba całkowita       interpretuje argument jako liczbę całkowitą zapisaną w systemie ósemkowym                 %x       liczba całkowita       interpretuje argument jako liczbę całkowitą zapisaną w systemie szesnastkowym                 %f       liczba zmiennoprzecinkowa       interpretuje argument jako liczbę zmiennoprzecinkową                 %%       -       nie potrzebuje argumentu, jest to sposób na umieszczenie znaku % wewnątrz sformatowanego łańcucha znaków                 %n       -       nie potrzebuje argumentu, jest to sposób na umieszczenie znaku nowej linii wewnątrz sformatowanego łańcucha znaków           Indeks argumentu   Metoda format przyjmuje łańcuch formatujący i parametry, które służą do wypełnienia znaczników formatujących. Jeśli chciałbyś użyć, któregoś obiektu wiele razy możesz użyć indeksu argumentu. Indeksy mają także zastosowanie jeśli chciałbyś użyć argumentów w innej kolejności. Numeracja argumentów zaczyna się od 1. Proszę spójrz na przykład poniżej:   System.out.format(\"[%2$s] [%1$s] [%1$s]\", \"pierwszy argument\", \"drugi argument\");   Po uruchomieniu tego kodu na konsoli zostanie wyświetlony napis:   [drugi argument] [pierwszy argument] [pierwszy argument]   Argument z numerem 1 użyty jest dwa razy, argument 2. użyty jest jako pierwszy w łańcuchu formatującym.  Szerokość   Możesz także określić minimalną szerokość jaką powinien zająć argument. Domyślnie zostanie on wyrównany do prawej. Proszę spójrz na przykład poniżej:   System.out.format(\"[%10s] [%3s]\", \"test\", \"test\");   Pierwszy fragment będzie uzupełniony sześcioma spacjami. Dzieje się tak ponieważ test ma cztery znaki a minimalna szerokość to 10. Zauważ, że w drugiej części gdzie minimalna szerokość to 3 żadne dodatkowe spacje nie zostały dodane.   [      test] [test]   Precyzja   Dodatkowo dla liczb zmiennoprzecinkowych możesz określić precyzję. Dodając ten modyfikator określasz ile liczb po przecinku powinno być wyświetlonych1.   Jeśli precyzja zostanie pominięta użyta jest domyślna wartość – sześć miejsc po przecinku. Proszę spójrz na przykład poniżej:   double x = 1.1234567890123; System.out.format(\"[%.10f] [%.3f] [%f]\", x, x, x);   Na konsoli pokażą się trzy liczby. Pierwsza z nich zawiera 10 liczb po przecinku, druga 3 a ostatnia domyślne 6:   [1.1234567890] [1.123] [1.123457]   Flagi   Flagi modyfikują zachowanie znaczników konwersji. Poniżej opiszę kilka dostępnych flag:     - element będzie wyrównany do lewej strony,   + liczba zawsze będzie zawierała znak (nawet jeśli jest dodatnia),   0 liczba będzie uzupełniona 0 do żądanej szerokości,   ( liczby ujemne nie będą prezentowane ze znakiem, będą otoczone (),   , użyj separatora do grupowania liczb. Ten separator zależny jest od lokalizacji.   Jeden znacznik może zawierać kilka flag. Dodatkowo wszystkie opisane wcześniej elementy mogą być połączone ze sobą.   Lokalizacja   W uproszczeniu lokalizacja to zbiór reguł, które określają w jaki sposób należy prezentować dany łańcuch znaków. Można powiedzieć, że jest to swego rodzaju tłumaczenie na reguły obowiązujące w danym kraju/regionie. To lokalizacja ma wpływ na to, jak na przykład wyświetlane są daty czy liczby.   Do tej pory w całym artykule używałem metod, które używały domyślnej lokalizacji, możesz ją uzyskać odwołując się do metody Locale.getDefault. Formatter pozwala także na formatowanie łańcucha znaków używając innych ustawień lokalizacji.   Proszę spójrz na przykład poniżej. Ta sama liczba prezentowana jest używając trzech różnych ustawień lokalizacji. Zwróć uwagę na to, że w każdym przypadku otrzymujemy różne wyniki:   double someNumber = 12345.12; System.out.format(Locale.US, \"%,.2f%n\", someNumber); System.out.format(Locale.GERMAN, \"%,.2f%n\", someNumber); System.out.format(Locale.forLanguageTag(\"PL\"), \"%,.2f%n\", someNumber);   12,345.12 12.345,12 12 345,12   Wyniki różnią się separatorem dziesiętnym (. lub ,) i separatorem grup liczb (,, . lub ` `).  Bardziej skomplikowany przykład   Teraz masz już wystarczająco dużo informacji aby zrozumieć pierwszy przykład użyty na początku artykułu. Dla przypomnienia:   %2$08.3f %3$(,08.3f %s   Rozkładając ten łańcuch formatujący na części widzisz trzy znaczniki formatujące:     %2$08.3f,   %3$(,08.3f,   %s.   Rozkładając najbardziej skomplikowany z nich %3$(,08.3f na części pierwsze otrzymujemy:     %3$ odwołanie się do trzeciego argumentu,   ( otoczenie liczb ujemnych nawiasami (),   , użycie separatora grup liczb,   0 uzupełnienie liczby zerami,   8 ustawienie minimalnej szerokości wyświetlanej liczby na osiem znaków,   .3 wyświetlenie trzech miejsc dziesiętnych,   f konwersja liczby zmiennoprzecinkowej.   Ćwiczenie do wykonania   Plik CSV zawiera trzy kolumny oddzielone znakiem ,. Pierwsza kolumna zawiera imię, druga liczbę zmiennoprzecinkową trzecia dzień tygodnia. Twoim zadaniem jest wczytanie zawartości tego pliku i wyświetlenie jej w formie tabeli. Efekt, który chcesz uzyskać wygląda następująco:   | Piotrek | 123.12  | poniedziałek | | Tomek   | 321.30  | wtorek       | | Marcin  | -123.12 | środa        | | Wojtek  | -3.12   | czwartek     |   Zachęcam Cię do rozwiązania zadania samodzielnie. Jeśli jednak będziesz miał problem z jego rozwiązaniem przygotowałem dla Ciebie przykładowe rozwiązanie.   Dodatkowe materiały do nauki   Artykuł ten to “skrót” dokumentacji dla klasy klasy Formatter. Jeśli chcesz dowiedzieć się czegoś więcej zachęcam do przeczytania dokumentacji tej klasy. Dodatkowo możesz także przejrzeć kod źródłowy wszystkich przykładów użytych w tym artykule.   Podsumowanie   W artykule przeczytałeś o formatowaniu łańcuchów znaków. Wiesz jak formatować liczby zmiennoprzecinkowe, poznałeś klasę Formatter wraz miejscami gdzie jest ona używana. Rozwiązując ćwiczenie wykorzystałeś całą wiedzę w praktyce.   Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli masz jakieś pytania nie wahaj się zadać je w komentarzach. Jeśli nie chcesz pominąć kolejnych artykułów polub Samouczka na facebooku i dopisz się do newslettera. Do następnego razu.                 Precyzję można także użyć na przykład wraz z %s, wtedy oznacza to maksymalną liczbę znaków do wyświetlenia. &#8617;           ","categories": ["Kurs programowania Java","DSP2017"],
        "tags": [],
        "url": "/formatter-formatowanie-lancuchow-znakow/",
        "teaser": "/assets/images/2017/05/12_formwatowanie_lancuchow_znakow_artykul.jpeg"
      },{
        "title": "Pogodynka – szkic interfejsu użytkownika",
        "excerpt":"Interfejs użytkownika   Nadszedł czas na część, która sprawia mi najmniej frajdy. Mianowicie na pracę z interfejsem użytkownika. Odszedłem już od wprawy i nie śledzę do końca technologii/bibliotek związanych z fontendem. Dlatego też poszedłem tutaj po najmniejszej linii oporu.   Mam świadomość, tego, że “dzisiejsze strony www robi się inaczej”, ale nie to jest celem tego projektu. W moim przypadku użyłem:      Highcharts – Rozbudowana biblioteka JavaScript do rysowania wykresów, świetnie nadaje się do mojego zastosowania. Licencja pozwala na darmowe użycie dla projektów niekomercyjnych,   Bootstrap – Ostylowanie strony, którego sam nie byłbym w stanie porządnie zrobić ;).   Po dodaniu odpowiednich wpisów w DNS podstawową wersję strony możesz zobaczyć pod adresem http://pogodynka.pietraszek.pl. Będzie to też adres, pod którym dostępna będzie finalna wersja strony.   Aktualnie strona to jedynie szkic, to co się zmieni to głównie kod JavaScript konfigurujący wykres aby pobierał dane z odpowiedniego miejsca. Aktualnie dane są na stałe wpisane w źródło strony, co nie jest oczywiście docelowym rozwiązaniem ;).             Pogodynka – interfejs użytkownika.        HTML i CSS znajdziesz na samouczkowym githubie. Sam wygląd strony do złudzenia przpomina jeden z przykładów ze strony Bootstrapa obcięty do moich potrzeb.   Serwer WWW   Tutaj wybór był prosty, zdecydowałem się na de facto standard obowiązujący w “branży”. Prosta instancja nginx serwująca statyczne strony HTML wydała się najprostszym rozwiązaniem.   Podsumowanie   Muszę jeszcze popracować nad spięciem wszystkich elementów w całość, został mi na to tydzień. Trzymajcie kciuki ;). Zostało też “kilka” brakujących funkcjonalności i finalne testy. Mówi się, że tego typu praca pochłania 80% czasu. Zobaczymy czy zasada 80/20 sprawdzi się i tym razem. Do następnego razu!  ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-szkic-interfejsu-uzytkownika/",
        "teaser": "/assets/images/2017/05/14_pogodynka_09_artykul.jpeg"
      },{
        "title": "Pogodynka – integracja",
        "excerpt":"Jak wspomniałem wyżej większość zmian związanych było z konfiguracją i integracją poszczególnych komponentów. Zacznę od serwera HTTP.   nginx   Jak wspomniałem w jednym z poprzednich raportów nie chcę rozdmuchiwać kosztów projektu. Nie chciałem też pisać warstwy widoku w oparciu o JSP. Mógłbym statyczne strony HTML zawrzeć w pliku WAR, jednak nie podoba mi się to rozwiązanie.   Moim zdaniem nie jest to podejście, w którym teraz tworzy się nowe strony WWW. Przy jednym pliku WAR miałbym monolityczną aplikację. Przy podejściu, które zastosowałem mam osobną warstwę z interfejsem użytkownika i osobną, która serwuje dane.   Aby obsłużyć taką konfigurację i używać wyłącznie jednej instancji VPS (ang. Virtual Private Server) użyłem serwera nginx.   Na tej samej instancji uruchomiony jest serwer Tomcat. W związku z konfiguracją firewall’a na tej maszynie nie jest on jednak dostępny bezpośrednio. nginx skonfigurowałem jako “reverse proxy”. Sprowadza się to do tego, że część żądań przesyłana jest przez nginx to Tomcata. Pozostała część to serwowanie statycznych stron.   W uproszczeniu konfiguracja ta podobna jest do tej pokazanej na diagramie poniżej:             Nginx – reverse proxy.        Interfejs użytkownika wykorzystywał będzie aplikację webową do pobrania informacji o dotychczasowych odczytach temperatury.   PostgreSQL   Baza danych, którą skonfigurowałem do pracy z projektem nie nadaje się na produkcję. Mowa tu o HyperSQL. Do produkcyjnego działania potrzebna jest baza z prawdziwego zdarzenia. I tak pojawił się PosgreSQL.   Przy pomocy puppet’a skonfigurowałem serwer bazy danych, utworzyłem bazę i dodałem odpowiednich użytkowników. Użytkownik, którego używam w aplikacji ma uprawnienia tylko do części elementów. Konfigurację możesz zobaczyć na githubie.   Dodatkowo sama baza danych zainstalowana jest na tym samym VPS co Tomcat. Dzięki temu nie ma potrzeby “otwierać” bazy danych na świat. Dostępna jest ona wyłącznie lokalnie. Zapewnia to sama konfiguracja PostgreSQL oraz reguł firewall’a.   Raspberry PI   Stwierdziłem, że skoro mam już Puppeta to wykorzystam go także po stronie Raspberry PI. Podzieliłem manifesty w ten sposób, że konfiguracja Malinki także jest jasno opisana. Całość znajduje się w pliku node_thermometer.pp.   Dzięki takiemu podejściu mam spójny sposób na konfigurację wszystkich “serwerów” jakie używam. Dodatkowo nie muszę już manualnie zarządzać wpisami w crontab. Robi to za mnie puppet.   Konfiguracja serwera Tomcat   Aplikacje Datavault i Thermometer starałem się pisać w taki sposób aby móc udostępnić kod publicznie.   Ma to pewne konsekwencje. Mianowicie pewne elementy takie jak hasła nie powinny być publicznie dostępne. Aby to obejść użyłem zmiennych środowiskowych. Używam takiej zmiennej na przykład aby pobrać hasło użytkownika bazy danych.   Zmienne te są ustawione na serwerze za pomocą puppet’a. Ich wartość pobierana jest za pośrednictwem mechanizmu hiera (opisałem go w jednym z poprzednich artykułów opisujących projekt Pogodynka) więc nie są to dane dostępne publicznie.   Zmiany w kodzie   Jak wspomniałem zmian w kodzie Javy było niewiele. Można je podzielić na dwie części:     wspólne interfejsy,   uwierzytelnianie.   Wspólne interfejsy   Pogodynka składa się z trzech modułów: Datavault, Thermometer i Frontend. Thermometer wysyła dane do Datavault używając zapytania HTTP. Zapytanie to zawiera dane w formacie JSON.   W aplikacji Thermometer wysyłałem dane sformatowane w trochę inny sposób niż było to oczekiwane przez Datavault. Jako konsekwencja Datavault zwracał odpowiedzi ze statusem 400 na każde żądanie wysłane z Thermometer. Uwspólnienie formatu rozwiązało problem.   Uwierzytelnianie   Chociaż dane z termometru są publicznie dostępne to powinny być dostępne wyłącznie do odczytu. Możesz to sprawdzić otwierając stronę pogodynki.   Zależy mi na tym aby te dane były rzetelne. Sprowadza się to do tego, że tylko określeni użytkownicy powinni móc dodawać informacje o aktualnych odczytach.   Nie chciałem zbytnio komplikować mechanizmu uwierzytelniania/autoryzacji więc poszedłem po najmniejszej linii oporu. Mianowicie przy żądaniu wysyłającym nowy pomiar sprawdzana jest zawartość pewnego nagłówka. Jeśli zawartość ta jest błędna żadne dane nie są dodawane do bazy. W odpowiedzi wysyłany jest kod 403.   Ta tajna wartość nagłówka również przechowywana jest w zmiennej środowiskowej.   Brakujące elementy   Czujnik zewnętrzny   Aktualnie całość działa w oparciu o czujnik wewnętrzny. Takie podejście raczej nie przejdzie próby deszczu ;). Kupiłem czujnik zewnętrzny, Mam nadzieję, że jutro już będzie uruchomiony.             Woododporny czujnik temperatury.        Interfejs użytkownika   Chociaż szablon interfejsu użytkownika jest już dostępny, nie jest on prawidłowy. Aby miał on sens musi pobierać dane o temperaturach z Datavault. Właśnie na tej części skupię się w przeciągu najbliższych dni.   Podsumowanie   Integrację mogę uznać za ukończoną. Monitoring całości opisany w początkowych odcinkach także działa. Zostały ostatnie szlify. Myślę, że mam duże szanse ukończyć projekt w terminie. Konkurs “Daj się poznać” trwa do 31.05.2017 więc zostało jeszcze parę dni. Trzymajcie kciuki i do następnego razu!  ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-integracja/",
        "teaser": "/assets/images/2017/05/23_pogodynka_integracja_artykul.jpeg"
      },{
        "title": "Pogodynka – podsumowanie",
        "excerpt":"Jeśli chcesz przeczytać więcej na temat samego projektu i jego założeń zapraszam do przeczytania pozostałych artykułów opisujących projekt.   Mistrz lutownicy ucieka   Aby mieć sensowne odczyty temperatury musiałem użyć czujnika zewnętrznego. Jest on odporny na wilgoć więc nie powinno być problemu z odczytem temperatury w trakcie deszczu. Mistrzem lutownicy na pewno nie jestem, ale finalny efekt nie wyszedł najgorzej.             Lutowanie czunika temperatury.        Na zdjęciu możesz zobaczyć opornik przylutowany do czujnika temperatury.   Profile Spring w aplikacji Datavault   Aplikacja webowa, która odpowiada za zapis i odczyt historycznych wskazań czujnika temperatury działa w kilku środowiskach. Pierwszym z nich jest środowisko developerskie. Kolejnym “produkcyjne”, w którym aplikacja jest dostępna z internetu.   Oba te środowiska różnią się między sobą. Jedną z różnic jest konfiguracja bazy danych. W związku z tym użyłem profili udostępnionych przez Springa.   Profil wybierany jest na podstawie jednego z parametrów przekazywanych podczas uruchomienia wirtualnej maszyny Javy. Dzięki temu bez zmieniania kodu aplikacji mogę użyć tego samego pliku war w różnych środowiskach.   Średnia dobowa temperatura   Użytkownik, dla którego pisałem tę aplikację (mój ociec ;)), wspomniał o paru funkcjonalnościach, które byłby przydatne.   Główną z nich jest możliwość udostępnienia średniej dobowej temperatury. W meteorologii temperatura ta jest średnią z odczytów z godzin 1, 7, 13 i 19.   W przypadku Pogodynki malinka wysyła odczyty temperatury co godzinę. Oczywiście jest to pomiar z “drobnym poślizgiem”, na przykład z godziny 13:00:05 a nie 13:00:00. Średnią dobową obliczam na etapie pobierania danych z bazy danych używając następującego zapytania SQL:     SELECT day,          SUM(temperature) / COUNT(temperature) AS daily_average     FROM (SELECT DATE(when_measured) AS day,                  EXTRACT('hour' FROM when_measured) AS hour,                  temperature             FROM temperature_measurements            WHERE EXTRACT('hour' FROM when_measured) IN (1, 7, 13, 19)              AND EXTRACT('minute' FROM when_measured) &lt; 2) AS daily_temps GROUP BY day   Następnie wyniki tego zapytania udostępnione są w formie dokumentu JSON. Tak sformatowane dane są następnie wykorzystywane przez interfejs użytkownika.   Interfejs użytkownika   Kilka ostatnich dni poświęciłem na pracę nad interfejsem użytkownika. Całość sprowadzała się do eksperymentów z JavaScript i API biblioteki Highcharts. Właśnie tej biblioteki użyłem do pokazywania historycznych wykresów temperatury.   Finalny efekt pracy wygląda następująco:             Pogodynka – interfejs użytkownika.        Podsumowanie projektu   W trakcie pracy nad projektem udało mi się zrealizować większość początkowych założeń. Projekt udało mi się “dowieźć” w terminie. Trello, którego używałem do śledzenia zadań w projekcie pokazuje dokładnie w jakim etapie jestem etapie. Jest bardzo dobrze :).   Chociaż całość mogę określić jako “udany projekt” mam świadomość pewnych niedociągnięć. Głównym z nich jest brak testów integracyjnych dla aplikacji Datavault. Podejrzewam, że znalazłbym kilka błędów po napisaniu odpowiedniego zestawu testów/   Muszę też powiedzieć, że zdecydowanie nie doszacowałem części związanej z integracją i konfiguracją. Praca nad modułami puppeta zajęła mi sporo czasu.   Podsumowując całość w jednym zdaniu. Bardzo się cieszę, że Pogodynka zakończyła się sukcesem :).   W przyszłości planuję realizację innych projektów tego typu. Może chciałbyś zobaczyć konkretny projekt realizowany w ten sposób? Daj znać w komentarzac, razem na pewno uda się nam wybrać coś ciekawego :).  ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-podsumowanie/",
        "teaser": "/assets/images/2017/05/28_pogodynka_podsumowanie_artykul.jpeg"
      },{
        "title": "Od zera do developera, czyli jak zostać programistą",
        "excerpt":"Nie ma dróg na skróty   Napiszę to w pierwszym akapicie. Moim zdaniem jest to bardzo ważny punkt, który wielu pomija. Programowanie nie jest łatwe. Nauka programowania tym bardziej nie jest łatwa. Wymaga od Ciebie zaangażowania, często również sporo poświęcenia. Jeśli aktualnie pracujesz i chcesz zmienić swój profil jesteś w jeszcze cięższej sytuacji.   Jak to mówią, “nikt nie powiedział, że będzie łatwo i słowa dotrzymał”. Z nauką programowania jest jak z nauką języków obcych. Są ludzie, którzy mają swego rodzaju dar i przychodzi im to łatwiej. Znakomita większość (w tym ja) musi spędzić mnóstwo czasu żeby przyswoić tę wiedzę. Jeśli liczysz na to, że kupisz kurs, przeczytasz dwie książki i zostaniesz programistą muszę wyprowadzić Cię z błędu. Tak nie będzie. Tylko Twoja ciężka praca może doprowadzić Cię do celu. Materiały w internecie mogą Ci w tym pomóc, nakierować na pewien tor. Na pewno nie zastąpią Twojej pracy. Ona po prostu jest niezbędna.   Jeśli masz słomiany zapał (jak ja) to też nie jesteś na uprzywilejowanej pozycji. Będzie ciężko, ale będzie też mnóstwo satysfakcji jeśli osiągniesz cel, który sobie założyłeś. Jeśli nie masz zamiaru ciężko pracować żeby zostać programistą zamknij tę zakładkę przeglądarki. Jeśli tak jest to szkoda Twojego czasu, nie ma sensu czytać dalej.   Full stack Java developer   Określenie “programista” czy “developer” jest bardzo szerokie. Kryje w sobie mnóstwo technologii i ścieżek, które możesz wybrać. A może “programista Java”? Programista Java niestety także nie jest wystarczająco specyficzne. Skupię się zatem na profilu, który moim zdaniem aktualnie jest jednym z najczęściej poszukiwanych na rynku pracy “full stack Java developer”.   Czym zajmuje się szablonowy “full stack Java devloper”? Jest to programista, który rozwija aplikacje webowe. Zajmuje się zarówno warstwą interfejsu użytkownika jak i kodem wykonywanym po stronie serwera. Dalsza część artykułu opisuje właśnie ten typ stanowiska wraz z zakresami wiedzy, które powinieneś opanować.   Rzeczy, które opiszę poniżej dotyczą profilu idealnego kandydata. Jest tego dużo, jednak nie zrażaj się. Firmy bardzo często patrzą na potencjał nie na aktualny zestaw umiejętności.   Wiedza ogólna   Składnia języka Java   Podstawą jest znajomość składni języka Java. Obsługa wyjątków, pętle, instrukcje warunkowe, adnotacje czy “lambdy” – wszystko co związane jest z samym językiem programowania. Wiedzę z tego zakresu możesz zdobyć przerabiając artykuły zebrane w ramach kursu języka Java.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Biblioteka standardowa   Bez znajomości biblioteki standardowej nie będziesz mógł efektywnie pracować z kodem źródłowym. Znajomość kolekcji czy wyrażeń regularnych świetnie pasuje do tej kategorii. Dobrym sposobem na ćwiczenie tej umiejętności jest rozwiązywanie zadań. Sporo zadań z przykładowymi rozwiązaniami znajdziesz na blogu.   Biblioteki narzędziowe   Tutaj mam na myśli najczęściej używane biblioteki, które rozszerzają możliwości biblioteki standardowej na przykład Guava, Apache Commons czy Joda. Nie chodzi mi tu o zapamiętanie całego API dostępnego w tych bibliotekach, chodzi o samą świadomość ich istnienia i możliwości użycia w projektach. Jako przykład mogę podać Ci jeden z projektów, który realizowałem. Pogodynka także dostępna jest na githubie gdzie możesz przejrzeć kod źródłowy tego projektu.   IDE   Do efektywnej pracy z językiem Java niezbędne jest IDE. Czy to będzie Idea, Eclipse, Netbeans czy cokolwiek innego – nie ma to znaczenia. Istotne jest abyś swobodnie pracował z IDE. Znajomość skrótów klawiaturowych czy możliwości IDE są bardzo przydatne. Tę umiejętność także rozwiniesz przez praktykę. W większości IDE są wtyczki, które wspierają pracę ze skrótami klawiaturowymi. Pracując z Eclipse używałem wtyczki mousefeed. Teraz z Ideą bardzo często używam funkcjonalności Search Everywhere (Shift + Shift) lub Navigate to Action (Ctrl + Shift + A).   System kontroli wersji   System kontroli wersji to mechanizm ułatwiający pracę z kodem. W systemie tym zapisuje się historyczne wersje plików, dzięki temu w łatwy sposób możemy śledzić zmiany. System ten pomaga także przy pracy zespołowej nad jednym fragmentem kodu. Standardem w większości firm jest Git, zdarzają się też firmy, które używają SVN czy innych bardziej “egzotycznych” systemów. Proponowałbym zacząć do Git’a. Jeśli dopiero zaczynasz przygodę z systemami kontroli wersji zachęcam do zajrzenia do kursu gita dostępnego na Samouczku.   Testy jednostkowe   Umiejętność pisania testów jednostkowych jest bardzo przydatna. Jeśli będziesz mógł się pochwalić znajomością bibliotek takich jak JUnit, Mockito czy Hamcrest będzie bardzo dobrze. Sam używam tej trójki przy pisaniu testów. Jeśli ta tematyka Cię interesuje napisałem serię artykułów dotyczących testów jednostkowych. Znajdziesz je na podstronie opisującej narzędzia i dobre praktyki.   Biblioteki, specyfikacje i technologie   Interfejs użytkownika   Aplikacje webowe posiadają interfejs użytkownika. W zależności od projektu, w którym będziesz pracował do jego tworzenia mogą wykorzystywane być różne technologie. Jest jednak pewien zestaw minimum, który zawsze powinieneś znać. Chodzi mi tu o podstawy HTML, CSS i JavaScript. Jako początkujący wystarczy, że znasz podstawy tych technologii. Im jesteś bardziej doświadczony poznasz kilka bibliotek JavaScript używanych przy pracy z interfejsem użytkownika. Osobiście bardzo zaniedbuję ten obszar. Sam musisz zobaczyć co Ci bardziej odpowiada :).   Kod wykonywany na serwerze   Pracując z aplikacjami webowymi w Javie będziesz miał styczność z servletami. Powinieneś poznać mechanizm ich działania wraz z ich ograniczeniami. Przechodząc przez serię artykułów na temat programowania webowego w Javie poznasz specyfikację serwletów.   Spring MVC   Spring MVC jest bardzo popularny. Używany jest w dużej liczbie projektów. Dokumentacja tylko do tej biblioteki to kilkaset stron tekstu. Nikt od początkującego nie będzie wymagał cudów. Jeśli będziesz potrafił stworzyć prostą aplikację webową opartą o kilka kontrolerów jesteś na dobrej drodze. Jako przykład może posłużyć Ci Pogodynka, którą realizowałem na blogu.   Bazy danych   Większość aplikacji webowych zapisuje dane w bazach danych. Powinieneś wiedzieć czym są relacyjne bazy danych. Takie rzeczy jak klucz główny, klucz obcy, indeks czy rodzaje złączeń nie powinny Cię zaskakiwać. Powinieneś także konstruować proste zapytania z użyciem GROUP BY, HAVING, ORDER BY i JOIN. Pomoże Ci w tym wstęp do relacyjnych baz danych, który jest częścią kursu SQL   ORM (ang. Object-Relational Mapping)   Po Spring MVC mamy tu kolejnego mocnego gracza. Chodzi o Hibernate. Jest to de facto standard w branży. Także i tutaj dokumentacja to kilkaset stron. Moim zdaniem na początek umiejętność zmapowania relacji wiele do wielu powinna wystarczyć. Resztę przeczytasz w dokumentacji jak będziesz tego potrzebował.   Programowanie to nie tylko technologia   Język angielski   Większość materiałów pomagających przy nauce programowania napisana jest w języku angielskim. Jeśli nie wiesz od czego zacząć podszlifuj angielski do poziomu gdzie czytanie dokumentacji technicznej nie jest problemem.   Praca zespołowa   Rzadko zdarzają się projekty, które możesz zrealizować samodzielnie. Szczególnie jeśli jesteś początkującym programistą. Programowanie to praca zespołowa. Musisz umieć pracować w zespole. Jak się tego nauczyć? Jak zwykle praktyka jest najlepsza, wcale nie trzeba ćwiczyć tej umiejętności w projekcie programistycznym. Równie dobrze można pracować zespołowo na aplikacją webową jak i innym projektem spoza działki IT.   Przyjmowanie krytyki   Programiści czasami potrafią być straszni. Część osób (w tym ja) ma problem z przyjmowaniem krytyki. Niestety jest to spora wada. Musisz koniecznie się tego oduczyć! Jeśli ktoś krytykuje Twoją pracę postaraj wyciągnąć od tej osoby jak najwięcej informacji. Szczególnie sposobu naprawienia danego błędu. Pamiętaj też, że krytykujące nie zawsze musi mieć rację. Niemniej jednak zawsze warto go wysłuchać aby poznać inny punkt widzenia.   Sprzedaż   No tak… W końcu nadchodzi czas na pierwszą rozmowę kwalifikacyjną. Rozmowa to nic innego jak sprzedawanie swojego czasu przyszłemu pracodawcy. Jeśli potrafisz ten czas sprzedać i pasujesz do zespołu dostaniesz pracę.W tym punkcie można też zawrzeć CV i jego przygotowanie. Tutaj odsyłam Cię do materiałów w internecie – są ludzie, którzy poradzą Ci jak to zrobić dużo lepiej ode mnie ;).   Podsumowanie   Jak wspomniałem na początku artykułu programowanie nie jest łatwe. Jego nauka także nie. Szczególnie, że materiału do opanowania jest sporo. W artykule tym starałem się zebrać dla Ciebie listę zagadnień, które są istotne w pracy jako “junior full-stack Java developer”. A może uważasz, że pominąłem coś istotnego? Daj znać w komentarzach co sądzisz o tej liście.   Mam nadzieję, że artykuł przypadł Ci do gustu. Proszę podziel się nim ze swoimi znajomymi, może ktoś z nich zechce nauczyć się programowania?   Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do samouczkowego newslettera i polub stronę na Facebooku. Do następnego razu!  ","categories": ["Programowanie","Początkujący programista"],
        "tags": [],
        "url": "/od-zera-do-developera-czyli-jak-zostac-programista/",
        "teaser": "/assets/images/2017/07/09_od_zera_do_developera_artykul.jpeg"
      },{
        "title": "Jak dostać pierwszą pracę jako programista",
        "excerpt":"Na początku chciałbym zaznaczyć, że nie jestem profesjonalnym rekruterem. Mimo tego miałem przyjemność brać udział w wielu rekrutacjach weryfikując umiejętności kandydatów. Przed napisaniem tego artykułu rozmawiałem też z kilkoma kolegami, którzy także takie rozmowy przeprowadzali. Udało mi się też dotrzeć do kilku rekruterów z firm pośredniczących w zatrudnianiu programistów. Opinie przedstawione w tym artykule pochodzą z tych właśnie rozmów.   Nie poddawaj się   Na początku historia prawdziwa, żeby podnieść Cię na duchu ;). Otrzymanie pierwszej pracy wcale nie musi być łatwe. Dla mnie na pewno nie było. Sam wysłałem kilkadziesiąt (sic!) CV zanim dostałem się do mojej pierwszej pracy. Byłem wtedy na przełomie trzeciego i czwartego roku studiów. Moje CV wyglądało, delikatnie mówiąc, tragicznie. Teraz wiem, że wymagało wielu poprawek. Mimo tego, że wysyłałem je masowo odzew był znikomy. Nie przeszedłem też kilku rozmów, zanim udało mi się znaleźć pierwszą pracę.   Nie jest to historia zmyślona na potrzeby artykułu. Tak rzeczywiście było. Brak odzewu i wysłanie tych kilkudziesięciu CV to prawda. Nie było mi łatwo znaleźć pierwszą pracę w branży, jednak od tamtej pory nie miałem z tym żadnego problemu. Dostać pracę bez komercyjnego doświadczenia może być trudno. Kilka wskazówek poniżej może Ci w tym pomóc.   Nie strzelaj ze śrutówki   Kiedyś usłyszałem ciekawy termin dotyczący masowego wysyłania ofert do kandydatów – “shotgun recruiting”. Shotgun recruiting jest jak spam. Nikt tego nie lubi. Historia, którą przytoczyłem na początku to nic innego jak shotgun recruiting w wykonaniu kandydata. Masowe wysyłanie tego samego CV do całej masy firm moim zdaniem jest błędem. Lepiej będzie jak przejrzysz dostępne oferty i dopasujesz swoje umiejętności do firmy, w której chcesz pracować.   Znajdź firmę, na której Ci zależy. Dopracuj swoje CV w ten sposób aby odpowiadało wymaganiom stawianym w tej firmie. Rekruterzy sprawdzają czy miałeś już jakiekolwiek doświadczenie z technologiami wykorzystywanym w danym projekcie. Jeśli takiego doświadczenia nie masz to zacznij dziubać projekt, który te technologie wykorzystuje.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Nie ma idealnego kandydata   Duża część ogłoszeń opisuje idealnego kandydata. Nie zrażaj się jeśli nie znasz części technologii wykorzystywanych w danym projekcie. Często pracodawca opisuje kogoś kto jest idealny dla danego stanowiska. Ideałów nie ma. Wszyscy jesteśmy ludźmi i mamy prawo nie wiedzieć wszystkiego. Ponadto jeśli pracodawca od początkującego programisty wymaga znajomości szeregu technologii jest oderwany od rzeczywistości. Zapomniał wół jak cielęciem był…   Bądź aktywny   W dużych miastach, gdzie rynek IT jest mocny programiści spotykają się dość często. Na tyle często, że jeśli chciałbyś chodzić na te wszystkie spotkania nie starczyłoby Ci czasu na nic innego ;). W trakcie takich spotkań przedstawiane są tematy związane z IT. Zacznij chodzić na spotkania programistów, słuchaj wykładów na tych spotkaniach. Zadawaj pytania i wdawaj się w dyskusje. Poszukaj już dzisiaj, może i w Twoim mieście są spotkania, które będą dla Ciebie interesujące? Na stronie www.meetup.com powinieneś znaleźć coś dla siebie. We Wrocławiu zdarzało mi się chodzić na spotkania programistów Javy, Rubiego czy Go.   Musisz wiedzieć, że dużo takich spotkań to nic innego jak rekrutacja :). Z racji dużej konkurencji na rynku IT firmy organizują takie spotkania aby przyciągnąć do siebie programistów. Na tych spotkaniach możesz także poznać pracowników rekrutujących programistów.   Niestety ostatnio na takich spotkaniach zjawiam się rzadziej, jeśli jednak potrzebujesz inspiracji możesz rzucić okiem na mój profil na meetupie. Znajdziesz tam kilka moim zdaniem ciekawych grup we Wrocławiu.   Twoje nastawienie jest kluczowe   Wspominałem wcześniej o byciu aktywnym w społeczności. Podobnie jest z aktywnością w miejscu pracy. Dużo się mówi o bycie proaktywnym. Powinieneś zawojować pracodawcę próbą wykazywania inicjatywy i głowy otwartej na nowe pomysły. Rekruterzy w trakcie rozmowy kwalifikacyjnej szukają takiej umiejętności.   Często pracodawcy zatrudniają programistów mimo braku znajomości wymaganych technologii. Mówi się wtedy o tym, że widać w kimś potencjał. Ten potencjał to właśnie wykazywanie własnej inicjatywy. Pokaż w CV swoje zaangażowanie. Mogę tu posłużyć jako przykład, dostałem pracę jako programista Pythona w ogóle nie znając tego języka. Pracuję w tej firmie do dzisiaj (17.07.2017). Nie masz doświadczenia zawodowego? Trudno, pokaż, że potrafisz się w coś zaangażować. Zgłoś się jako wolontariusz na jakiejś konferencji organizowanej w Twoim mieście, zorganizuj meetup, cokolwiek :).   Sam pomagałem przy organizacji jednej z edycji wroc_love.rb czy byłem wolontariuszem/wykładowcą na Devoxx4Kids we Wrocławiu. Oczywiście wymaga to Twojego czasu i zaangażowania. Wyznaję zasadę, że nie ma dróg na skróty, musisz zapracować na swoją pierwszą pracę :).   Przygotuj Twoje CV pod pracodawcę   Wątek ten przewijał się wcześniej, jednak wymaga osobnego akapitu. Znasz treść ogłoszenia pracodawcy. Twoje CV ma być ofertą, która zachęca do rozmowy z Tobą. Powinno pokrywać część (w idealnym świecie wszystkie) wymagań pracodawcy. Jeśli tak nie jest to zacznij pracować nad projektem, który wykorzysta wymagane technologie. Pokazanie efektów Twojej pracy na gotowym projekcie jest dużo lepsze niż “suche” wypisanie nazw technologii.   Posługuj się przykładami   Określenia w stylu “potrafię pracować zespołowo” czy “szybko się uczę” są słabe. Pokaż to na przykładzie. Lepiej jest jeśli napiszesz “potrafię pracować w zespole, w grupie zrealizowałem projekt X” albo “szybko się uczę, napisałem projekt Y w miesiąc wcześniej nie mając doświadczenia w tej technologii”. Rekruterzy przychylniej patrzą na osoby, które potrafią poprzeć swoje umiejętności przykładami.   Dziub swój projekt   Jest to niejako powiązane z posługiwaniem się przykładami i byciem aktywnym. Przez twoje działanie pokazujesz, że potrafisz dociągnąć coś do końca. Zaczynanie rzeczy jest proste, gorzej jest z ich ukończeniem, dowożeniem do końca ;).   Poza tym dziubanie swojego projektu daje Ci coś co jest bardzo cenne. Daje Ci doświadczenie, którego pracodawca poszukuje. Jeśli to doświadczenie dotyczy technologii, które są ważne dla pracodawcy, tym lepiej.   Nie kłam w CV   Nie wymyślaj rzeczy niestworzonych. Twoje CV będzie zweryfikowane. Nawet jeśli uda Ci się przekonać pracodawcę na rozmowie, to kłamstwo ma krótkie nogi. W codziennej pracy stan Twojej wiedzy będzie widoczny jak na dłoni. Masz prawo nie wiedzieć wszystkiego, ale nie masz prawa pisać, że wiesz wszystko.   Odrób zadanie domowe   Jeśli Twoje CV zostało wybrane spośród pozostałych to jesteś na dobrej drodze. Nogę w drzwi już wsadziłeś ;). Teraz czas na odrobienie zadania domowego, jeśli nie zrobiłeś tego wcześniej. Dowiedz się z kim będziesz miał rozmowę kwalifikacyjną. Znajdź tę osobę w sieciach społecznościowych, poczytaj o niej na linkedin czy goldenline. Dobrze jest znać swojego „przeciwnika” ;). Dużo lepiej rozmawia się z kimś kogo “znamy”.   Dowiedz się więcej o samej firmie, poznaj ich produkty i projekty. Najlepiej byłoby, gdyby udało Ci się porozmawiać z kimś pracującym w tej firmie. Wbrew pozorom programiści czasami lubią pomagać :). Jeśli jasno dasz do zrozumienia na czym Ci zależy jestem pewien, że uda Ci się znaleźć kogoś kto Ci pomoże. W ten sposób uzyskasz odpowiedzi na Twoje pytania. A może uda Ci się dowiedzieć czegoś więcej na temat samego procesu rekrutacji?   Rozmowa kwalifikacyjna   Prezentacja na rozmowach kwalifikacyjnych to też umiejętność. Jak każda inna wymaga ćwiczeń, żeby ją opanować. Innymi słowy kolejna rozmowa pójdzie Ci lepiej niż poprzednia. Na poprzedniej nauczyłeś się już kilku rzeczy, zdobyłeś jakieś doświadczenie w odbywaniu rozmów kwalifikacyjnych.   Nie zrażaj się, jeśli nie uda Ci się przejść przez rozmowę kwalifikacyjną. Często jest tak, że fakt zatrudnienia to składowa kilku czynników. Może się zdarzyć, że nie będzie „chemii” pomiędzy Tobą a rekrutującym. To jest normalne. Jeśli zależy Ci na tej pracy zapytaj kiedy możesz podejść do rozmowy po raz kolejny.   Jak przyjdzie na to czas w trakcie rozmowy zadawaj pytania. Rozmowa kwalifikacyjna jest źródłem wiedzy dla obu stron. Może się okazać, że podejście pracodawcy do pracownika może Ci nie odpowiadać. Może obowiązkowe wyjazdy służbowe nie będą Ci pasowały? Rozmowa kwalifikacyjna to czas kiedy powinieneś upewnić się, że dany pracodawca jest dla Ciebie.   Kilka wskazówek od rekrutera   Rozmawiając z rekruterami udało mi się wysupłać kilka szczegółów, które warto zawrzeć w CV. Niestety część z nich jest często pomijana. Opisywałem je w poprzednich akapitach jednak taka wypunktowana lista może być pomocna:     dodaj swoje prywatne projekty do CV, nie zapomnij o wpisaniu używanych technologii,   wspomnij o swoim zaangażowaniu w organizacji różnych wydarzeń,   jeśli uczestniczyłeś w konferencjach programistycznych możesz także dodać to do CV,   jeśli jesteś studentem to uzupełnij CV o projekty realizowane na uczelni.   Podsumowanie   Postaram się streścić cały artykuł w kilku punktach. Punkty te powinny Ci pomóc dobrze przygotować swoje pierwsze CV i dobrze podejść do rozmowy kwalifikacyjnej:     wybierz pracodawcę, u którego chcesz pracować,   dowiedz się czegoś więcej o tej firmie,   dostosuj swoje umiejętności do jego wymagań,   nikt nie wie wszystkiego, nie zrażaj się jeśli nie spełniasz części wymagań,   bądź aktywny w społeczności programistów,   dziub projekt po godzinach ;).   Na koniec życzę Ci powodzenia, mam nadzieję, że uda Ci się zdobyć Twoją pierwszą pracę w IT. Będzie mi bardzo miło, jeśli pochwalisz się tym w komentarzu. W każdym razie trzymam za Ciebie kciuki! ;)   Jeśli artykuł ten był dla Ciebie pomocny będę wdzięczny jeśli podzielisz sie nim ze swoimi znajomymi. Może im też pomoże przy znalezieniu pierwszej pracy w IT? Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę dopisz się do newslettera i polub samouczka na facebooku. Trzymaj się!  ","categories": ["Początkujący programista"],
        "tags": [],
        "url": "/jak-dostac-pierwsza-prace-jako-programista/",
        "teaser": "/assets/images/2017/07/17_jak_dostac_prace_jako_programista_artykul.jpeg"
      },{
        "title": "Wyrażenia lambda w języku Java",
        "excerpt":"     Artykuł ten dotyczy bardziej zaawansowanego fragmentu składni języka Java. Z tego powodu aby móc w pełni skorzystać z artykułu warto zapoznać się z wcześniejszymi artykułami, które dotyczą:      klas anonimowych,   typów generycznych,   adnotacji.     Czym jest wyrażenie lambda   Dla uproszczenia można powiedzieć, że wyrażenie lambda jest metodą1. Metodą, którą możesz przypisać do zmiennej. Możesz ją także wywołać czy przekazać jako argument do innej metody.   Wyrażenia lambda możesz także porównać do klas anonimowych2. Mają one jednak dużo bardziej czytelną i zwięzłą składnię.   Na przykład wyrażenie lambda, które podnosi do kwadratu przekazaną liczbę wygląda następująco:   x -&gt; x * x   Składnia wyrażeń lambda   Wyrażenie lambda ma następującą składnię   &lt;lista parametrów&gt; -&gt; &lt;ciało wyrażenia&gt;   Lista parametrów   Lista parametrów zawiera wszystkie parametry przekazane do “ciała” wyrażenia lambda. W szczególności lista ta może być pusta. Wyrażenie lambda poniżej nie przyjmuje żadnych argumentów, zwraca natomiast instancję klasy String:   () -&gt; “some return value”   Podawanie typów parametrów jest opcjonalne. Kompilator jest w stanie poznać te parametry z kontekstu w którym znajduje się dane wyrażenie lambda. Jeśli chcesz możesz je także podać:   (Integer x, Long y) -&gt; System.out.println(x * y)   Nawiasy otaczające listę parametrów są opcjonalne jeśli wyrażenie ma wyłącznie jeden parametr bez określonego typu3.   Ciało wyrażenia lambda   W ogromnej większości przypadków wyrażenia lambda zawierają jedną linijkę kodu:   x -&gt; x * x  () -&gt; “some return value”  (Integer x, Long y) -&gt; System.out.println(x * y);   Może się jednak zdarzyć, że Twoje wyrażenie lambda będzie zawierało więcej linii. W takim przypadku musisz otoczyć je nawiasami {} jak w przykładzie poniżej:   x -&gt; {     if (x != null &amp;&amp; x % 2 == 0) {         return (long) x * x;     }     else {         return 123L;     } }   Można sobie wyobrazić wyrażenie lambda, które nie przyjmuje żadnych parametrów i nie zwraca żadnych wartości. Najprostsza wersja takiego wyrażenia wygląda następująco:   () -&gt; {}   Od klasy anonimowej do wyrażenia lambda   Wiesz już czym jest klasa anonimowa. Dla przypomnienia powiem, że jest to stworzenie jedynej instancji klasy w miejscu jej użycia. Wiesz już też jak wyglądają wyrażenia lambda. Teraz nadszedł czas na zamianę klasy anonimowej na wyrażenie lambda. Proszę spójrz na przykład poniżej:   public interface Checker&lt;T&gt; {     boolean check(T object); }   Checker&lt;Integer&gt; isOddAnonymous = new Checker&lt;Integer&gt;() {     @Override     public boolean check(Integer object) {         return object % 2 != 0;     } };   System.out.println(isOddAnonymous.check(123)); System.out.println(isOddAnonymous.check(124));   W przykładzie tym zdefiniowałem interfejs Checker, który posiada jedną metodę check. Metoda ta zwraca wartość logiczną na podstawie przekazanego argumentu.   Fragment kodu robiący to samo jednak przy użyciu składni wyrażeń lambda wygląda następująco:   Checker&lt;Integer&gt; isOddLambda = object -&gt; object % 2 != 0;   System.out.println(isOddLambda.check(123)); System.out.println(isOddLambda.check(124));   Prawda, że ładniej :)?   Dochodzimy teraz do momentu, w którym muszę Ci powiedzieć o typach w wyrażeniach lambda. Każde wyrażenie lambda jest instancją dowolnego interfejsu funkcyjnego. Jest to bardzo ważne, dlatego też musisz dokładnie wiedzieć czym jest interfejs funkcyjny.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Interfejs funkcyjny   Interfejs funkcyjny to interfejs, który ma jedną abstrakcyjną metodę4. Wprowadzono adnotację @FunctionalInterface, którą możesz dodać do interfejsów tego typu.   Adnotacja ta zapewnia, że kompilator upewni się, że dany interfejs jest interfejsem funkcyjnym. Jeśli nie, wówczas kompilacja się nie powiedzie.   Przykładem interfejsu funkcyjnego może być zdefiniowany wcześniej interfejs Checker.   @FunctionalInterface public interface Checker&lt;T&gt; {     boolean check(T object); }   Zawiera on wyłącznie jedną metodę check.   Przykładowe interfejsy funkcyjne   Twórcy języka Java przygotowali zestaw interfejsów funkcyjnych, które możesz implementować. W większości przypadków w zupełności wystarczy ich użycie. Część z nich znajduje się w pakiecie java.util.function. Najważniejsze z nich zebrałem poniżej:     Function&lt;T, R&gt; zawiera metodę apply, która przyjmuje instancję klasy T zwracając instancję klasy R,   Consumer&lt;T&gt; zawiera metodę accept, która przyjmuje instancję klasy T,   Predicate&lt;T&gt; zawiera metodę test, która przyjmuje instancję klasy T i zwraca flagę. Interfejs ten może posłużyć do zastąpienia interfejsu Checker,   Supplier&lt;T&gt; zawiera metodę get, która nie przyjmuje żadnych parametrów i zwraca instancję klasy T,   UnaryOperator&lt;T&gt; jest specyficznym przypadkiem interfejsu Function. W tym przypadku typ argumentu i typ zwracany są te same.   Wyrażenia lambda zdefiniowane na początku artykułu można przypisać do tych właśnie interfejsów:   UnaryOperator&lt;Integer&gt; square = x -&gt; x * x;  Supplier&lt;String&gt; someString = () -&gt; \"some return value\";  BiConsumer&lt;Integer, Long&gt; multiplier = (Integer x, Long y) -&gt; System.out.println(x * y);  Function&lt;Integer, Long&gt; multiline = x -&gt; {     if (x != null &amp;&amp; x % 2 == 0) {         return (long) x * x;     }     else {         return 123L;     } };   Zalety stosowania wyrażeń lambda   Wyrażenia lambda są bardzo pomocne przy operacji na kolekcjach. Są niezastąpione także przy pracy ze strumieniami. Pozwalają także na pisanie w Javie w sposób “funkcyjny”5.   Oczywistą zaletą wyrażeń lambda jest ich zwięzłość. Kod zajmuje o wiele mniej miejsca, staje się przez to bardziej czytelny.   Odwoływanie się do metod   Wraz z wyrażeniami lambda Java została rozbudowana o składnię pozwalającą na odwoływanie się do metod. Służy do tego ::. Dzięki temu wyrażeniu możemy przypisać metodę do zmiennej bez jej wywołania. Takie podejście pozwala na przekazanie tak wyłuskanej metody i wywołanie jej w zupełnie innym miejscu. Proszę spójrz na przykład poniżej:   Object objectInstance = new Object(); IntSupplier equalsMethodOnObject = objectInstance::hashCode; System.out.println(equalsMethodOnObject.getAsInt());   W przykładzie tym tworzę nową instancję klasy Object. Następnie pobieram metodę hashCode z tego obiektu i przypisuję ją do typu IntSupplier. Jest to kolejny interfejs funkcyjny znajdujący się w standardowej bibliotece. Ostatnia linijka to wywołanie metody znajdującej się w tym interfejsie.   Kod powyżej można porównać do:   Object objectInstance = new Object(); System.out.println(objectInstance.hashCode());   W obu przypadkach tworzę nowy obiekt klasy Object i wywołują na nim metodę hashCode.   Odwoływanie się do metod bez podania instancji   Można także odwołać się do metody bez podania instancji, na której metoda powinna być wywołana. Wówczas ta instancja musi być przekazana jako pierwszy argument. Przykład poniżej powinien pomóc zrozumieć to zastosowanie:   ToIntFunction&lt;Object&gt; hashCodeMethodOnClass = Object::hashCode; Object objectInstance = new Object(); System.out.println(hashCodeMethodOnClass.applyAsInt(objectInstance));   W odróżnieniu do poprzedniego przykładu tutaj na początku pobieram metodę. Tym razem metoda nie jest przypisana do instancji. W związku z tym wyrażenie lambda jest już innego typu. W takim przypadku zawsze pierwszym argumentem jest instancja na której metoda powinna być wywołana. W kolejnej linijce tworzę instancję klasy Object. Ostatnia linijka to wywołanie metody na tej instancji.   Kod bez użycia odwołania do metody robiący dokładnie to samo wygląda trochę mniej skomplikowanie:   Object objectInstance = new Object(); System.out.println(objectInstance.hashCode());   Odwoływanie się do konstruktora   Notacja z :: może być także użyta do odwołania się do konstruktora. W tym przypadku należy użyć :: wraz ze słowem kluczowym new. Proszę spójrz na przykład poniżej:   Supplier&lt;Object&gt; objectCreator = Object::new; System.out.println(objectCreator.get());   W pierwszej linijce przykładu przypisuje konstruktor klasy Object do zmiennej objectCreator. Kolejna linijka to wywołanie konstruktora.   To samo bez użycia referencji metody możesz uzyskać w dobrze Ci znany sposób:   System.out.println(new Object());   Przykład zastosowania wyrażeń lambda i odwołania do metody   Załóżmy, że chcemy wypisać na konsoli liczby znajdujące się w kolekcji. Możemy to zrobić przy pomocy standardowej pętli, którą już znasz:   List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);   for (Integer number : numbers) {     System.out.println(number); }   To samo zadanie można także zrobić przy pomocy wyrażeń lambda:   List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4); Consumer&lt;Integer&gt; integerConsumer = n -&gt; System.out.println(n); numbers.forEach(integerConsumer);   Pierwsza linijka to utworzenie listy z liczbami. Kolejna jest bardziej ciekawa, zawiera wyrażenie lambda, które konsumuje liczbę wypisując ją na konsoli. Ostatnia to wywołanie metody forEach wraz z wyrażeniem lambda. Wyrażenie to zostanie wywołane dla każdego elementu.   Kod ten można jeszcze bardziej skrócić używając mechanizmu odwoływania się do metod:   List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4); numbers.forEach(System.out::println);   Efekt działania wszystkich trzech fragmentów jest dokładnie taki sam. Różnią się między sobą sposobem rozwiązania danego problemu.   Zadania   Na koniec mam dla Ciebie kilka zadań, które pomogą przećwiczyć Ci wiedzę z tego artykułu.     Napisz program, który pobierze o użytkownika cztery łańcuchy znaków, które umieścisz w liście. Następnie posortuj tę listę używając metody List.sort. Użyj wyrażenia lambda, które posortuje łańcuchy znaków malejąco po długości.   Napisz program, który wywoła funkcję equals na instancji klasy Object używając mechanizmu odwoływania się do metody (przy pomocy ::).   Utwórz instancję klasy Human przy pomocy mechanizmu odwoływania się do konstruktora (przy pomocy ::).   public class Human {       private int age;     private String name;       public Human(int age, String name) {         this.age = age;         this.name = name;     }       public int getAge() {         return age;     }       public String getName() {         return name;     } }   Jeśli będziesz miał problem z rozwiązaniem zadań możesz rzucić okiem na przykładowe rozwiązania, które umieściłem na samouczkowym githubie.   Dodatkowe materiały do nauki   Przygotowałem dla Ciebie zestaw kilku linków z materiałami dodatkowymi:     Wprowadzenie do wyrażeń lambda na stronie Oracle,   Tutorial dotyczący wyrażeń lambda na stronie Oracle,   Opis interfejsów funkcyjnych w JLS,   Referencja do metody w JLS,   Wyrażenia lambda w JLS.   Podsumowanie   Wyrażenia lambda nie są proste. Mogą powodować sporo zakłopotania, szczególnie na początku. Jeśli jednak się do nich przyzwyczaisz pisanie kodu z ich udziałem będzie sprawiało Ci sporo frajdy :). Po pewnym czasie docenisz też zwięzłość wyrażeń lambda.   Po przeczytaniu artykułu wiesz czym są wyrażenia lambda i jak je stosować. Znasz też mechanizm odwoływania się do metod. Przećwiczyłeś te mechanizmy rozwiązując przykładowe zadania. Nie zapomnij pochwalić się w komentarzu gdzie ostatnio użyłeś wyrażeń lambda :).   Na koniec mam do Ciebie prośbę. Jeśli uważasz, że artykuł ten był dla Ciebie pomocny proszę podziel się nim ze swoimi znajomymi. Zależy mi na dotarciu do jak największej grupy czytelników a Ty możesz mi w tym pomóc. Jeśli nie chcesz pominąć żadnego nowego artykułu dopisz się do samouczkowego newslettera i polub samouczka na Facebooku. Do następnego razu!                 Nie jest to do końca prawda, na przykład wyrażenie lambda nie wprowadza nowego zakresu zmiennych, ale takie uproszczenie pomoże zrozumieć działanie wyrażeń lambda. &#8617;                  Podobnie jak przy poprzednim porównaniu, są różnice pomiędzy wyrażeniami lambda i klasami anonimowymi. Jednak na potrzeby tego wprowadzenia możemy je pominąć. &#8617;                  Oczywiście w trakcie kompilacji typ jest znany, ale nie jest jawnie podany w kodzie źródłowym. &#8617;                  Efektywnie abstrakcyjną, czyli dodanie do interfejsu np. metody equals, która jest w klasie Object nadal spełnia to wymaganie. &#8617;                  Oczywiście Java nie jest językiem w pełni funkcyjnym, jednak taka namiastka jest przydatna. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/wyrazenia-lambda-w-jezyku-java/",
        "teaser": "/assets/images/2017/07/26_wyrazenia_lambda_artykul.jpeg"
      },{
        "title": "Modyfikatory dostępu w języku Java",
        "excerpt":"       Artykuł ten wymaga podstawowej wiedzy na temat języka Java. Z tego powodu, aby móc w pełni z niego skorzystać, warto zapoznać się z wcześniejszymi artykułami:      obiekty, klasy i pakiety w języku Java,   dziedziczenie w języku Java.           UWAGA   Artykuł ten nie zawiera informacji na temat modułów. Moduły zostały wprowadzone do języka Java wraz z wersją 9. Moduły, podobnie jak modyfikatory dostępu także mają wpływ na widoczność. Operują one na pakietach. W artykule tym zakładam, że każdy z pakietów jest eksportowany przez moduł, w którym się znajduje.   Więcej na temat modułów przeczytasz w osobnym artykule.     Czym są modyfikatory dostępu   Modyfikatory dostępu to słowa kluczowe, które mają wpływ na widoczność elementu który poprzedzają. Są to słowa kluczowe public, protected i private. Brak jakiegokolwiek ze wspomnianych słów kluczowych także ma wpływ na dostępność danego elementu. Czasami brak modyfikatora dostępu określa się jako dostęp typu “package”. Modyfikatory dostępu mogą być stosowane na przykład przed definicją klasy, czy interfejsu. Możemy ich także używać przed polami klasy, metodami czy typami wewnętrznymi.   Rodzaje modyfikatorów dostępu   Modyfikator public   Słowo kluczowe public jest modyfikatorem dostępu, który pozwala na najbardziej swobodny dostęp do elementu, który poprzedza. public może być używane przed definicjami klas, pól w klasach, metod czy typów wewnętrznych. Zakładając, że klasa poprzedzona jest public i element w tej klasie jest także public, jest on dostępny dla wszystkich1.   Poniższy fragment kodu pokazuje kasę PublicVisitCounter. Klasa ta implementuje licznik odwiedzin. Założenie jest takie, że każdy użytkownik wywoła metodę increment. Dzięki takiej klasie można w łatwy sposób zliczyć liczbę wizyt na stronie:   package pl.samouczekprogramisty.kursjava.accessmodifiers.public_keyword;  public class PublicVisitCounter {     public int userCount = 0;      public void increment() {         userCount++;     } }   Klasa dostępna jest dla wszystkich, ze względu na modyfikator public. Zawiera jedno pole userCount, metodę increment i domyślny konstruktor. Każdy z tych elementów ma dostęp typu public. Oznacza to tyle, że jest dostępny dla wszystkich.   Ma to swoje konsekwencje. Wyobraźmy sobie klasę MaliciousUser, która informuje PublicVisitCounter o swojej wizycie na stronie:   package pl.samouczekprogramisty.kursjava.accessmodifiers.public_keyword;  public class MaliciousUser {     public void countMyVisit(PublicVisitCounter counter) {         counter.increment();         counter.userCount = -10;     } }   Jak widzisz, dzięki modyfikatorowi public przed polem userCount instancja MaliciousUser ma dostęp do pola userCount. W takim przypadku możemy mówić o tym, że obiekt PublicVisitCounter udostępnia swój stan na zewnątrz. Nie jest to dobrą praktyką.   Modyfikator protected   Modyfikator protected ma znaczenie w przypadku dziedziczenia. Elementy poprzedzone tym modyfikatorem dostępu są udostępnione dla danej klasy i jej podklas. Dodatkowo elementy oznaczone modyfikatorem protected dostępne są dla innych klas w tym samym pakiecie. Modyfikatora protected nie można stosować przed klasami2. Proszę spójrz na przykład poniżej:   package pl.samouczekprogramisty.kursjava.accessmodifiers.protected_keyword;  public class Pen {     protected String color;      public Pen(String color) {         this.color = color;     } }   package pl.samouczekprogramisty.kursjava.accessmodifiers.protected_keyword.different_package;  public class BallPen extends Pen {     protected String manufacturer;      public BallPen(String color, String manufacturer) {         super(color);         this.manufacturer = manufacturer;     }      @Override     public String toString() {         return manufacturer + \" \" + color;     } }   Klasa Pen posiada pole color, które poprzedzone jest słowem protected. Dzięki temu klasa BallPen ma dostęp do tego pola. Używa go w implementacji metody toString. Proszę zwróć uwagę na to, że obie klasy znajdują się w różnych pakietach. Mimo to słowo kluczowe protected pozwala na dostęp do pola color.   Jak wspomniałem wcześniej ten modyfikator dostępu pozwala także na dostęp dla klas z tego samego pakietu. Ten przypadek pokazuje klasa poniżej:   package pl.samouczekprogramisty.kursjava.accessmodifiers.protected_keyword;  public class PenOwner {     private Pen pen;      public PenOwner(Pen pen) {         this.pen = pen;     }      @Override     public String toString() {         return \"Mam pioro w kolorze \" + pen.color;     } }   W tym przypadku PenOwner ma dostęp do pola color ponieważ obie klasy znajdują się w tym samym pakiecie pl.samouczekprogramisty.kursjava.accessmodifiers.protected_keyword.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Brak modyfikatora dostępu   Brak modyfikatora dostępu również ma znaczenie. W przypadku gdy pominiemy modyfikator dostępu wówczas dana klasa czy element jest dostępna wyłącznie wewnątrz tego samego pakietu. Jest to podzbiór uprawnień, które nadaje modyfikator protected. Proszę spójrz na przykład poniżej:   package pl.samouczekprogramisty.kursjava.accessmodifiers.missing_keyword;  public class Car {     public static final double FUEL_TANK_CAPACITY = 50.0;      double fuelLevel = 12.5; }   package pl.samouczekprogramisty.kursjava.accessmodifiers.missing_keyword;  public class FuelStation {     public void fillUp(Car car) {         double toFill = Car.FUEL_TANK_CAPACITY - car.fuelLevel;         System.out.println(\"Tankuje \" + toFill + \" litrow.\");         car.fuelLevel = Car.FUEL_TANK_CAPACITY;     } }   Modyfikator private   Słowo kluczowe private jest najbardziej restrykcyjnym modyfikatorem dostępu. Może być stosowane wyłącznie przed elementami klasy, w tym przed klasami wewnętrznymi. Oznacza on tyle, że dany element (klasa, metoda, czy pole) widoczny jest tylko i wyłącznie wewnątrz klasy. Proszę spójrz na zmodyfikowaną klasę licznika:   package pl.samouczekprogramisty.kursjava.accessmodifiers.encapsulated;  public class EncapsulatedVisitCounter {     private int userCount = 0;      public void increment() {         userCount++;     }      public int getUserCount() {         return userCount;     } }   W tym przypadku pole userCount poprzedzone jest słowem kluczowym private. Dzięki niemu stan wewnętrzny klasy nie jest dostępny na zewnątrz. Tylko elementy wewnątrz definicji klasy mają dostęp do tego pola.   Porównanie modyfikatorów dostępu   Informacje na temat działania modyfikatorów dostępu można zebrać je w następującej tabeli:                  Modyfikator       Klasa       Pakiet       Podklasa       Inni       Poprawny dla klas                       public       tak       tak       tak       tak       tak                 protected       tak       tak       tak       nie       nie                 brak modyfikatora       tak       tak       nie       nie       tak                 private       tak       nie       nie       nie       nie           Enkapsulacja, czyli kiedy używać modyfikatorów dostępu   Enkapsulacja (ang. encapsulation), czy inaczej hermetyzacja to sposób na ukrycie szczegółów implementacji klasy. Enkapsulacja to bardzo ważny element programowania obiektowego. Pozwala to na pełną kontrolę nad zachowaniem i stanem danego obiektu.   Dobrą praktyką jest stosowanie najbardziej restrykcyjnych modyfikatorów dostępu. Sprowadza się to do użycia private dla wszystkich pól i metod, które powinny być używane “wewnątrz”. Pozostałe elementy, które stanowią interfejs komunikacji oznaczamy słowem kluczowym public. Brak modyfikatora dostępu czy protected mają znaczenie w przypadku bardziej złożonych relacji pomiędzy obiektami.   Fragment kodu poniżej pokazuje licznik, który poprawnie ukrywa swój stan. Pozwala on na modyfikację czy dostęp do userCount wyłącznie poprzez publiczny interfejs – metody increment i getUserCount:   package pl.samouczekprogramisty.kursjava.accessmodifiers.encapsulated;  public class EncapsulatedVisitCounter {     private int userCount = 0;      public void increment() {         userCount++;     }      public int getUserCount() {         return userCount;     } }   Dodatkowe informacje   Modyfikatory dostępu a interfejsy i typy wyliczeniowe   Chciałbym Cię uczulić na przypadek interfejsów. Brak modyfikatora dostępu w definicji interfejsu oznacza, że dana metoda ma modyfikator public. Proszę spójrz na przykład poniżej:   @FunctionalInterface public interface Supplier&lt;T&gt; {     T get(); }   Jest to interfejs Supplier dostępny w standardowej bibliotece języka Java. Jak widzisz przed metodą get nie ma żadnego modyfikatora. W przypadku interfejsów oznacza to, że dana funkcja jest dostępna publicznie.   Innym przykładem są wartości typu wyliczeniowego. Poniższy przykład to typ wyliczeniowy AccessMode ze standardowej biblioteki. Jego wartości READ, WRITE i EXECUTE są dostępne publicznie mimo braku jakiegokolwiek modyfikatora dostępu:   public enum AccessMode {     READ,     WRITE,     EXECUTE; }       Interfejs Supplier jest generyczny, często jest wykorzystywany wraz z wyrażeniami lambda. Jeśli chcesz przeczytać więcej na ten temat zapraszam do oddzielnych artykułów:      typy generyczne w języku Java,   wyrażenia lambda w języku Java,   typ wyliczeniowe w języku Java.     Modyfikatory dostępu a dziedziczenie   Dzięki mechanizmowi nadpisywania metod mamy możliwość nadpisywania modyfikatorów dostępu. Jest to możliwe w przypadku dziedziczenia. Jeśli dziedziczymy po innej klasie mamy możliwość rozszerzenia dostępu do danej metody. W praktyce mamy dwie metody, jedną w klasie bazowej i kolejną w klasie potomnej:   public class Tree {     protected int height = 12;      protected void prune() {         if (height &gt; 15) {             height -= 1;         }     }      public void grow() {         height += 1;     } }   public class Oak extends Tree {     @Override     public void prune() {         super.prune();     } }   Aby uniemożliwić przedefiniowanie metody należy umieścić przed nią słowo kluczowe final.   Modyfikatory dostępu a mechanizm refleksji   Tylko i wyłącznie dla pełnego obrazu napiszę Ci o mechanizmie refleksji. W większości produkcyjnego kodu nie jest on używany. Pozwala on na dostęp do dowolnego elementu klasy pomijając modyfikator dostępu. Proszę spójrz na przykład poniżej:   public class BankAccount {      private int balance = 100;      public int getBalance() {         return balance;     } }   public class Thief {     public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {         BankAccount account = new BankAccount();         System.out.println(\"Stan konta: \" + account.getBalance());          Field balance = BankAccount.class.getDeclaredField(\"balance\");         balance.setAccessible(true);         balance.set(account, -5000);          System.out.println(\"Stan konta: \" + account.getBalance());     } }   Dzięki mechanizmowi refleksji zmieniłem wartość pola prywatnego. Po uruchomieniu takiego programu na konsoli wyświetlą się dwie linijki:   Stan konta: 100 Stan konta: -5000   Ogólna reguła brzmi – nie używaj mechanizmu refleksji w produkcyjnym kodzie. Chyba, że wiesz co robisz i rzeczywiście jest to potrzebne ;).   Zadanie   Napisz program, który będzie symulował działanie banku. Zaimplementuj następujące interfejsy:   public interface Account {     void deposit(int amount);     void withdraw(int amount); }  public interface BankTransfer {     void transfer(BankAccount from, BankAccount to, int amount); }   Bank przeprowadzający operację przesyłu środków pobiera stałą opłatę 1zł od nadawcy przelewu. Jakich modyfikatorów dostępu użyjesz? Dlaczego akurat tych?   Pamiętaj, że nie ma jednego rozwiązania tego zadania. Jest ich nieskończenie wiele, jedno z przykładowych rozwiązań znajdziesz na samouczkowym githubie.   Dodatkowe materiały do nauki   Przygotowałem dla Ciebie zestaw kilku linków z materiałami dodatkowymi:     fragment kursu na stronie Oracle opisujący modyfikatory dostępu,   artykuł na Wikipedii na temat hermetyzacji,   przykłady kodu użyte w artykule.   Podsumowanie   Modyfikatory dostępu w Javie są bardzo ważne. Po przeczytaniu artykułu wiesz czym do czego służą i jak ich używać. Wiesz czym jest hermetyzacja i dlaczego jest istotna. Dowiedziałeś się czegoś więcej mechanizmie refleksji i wiesz, że nie powinieneś go używać ;). Po rozwiązaniu zadania przećwiczyłeś wiedzę z artykułu w praktyce.   Mam nadzieję, że artykuł był dla Ciebie pomocny. Jeśli tak to proszę podziel się z nim ze swoimi znajomymi. Jeśli nie chcesz pominąć żadnego artykułu w przyszłości proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu!                 Jak wspomniałem we wstępie pomijam tutaj moduły, które mogą ograniczyć dostęp do elementów poprzedzonych słowem kluczowym public. &#8617;                  Chyba, że są to klasy wewnętrzne. W takim przypadku modyfikator protected jest dozwolony. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/modyfikatory-dostepu-w-jezyku-java/",
        "teaser": "/assets/images/2017/10/29_modyfikatory_dostepu_w_jezyku_java_artykul.jpg"
      },{
        "title": "Liczby zmiennoprzecinkowe",
        "excerpt":"  Artykuł ten wymaga znajomości notacji binarnej. Jeśli jeszcze jej nie znasz koniecznie zapoznaj się z artykułem opisującym system binarny.       Artykuł ten ma Cię jedynie wprowadzić w tematykę związaną ze standardem IEEE754. Nie poruszam w nim kwestii związanych z arytmetyką, zaokrąglaniem czy wartościami specjalnymi.   Celem tego artykułu jest wytłumaczenie dlaczego operacje na liczbach zmiennoprzecinkowych nie są dokładne. Jeśli szukasz bardziej szczegółowych informacji odsyłam do punktu “Dodatkowe materiały do nauki”.     Niezbędne podstawy   Odrobina matematyki   Żeby móc mówić o liczbach zmiennoprzecinkowych należy zrozumieć czym są liczby wymierne. Liczba wymierna to liczba, którą można przedstawić w postaci ułamka zwykłego. Dla przypomnienia to ten ułamek z kreską poziomą, który ma licznik i mianownik. Przykładem ułamka zwykłego jest ½.   Ułamki mają jeszcze postać dziesiętną. Przykładem ułamka dziesiętnego jest 0,5.   Niektóre ułamki zwykłe nie mają skończonej reprezentacji jako ułamek dziesiętny. Na przykład ułamek ⅓ zapisany dziesiętnie ma postać 0,(3). Taka notacja oznacza, że ułamek dziesiętny ma rozwinięcie okresowe. Zawartość nawiasu powtarzana jest w nieskończoność 0,33333.... Okres ułamka może mieć kilka cyfr, na przykład 0,38(12). Taki okres rozwija się do ułamka 0,3812121212....   Liczby wymierne zapisywane binarnie   Liczby wymierne można zapisać także binarnie. Algorytm na zamianę liczb całkowitych z postaci dziesiętnej na postać binarną opisałem w artykule na temat systemu binarnego. Do zamiany zostaje część po przecinku. Weźmy na przykład liczbę 0,25. Aby zapisać ją binarnie należy postępować zgodnie z algorytmem:      Zapisz 0,,   Pomnóż ułamek przez 2, jeśli wynik jest większy bądź równy 1 należy dopisać 1 w reprezentacji binarnej. W przeciwnym wypadku należy dopisać 0.   Jeśli wynik jest równy 1 jest to koniec algorytmu. Jeśli wynik jest mniejszy od 1 należy przejść do punktu drugiego. Jeśli wynik jest większy od 1 należy odjąć od niego 1 i przejść do punktu drugiego.   Mam nadzieję, że przykład pozwoli Ci lepiej zrozumieć zasadę działania algorytmu. Zacznijmy od liczby 0,75.      Postać binarna 0,,   0,75 * 2 = 1,5. Wynik jest większy od 1 więc dopisuję 1. Postać binarna 0,1. Wynik jest większy od 1 więc odejmuję jedynkę: 1,5 - 1 = 0,5,   0,5 * 2 = 1. Wynik jest równy 1 więc dopisuję 1. Postać binarna 0,11. Wynik jest równy 1 więc to koniec algorytmu,   0,75 zapisane jako ułamek binarny to 0,11.   Inny przykład, tym razem ułamek dziesiętny to 0,125:      Postać binarna 0,,   0,125 * 2 = 0,25. 0,25 &lt; 1 więc dopisuję 0. Postać binarna to 0,0,   0,25 * 2 = 0,5. 0,5 &lt; 1 więc dopisuję 0. Postać binarna to 0,00,   0,5 * 2 = 1. 1 == 1 więc dopisuję 1. Postać binarna to 0,001, koniec algorytmu,   0,125 zapisane jako ułamek binarny to 0,001.   Nie wszystkie ułamki, które mają skończone rozwinięcie dziesiętne są skończone w postaci binarnej. Spójrz jak wygląda to w przypadku ułamka 0,1:      Postać binarna 0,,   0,1 * 2 = 0,2. 0,2 &lt; 1 więc dopisuję 0. Postać binarna to 0,0,   0,2 * 2 = 0,4. 0,4 &lt; 1 więc dopisuję 0. Postać binarna to 0,00,   0,4 * 2 = 0,8. 0,8 &lt; 1 więc dopisuję 0. Postać binarna to 0,000,   0,8 * 2 = 1,6. 1,6 &gt; 1 więc dopisuję 1 i odejmuję 1 od wyniku. Postać binarna to 0,0001,   0,6 * 2 = 1,2. 1,2 &gt; 1 więc dopisuję 1 i odejmuję 1 od wyniku. Postać binarna to 0,00011,   Ułamek 0,2 występował już w kroku 3. Jeśli liczba się powtarza mamy do czynienia z ułamkiem, który ma nieskończone rozwinięcie binarne. Postać binarna to 0,0(0011).   Aby zapisać liczbę wymierną, która ma zarówno część całkowitą i ułamkową należy połączyć zapis części całkowitej i ułamkowej. Na przykład liczba 20,1 zapisana binarnie to 10100,0(0011). Jest to tak zwana stałoprzecinkowa reprezentacja liczby wymiernej.   Notacja naukowa a liczby wymierne   W matematyce poza standardowym zapisem liczb, który już znasz 10, 123,15 czy 0,00000827194 istnieje tak zwana notacja naukowa. Jest ona pomocna przy zapisywaniu bardzo dużych/małych liczb w stosunkowo zwięzłej formie. Na przykład liczbę 0,00000827194 można zapisać jako (8,27194 * 10^{-6}). Inna postać tej liczby to 8,27194e-6.   W języku Java możesz zobaczyć jak dana liczba wygląda w postaci naukowej:   System.out.println(String.format(\"%e\", 123.456));   Po uruchomieniu powyższego kodu na konsoli pokaże się:   1.234560e+02       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Czym jest standard IEEE754   Standard IEEE754 jest standardem opisującym arytmetykę zmiennoprzecinkową. W dużym uproszczeniu można powiedzieć, że opisuje on sposób zapisywania liczby wymiernej w pamięci komputera. Standard ten może być implementowany już na poziomie sprzętowym. Oznacza to tyle, że procesor może mieć specjalną jednostkę odpowiedzialną za obliczenia zmiennoprzecinkowe.   Standard ten opisuje kilka formatów zapisu liczb. Jednym z nich jest zapis pojedynczej precyzji gdzie do zapisania liczby używa się 32 bitów. Występuje też wersja z podwójną precyzją, gdzie używa się 64 bitów do zapisania liczby.   W języku Java liczby typu float są liczbami zmiennoprzecinkowymi formacie pojedynczej precyzji. Liczby typu double to liczby zmiennoprzecinkowe zapisane na 64 bitach w formacie podwójnej precyzji.   W dalszej części artykułu skupię się wyłącznie na liczbach zmiennoprzecinkowych zapisanych w formacie pojedynczej precyzji.   Liczba zmiennoprzecinkowa   Liczba zmiennoprzecinkowa to liczba wymierna zapisana w formacie IEEE754. Nazwa zmiennoprzecinkowa wynika z tego, że miejsce przecinka w liczbie zmienia swoje położenie. Spójrz na przykład poniżej:   1234,567 1,234567e+3   Obie te liczby są równe, jednak przecinek w drugiej z nich znajduje się w innym miejscu. Druga liczba zapisana jest w notacji naukowej.   Części składowe liczby zmiennoprzecinkowej   Każdą liczbę zmiennoprzecinkową zapisujemy w pamięci przy pomocy trzech składowych:      znaku,   wykładnika,   mantysy.             Liczba zmiennoprzecinkowa pojedynczej precyzji © Wikipedia        Wartość liczby zmiennoprzecinkowej zależy od wartości poszczególnych pól. Można ją zapisać przy pomocy wzoru:   \\[-1^{znak} * 2^{wykładnik} * mantysa\\]  Wzór ten przypomina notację naukową.   Znak   Liczby mogą być dodanie, ujemne lub 0. Znak służy do określenia czy dana liczba jest dodania czy ujemna. Jeśli liczba jest dodatnia bit znaku zawiera 0.   Wykładnik   Wykładnik to liczba zapisana na ośmiu bitach. Używa się tu tak zwanego kodowania z nadmiarem. W tym przypadku nadmiar wynosi -127. Oznacza to, że od zakodowanej liczby należy odjąć liczbę 127 aby uzyskać zakodowaną wartość. Standardowo na ośmiu bitach możemy zapisać liczbę (2^8 -1 == 255). Używając kodowania z nadmiarem -127 na ośmiu bitach możemy zakodować liczby z zakresu [-127, 128].   Innymi słowy wykładnik w liczbie zmiennoprzecinkowej może być z zakresu -127 do 1281.   Mantysa   Mantysa zapisana jest na 23 bitach. Zawiera ona właściwą liczbę, która zostanie pomnożona przez wykładnik zgodnie ze wzorem podanym wyżej.   Mantysa w większości przypadków ma postać znormalizowaną. Najłatwiej będzie mi to wytłumaczyć na przykładzie. Załóżmy, że mamy liczbę zapisaną binarnie 1011,1101. Znormalizowana postać tej liczby to (1,0111101 * 2^3). Jak widzisz przecinek przesunięty jest do pierwszej jedynki.   Inny przykład to 0,0001010110001, która po normalizacji wygląda następująco (1,010110001 * 2^{-4}).   W znormalizowanej mantysie pierwszą cyfrą jest zawsze 1. W związku z tym jest pomijana. Zatem mając liczbę 1,010110001 mantysa będzie miała wartość (spacje dla czytelności):   0101 1000 1000 0000 0000 000   Część ułamkowa 010110001 została uzupełniona zerami aby zapełnić wszystkie 23 bity przeznaczone na mantysę.   Zapis liczby zmiennoprzecinkowej   Teraz masz już wszystkie informacje potrzebne do zapisania liczby zmiennoprzecinkowej. Zacznijmy od liczby 270,125. Liczba ta zapisana binarnie to 100001110,001. Po znormalizowaniu otrzymujemy   \\[1,00001110001 * 2^{8}\\]  W naszym przypadku po przecinku mamy 11 cyfr. Mantysę zapisujemy na 23. Brakujące miejsca uzupełniamy zerami. Więc mantysa będzie miała następującą postać (spacje dla czytelności):   0000 1110 0010 0000 0000 000   Nasz wykładnik to 8. Wynika on z przesunięcia w związku z normalizacją mantysy. Pamiętając o sposobie kodowania wykładnika dodaję do niego 127. Kodując 135 binarnie uzyskuję (spacja dla czytelności):   1000 0111   Nasza liczba jest dodania, więc bit znaku ma wartość 0.   Zbierając te informacje razem mogę zapisać liczbę 270,125 w standardzie IEEE754. Zapis ten wygląda następująco (spacje dla czytelności):   0  1000 0111  0000 1110 0010 0000 0000 000   Dlaczego 0,1 + 0,2 != 0,3   Standard IEEE754 bardzo ułatwił pracę z liczbami wymiernymi. Niestety ma on swoje wady. Jedną z nich jest to, że w pewnych przypadkach zapis liczby w tym formacie prowadzi do utracenia informacji. Dzieje się tak na przykład w przypadku gdy ułamek zapisany binarnie ma rozwinięcie okresowe. Przykładem takich ułamków są 0,1 czy 0,2.   Proszę spójrz na przykłady poniżej. Używam tu kodu Javy, jednak właściwość ta jest prawdziwa także w innych językach programowania:   System.out.println(String.format(\"%.17f\" , 0.1F)); System.out.println(String.format(\"%.17f\" , 0.2F)); System.out.println(String.format(\"%.17f\" , 0.3F));   0.10000000149011612 0.20000000298023224 0.30000001192092896   Jeśli chcesz wiedzieć czym jest magiczne \"%.17f\" zachęcam Cię do przeczytania artykułu na temat formatowania łańcuchów znaków w języku Java.   Jak widzisz wprowadzone 0,1 trochę różni się od właściwej wartości zapisanej w pamięci komputera. Chociaż 0,1 + 0,2 == 0,3 to w pamięci komputera wygląda to trochę inaczej:   0.10000000149011612 + 0.20000000298023224 != 0.30000001192092896   Rady praktyczne   W związku z opisanymi problemami typy double czy float nie zawsze są dobrym wyborem. Na przykład pisząc aplikację do banku, która oblicza ratę kredytu na pewno nie powinieneś używać tych typów. Z pomocą przychodzi klasa BigDecimal. Jeśli zależy Ci na dokładnych obliczeniach w większości przypadków będzie to dobry wybór:   System.out.println(new BigDecimal(\"0.1\"));  Wyświetli oczekiwane   0.1   Proszę zwróć uwagę na sposób tworzenia instancji BigDecimal. Używam tutaj konstruktora, który przyjmuje liczbę jako łańcuch znaków. Użycie klasy BigDecimal utworzonej na podstawie instancji float powtórzy błąd:   System.out.println(new BigDecimal(0.1F));   0.100000001490116119384765625   Innym sposobem na pracę z liczbami wymiernymi jest użycie typów całkowitoliczbowych. Jest to możliwe w przypadku gdy wiesz ile miejsc po przecinku jest dla Ciebie ważne. Na przykład operacje pieniężne w większości przypadków potrzebują dwóch miejsc po przecinku. Zatem kwotę 125 złotych 68 groszy możemy zapisać jako 12568 i przechowywać w polu o typu int czy long. Przy pomocy dzielenia możemy uzyskać część całkowitoliczbową i część ułamkową:   int money = 12568;  System.out.println(\"zlotych: \" + money / 100); System.out.println(\"groszy: \" + money % 100);   Dodatkowe materiały do nauki   Jeśli chcesz spojrzeć na temat liczb zmiennoprzecinkowych z innej perspektywy możesz rzucić okiem na poniższe materiały:      artykuł na Wikipedii na temat liczb zmiennoprzecinkowych,   artykuł na Wikipedii na temat standardu IEEE754,   artykuł opisujący standard IEEE754,   treść najnowszej wersji standardu IEEE754 (wymaga wykupienia dostępu).   Zadania do wykonania   Do wykonania zadań mogą Ci się przydać następujące funkcje:      Integer.toBinaryString,   Long.toBinaryString,   Float.floatToRawIntBits.   Double.doubleToRawLongBits,   Zadania do wykonania:      Napisz program, który pobierze od użytkownika liczbę wymierną. Następnie wypisze tę liczbę w postaci binarnej pokazując osobno znak, wykładnik i mantysę.   Uzupełnij program z punktu 1. w ten sposób, aby pokazywał błąd wynikający z zapisu liczb. Na przykład jeśli użytkownik wprowadzi liczbę 0,1 wówczas program powinien wyświetlić binarną reprezentację i błąd powstały w wyniku zapisu liczby w tym formacie,   Spróbuj rozszerzyć program w ten sposób aby wspierał liczby zmiennoprzecinkowe zapisane w formacie podwójnej precyzji (1 bit znaku, 11 bitów wykładnika i 52 bity mantysy).   Zachęcam Cię do samodzielnego rozwiązania zadań, wtedy nauczysz się najwięcej. Jeśli jednak będziesz potrzebował pomocy możesz rzucić okiem na przykładowe rozwiązanie na githubie.   Podsumowanie   Po przeczytaniu artykułu wiesz już czym są liczby zmiennoprzecinkowe. Znasz podstawy standardu IEEE754. Wiesz dlaczego niektóre operacje na liczbach zmiennoprzecinkowych nie są dokładne. Wiesz także jak wykonywać dokładne operacje na liczbach wymiernych. Innymi słowy kawał wiedzy! :).   Mam nadzieję, że artykuł przypadł Ci do gustu. Proszę podziel się nim ze swoimi znajomymi, którzy mogą być nim zainteresowani. Jeśli nie chcesz pominąć nowych artykułów polub Samouczka na Facebooku i dopisz się do samouczkowego newslettera.   Do następnego razu!                 Jak już wspomniałem wcześniej dotyczy to liczb zapisanych w formacie pojedynczej precyzji. &#8617;           ","categories": ["Programowanie","Wiedza ogólna"],
        "tags": [],
        "url": "/liczby-zmiennoprzecinkowe/",
        "teaser": "/assets/images/2017/11/06_liczby_zmiennoprzecinkowe_artykul.jpg"
      },{
        "title": "Podstawy złożoności obliczeniowej",
        "excerpt":"      Artykuł ten zawiera jedynie podstawy związane z zagadnieniem złożoności obliczeniowej. Bynajmniej nie wyczerpuje tematu. Teoria obliczeń to osobny dział informatyki. Jeśli chcesz go zgłębić zachęcam Cię do przejrzenia dodatkowych materiałów do nauki.   Mam świadomość, że tłumaczenie złożoności obliczeniowej bez wspominania o maszynie Turinga to profanacja. Jednak dla zupełnie początkujących w temacie takie podejście wydaje mi się łatwiejsze.     Teoria obliczeń   Teoria obliczeń to dział informatyki. Jedną z gałęzi tego działu jest teoria złożoności obliczeniowej. W uproszczeniu można powiedzieć, że zajmuje się ona oszacowaniem wydajności czasowej i pamięciowej algorytmów. Teoria złożoności obliczeniowej bazuje na wielu modelach, które służą do łatwego porównywania algorytmów.   Dlaczego używamy złożoności obliczeniowej   Komputerów na świecie są miliony. Wiele z nich bardzo się od siebie różni. Mają różny procesor, inny moduł RAM. Część z nich używa bardziej wydajnych dysków, które pozwalają na szybszy dostęp do danych. Dla części z nich dane dostępne są na zdalnych maszynach, do których trzeba łączyć się przez sieć. Są też mega-komputery, maszyny o ogromnej mocy obliczeniowej, czy smartfony w kieszeniach.   W związku z tą różnorodnością pojawia się potrzeba wspólnej miary. Miary, która jest niezależna od zmiennych czynników. Może ona pomóc zorientować się w wydajności danego algorytmu, przyporządkować go do zdefiniowanej klasy algorytmów. Tutaj w grę wkraczają modele, o których wspomniałem wcześniej. Modele te upraszczają zawiłości związane z różnorodnością sprzętu.   Mamy zatem wspólną bazę – model. Dalej jednak pozostaje pytanie: w jaki sposób mierzyć wydajność poszczególnych algorytmów? Mierzenie czasu jest mało praktyczne. Na modelu nie możemy mierzyć czasu. Mierzenie czasu nie ma większego sensu na komputerze z powodu różnorodności sprzętu. Otrzymane wyniki nie byłby miarodajne w przypadku innego komputera.   Mierzymy więc zatem liczbę operacji wykonanych na modelu. Następnie próbujemy znaleźć funkcję, która będzie opisywała liczbę operacji w zależności od wejścia algorytmu. Funkcje te możemy porównywać ze sobą.   Przykład wyznaczania złożoności obliczeniowej   Załóżmy że chcemy policzyć sumę elementów tablicy. Może nam w tym pomóc następujący algorytm:   public int sum(int[] numbers) {     int sum = 0;     for (int number : numbers) {         sum += number;     }     return sum; }   Ile mamy w nim operacji? int sum = 0;, przypisanie to jedna operacja. Następnie mamy pętlę for. Jej ciało zawiera jedną operację. Sama pętla wykona się dokładnie tyle razy ile jest elementów tablicy numbers. Liczbę tych elementów określmy jako n. Na końcu mamy instrukcję return sum;. Jest to ostatnia operacja.   Dodając te operacje do siebie otrzymujemy wzór:   \\[f(n) = 1 + n + 1 = n + 2\\]  Zatem złożoność naszego algorytmu opisana jest przez funkcję f(n) = n + 2.   Tak dla przypomnienia ;). Funkcje możesz pamiętać z matematyki. Na przykład funkcja f(x) = ax^2 + bx + c opisuje parabolę.   Złożoność obliczeniowa a funkcja   Złożoność obliczeniową określamy jako funkcję danych wejściowych algorytmu. Wyznacza się ją jak opisałem w poprzednim punkcie – licząc operacje.   O ile dla naukowców znalezienie dokładnej funkcji może być bardzo istotne, to w praktyce wystarczą jej oszacowania. Takie oszacowania to notacja Ο (dużego O), notacja Ω (omega) i notacja Θ (theta).   Oszacowania rzędu złożoności funkcji   Na tapetę bierzemy przykładową funkcję:   \\[f(n) = n^3 - 6n^2 + 4n + 12\\]  Możemy założyć, że funkcja ta dokładnie opisuje złożoność obliczeniową jakiegoś algorytmu. Argument n to rozmiar danych wejściowych do algorytmu. Wykres1 tej funkcji wygląda następująco:             Wykres funkcji f(n) = n^3 - 6n^2 + 4n + 12        Notacja Ο (dużego O)   Notacja ta zakłada, że istnieje funkcja g(n), dla której spełniona jest poniższa własność:   \\[\\forall n \\geqslant n_0 : f(n) \\leqslant c * g(n)\\]  Teraz przetłumaczę te matematyczne hieroglify :). Własność ta oznacza, że wynik funkcji g(n) pomnożony przez jakąś stałą c będzie większy bądź równy wynikowi funkcji f(n). Własność ta jest spełniona dla wszystkich n, które będą większe od n0. Jeszcze łatwiej wygląda to na wykresie:             Oszacowanie z góry, notacja Ο.        Powyższy wykres pokazuje dwie funkcje. Pierwszą, którą już znasz z poprzedniego wykresu. Druga to wykres funkcji g(n) = n^3. Jak widzisz od pewnego punktu zielona linia jest zawsze ponad czerwoną linią. To nic innego jak oszacowanie z góry. To właśnie jest notacja Ο. Zatem w naszym przypadku nasza funkcja f(n) ma złożoność Ο(n^3).   W mojej dotychczasowej praktyce notacja Ο jest najczęściej spotykana do określania złożoności algorytmów.   Notacja Ο jest oszacowaniem z góry. Zatem można powiedzieć, że jeśli algorytm ma złożoność Ο(n^2) to ma także złożoność Ο(n^3) czy nawet Ο(n!). Jednak Ο(n^2) może być najlepszym oszacowaniem złożoności danego algorytmu.   Z racji tego, że jest to oszacowanie pomijamy w nim wszelkiego rodzaju stałe. Zatem Ο(2n + 123), Ο(2n) i Ο(n) to ta sama złożoność obliczeniowa. Stałe te i tak nie mają znaczenia przy odpowiednio dużych wartościach n.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Notacja Ω (omega)   Notacja ta różni się od poprzedniej własnością, którą spełnia nowa funkcja:   \\[\\forall n \\geqslant n_0 : f(n) \\geqslant c * g(n)\\]  Własność ta oznacza, że wynik funkcji g(n) pomnożony przez jakąś stałą c będzie mniejszy bądź równy wynikowi funkcji f(n). Własność ta jest spełniona dla wszystkich n, które będą większe od n0. Ponownie wykres pomoże Ci to zrozumieć:             Oszacowanie z dołu, notacja Ω.        Na wykresie widoczne są dwie funkcje. Pierwszą znasz. Druga to wykres funkcji g(n) = n^2. “Ostatni” punkt przecięcia tych dwóch wykresów, to n02. Od tego miejsca wykres funkcji g(n) jest zawsze pod wykresem funkcji f(n). Możemy powiedzieć, że funkcja f(n) ma złożoność Ω(n^2).   Notacja Θ (theta)   Można powiedzieć, że notacja Θ to połączenie notacji Ο i Ω. W tym przypadku funkcja użyta do oszacowania musi spełniać zależność:   \\[\\forall n \\geqslant n_0 : c_1 * g(n) \\geqslant f(n) \\geqslant c_2 * g(n)\\]  Tłumacząc to na polski można powiedzieć, że wynik funkcji g(n) pomnożony przez stałą c1 będzie większy bądź równy wartości funkcji f(n). Jednocześnie będzie mniejszy bądź równy wartości funkcji f(n) jeśli pomnożymy go przez stałą c2. Ponownie wykres może pomóc to zrozumieć:             Dokładne oszacowanie rzędu, notacja Θ.        W naszym przypadku funkcję g(n) możemy opisać wzorem g(n) = (n-4)^3. Stałe mają odpowiednio wartości c1 = 5, c2 = 1. Wykres oznaczony kolorem niebieskim to wynik funkcji g(n) przemnożony przez stałą c1. Wykres oznaczony kolorem fioletowym to wynik funkcji g(n) przemnożony przez stałą c2.   Jak wcześniej wspomniałem notacja Ο jest najczęściej spotykana. W dalszej części artykułu będę odnosił się tylko do tej notacji.   Rząd złożoności obliczeniowej   Tu także skupię się na przykładzie wzoru wałkowanego wcześniej:   \\[f(n) = n^3 - 6n^2 + 4n + 12\\]  Jak wspomniałem wcześniej w praktyce nie potrzebujemy tak dokładnego wzoru wystarczy jedynie zgrubne oszacowanie, które uwzględnia najbardziej istotny element funkcji. Który element funkcji jest najbardziej istotny? Ten, który ma największy wpływ na ostateczny wynik funkcji. Jak to sprawdzić? Wystarczy pod n podstawić bardzo dużą liczbę i zobaczyć, który element będzie miał największą wartość. Na przykład:                  Element       Wartość przy n = 1'000'000'000                       n^3       1’000’000’000’000’000’000’000’000’000                 6n^2       6’000’000’000’000’000’000                 4n       4’000’000’000                 12       12           Jak widzisz, przy odpowiednio dużych wartościach n część “elementów równania” jest mniej istotna. W przypadku funkcji powyżej najszybciej rosnącym elementem jest n^3. Ma on największy wpływ na ostateczny wynik funkcji.   Wiesz już z powyższych rozważań, że funkcja f(n) ma złożoność Ο(n^3). Jest to tak zwana złożoność wielomianowa. Istnieje kilka popularnych rzędów złożoności obliczeniowej.   Ο(1)   Złożoność stała, niezależna od liczby danych wejściowych. Mówimy, że problem o złożoności Ο(1) możemy rozwiązać w stałym czasie niezależnie od wielkości danych wejściowych. Przykład problemu, dla którego istnieje algorytm Ο(1):      Na wejściu programu jest tablica liczb o długości N. Liczby są posortowane rosnąco. Pomiędzy dwoma sąsiadującymi liczbami różnica jest stała. Znajdź sumę liczb w tablicy.    Problem to nic innego jak obliczenie sumy ciągu arytmetycznego. Istnieje na to wzór, który można zaimplementować:   public int sum(int[] numbers) {     if (numbers == null || numbers.length == 0) {         return 0;     }     return (numbers[0] + numbers[numbers.length - 1]) * numbers.length / 2; }   W tym przypadku nie potrzebujemy iterować po elementach tablicy. Niezależnie od wielkości tablicy wejściowej możemy obliczyć sumę ciągu w stałym czasie.   Ο(n)   Złożoność liniowa. Jest to specyficzny przypadek złożoności wielomianowej. Czas rozwiązania problemu jest wprost proporcjonalny do wielkości danych wejściowych. Przykład problemu, dla którego istnieje algorytm Ο(n):      Na wejściu programu jest tablica liczb o długości N. Znajdź sumę wszystkich liczb w tablicy wejściowej.    public int sum(int[] numbers) {     int sum = 0;     for (int number : numbers) {         sum += number;     }     return sum; }   Aby znaleźć tę sumę należy sprawdzić wszystkie elementy tablicy. Musimy zatem odbyć N kroków.   Ο(log(n))   Złożoność logarytmiczna, czas rozwiązania zależy od wyniku logarytmu3 z wielkości danych wejściowych. Przykład problemu, dla którego istnieje algorytm Ο(log(n)):      Na wejściu programu jest posortowana tablica liczb o długości N. Sprawdź czy liczba x istnieje w tablicy wejściowej.    To popularny algorytm przeszukiwania binarnego. Jego nazwa pochodzi od tego, że przy każdej iteracji algorytmu dzielimy przeszukiwany zbiór na dwie równe4 części. Algorytmy, które dzielą w ten sposób problem na mniejsze problemy przeważnie są zależne od logarytmu wielkości danych wejściowych.   public boolean binarySearch(int[] numbers, int number) {     int indexLow = 0;     int indexHigh = numbers.length - 1;     while (indexLow &lt;= indexHigh) {         int indexMiddle = indexLow + (indexHigh - indexLow) / 2;          if (number &lt; numbers[indexMiddle]) {             indexHigh = indexMiddle - 1;         }         else if (number &gt; numbers[indexMiddle]) {             indexLow = indexMiddle + 1;         }         else {             return true;         }     }     return false; }   Ο(nlog(n))   Złożoność liniowo-logarytmiczna. Czas rozwiązania problemu jest wprost proporcjonalny do iloczynu wielkości danych wejściowych i ich logarytmu. Przykładem problemu dla którego istnieje algorytm o złożoności Ο(nlog(n)) jest:      Na wejściu programu jest tablica liczb. Zwróć tablicę, która będzie zawierała te same elementy, które są w tablicy wejściowej. Tablica wynikowa powinna być posortowana w porządku rosnącym.    Powyższy problem to sortowanie. Jeden z ze standardowych problemów w informatyce. Algorytmem sortującym, który ma złożoność obliczeniową Ο(nlog(n)) jest sortowanie przez scalanie (ang. merge sort):   public static int[] sort(int[] numbers) {     if (numbers.length &lt;= 1) {         return numbers;     }     int[] first = new int[numbers.length / 2];     int[] second = new int[numbers.length - first.length];     for (int i = 0; i &lt; first.length; i++) {         first[i] = numbers[i];     }     for (int i = 0; i &lt; second.length; i++) {         second[i] = numbers[first.length + i];     }     return merge(sort(first), sort(second)); }  private static int[] merge(int[] first, int[] second) {     int[] merged = new int[first.length + second.length];     for (int indexFirst = 0, indexSecond = 0, indexMerged = 0; indexMerged &lt; merged.length; indexMerged++) {         if (indexFirst &gt;= first.length) {             merged[indexMerged] = second[indexSecond++];         }         else if (indexSecond &gt;= second.length) {             merged[indexMerged] = first[indexFirst++];         }         else if (first[indexFirst] &lt;= second[indexSecond]) {             merged[indexMerged] = first[indexFirst++];         }         else {             merged[indexMerged] = second[indexSecond++];         }     }     return merged; }   Algorytm dzieli tablicę na części do czasu aż każda z nich będzie miała długość 1. Następnie scala je ze sobą. Każde takie scalenie to koszt Ο(n). W związku z tym, że tablicę wejściową dzieliliśmy za każdym razem na pół takich scaleń mamy log(n). Zatem wynikowa złożoność algorytmu to Ο(nlog(n)).   Jak widzisz obliczanie złożoności obliczeniowej bardziej skomplikowanych algorytmów nie jest takie łatwe.   Ο(n^2)   Złożoność kwadratowa. Jest to specyficzny przypadek złożoności wielomianowej. Przykładowy problem może być ten, który użyłem wyżej – posortowanie tablicy. Tym razem jednak algorytm jest mniej wydajny. Sortowanie bąbelkowe charakteryzuje się złożonością obliczeniową Ο(n^2):   public int[] sort(int[] numbers) {     for (int i = 0; i &lt; numbers.length; i++) {         for (int j = 0; j &lt; numbers.length - 1; j++) {             if (numbers[j] &gt; numbers[j + 1]) {                 int temp = numbers[j + 1];                 numbers[j + 1] = numbers[j];                 numbers[j] = temp;             }         }     }     return numbers; }   Mamy tutaj dwie zagnieżdżone pętle. Każda z nich iteruje po n elementach. W związku z tym otrzymujemy złożoność Ο(n^2).   Ο(n^x)   Złożoność wielomianowa. Jak już wiesz złożoność liniowa i złożoność kwadratowa są specyficznymi przypadkami złożoności wielomianowej. Ze względu na częste występowanie wyszczególniłem je jako osobne rzędy złożoności. Przykłady problemów i rozwiązań znajdziesz w poprzednich punktach.   Ο(x^n)   Jest to złożoność wykładnicza, jej przykładem może być Ο(2^n). Problemem, który ma rozwiązanie o złożoności co najmniej Ο(2^n) jest:      Na wejściu programu jest tablica unikalnych liczb. Zwróć tablicę, która będzie zawierała wszystkie możliwe podzbiory elementów tablicy wejściowej.    Wynika to z faktu, że wszystkich możliwych podzbiorów zbioru, który ma n elementów jest dokładnie 2^n. Poniższy algorytm ma złożoność Ο(log(n)2^n).   public static int[][] powerSet(int[] numbers) {     int two_pow_n = 1 &lt;&lt; numbers.length;      int[][] powerSet = new int[two_pow_n][];     for (int subsetIndex = 0; subsetIndex &lt; two_pow_n; subsetIndex++) {         powerSet[subsetIndex] = pickNumbers(subsetIndex, numbers);     }     return powerSet; }  private static int[] pickNumbers(int subsetIndex, int[] numbers) {     int howManyOnes = 0;     int temp = subsetIndex;     while (temp &gt; 0) {         if (temp % 2 == 1) {             howManyOnes++;         }         temp &gt;&gt;= 1;     }      int[] subset = new int[howManyOnes];      for (int charIndex = 0, lastElementIndex = 0; subsetIndex &gt; 0; charIndex++) {         if (subsetIndex % 2 == 1) {             subset[lastElementIndex++] = numbers[charIndex];         }         subsetIndex &gt;&gt;= 1;     }      return subset; }   Wynika to z faktu, że pętla wewnątrz metody powerSet wywołana jest dokładnie 2^n razy. Natomiast wewnątrz metody pickNumbers są dwie pętle. Każda z nich ma złożoność Ο(log(n)). Zatem finalna złożoność algorytmu to Ο(log(n)2^n).   Spróbuj uruchomić ten kod z tablicą wejściową z 30 elementami, życzę powodzenia ;).   Ο(n!)   Jest to złożoność typu silnia.  Dla przypomnienia silnia n, albo inaczej n! to iloczyn wszystkich liczb od 1 do n. Na przykład 3! = 1 * 2 * 3 = 6. Przykładem problemu, dla którego istnieje naiwny algorytm o tej złożoności to problem komiwojażera:      Na wejściu programu jest n miast oraz odległości pomiędzy każdą parą miast. Zakładając, że komiwojażer zaczyna z miasta A i ma dojść do miasta B jaką trasę powinien pokonać aby była ona najkrótsza?    Nie silę się nawet na naiwny algorytm dla tego problemu, nie jest on możliwy do uruchomienia na dzisiejszych komputerach dla problemów odpowiednio dużych. Wyobraź sobie, skalę możliwych rozwiązań. (60 - 1)!/2 ~= 6,9 * 10^795. Szacowana liczba atomów wodoru w widzialnym wszechświecie to około 10^80. Przekładając to na problem wyżej, możliwych dróg pomiędzy 60 miastami jest tylko 31% mniej niż atomów wodoru w widzialnym wszechświecie ;).   Najlepszy, średni i najgorszy przypadek   Ten sam algorytm może zachowywać się zupełnie inaczej w przypadku innych danych wejściowych. Nie mówię tu o wielkości problemu, wielkości danych wejściowych. A o instancji problemu.   Jeśli algorytm jako dane wejściowe przyjmuje tablicę liczb to wielkością problemu może być 5 – tablica o długości 5. Natomiast instancji tego problemu jest nieskończenie wiele: [1, 2, 3, 4, 5], [-1, 2, -3, 4, -5] czy [5, 4, 3, 2, 1]. Algorytm może mieć różną złożoność obliczeniową określoną w notacji Ο w zależności od instancji problemu. Są także algorytmy, których złożoność obliczeniowa jest niezależna od instancji problemu.   W zależności od wymagań w wyborze algorytmu bierze się pod uwagę złożoność odpowiedniego przypadku.   Dodatkowe materiały do nauki   Informacji na temat teorii obliczeń i złożoności obliczeniowej w internecie jest sporo. Jednak dość ciężko jest znaleźć jakiekolwiek informacje, które są na początkującym poziomie. Niemniej jednak poniżej starałem się zebrać materiały, które mogą być interesujące:      Kilka krótkich artykułów opisujących podstawy teorii obliczeń,   Computational Complexity: A Modern Approach, szkic książki o złożoności obliczeniowej. Jej ostateczna wersja dostępna jest na Amazonie,   Artykuł na temat złożoności obliczeniowej z uniwersytetu Stanford,   Sekcja Wolfram Alpha poświęcona złożoności obliczeniowej,   Artykuł na Wikipedii na temat funkcji służących do szacowania,   Artykuł o złożoności obliczeniowej na Codility6,   Fragmenty kodu użyte w tym artykule.   Podsumowanie   Jeśli zrozumiałeś ten artykuł możesz śmiało powiedzieć, że wiesz czym jest złożoność obliczeniowa. Wiesz jak ją szacować, znasz przykłady algorytmów z najczęściej spotykanych rzędów złożoności obliczeniowej. Znasz kilka notacji do określania złożoności. Dowiedziałeś się też ile jest atomów wodoru we wszechświecie ;). W każdym razie masz za sobą spory kawałek lektury i sporo wiedzy.   Na koniec mam do Ciebie prośbę. Proszę podziel się tym artykułem ze swoimi znajomymi, sporo się nad nim napracowałem. Mam nadzieję, że będzie mógł pomóc jak największej grupie osób. Jeśli nie chcesz ominąć kolejnych artykułów w przyszłości polub Samouczka na Facebooku i zapisz się do newslettera. Do następnego razu!                 Wykresy użyte w tym artykule stworzyłem przy pomocy graphsketch. &#8617;                  To oczywiście kolejne uproszczenie, punkt to para dwóch liczb. n0 jest jedną z nich – tą na osi poziomej. Dasz radę wyznaczyć drugą współrzędną? ;) &#8617;                  Podstawą logarytmu przeważnie jest 2. Zdarzają się także algorytmy, w których logarytm ma inną podstawę. &#8617;                  Oczywiście, w przypadku tablicy o nieparzystej długości jedna z części nie będzie “równiejsza” od drugiej ;). &#8617;                  Z pierwszego miasta mamy możliwość pójść do 59 miast, następnie możemy wybrać 58 miast, itd. Wynik dzielony jest przez 2 ponieważ nie ma znaczenia czy pójdziemy z miasta A do miasta B czy odwrotnie. &#8617;                  Wielkie dzięki dla Marka za podesłanie linka do tego artykułu. &#8617;           ","categories": ["Programowanie","Wiedza ogólna"],
        "tags": [],
        "url": "/podstawy-zlozonosci-obliczeniowej/",
        "teaser": "/assets/images/2017/11/13_zlozonosc_obliczeniowa_artykul.jpg"
      },{
        "title": "REST web service z Java EE część 1",
        "excerpt":"     To jest jeden z artykułów w ramach darmowego kursu programowania aplikacji webowych w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   W kursie tym zakładam, że znasz język Java. Możesz go poznać w osobnym kursie programowania w języku Java. Do budowania wszystkich projetków używam Gradle, przeczytasz o nim więcej w osobnym artykule.     Słownik pojęć   Na początku postaram się wytłumaczyć pojęcia, które będą używane w dalszej części artykułu.   Czym jest web service   Wyobraź sobie obiekt. Obiekt ma zestaw metod. W normalnych warunkach metody na tym obiekcie możemy wywoływać wyłącznie w tym samym programie, w ramach tej samej wirtualnej maszyny Java. W uproszczeniu web service1 to mechanizm umożliwiający wywołanie jakiejś funkcjonalności za pośrednictwem internetu. Istnieje kilka podejść do tworzenia web service’ów.   Jednym z nich jest tak zwany REST.   Czym jest REST   REST to rozwinięcie Representational State Transfer. REST to zbiór praktyk, które określają w jaki sposób powinniśmy implementować web service’y. REST kręci się wokół tak zwanych encji (ang. resource). Encja to obiekt, który reprezentuje byt w aplikacji. Może to być na przykład obiekt reprezentujący rezerwację stolika, użytkownika aplikacji czy kredyt w banku.   Operacje na encjach wykonuje się za pomocą zapytań HTTP. Do encji dobieramy się używając odpowiednich typów zapytań. Typy zapytań określone są przez czasowniki HTTP: GET, POST, PUT i DELETE. Czasowniki te wraz z adresem URL definiują dokładnie jaką operację chcemy wykonać na danej encji.                  Czasownik       Przykład       Znaczenie                       GET       GET /rezerwacja/123       Pobranie rezerwacji o identyfikatorze 123                 PUT       PUT /rezerwacja/123       Edycja rezerwacji o identyfikatorze 123                 POST       POST /rezerwacja       Utworzenie nowej rezerwacji                 DELETE       DELETE /rezerwacja/123       Usunięcie rezerwacji o identyfikatorze 123           Zanim powstał REST, web service’y w języku Java tworzono w oparciu o SOAP (ang. Simple Object Access Protocol). SOAP w porównaniu do REST jest dużo bardziej złożony. SOAP oparty jest o XML‘a i jest dość rozwlekłym protokołem. Moim zdaniem REST zdobył dużą przewagę właśnie swoją prostotą w porównaniu do SOAP. REST jest de facto standardem jeśli chodzi o tworzenie web service’ów w większości aplikacji webowych.   Wysłane zapytanie informuje także web service o preferowanej formie odpowiedzi. Dzieje się to zazwyczaj przy pomocy nagłówków HTTP. Na przykład nagłówek zapytania Accept: application/json informuje web service, że klient oczekuje odpowiedzi w formacie JSON.   Jest to tylko krótkie wprowadzenie, jeśli chcesz dowiedzieć się więcej na temat REST odsyłam Cię do materiałów dodatkowych.   PUT czy POST?   W tabeli wyżej wspomniałem o tym, że to zapytania typu POST powinny tworzyć nową instancję a zapytania typu PUT powinny ją edytować. Dla pełni informacji muszę Ci powiedzieć, że z tego co wiem, nie jest to nigdzie ustandaryzowane.   Spotkasz się zarówno z takim podejściem jak w tabeli wyżej jak i odwrotnym, w którym to zapytania typu POST służą do edycji encji.   Czym jest Java EE   W jednym zdaniu. Java EE to platforma, która oparta jest na zbiorze specyfikacji. Technologie opisane w tych specyfikacjach są używane głównie do tworzenia aplikacji webowych.             Logo Java EE        Teraz należy Ci się rozwinięcie. Język Java już znasz. Java wraz z zestawem biblioteki standardowej to Java SE (ang. Standard Edition). Istnieje również taki twór jak Java EE (ang. Enterprise Edition). Jak napisałem wyżej Java EE to nic innego jak zbiór różnych specyfikacji. Można powiedzieć, że Java EE rozbudowuje możliwości Java SE. Oczywiście podstawą tutaj jest język programowania Java. Java EE w wersji 8 została opublikowana 31 sierpnia 2017 roku. Java EE w wersji 8 to 41 osobnych specyfikacji! Jedną ze specyfikacji jest Java Servlets. Opisywałem ją w poprzednich artykułach w ramach kursu.   Java Servlets jest specyfikacją, którą można używać w kontenerach serwletów. Niestety nie wszystkie ze wspomnianych 41 specyfikacji można używać w kontenerze serwletów. Java API for RESTful Web Services (w skrócie JAX-RS) jest tu dobrym przykładem. Aby móc używać tej technologii potrzebujemy kontenera aplikacji.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Kontener aplikacji a kontener serwletów   Apache Tomcat, którego używałem do tej pory w ramach kursu jest kontenerem serwletów. Umożliwia on uruchamianie aplikacji webowych, które używają podzbioru specyfikacji Java EE (na przykład specyfikacji serwletów).   Pisanie web service’ów w oparciu o JAX-RS wymaga kontenera aplikacji. Jednym z kontenerów aplikacji jest Apache TomEE.   Instalacja kontenera aplikacji   Jest wiele kontenerów aplikacji. W tym kursie będę używał Apache TomEE. Jest to jeden z darmowych kontenerów. Aby go zainstalować pobierz TomEE PluME i rozpakuj plik ZIP do dowolnego folderu. To tyle, instalację kontenera aplikacji masz już za sobą.   Ważne jest, żebyś pobrał wersję TomEE PluME, lub TomEE+. Te wersje wspierają specyfikację JAX-RS.             Pobieranie TomEE Plume        Web service z JAX-RS   build.gradle   Nadszedł czas na to, żeby utworzyć swój pierwszy web service. Do budowania aplikacji użyłem Gradle. Plik build.gradle wygląda następująco:   apply plugin: 'java' apply plugin: 'idea' apply plugin: 'war' apply from: 'https://raw.github.com/akhikhl/gretty/master/pluginScripts/gretty.plugin'  repositories {     mavenCentral() }  sourceCompatibility = 1.8 group = 'pl.samouczekprogramisty.kursaplikacjewebowe' version = '1.0-SNAPSHOT'  dependencies {     providedCompile group: 'javax.servlet', name: 'javax.servlet-api', version: '3.1.0'     providedCompile group: 'javax.ws.rs', name: 'javax.ws.rs-api', version: '2.1'      testCompile group: 'junit', name: 'junit', version: '4.12'     testCompile group: 'org.hamcrest', name: 'hamcrest-all', version: '1.3'     testCompile group: 'org.mockito', name: 'mockito-all', version: '1.10.19' }  task explodedWar(type: Copy) {     into \"$buildDir/explodedWar\"     with war }  war.dependsOn explodedWar   Najbardziej istotnym fragmentem jest providedCompile group: 'javax.ws.rs', name: 'javax.ws.rs-api', version: '2.1'2. Jest to zależność, która zawiera klasy określone przez specyfikację JAX-RS. providedCompile mówi Gradle o tym, że zależność jest wymagana przez aplikację wyłącznie w trakcie kompilacji. Nie zostanie umieszczona w wynikowymi pliku war. Nie jest ona tam potrzebna ponieważ jest dostępna na classpath kontenera aplikacji.   Pierwszy web service   Utwórz klasę, która będzie odpowiedzialna za encję Reservation. Może to być na przykład ReservationWebservice:   package pl.samouczekprogramisty.kursaplikacjewebowe.rest;  import javax.ws.rs.GET; import javax.ws.rs.Path; import javax.ws.rs.core.Response;  @Path(\"/reservation\") public class ReservationWebservice {     @GET     public Response listReservations() {         return Response.ok(\"Oto wszystkie rezerwacje :)\").build();     } }   Jest to standardowa klasa Javy, tak zwane POJO (ang. Plain Old Java Object). Zawiera ona jedną metodą, listReservations. Dodatkowo znajdują się w niej dwie adnotacje: @Path i @GET. Metoda ta zwraca instancję obiektu Response.   Ta kombinacja to Twój pierwszy web service. Adnotacja @Path informuje JAX-RS o tym pod jakim URL dana klasa/metoda powinna odpowiadać. Adnotacja @GET mówi o tym jaki czasownik HTTP jest obsługiwany przez daną metodę.   Następnie zbuduj aplikację używając polecenia:   gradle war   Po jego wykonaniu w katalogu build/libs projektu powinien znaleźć się plik war. Przekopiuj go do katalogu webapps w miejscu gdzie zainstalowałeś TomEE. W moim przypadku wygląda to następująco:   cp /home/mapi/KursAplikacjeWebowe/06_rest_endpoint/build/libs/06_rest_endpoint-1.0-SNAPSHOT.war /home/mapi/opt/apache-tomee/webapps/rest.war   Zauważ, że w trakcie kopiowania zmieniłem nazwę pliku war z 06_rest_endpoint-1.0-SNAPSHOT.war na rest.war. Zrobiłem tak, ponieważ TomEE, podobnie jak Tomcat używa nazwy pliku war jako fragmentu adresu URI aplikacji. Szybciej napiszę rest niż 06_rest_endpoint-1.0-SNAPSHOT.   Po przekopiowaniu pliku war uruchom serwer TomEE. Możesz to zrobić przy pomocy pliku catalina.sh3:   /home/mapi/opt/apache-tomee/bin/catalina.sh run   Jeśli zrobiłeś wszystko zgodnie z powyższą instrukcją masz swój pierwszy działający web service. Gratulacje ;). Aby móc zobaczyć go w działaniu odwiedź stronę: http://localhost:8080/rest/reservation. Powinieneś zobaczyć napis Oto Wszystkie rezerwacje :).   Jak działa web service z użyciem JAX-RS   Skoro napisałeś już swój pierwszy web service warto zrozumieć co dzieje się pod spodem. Nie ma tam żadnej magii. Jedynie trochę pracy po stronie kontenera aplikacji.   Otóż w naszym przypadku specyfikacja JAX-RS wymaga od kontenera aplikacji utworzenia specjalnego serwletu. Serlwet ten ma za zadanie obsługiwać wszystkie żądania, które wysyłane są do naszej aplikacji.   Kontener aplikacji musi przeskanować wszystkie klasy w naszej aplikacji pod kątem adnotacji JAX-RS. Jeśli znajdzie te adnotacje w klasach zapamiętuje je. Następnie używa tych klas do obsługi żądań wysyłanych przez klienty4.   Więc w tym przypadku, wysłanie żądania na adres http://localhost:8080/rest/reservation spowoduje wywołanie tego serwletu. Następnie serwlet stworzy instancję klasy  ReservationWebservice. Na tej instancji wywoła metodę listReservations. Wartość zwrócona przez tę metodę zostanie użyta do przygotowania odpowiedzi dla klienta.   REST bez użycia JAX-RS   Jak widzisz z powyższego opisu JAX-RS jest jedynie nakładką na mechanizm serwletów. Jeśli czytałeś poprzednie artykuły w ramach kursu to wiesz, że serwlety są sercem ogromnej większości aplikacji webowych napisanych w Javie.   Skoro jest to nakładka, to można tę samą funkcjonalność uzyskać bez niej. Innymi słowy można pisać REST’owe web service’y bez użycia JAX-RS, używając standardowego kontenera serwletów. Jednak JAX-RS sporo upraszcza, pozwala programiście używać wyższego poziomu abstrakcji. Nie musisz pamiętać o doGet czy innych metodach z API serwletów.   Pozostałe metody web service’u   Metody te to jedynie szablony, które mają pokazać Ci przykład użycia adnotacji udostępnionych przez JAX-RS.   Pobieranie encji. Metoda GET   Poprzednia metoda listReservations odpowiadała na żądanie do ścieżki /reservation i zwracała (teoretycznie) wszystkie rezerwacje. Tym razem chcemy zwrócić pojedynczą rezerwację. Proszę spójrz na przykład poniżej:   @GET @Path(\"{id}\") public Response getReservation(@PathParam(\"id\") Integer id) {     return Response.ok(\"Oto rezerwacja o identyfikatorze \" + id + \" :)\").build(); }   Jak widzisz w tym przypadku metoda getReservation dekorowana jest adnotacją @Path. Metoda ta zostanie wywołana do obsłużenia zapytania wysłanego pod adres /reservation/{id}. Składnia {id} użyta jest do przechwytywania części adresu URL. Dzięki tej składni i użyciu adnotacji @PathParam część tej ścieżki zostanie przekazana w trakcie wywołania metody getReservation. Na przykład zapytanie GET /reservation/123 spowoduje wywołanie tej metody z argumentem id o wartości 123.   Edycja encji. Metoda PUT   @PUT @Path(\"{id}\") public Response updateReservation(@PathParam(\"id\") Integer id) {     return Response.ok(\"Zmodyfikowaliśmy rezerwację o numerze \" + id + \" :)\").build(); }   W tym przypadku nowa jest dla Ciebie jedynie adnotacja @PUT. Informuje ona kontener aplikacji o tym, że metoda updateReservation powinna być wywołana jeśli klient wyśle zapytanie PUT /reservation/{id}.   Usuwanie encji. Metoda ‘DELETE`   @DELETE @Path(\"{id}\") public Response deleteReservation(@PathParam(\"id\") Integer id) {     return Response.ok(\"Usunęliśmy rezerwację o numerze \" + id + \" :)\").build(); }   Dodawanie encji. Metoda ‘POST`   @POST public Response createReservation() {     return Response.ok(\"Rezerwacja została utworzona!\").build(); }   Testowanie zapytań typu PUT, DELETE   Do przetestowania zapytań typu PUT czy DELETE w przeglądarce potrzebujesz odrobiny HTML’a i kodu w języku JavaScript. Przygotowałem dla Ciebie prostą stronę, która może Ci w tym pomóc.   Jeśli Twoja instancja TomEE będzie uruchomiona i aplikacja będzie zainstalowana, to po odpowiednim wypełnieniu pól zostanie wysłane żądanie.   Słów kilka o CORS   CORS (ang. Cross-Origin Resource Sharing) jest mechanizmem używanym przez przeglądarki. Polega on na dodawaniu odpowiednich nagłówków do odpowiedzi serwera. Zawartość tych nagłówków informuje przeglądarkę czy może używać wyników tego zapytania.   Mechanizm ten użyty jest do podniesienia bezpieczeństwa używania stron internetowych. Na chwilę obecną musisz wiedzieć, że aby móc używać strony do testowania Twój web service musi dodawać odpowiednie nagłówki do odpowiedzi.   Innymi słowy zamiast wysyłać prostą odpowiedź:   Response.     ok(\"Usunęliśmy rezerwację o numerze \" + id + \" :)\").     build();   Musiałbyś dodać zestaw nagłówków:   Response.     ok(\"Usunęliśmy rezerwację o numerze \" + id + \" :)\").     header(\"Access-Control-Allow-Origin\", \"*\")     header(\"Access-Control-Allow-Headers\", \"Content-Type\")     header(\"Access-Control-Allow-Methods\", \"DELETE\")     build();   Jest to wymagane dla każdego zapytania, które będzie uruchamiane ze strony do testowania. Jest to spowodowane tym, że adres URL źródła zapytania jest inny niż adres URL web service’u5. W związku z tym, że trzeba to umieścić w wielu miejscach JAX-RS przychodzi z pomocą.   Adnotacja @Provider   Więcej o tej adnotacji przeczytasz w drugiej części artykułu. Dzisiaj opiszę jedynie część jej możliwości.   JAX-RS udostępnia adnotację @Provider. Służy ona do oznaczenia komponentów, które powinny być automatycznie odkryte przez kontener aplikacji. Tą adnotacją oznacza się klasy, które są odpowiedzialne za przekrojowe zadania (ang. cross-cutting) związane z aplikacją.   Przykładem takiego przekrojowego zadania może być automatyczne dodawanie nagłówków do każdej odpowiedzi. Ta funkcjonalność pozwala na łatwą implementację wymagań narzucanych przez CORS:   @Provider public class CORSFilter implements ContainerResponseFilter {     @Override     public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {         MultivaluedMap&lt;String, Object&gt; headers = responseContext.getHeaders();         if (!headers.containsKey(\"Access-Control-Allow-Origin\")) {             headers.add(\"Access-Control-Allow-Origin\", \"*\");         }         if (!headers.containsKey(\"Access-Control-Allow-Headers\")) {             headers.add(\"Access-Control-Allow-Headers\", \"Content-Type\");         }         if (!headers.containsKey(\"Access-Control-Allow-Methods\")) {             headers.add(\"Access-Control-Allow-Methods\", \"GET, PUT, POST, DELETE\");         }     } }   Klasa CORSFilter implementuje interfejs ContainerResponseFilter. Interfejs ten zawiera metodę filter, która pozwala między innymi na dodanie nagłówków do każdej odpowiedzi.   Dodatkowe materiały do nauki   Jest tego sporo, głównie w języku angielskim:      Przykłady kodu użyte w artykule,   Tutorial dotyczący JAX-RS przygotowany przez Oracle,   Praca doktorska Roy’a Fielding’a, gdzie po raz pierwszy użyto określenia REST,   Rozdział w wyżej wspomnianej pracy na temat REST,   REST API Tutorial,   Artykuł o REST na anglojęzycznej wersji Wikipedii,   Specyfikacja JAX-RS 2.1,   Dokumentacja API JAX-RS,   Artykuł na stronie Mozilli o CORS,   Artykuł na temat dojrzałości architektury REST,   Podsumowanie   Dzisiaj udało Ci się zdobyć sporo wiedzy. Dowiedziałeś się czym jest REST. Co składa się na platformę Java EE. Poznałeś część funkcjonalności jednej ze specyfikacji znajdującej się pod parasolem Java EE. Zainstalowałeś kontener aplikacji, no i przede wszystkim napisałeś swój pierwszy web service przy pomocy JAX-RS.   W kolejnym artykule z tej serii zajmę się implementacją bardziej użytecznego web service’u. Jeśli nie chcesz pominąć kolejnych artykułów na blogu dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu!                 Zawsze staram się tłumaczyć angielskie terminy. Jednak w tym przypadku poddałem się. Jak przetłumaczyć web service? Usługa sieciowa? Serwis internetowy? Takie tłumaczenie wprowadzałoby więcej zamieszania niż pożytku. Zostanie więc web service, jeśli masz jakiś pomysł jak to przetłumaczyć daj znać ;). &#8617;                  W rzeczywistości mimo, że importuję tu API w wersji 2.1 serwer TomEE, którego używam (7.0.4) wspiera wersję 2.0. &#8617;                  Jeśli pracujesz w systemie Windows wówczas plik ten nazywa się catalina.bat. &#8617;                  Oczywiście jest to uproszczenie. W praktyce proces jest trochę bardziej rozbudowany. Proces ten opisany jest w sekcji 3.7 specyfikacji “Matching Requests to Resource Methods”. Domyślnie nowa instancja klasy obsługującej zapytanie tworzona jest dla każdego zapytania. W większości przypadków nie jest to zachowanie, które chcesz zostawić na produkcyjnym środowisku. &#8617;                  W tym przypadku porównywany jest protokół (np. http), domena (np. www.samouczekprogramisty.pl) i port (np. 8080). &#8617;           ","categories": ["Kurs aplikacji webowych"],
        "tags": [],
        "url": "/rest-web-service-z-java-ee-czesc-1/",
        "teaser": "/assets/images/2017/11/20_rest_web_service_artykul.jpg"
      },{
        "title": "SOLID czyli dobre praktyki w programowaniu obiektowym",
        "excerpt":"Artykuł ten zakłada, że znasz już podstawy języka programowania. Najlepiej gdybyś miał już za sobą drobny projekt, na przykład prosty kalkulator. Abyś mógł wynieść coś z tego artykułu musisz wiedzieć czym są interfejsy i dziedziczenie. Przydatne mogą być też pozostałe artykuły z kursu programowania w języku Java.   Czym jest SOLID   S.O.L.I.D. to akronim, który wymyślił Robert C. Martin. Uncle Bob (taki ma pseudonim) jest programistą. Ma sporo doświadczenia, przez wielu uważany jest za swego rodzaju autorytet.   Akronim ten zbiera zestaw wytycznych. Wytyczne te stosuje się podczas pisania programów w sposób obiektowy. Samo słówko solid można przetłumaczyć jako solidny, konkretny, mocny. Ta gra słów pewnie też miała spore znaczenie dla popularności samego akronimu.   Poniżej na przykładach postaram się wyjaśnić poszczególne literki.   S jak Samodzielny   S pochodzi od Single Responsibility Principle. W oryginalnym wydaniu autor mówi o tym, że klasa powinna mieć wyłącznie jeden powód do zmiany. Wytyczna ta sprowadza się do tego, że dana klasa powinna mieć jeden główny cel. Jedną główną odpowiedzialność. Jedną funkcjonalność, którą realizuje.   Klasy, które implementują wyłącznie jedną odpowiedzialność nie są bezpośrednio związane (ang. coupled) z inną funkcjonalnością. Moim zdaniem, w większości przypadków łatwiej jest zrozumieć taki kod, który jest odpowiedzialny za jedną rzecz.   Twoje klasy powinny mieć motto: rób jedną rzecz, rób tę rzecz dobrze1.   Przykład   W praktyce możesz pomyśleć o klasie, która przechowuje szczegóły umowy. Taką umowę czasami trzeba wydrukować. Niezbędne jest też obliczenie miesięcznej kwoty abonamentu. W przypadku upakowania tych dwóch odpowiedzialności do jednej klasy może ona wyglądać następująco:   public class Contract {      private final Date start;      private final Date end;      public Contract(Date start, Date end) {         this.start = start;         this.end = end;     }      public BigDecimal getMonthlySubscriptionFee() {         // compute based on end and start         return BigDecimal.ONE;     }      public byte[] formatAsPDF() {         return \"...\".getBytes();     } }   Ewidentnie w tym przypadku mamy kilka powodów do zmiany. Jeśli zmieni się wymaganie dotyczące wydruków, czy sposobu obliczania abonamentu musimy zmienić klasę Contract. Literka S w SOLID zachęca do rozdzielenia tych zagadnień:   public class Contract {      private final Date start;      private final Date end;      public Contract(Date start, Date end) {         this.start = start;         this.end = end;     }      public Date getStart() {         return start;     }      public Date getEnd() {         return end;     }      public BigDecimal getMonthlySubscriptionFee() {         // compute based on end and start         return BigDecimal.ONE;     } }   public class PDFFormatter {      private final Contract contract;      public PDFFormatter(Contract contract) {         this.contract = contract;     }      public byte[] format() {         return \"...\".getBytes();     } }       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        O jak Otwarty   O pochodzi od Open/Closed Principle. W tym miejscu Uncle Bob zwraca uwagę na to aby kod, który tworzymy był “możliwy do rozszerzania i zamknięty na modyfikacje”. Sprowadza się do do świadomego użycia kompozycji, dziedziczenia czy modyfikatorów dostępu.   Przykład   Załóżmy, że firma poza umową chce też wydrukować ulotki. Drukarnia przyjmuje dokumenty w formacie PDF więc i ulotkę trzeba zapisać w tym właśnie formacie. Klasy Contract i PDFFormatter nie różnią się od poprzedniego przykładu. Aby zrealizować to wymaganie można utworzyć dwie nowe klasy:   public class Leaflet {      private final String title;      private final String location;      public Leaflet(String title, String location) {         this.title = title;         this.location = location;     }      public String getTitle() {         return title;     }      public String getLocation() {         return location;     } }  public class LeafletPDFFormatter {      private final Leaflet leaflet;      public LeafletPDFFormatter(Leaflet leaflet) {         this.leaflet = leaflet;     }      public byte[] format() {         return \"...\".getBytes();     }  }   Klasa LeafletPDFFormatter jest praktycznie taka sama jak klasa PDFFormatter. W tym przypadku klasa PDFFormatter nie spełnia wytycznych Open/Closed Principle. Nie można rozszerzyć jej funkcjonalności bez zmiany jej kodu źródłowego. Proszę spójrz na przykład poniżej:   public class PDFMetadata {      public final List&lt;String&gt; metadata;      public PDFMetadata(String... metadata) {         this.metadata = Arrays.asList(metadata);     }      public List&lt;String&gt; getMetadata() {         return Collections.unmodifiableList(metadata);     } }  public class Leaflet {      // ...      public PDFMetadata getPDFMetadata() {         return new PDFMetadata(title, location);     } }  public class Contract {      // ...      public PDFMetadata getPDFMetadata() {         return new PDFMetadata(start.toString(), end.toString());     } }  public class PDFFormatter {      private final PDFMetadata metadata;      public PDFFormatter(PDFMetadata metadata) {         this.metadata = metadata;     }      public byte[] format() {         return metadata.toString().getBytes();     }  }   W tym przypadku wprowadziłem klasę PDFMetadata. Zawiera ona dane niezbędne do przygotowania wydruku PDF. Zarówno klasa Leaflet jak i Contract zwracają taką reprezentację. Dzięki temu klasa PDFFormatter może utworzyć wydruk dla każdej z nich. Zauważ, ze teraz klasa PDFFormatter jest otwarta na rozszerzenie. Jeśli Twoja nowa klasa będzie zwracała instancję PDFMetadata będzie można ją przekonwertować do formatu PDF.   L jak Liskov Barbara   L pochodzi od Liskov Substitution Principle. W przypadku tej wytycznej Twój kod powinien współpracować poprawnie z klasą, jak i wszystkimi jej podklasami. Innymi słowy jeśli zależysz od jakiegoś interfejsu to wszystkie jego implementacje powinny poprawnie działać z Twoją klasą/metodą.   Stosowanie się do tej zasady pozwala na dostarczenie alternatywnej implementacji danej funkcjonalności bez zmiany Twojego kodu.   Przykład   W tym przypadku świetnym przykładem są kolekcje w języku Java:   public class SubstitutionExample {      public static void main(String[] args) {         List&lt;String&gt; someList = new ArrayList&lt;&gt;();         Set&lt;String&gt; someSet = new HashSet&lt;&gt;();         Queue&lt;String&gt; someQueue = new PriorityQueue&lt;&gt;();          SubstitutionExample example = new SubstitutionExample();         example.doSomethingWithElements(someList);         example.doSomethingWithElements(someSet);         example.doSomethingWithElements(someQueue);     }      public void doSomethingWithElements(Collection&lt;String&gt; someCollection) {         for (String element : someCollection) {             System.out.println(\"element: \" + element);         }     }  }   Metoda doSomethingWithElements zrobi dokładnie to samo bez wiedzy o tym z jakim podtypem ma do czynienia. Niezależnie od tego czy będzie to ArrayList czy PriorityQueue metoda zadziała poprawnie.   I jak Interfejsy   I pochodzi od Interface Segregation Principle. Wytyczna ta mówi o tym, abyś rozdzielał interfejs klasy. Interfejs ten powinien być odpowiednio zdefiniowany. Chodzi tu o aby inny fragment kodu, który używa Twojej klasy używał wyłącznie podzbioru metod, który jest w tamtym przypadku istotny. W oryginale wytyczna ta mówi o tym, ze klienty nie powinny być zmuszane do wprowadzania zależności od interfejsów, których nie używają.   Jeśli będziesz stosował się do tej wytycznej to zmiany Twoich klas powinny być łatwiejsze do przeprowadzenia. Dzięki jasno zdefiniowanym interfejsom ryzyko zmiany klas, które używają tych interfejsów będzie mniejsze.   Przykład   Załóżmy, ze w swoim interfejsie masz 3 metody:   public interface ObjectFormatter {      byte[] toPDF(Object someObject);      String toXML(Object someObject);      String toJSON(Object someObject);  }   Interfejs ten jest używany w trzydziestu innych projektach. W każdym przypadku używa wyłącznie jednej z tych trzech metod. Niestety z jakiegoś powodu musisz zmienić ten interfejs. W konsekwencji każdy z tych projektów musi wprowadzić jakieś zmiany. W praktyce rozdzielenie tego interfejsu na trzy oddzielne może mieć sens:   public interface PDFFormatter {      byte[] toPDF(Object someObject);  }  public interface XMLFormatter {      String toXML(Object someObject);  }  public interface JSONFormatter {      String toJSON(Object someObject);  }   W takim przypadku zmiana jednej z tych metod nie pociąga za sobą zmian w każdym z 30 wspomnianych projektów.   D jak oDwrócenie zależności   D pochodzi od Dependency Inversion Principle. Wytyczna ta mówi, że wysokopoziomowe klasy nie powinny zależeć od niskopoziomowych detali. Zależność ta powinna być odwrócona poprzez wprowadzenie dodatkowych elementów. Mówi się tu o dodatkowych warstwach abstrakcji, które pozwalają na zmianę kierunku takiej zależności.   Osobiście ciężko było mi tę zasadę zrozumieć bez dobrego przykładu. Mam nadzieję, że ten przytoczony poniżej trochę Ci to ułatwi.   Przykład   Przykład poniżej pokazuje klasę PageCrawler. Klasa ta ma powinna zwrócić odnośniki znajdujące się na stronie. Poza tym, że widzisz tu pogwałcenie zasady Single Responsibility Principle to jeszcze  Dependency Inversion Principle także nie jest spełnione. Klasa PageCrawler zleży od niskopoziomowych detali związanych z obsługą protokołu HTTP i parsowaniem HTML. Zależność ta powinna być odwrócona:   public class PageCrawler {      public List&lt;String&gt; findLinks(String url) throws IOException {         HttpURLConnection connection = makeRequest(url);         validateResponse(connection);         String content = getResponse(connection);         return parseLinks(content);     }      private List&lt;String&gt; parseLinks(String content) {         return Collections.emptyList(); // do some magic with content     }      private String getResponse(HttpURLConnection connection) throws IOException {         return connection.getContent().toString();     }      private HttpURLConnection makeRequest(String url) {         return null; //     }      private void validateResponse(HttpURLConnection connection) throws IOException {         if (connection.getResponseCode() != 200) {             throw new IllegalStateException(\"Wrong response code!\");         }         if (connection.getContentLength() &lt; 100) {             throw new IllegalStateException(\"Too small response!\");         }     } }   Poniższy przykład pokazuje wprowadzenie dwóch dodatkowych elementów. Są to odpowiednio HTTPFetcher i HTMLTokenizer. Klasy te odpowiedzialne są za ukrycie niskopoziomowych detali wymaganych przez PageCrawler. W tym przypadku PageCrawler zależy od tych dwóch klas. Odwróciłem więc zależność, teraz już wysokopoziomowa klasa (PageCrawler) nie zależy od niskopoziomowych detali (protokół HTTP czy parsowanie HTML).   public class HTTPFetcher {      public String fetch(String url) throws IOException {         return \"HTTP request details goes here\";     } }  public class HTMLTokenizer {      public List&lt;String&gt; tokenize(String response) {         return Collections.emptyList(); // details about HTML handling goes here     } }  public class PageCrawler {      private final HTTPFetcher fetcher;      private final HTMLTokenizer tokenizer;      public PageCrawler(HTTPFetcher fetcher, HTMLTokenizer tokenizer) {         this.fetcher = fetcher;         this.tokenizer = tokenizer;     }      public List&lt;String&gt; findLinks(String url) throws IOException {         String response = fetcher.fetch(url);         List&lt;String&gt; tokens = tokenizer.tokenize(response);         return findLinks(tokens);     }      private List&lt;String&gt; findLinks(List&lt;String&gt; tokens) {         return tokens; // pick only links here     } }   Nie rób nic na ślepo   Z mojego doświadczenia wynika to, że nie można na ślepo stosować się do wszystkich reguł. Mogą zdarzyć się sytuacje, w których w swojej codziennej pracy znajdziesz przypadek gdzie złamanie wytycznych SOLID ma sens. Możliwe, że czasami napisanie klasy, która ma dziesięć różnych zakresów odpowiedzialności jest dobre. Możliwe, że to dopiero przyczółek do dalszej pracy nad kodem.   Postaraj się zrozumieć poszczególne wytyczne. Zacznij je rozważnie stosować dopiero po pełnym ich zrozumieniu. Robienie czegoś na ślepo tylko dlatego, że przeczytało się o tym w dowolnym miejscu moim zdaniem mija się z celem. Zastanów się nad SOLID, zrozum i dopiero wtedy zacznij stosować. Oczywiście tylko w przypadkach gdzie ma to sens :). Istotna jest także sama świadomość istnienia takich wytycznych. Prawdą jest, że nie wszyscy programiści są ich świadomi.   Dodatkowe materiały do nauki   Z racji tego, że akronim ten jest powszechnie używany znajdziesz sporo informacji na jego temat w internecie. Poniżej zebrałem materiały źródłowe:      SOLID opisany przez Robert’a C. Martin’a,   Single Responsibility Principle,   Open-Closed Principle,   Liskov Substitution Principle,   Interface Segregation Principle,   Dependency Inversion Principle.   Dodatkowo poniżej mam dla Ciebie książkę autorstwa twórcy akronimu S.O.L.I.D. Moim zdaniem jest to jedna z obowiązkowych pozycji na liście lektur każdego programisty:      The Clean Code2,   Przykłady użyte w treści artykułu.   Podsumowanie   Dzisiejszy artykuł był mocno teoretyczny. Przeczytałeś w nim o akronimie SOLID. Na przykładach zobaczyłeś jak wyglądają poszczególne składowe tego akronimu. Mam nadzieję, że zachęci Cię to do pisania solidnego kodu ;).   Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku w przyszłości proszę dopisz się do newslettera i polub Samouczka na Facebooku. Jeśli będziesz miał jakiekolwiek pytania czy wątpliwości proszę zadaj je w komentarzu, postaram się pomóc. Do następnego razu :).                 Wszystkie te reguły podlegają oczywiście dyskusji. W praktyce często ciężko jest zdefiniować czym ta “jedna” rzecz jest. &#8617;                  To jest link afiliacyjny. Oznacza to tyle, że jeśli kupisz ten produkt z tego odnośnika pomożesz mi w dalszym prowadzeniu bloga. Nie jest to związane z żadnymi dodatkowymi kosztami dla Ciebie. Dziękuję! :) &#8617;           ","categories": ["Wiedza ogólna","Programista rzemieślnik"],
        "tags": [],
        "url": "/solid-czyli-dobre-praktyki-w-programowaniu-obiektowym/",
        "teaser": "/assets/images/2017/11/27_solid_dobre_praktyki_w_programowaniu_obiektowym_artykul.jpg"
      },{
        "title": "Walidacja obiektów w języku Java",
        "excerpt":"     Artykuł ten zakłada, że znasz już podstawy języka Java. Abyś mógł wynieść coś z tego artykułu musisz wiedzieć czym są adnotacje. Przydatne mogą być też pozostałe artykuły z kursu programowania w języku Java, szczególnie te dotyczące:     interfejsów,   typów wyliczeniowych (enumów),   wyjątków.   Przy budowaniu projektu może pomóc też znajomość Gradle.     Specyfikacja Bean Validation   Specyfikacja Bean Validation ewoluuje. Wszystko zaczęło się od specyfikacji w wersji 1.0 wydanej w 2009 roku. Najnowsza wersja tej specyfikacji to 2.0. Jest ona częścią Java Enterprise Edition 8. Dodatkowo implementacji tej specyfikacji można używać w Java SE. Walidacja odbywa się w oparciu o reguły (ang. constraint), które stwierdzają, czy dany element jest poprawny.   Specyfikacja pozwala na przypisywanie reguł do poszczególnych elementów za pomocą adnotacji i XML1. W dalszej części artykułu opisuję wyłącznie walidację opartą o adnotacje. Dla uproszczenia skupię się jedynie na zastosowaniu walidacji w Java SE.   Proszę spójrz na przykładową klasę z adnotacjami do walidacji:   public class PaidAccount {     @NotBlank     @Size(min=3)     private String owner;      @Future     private Date validUntil;      public PaidAccount(@NotNull @Size(min = 3) String owner, @Future Date validUntil) {         this.owner = owner;         this.validUntil = validUntil;     }      public String getOwner() {         return owner;     }      public Date getValidUntil() {         return validUntil;     } }   W ramach specyfikacji udostępniony jest standardowy zestaw reguł. Na przykład “element nie może mieć wartości null” (@NotNull), “element musi mieć minimum X znaków” (@Size(min=X)), “element musi być datą w przyszłości” (@Future) itd. Przykład powyżej używa właśnie tych standardowych adnotacji. Zwróć uwagę, że do jednego elementu można przypisać wiele adnotacji. Na przykład atrybut owner posiada adnotacje @NotBlank i @Size.   Implementacja specyfikacji   Sama specyfikacja to nie wszystko. Dostarcza ona jedynie API. Zestaw interfejsów, adnotacji, typów wyliczeniowych i wyjątków. Potrzebna jest jeszcze konkretna implementacja tej specyfikacji. W artykule tym będę używał Hibernate Validator w wersji 6.0.5. Jest to implementacja referencyjna dla specyfikacji Bean Validation w wersji 2.0. Do projektu mogę ją dodać przez następujący fragment w pliku build.gradle:   dependencies {     compile group: 'org.hibernate.validator', name: 'hibernate-validator', version: '6.0.5.Final'     compile group: 'org.glassfish', name: 'javax.el', version: '3.0.1-b08' }   Druga zależność jest wymagana, ponieważ EL (Expression Language) wykorzystywany jest do formatowania komunikatów błędów.   Wymagania dotyczące walidacji   Atrybuty, których poprawność będzie sprawdzana, muszą być atrybutami w kontekście specyfikacji Java Beans. Innymi słowy dla każdego ze sprawdzanych atrybutów powinna być zaimplementowana metoda dostępowa. Tak zwany “getter”. W poprzednim fragmencie kodu są to metody getOwner i getValidUntil.   Adnotacja dotyczące walidacji można stosować do:      atrybutów,   parametrów metody czy konstruktora, na przykład public PaidAccount(@NotNull owner),   elementów wewnątrz kolekcji, na przykład List&lt;@NotBlank String&gt; users,   wartości zwracanej metody,   klas.   W przypadku wartości zwracanej metody odpowiednią adnotację przypisuje się do metody dostępowej (gettera). Proszę spójrz na przykład poniżej:   @Future public Date getValidUntil() {     return validUntil; }   Adnotacje przypisane do klas używane są wtedy, gdy do stwierdzenia czy dany obiekt jest poprawny potrzebujemy dostępu do wielu atrybutów:   @ZipCodeCityCoherent public class Address {      @NotEmpty     private String zipCode;      @NotEmpty     private String postOfficeCity;      @NotEmpty     private String street;      @NotEmpty     private String number;      public Address(@NotEmpty String zipCode, @NotEmpty String postOfficeCity, @NotEmpty String street, @NotEmpty String number) {         this.zipCode = zipCode;         this.postOfficeCity = postOfficeCity;         this.street = street;         this.number = number;     }      public String getZipCode() {         return zipCode;     }      public String getPostOfficeCity() {         return postOfficeCity;     }      public String getStreet() {         return street;     }      public String getNumber() {         return number;     } }   W przykładzie powyżej użyłem własnej adnotacji @ZipCodeCityCoherent. Adnotacja ta pozwala na sprawdzenie czy kod pocztowy i miasto są spójne. O tym jak tworzyć swoje własne adnotacje do walidacji przeczytasz w dalszej części artykułu.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dlaczego używa się walidacji   Odpowiedź jest prosta ;). Walidacji używa się, aby mieć pewność, że dany obiekt wypełniony jest poprawnymi danymi. Takie podejście pozwala na stosowanie praktyki “Psuj się szybko, psuj się często” (ang. Fail fast, fail often). Można powiedzieć, że programy napisane przy takim założeniu szybko raportują błędy. Dzięki temu łatwiej jest znaleźć potencjalny błąd – informacja o błędzie pochodzi z miejsca jego wystąpienia, a nie z odległego miejsca w systemie.   Nigdy nie ufaj danym pochodzącym od użytkownika Twojego kodu. Niezależnie czy jest to człowiek czy maszyna. Dane wejściowe trzeba walidować. Zawsze. Zdarza się, że brak przecinka kosztuje kilka ładnych milionów dolarów. Walidacja danych nie gwarantuje wyeliminowania wszystkich błędów. Pozwala jednak odsiać znaczną ich część.   Dodatkowo walidacja jest czymś powtarzalnym. Mam tu na myśli to, że sposoby walidacji są podobne. Często chcemy sprawdzić czy pole jest wypełnione, czy jest liczbą z odpowiedniego zakresu, czy jest adresem e-mail, itd. Używanie gotowych mechanizmów walidacji pozwala na uniknięcie tej powtarzalnej części pracy.   Jak działa walidacja   Walidacja to nic innego jak szereg reguł, ograniczeń. Tylko poprawne dane spełniają te ograniczenia. Nakładanie ograniczeń na dane sprowadza się do użycia odpowiednich adnotacji.   Instancja klasy, którą sprawdzamy, przekazywana jest do tak zwanego walidatora. Walidator interpretuje adnotacje i uruchamia poszczególne reguły walidacji. Walidacja, bez jasno określonej kolejności polega na:     sprawdzeniu wszystkich “osiągalnych” atrybutów danej instancji,   sprawdzeniu wszystkich metod dostępowych danej instancji (getterów),   sprawdzeniu reguł przypisanych do klasy (adnotacje klasy).   Walidacja uruchamiana jest kaskadowo. Proszę spójrz na przykład poniżej:   public class MembershipBonus {      @Valid     private PaidAccount userAccount;      @NotEmpty     private String bonusName;      public MembershipBonus(@Valid PaidAccount userAccount, @NotEmpty String bonusName) {         this.userAccount = userAccount;         this.bonusName = bonusName;     }      public PaidAccount getUserAccount() {         return userAccount;     }      public String getBonusName() {         return bonusName;     } }   W przykładzie tym użyta jest adnotacja @Valid. Zwraca ona uwagę na to, że instancja klasy PaidAccount także musi być sprawdzona pod kątem poprawności. To czy PaidAccount jest poprawne czy nie określone jest przez adnotacje wewnątrz tej klasy.   Sprawdzenie reguł odbywa się poprzez uruchomienie metody validate na instancji klasy implementującej interfejs Validator. Biblioteka, która implementuje specyfikację Bean Validation dostarcza odpowiednią klasę.   Kiedy używamy automatycznej walidacji   Do tej pory z użyciem specyfikacji Bean Validation spotkałem się głównie w aplikacjach webowych, bądź takich które używają bazy danych. Specyfikacja nie ogranicza użycia tego mechanizmu tylko do tych zastosowań.   Aplikacje webowe   Wszystkie dane pochodzące od użytkownika muszą zostać sprawdzone. Użytkownicy Twojej aplikacji mogą wpisać cuda w formularzu, nie można tym danym do końca ufać. Zatem wszystkie dane przychodzące do aplikacji webowej w formie zapytań HTTP są bardzo często walidowane przy użyciu Bean Validation.   Obiekty w bazie danych   Mimo tego, że baza danych bardzo często pozwala na podstawową walidację przechowywanych danych, nie jest ona wystarczająca. Dodatkowo, poza walidacją przeprowadzaną przez samą bazę danych, używa się Bean Validation. Jest to istotne ponieważ część reguł nie da się wymusić używając wyłącznie mechanizmów bazodanowych. Poza tym szybciej można sprawdzić poprawność danych w kodzie. Wynika to głównie z faktu, że wysłanie zapytania do bazy danych raczej nie jest szybsze niż walidacja przeprowadzona w kodzie.   Najczęściej używane reguły   Jak już wspomniałem specyfikacja zawiera adnotacje określające najczęściej używane reguły walidacji. Część z nich zebrałem dla Ciebie poniżej:      @NotNull – dany element nie może mieć wartości null,   @NotBlank – dany element nie może mieć wartości null i musi zawierać co najmniej jeden znak (nie może to być spacja, tabulator etc.),   @NotEmpty – dany element nie może mieć wartości null i musi zawierać co najmniej jeden znak,   @Min(X) – dany element musi być liczbą i jego wartość musi być większa bądź równa X,   @Max(X) – dany element musi być liczbą i jego wartość musi być mniejsza bądź równa X,   @Email – dane element musi zawierać poprawny adres e-mail,   @Pattern(regexp=X) – dany element musi pasować do wyrażenia regularnego X.   @Size(min=X, max=Y) – dany element musi mieć rozmiar określony przez elementy adnotacji min i max. Obie wartości są opcjonalne.   Oczywiście lista reguł zapewniona przez specyfikację nie jest kompletna. Specyfikacja pozwala na rozszerzanie listy dostępnych reguł.   Java SE i walidacja   Skoro już wiesz czym jest walidacja, to najwyższy czas sprawdzić ją w praktyce. Przykład poniżej pokazuje sposób uruchomienia walidacji w aplikacji Java SE   public class ValidationExample {      private final Validator validator;      public ValidationExample() {         ValidatorFactory validationFactory = Validation.buildDefaultValidatorFactory();         validator = validationFactory.getValidator();     }      public static void main(String[] args) {         ValidationExample example = new ValidationExample();         example.showSimpleValidation();     }      private void showSimpleValidation() {         PaidAccount account = new PaidAccount(\"mp\", Calendar.getInstance().getTime());         Set&lt;ConstraintViolation&lt;PaidAccount&gt;&gt; validationErrors = validator.validate(account);         for (ConstraintViolation&lt;PaidAccount&gt; validationError : validationErrors) {             System.out.println(validationError.getPropertyPath().toString() + \" \" + validationError.getMessage());         }     } }   Po uruchomieniu tego programu na konsoli pokażą się następujące komunikaty błędów:   validUntil must be a future date owner size must be between 3 and 2147483647   Formatowanie komunikatu błędu   Jak widzisz komunikaty błędów nie są po polsku. Wynika to z tego, że domyślne komunikaty dostarczone przez Hibernate Validator są w języku angielskim. Niestety biblioteka aktualnie nie zawiera polskich komunikatów. Możesz to zmienić.   Komunikaty błędów zaszyte w kodzie   Sposób ten nie jest zalecany! Generalnie niezbyt dobrą praktyką jest umieszczanie tekstu w kodzie źródłowym programu. Doskonale do tego nadają się za to pliki properties, które opisałem poniżej.   Modyfikując nieznacznie klasę z adnotacjami możemy wymusić inne komunikaty błędów:   @NotNull(message=\"nie może być puste\") @Size(min=3, message=\"musi być dłuższe niż {min}\") private String owner;  @Future(message=\"musi być w przyszłości\") private Date validUntil;   Po takiej modyfikacji na konsoli pokażą się następujące komunikaty błędów:   validUntil musi być w przyszłości owner musi być dłuższe niż 3   Komunikaty błędów w plikach properties   Pliki z rozszerzeniem properties to pliki tekstowe. Zawierają one zbiór wierszy w postaci klucz=wartość. Pliki te nadają się do przechowywania komunikatów błędów.   Domyślna implementacja w kodzie ma zaszyty wyłącznie klucz komunikatu błędu. Na przykład:   public @interface Size {     String message() default \"{javax.validation.constraints.Size.message}\";     //... }   Przyjęło się, że klucz ma postać &lt;pakiet&gt;.&lt;nazwa_klasy&gt;.&lt;nazwa_atrybutu&gt;. W powyższym przykładzie jest to javax.validation.constraints.Size.message. Następnie klucz ten wraz z wartością umieszcza się w pliku ValidationMessages.properties. Plik ten jest odczytywany przez implementację Bean Validation. Znalezione tam wartości użyte są do budowania komunikatów błędów.   Plik ValidationMessages.properties umieść w katalogu projektu src/main/resources:   javax.validation.constraints.Size.message=musi być dłuższe niż {min} javax.validation.constraints.NotNull.message=nie może być puste javax.validation.constraints.Future.message=musi być w przyszłości       Niestety pliki properties do wersji 8 języka są “dziwne”. Mam tu na myśli to, że domyślnym kodowaniem z jakim są one czytane jest ISO-8859-1. W związku z tym możesz zobaczyć na konsoli:   validUntil musi byÄ w przyszÅoÅci owner musi byÄ dÅuÅ¼sze niÅ¼ 3   Te magiczne znaczki to nic innego ja próba interpretowania pliku properties zapisanego przy pomocy kodowania UTF-8 przez Javę stosując kodowanie ISO-8859-1. IntelliJ Idea pozwala na ustawienie kodowania plików properties. Możesz to zrobić w menu File -&gt; Settings -&gt; Editor -&gt; File encodings. Istotne jest abyś ustawił ich kodowanie na ISO-8859-1 i zaznaczył opcję “Transparent native-to-ascii conversion”.   Przy takim ustawieniu możesz tworzyć pliki properties w normalny sposób. IntelliJ pod spodem zrobi za Ciebie odpowiednią konwersję znaków. Na przykład powyższy plik properties przerobiony przez IntelliJ wygląda następująco:   javax.validation.constraints.Size.message=musi być dłuższe niż {min} javax.validation.constraints.NotNull.message=nie może być puste javax.validation.constraints.Future.message=musi być w przyszłości   Java 9 rozwiązuje ten problem przez ustawienie domyślnego kodowania na UTF-8 co dużo lepiej odpowiada obecnym standardom.     Szablon formatów błędu   Celem tego artykułu nie jest wyjaśnianie Expression Language, ma on dużo większe możliwości. Ten podpunkt ma Ci tylko pomóc zrozumieć użycie EL w komunikatach błędów.   Zauważyłeś użycie {min} wewnątrz komunikatu błędu? To właśnie język EL. To właśnie ten element, który zmusił mnie do dodania dodatkowej zależności w pliku build.gradle. Składnia {zmienna} pozwala na odwołanie się do elementu adnotacji. W naszym przypadku jest to element min. W wynikowym komunikacie błędu znalazła się wartość 3 – wartość elementu min.   Te same szablony użyte są do odwołania się do wartości komunikatu błędu z plików properties.   Własna adnotacja do walidacji   Specyfikacja Bean Validation zezwala na tworzenie własnych reguł walidacji. Dzięki temu mechanizm ten jest łatwo rozszerzalny. Utworzenie własnej reguły przeważnie sprowadza się do utworzenia adnotacji i implementacji klasy sprawdzającej.   Implementacja adnotacji   Poniższy przykład pokazuje adnotację, którą użyłem w jednym z powyższych fragmentów kodu. Służy ona do sprawdzenia czy atrybut klasy zawierający kod pocztowy pasuje do atrybutu zawierającego miasto:   @Target(TYPE) @Retention(RUNTIME) @Constraint(validatedBy = ZipCodeCityCoherentValidator.class) public @interface ZipCodeCityCoherent {     String message() default \"{pl.samouczekprogramisty.misc.validation.ZipCodeCityCoherent.message}\";      Class&lt;?&gt;[] groups() default {};      Class&lt;? extends Payload&gt;[] payload() default {}; }   Adnotacja ta może być przypisana wyłącznie do klasy @Target(TYPE). @Retention(RUNTIME) określa, że informacja o adnotacji ma być widoczna w trakcie uruchomienia programu. Dodanie do naszej adnotacji @Constraint(validatedBy = ZipCodeCityCoherentValidator.class) sprawia, że jest ona “widoczna” przez Bean Validation. W tym miejscu określiłem też klasę, która będzie wywołana aby przeprowadzić właściwą walidację. W tym przypadku jest to klasa ZipCodeCityCoherentValidator.   Ciało adnotacji zawiera trzy elementy. Są to odpowiednio message, groups i payload. Komunikat błędu jest przechowywany w elemencie message. W tym przypadku jest to odwołanie do zawartości pliku properties:   pl.samouczekprogramisty.misc.validation.ZipCodeCityCoherent.message=miasto nie pasuje do kodu pocztowego   Elementy groups i payload są wymagane. Ich zastosowanie pominę, artykuł i tak jest wystarczająco długi ;).   Skoro mamy już adnotację nadszedł czas na implementację klasy sprawdzającej.   Implementacja klasy sprawdzającej   Każda klasa sprawdzająca powinien implementować interfejs ConstraintValidator. W momencie walidowania danego elementu zostaje wywołana metoda isValid. To implementacja tej metody będzie decydowała o tym czy dany element jest poprawny.   public class ZipCodeCityCoherentValidator implements ConstraintValidator&lt;ZipCodeCityCoherent, Address&gt; { \t@Override \tpublic boolean isValid(Address address, ConstraintValidatorContext context) { \t\treturn \"00-000\".equals(address.getZipCode()) &amp;&amp; \"Warszawa\".equals(address.getPostOfficeCity()); \t} }   W powyższym przykładzie implementacja jest strasznie naiwna, masz pomysł jak obsłużyć więcej kombinacji miast/kodów pocztowych?   Zadanie do wykonania   Napisz program, który pobierze od użytkownika następujące dane:      imię,   datę urodzenia w formacie YYYY-MM-dd hh:mm,   adres e-mail.   Utwórz klasę grupującą te dane. Upewnij się, że są one poprawne używając adnotacji dostępnych w specyfikacji Bean Validation bądź własnych:      imię powinno mieć długość co najmniej 3 liter,   imię powinno zaczynać się od wielkiej litery,   imię powinno składać się wyłącznie z liter,   data urodzenia powinna być w przeszłości,   użytkownik powinien mieć co najmniej 4 lata.   Przygotowałem dla Ciebie przykładowe rozwiązanie, jednak jak zwykle zachęcam Cię do samodzielnego rozwiązania zadania.   Materiały dodatkowe      Specyfikacja Bean Validation 2.0,   Artykuł na temat Fail fast, fail often,   Biblioteka rozszerzająca standardowy zestaw reguł,   Fragment tutoriala dla Java EE 7 opisujący walidację,   Strona projektu Hibernate Validator,   Kod źródłowy przykładów użytych w artykule.   Podsumowanie   Po lekturze artykułu wiesz już czym jest walidacja. Masz świadomość dlaczego jest ona istotna. Potrafisz użyć walidacji w swojej aplikacji używając dostępnych reguł walidacji. Umiesz też zaimplementować swoje własne reguły. Ćwiczenie, które wykonałeś pozwoliło Ci sprawdzić tę wiedzę w praktyce. Gratulacje! ;)   Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku proszę dopisz się do samouczkowego newslettera i polub stronę na Facebooku. Jeśli cokolwiek nie będzie dla Ciebie jasne zadaj pytanie w komentarzu, postaram się pomóc. Do następnego razu!                 Jeśli chcesz przeczytać więcej o XML zapraszam do osobnego artykułu na blogu. &#8617;           ","categories": ["Kurs aplikacji webowych"],
        "tags": [],
        "url": "/walidacja-obiektow-w-jezyku-java/",
        "teaser": "/assets/images/2017/12/04_walidacja_obiektow_w_jezyku_java_artykul.jpg"
      },{
        "title": "Samouczek na rozmowie – znajdź brakujący element",
        "excerpt":"      To jest artykuł z serii “Samouczek na rozmowie”. W ramach tej serii staram się, między innymi, rozwiązywać zadania. Zadania te często zdarzają się na rozmowach kwalifikacyjnych.   W trakcie rozwiązywania takich zadań umiejętność szacowania złożoności obliczeniowej jest niezwykle ważna. Przyda się też umiejętność pisania testów jednostkowych. Dzięki nim bardzo łatwo przetestujesz działanie algorytmu.      Podstawy złożoności obliczeniowej,   Test Driven Development na przykładzie,   Testy jednostkowe z JUnit,   Podstawą jest oczywiście znajomość języka programowania, ja używał będę Javy jednak możesz użyć dowolnego języka programowania. W opisie problemu czasami będę używał “pseudo kodu”. Przykładowe rozwiązania będą w języku Java.      Kurs programowania w języku Java.     Kilka wskazówek dotyczących rozwiązywania zadań   Akurat to zadanie miałem sam na rozmowie kwalifikacyjnej. Rozmowa przeprowadzana na stanowisko starszego programisty. Sam problem nie jest dość trudny. Zauważyłem, że jest to częsta praktyka. Problemy do rozwiązania na rozmowach kwalifikacyjnych przeważnie służą tylko do tego, żeby zweryfikować czy kandydat zna składnię danego języka. Dodatkowo zadania tego typu sprawdzają umiejętność analizowania problemu i szukania rozwiązania.   Na rozmowie rozwiązałem ten problem algorytmem o najlepszej złożoności czasowej, jednak nie był on optymalny pod kątem użycia pamięci. Mimo tego, że moje rozwiązanie nie było idealne dostałem ofertę pracy. Tutaj chcę Ci pokazać, że nawet jeśli nie rozwiążesz problemu w idealny sposób a będziesz sensownie kombinował, uda się.   Zacznij od najprostszego rozwiązania. Zacznij od czegokolwiek i później głośno zastanawiaj się nad minusami Twojego rozwiązania. Prowadzący rozmowę widząc Twoje zaangażowanie często pomogą i nakierują Cię na lepsze rozwiązanie problemu.   Zadanie do wykonania   Napisz funkcję findMissing, która jako argument przyjmuje tablicę N liczb całkowitych z zakresu od 0 do N. W tablicy wszystkie elementy są unikalne. Liczb z zakresu &lt;0, N&gt;, jest N + 1. Tablica ma długość N. W tablicy brakuje jednego elementu z zakresu. Funkcja findMissing powinna zwrócić brakujący element:   tablica = [0, 2, 1, 4] findMissing(tablica) == 3   W przykładzie wejściem jest tablica, która ma 4 elementy. Brakuje w niej liczby 3, i właśnie taką liczbę zwraca funkcja findMissing.   Najprostsze rozwiązanie problemu   Zacznę od najprostszego rozwiązania problemu. Na wejściu mamy tablicę1, w której brakuje jednego elementu z zakresu &lt;0, N&gt;. Żeby znaleźć brakujący element można sprawdzić czy każdy z elementów występuje w tablicy. Pierwsza iteracja sprawdzi czy w tablicy występuje 0, kolejna 1 i tak dalej aż dojdziemy do N. Proszę spójrz na przykładowe rozwiązanie:   private static int naiveFindMissing(int... array) {     int missing = 0;     boolean elementFound;     for (int elementToFind = 0; elementToFind &lt;= array.length; elementToFind++) {         elementFound = false;         for (int elementInArray : array) {             if (elementToFind == elementInArray) {                 elementFound = true;                 break;             }         }         if (!elementFound) {             missing = elementToFind;             break;         }     }     return  missing; }   Złożoność obliczeniowa   Ten algorytm działa i znajduje brakujący element. Aby znaleźć brakujący element algorytm używa zagnieżdżonych pętli. Ilość iteracji w każdej z nich zależna jest od liczby elementów. Złożoność obliczeniowa tego algorytmu to Ο(n^2)   Złożoność pamięciowa   Algorytm ten używa stałej liczby zmiennych, jest ona niezależna od wielkości danych wejściowych. W związku z tym złożoność pamięciowa tego algorytmu jest stała, wynosi ona Ο(1).   Pamięciożerne rozwiązanie   Teraz spróbuję ugryźć problem z innej strony. Z opisu problemu wiem, że brakuje jednej liczby z zakresu &lt;0, N&gt;. Pomysł jest taki, aby stworzyć tablicę wartości logicznych (flag), które będą wskazywały czy dany element znajduje się w tablicy. Iterując po elementach tablicy wejściowej można oznaczać każdą z flag. Następnie iterując po tablicy z flagami można znaleźć tę, która ma wartość false. To ona będzie wskazywała brakujący element:   private static int memoryGreedyFindMissing(int... array) {     boolean[] foundElements = new boolean[array.length + 1];      for (int element : array) {         foundElements[element] = true;     }      for (int index = 0; index &lt; foundElements.length; index++) {         if (!foundElements[index]) {             return index;         }     }     throw new IllegalStateException(\"At least one flag should be equal false!\"); }   Złożoność obliczeniowa   Algorytm wymaga przejścia przez wszystkie elementy tablicy wejściowej. Dodatkowo iterujemy po tablicy flag. Rozmiar tej tablicy jest także zależy od wielkości danych wejściowych. Uzyskujemy zatem lepszą złożoność obliczeniową niż w poprzednim przypadku Ο(2n) = Ο(n).   Złożoność pamięciowa   Aby algorytm działał konieczna jest inicjalizacja tablicy z flagami. Jej rozmiar zależny jest od wielkości danych wejściowych. W związku z tym algorytm ten ma złożoność pamięciową Ο(n). Zatem kosztem pamięci udało mi się poprawić wydajność algorytmu. W większości przypadków taka zmiana jest akceptowalna, jednak problem ten można rozwiązać jeszcze wydajniej.   Optymalne rozwiązanie   Z opisu zadania wiesz, że szukamy brakującej liczby z zakresu &lt;0, N&gt;. Liczby 0, 1, 2, …, N to ciąg arytmetyczny. Istnieje wzór, który pozwala na obliczenie sumy elementów ciągu arytmetycznego:   \\[S_n = \frac{n(2a_1 + (n - 1)r)}{2}\\]  Załóżmy, że tablica wejściowa ma 100. Wiemy zatem, że szukamy liczby z zakresu 0 do 100. Liczb w tym zakresie jest 101, pierwszy element ma wartość 0 a różnica pomiędzy elementami wynosi 1. Podstawiając te wartości pod wzór otrzymujemy sumę elementów:   \\[S_n = \frac{101 * (2 * 0 + (101 - 1) * 1)}{2} = \frac{101 * 100}{2} = 5050\\]  Skoro znamy oczekiwaną sumę możemy zsumować zawartość przekazanej tablicy i odjąć tę wartość od oczekiwanej sumy. Wynik odejmowania to brakujący element:   private static int optimalFindMissing(int... array) {     int expectedSum = (array.length + 1) * array.length / 2;     int actualSum = 0;      for (int element : array) {         actualSum += element;     }      return expectedSum - actualSum; }   Złożoność obliczeniowa   W tym przypadku w rozwiązaniu jest wyłącznie jedna pętla o złożoności Ο(n). Obliczenie sumy elementów ma złożoność Ο(1). Więc finalnie złożoność obliczeniowa tego algorytmu to Ο(n).   Złożoność pamięciowa   Algorytm ten wymaga stałej liczby zmiennych. Liczba ta nie jest zależna od wielkości danych wejściowych. Zatem złożoność pamięciowa tego algorytmu to Ο(1).   Wyślij mi swoje zadanie   Jeśli chcesz abym spróbował omówić zadanie, na które Ty trafiłeś daj znać. Zastrzegam jednak, że nie jestem alfą i omegą. Potrafię sobie wyobrazić problemy, na które nie znajdę najlepszego rozwiązania. Niemniej jednak postaram się rozwiązać to zadanie w najlepszy znany mi sposób. Zadania możesz wysłać na mój adres e-mail marcin [małpka] samouczekprogramisty.pl.     Często firmy zastrzegają sobie to, żeby nie rozpowszechniać zadań, które były na rozmowie kwalifikacyjnej. Jeśli tak było w Twoim przypadku proszę uszanuj wolę danej firmy i nie przesyłaj mi takiego zadania.   Dostając zadanie od Ciebie zakładam, że mogę je opublikować na blogu.     Podsumowanie   Po przeczytaniu artykułu znasz trzy sposoby rozwiązania zadanego problemu. Znasz złożoność pamięciową i obliczeniową każdego z rozwiązań. Jesteś o jedno zadanie lepiej przygotowany do rozmowy kwalifikacyjnej ;).   Przykładowe rozwiązania, przedstawione w artykule znajdziesz na samouczkowym githubie. Kod zawiera także testy jednostkowe, których użyłem do weryfikacji poprawności działania algorytmów.   Jeśli nie chcesz pominąć kolejnych artykułów z tej serii dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Jak zwykle, jeśli masz jakiekolwiek pytania proszę zadaj je w komentarzach. Postaram się pomóc ;). Do następnego razu!                 Właściwie jest to argument, który akceptuje zmienną liczbę argumentów. Taka sygnatura metody pozwala także na przekazanie tablicy. &#8617;           ","categories": ["Samouczek na rozmowie","Strefa zadaniowa"],
        "tags": [],
        "url": "/samouczek-na-rozmowie-znajdz-brakujacy-element/",
        "teaser": "/assets/images/2017/12/10_rozmowa_kwalifikacyjna_brakujacy_element_zadanie_artykul.jpg"
      },{
        "title": "Struktury danych – lista wiązana",
        "excerpt":"Struktury danych   Lista wiązana to struktura danych. Struktury danych opisują sposób przechowywania danych w pamięci komputera. Przykładową strukturą danych jest tablica. Każda struktura danych ma charakterystyczne dla siebie właściwości. Na przykład dodanie elementu na początek tablicy ma złożoność obliczeniową Ο(n). Ta sama operacja dla listy wiązanej ma złożoność Ο(1)1.   Te właściwości sprawiają, że użycie konkretnej struktury może uprościć rozwiązanie niektórych problemów. Możemy powiedzieć, że czasami lepiej jest użyć tablicy a w innym przypadku lista wiązana jest lepszym rozwiązaniem. Wszystko zależy od problemu, który próbujemy rozwiązać. Strukturę danych dopasowuje się do problemu.   Klasyczną pozycją jeśli chodzi o powiązanie algorytmów i struktur danych jest książka autorstwa Niklausa Wirtha Algorytmy + struktury danych = programy.   Struktury danych w językach programowania   Struktura danych jest niezależna od języka programowania. Można ją zaimplementować w różnych językach. Na przykład tablica jest uniwersalną strukturą, która istnieje w każdym znanym mi języku programowania.   Podobnie sytuacja wygląda z listą wiązaną. Przeważnie w standardowej bibliotece danego języka znajdzie się już gotowa implementacja tej struktury danych. W języku Java implementacją dwukierunkowej listy wiązanej jest klasa LinkedList. O tym czym jest dwukierunkowa lista wiązana przeczytasz w jednym z akapitów poniżej.   Skoro zatem mamy gotowe implementacje to po co pisać kolejną? Jedynym powodem jest nauka i zrozumienie zasady działania danej struktury danych. Jeśli dany język dostarcza implementacji danej struktury najlepszym sposobem będzie jej użycie. Nie wymyślaj koła na nowo :).   Struktury danych dostępne w standardowej bibliotece będą na pewno lepiej zaimplementowane niż własna wersja. Dodatkowo będą przetestowane przez dużo większą liczbę programistów.   Jak działa lista wiązana   Lista wiązana to struktura, która składa się z węzłów. Każdy z węzłów zawiera element, który przechowuje. Dodatkowo posiada także odnośniki do innych elementów. W ten sposób powstaje łańcuch powiązanych ze sobą węzłów. To ile odnośników przechowuje węzeł określa czy lista jest jedno, czy dwukierunkowa.   W dalszej części artykułu te odnośniki do sąsiednich elementów będę nazywał wskaźnikami.   Lista jednokierunkowa posiada wyłącznie wskaźnik do jednego elementu. Lista dwukierunkowa posiada dwa wskaźniki, do obu sąsiadujących elementów. Obrazki poniżej prezentują przykładowe listy z trzema elementami. Prostokąty to węzły, strzałki pokazują powiązania pomiędzy węzłami.             Lista jednokierunkowa.                  Lista dwukierunkowa.        Lista wiązana jest strukturą, w której kolejność elementów ma znaczenie. Każdy z elementów ma swój numer, indeks, który zwyczajowo zaczyna się liczyć od 0.   Jeśli lista jest pusta wskaźnik na pierwszy/ostatni węzeł jest pusty (w przypadku Javy ma wartość null). Wskaźniki na następny/poprzedni węzeł w ostatnim/pierwszym węźle w liście są puste.   Lista jednokierunkowa   Jak już wiesz lista to powiązane ze sobą węzły. Przykładowa implementacja takiego węzła może wyglądać następująco:   private static class Node&lt;E&gt; {     private E element;     private Node&lt;E&gt; next;      Node(E element) {         this.element = element;     } }   Klasa ta posiada element, atrybut ten przechowuje wartość z danego węzła. Każdy węzeł zawiera również wskaźnik do kolejnego węzła w liście. Kolejny węzeł przechowywany jest w atrybucie next.   Listę jednokierunkową w tym przypadku można przedstawić jako klasę, która zawiera informację o początku listy. W przykładzie poniżej pierwszy element z listy przechowywany jest w atrybucie first.   public class SingleLinkedList&lt;E&gt; {      private Node&lt;E&gt; first;      private static class Node&lt;E&gt; {         private E element;         private Node&lt;E&gt; next;          Node(E element) {             this.element = element;         }     }  }   Sprawdzanie czy lista jest pusta   Mając taką klasę w prosty sposób możemy sprawdzić czy lista zawiera jakiekolwiek elementy. Wystarczy sprawdzić czy pierwszy element istnieje:   public boolean isEmpty() {     return first == null; }   Złożoność obliczeniowa tej operacji to Ο(1).   Sprawdzanie rozmiaru listy   Kolejną podstawową operacją jest sprawdzanie rozmiaru listy. Poniżej pokazuję naiwną implementację tej operacji:   public int size() {     int size = 0;     Node&lt;E&gt; currentNode = first;     while (currentNode != null) {         size++;         currentNode = currentNode.next;     }     return size; }  Przechodząc po wszystkich elementach listy otrzymuję złożoność Ο(n)2.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Pobieranie elementu z listy   Wspomniałem wyżej, że lista wiązana jest strukturą, w której kolejność elementów jest istotna. Każdy z elementów ma swój indeks, podobnie jak w tablicy. Przydałaby się w takim razie metoda, która pozwoli pobrać element znajdujący się pod danym indeksem:   public E get(int index) {     if (isEmpty() || index &lt; 0) {         throw new IndexOutOfBoundsException(\"Index \" + index);     }      Node&lt;E&gt; currentNode = first;     int currentIndex = index;     while (currentIndex &gt; 0) {         if (currentNode == null) {             throw new IndexOutOfBoundsException(\"Index \" + index);         }         currentNode = currentNode.next;         currentIndex--;     }      return currentNode.element; }   Pierwszy warunek sprawdza czy index ma szanse być poprawny. Następnie przechodząc przez kolejne elementy listy, zaczynając od początku dochodzę do elementu znajdującego się pod żądanym indeksem.   W związku z tym, że pętla while zależna jest od liczby elementów znajdujących się w liście złożoność tej operacji to Ο(n).   Dodawanie elementu do listy   Dodawanie nowego elementu do listy wiązanej zależy od tego gdzie chcemy taki element dodać. Rysunek poniżej pokazuje przykład dodawania elementu pomiędzy istniejącymi węzłami:             Dodawanie węzła do listy jednokierunkowej.        W takim przypadku należy w odpowiedni sposób przepiąć wskaźnik na kolejny element. Więc aby dodać element pod indeksem N potrzebuję dostęp do elementu pod indeksem N - 1. Metoda pomocnicza pozwala w łatwy sposób dostać się do obu węzłów:   private static class NodePair&lt;E&gt; {     private final Node&lt;E&gt; previous;     private final Node&lt;E&gt; current;      private NodePair(Node&lt;E&gt; previous, Node&lt;E&gt; current) {         this.previous = previous;         this.current = current;     } }  private NodePair&lt;E&gt; getNodeWithPrevious(int index) {     if (isEmpty() || index &lt; 0) {         throw new IndexOutOfBoundsException(\"Index \" + index);     }      Node&lt;E&gt; previousNode = null;     Node&lt;E&gt; currentNode = first;     int currentIndex = index;     while (currentIndex &gt; 0) {         if (currentNode == null) {             throw new IndexOutOfBoundsException(\"Index \" + index);         }         previousNode = currentNode;         currentNode = currentNode.next;         currentIndex--;     }      return new NodePair&lt;&gt;(previousNode, currentNode); }   Mając już metodę pomocniczą mogę zaimplementować dodawanie elementów do listy. Proszę spójrz na przykładową implementację poniżej:   public boolean add(int index, E element) {     if (first == null &amp;&amp; index == 0) {         first = new Node&lt;&gt;(element);         return true;     }      NodePair&lt;E&gt; pair = getNodeWithPrevious(index);     Node&lt;E&gt; previousNode = pair.previous;     Node&lt;E&gt; nodeAtIndex = pair.current;      // adding at the beginning of the list     if (previousNode == null) {         first = new Node&lt;&gt;(element);         first.next = nodeAtIndex;         return true;     }      Node&lt;E&gt; newNode = new Node&lt;&gt;(element);     newNode.next = nodeAtIndex;     previousNode.next = newNode;     return true; }   Pierwszy blok if obsługuje dodanie elementu do pustej listy. W tym przypadku po prostu tworzę nową instancję klasy Node i ustawiam ją jako atrybut first. Kolejny blok if obsługuje dodanie elementu na początku listy. W tym przypadku atrybut first musi być zmieniony. Resztę przypadków obsługują ostatnie linijki metody.   W przypadku tej implementacji dodanie elementu na początku listy ma złożoność Ο(1). Dodanie nowego elementu w innym miejscu to operacja o złożoności Ο(n).   Usuwanie elementu z listy   W przypadku usuwania elementu z listy również trzeba manipulować wskaźnikiem na kolejny element. Operację usuwanie pokazałem na rysunku poniżej:             Usuwanie węzła z listy jednokierunkowej.        Także i tutaj pomocna jest metoda getNodeWithPrevious.   public E remove(int index) {     NodePair&lt;E&gt; pair = getNodeWithPrevious(index);     Node&lt;E&gt; previousNode = pair.previous;     Node&lt;E&gt; nodeToRemove = pair.current;     E removedElement = nodeToRemove.element;      // removing first node     if (previousNode == null) {         first = nodeToRemove.next;         return removedElement;     }      previousNode.next = nodeToRemove.next;     return removedElement; }   Blok if obsługuje usunięcie pierwszego elementu z listy. W tym przypadku należy zmienić wartość atrybutu first.   W przypadku tej implementacji usunięcie elementu z początku listy ma złożoność Ο(1). Usunięcie elementu z innego miejsca to operacja o złożoności Ο(n).   Dwukierunkowa lista wiązana   Dwukierunkowa lista wiązana od listy jednokierunkowej różni się tym, że każdy z węzłów zawiera wskaźnik na poprzedni i następny element. Sama lista zawiera też atrybuty wskazujące pierwszy i ostatni węzeł w liście:   public class DoubleLinkedList&lt;E&gt; {      private Node&lt;E&gt; first;     private Node&lt;E&gt; last;      private static class Node&lt;E&gt; {         private E element;         private Node&lt;E&gt; next;         private Node&lt;E&gt; previous;          Node(E element) {             this.element = element;         }     } }   Sprawdzanie czy lista jest pusta   Podobnie jak w przypadku listy jednokierunkowej, sprawdzenie czy lista ma pierwszy węzeł wystarczy:   public boolean isEmpty() {     return first == null; }   Sprawdzanie rozmiaru listy   public int size() {     int size = 0;     Node&lt;E&gt; currentNode = first;     while (currentNode != null) {         size++;         currentNode = currentNode.next;     }     return size; }   Także tutaj naiwna implementacja polega na każdorazowym zliczaniu wszystkich elementów listy.   Pobieranie elementu z listy   Implementacja tej metody polega na przechodzeniu po wszystkich elementach od początku do żądanego indeksu. Także tutaj implementacja ta nie różni się znacznie od listy jednokierunkowej:   public E get(int index) {     return getNode(index).element; }  private Node&lt;E&gt; getNode(int index) {     if (isEmpty() || index &lt; 0) {         throw new IndexOutOfBoundsException(\"Index \" + index);     }     Node&lt;E&gt; currentNode = first;     int currentIndex = index;     while (currentIndex &gt; 0) {         if (currentNode == null) {             throw new IndexOutOfBoundsException(\"Index \" + index);         }         currentNode = currentNode.next;         currentIndex--;     }     return currentNode; }   Dodawanie elementu do listy   W przypadku listy dwukierunkowej węzły zawierają dwa wskaźniki. Operacje modyfikujące taką listę wymagają przepięcia każdego z tych wskaźników. Rysunek poniżej pokazuje przykładowe usunięcie elementu znajdującego się w środku listy:             Dodawanie nowego węzła do listy dwukierunkowej.        Implementacja tej metody musi obsłużyć dodawanie elementu do pustej listy, dodawanie elementu na koniec i początek listy jak i dodawanie element pomiędzy istniejące węzły:   public boolean add(int index, E element) {     if (first == null &amp;&amp; index == 0) {         first = new Node&lt;&gt;(element);         last = first;         return true;     }      Node&lt;E&gt; nodeAtIndex = getNode(index);      // adding at the end of the list     if (nodeAtIndex == null) {         Node&lt;E&gt; previousLast = last;         last = new Node&lt;&gt;(element);         last.previous = previousLast;         previousLast.next = last;         return true;     }      // adding at the beginning of the list     if (nodeAtIndex.previous == null) {         Node&lt;E&gt; previousFirst = first;         first = new Node&lt;&gt;(element);         first.next = previousFirst;         previousFirst.previous = first;         return true;     }      Node&lt;E&gt; newNode = new Node&lt;&gt;(element);     Node&lt;E&gt; previous = nodeAtIndex.previous;     previous.next = newNode;     newNode.previous = previous;      newNode.next = nodeAtIndex;     nodeAtIndex.previous = newNode;     return true; }   Usuwanie elementu z listy   W tym przypadku także należy zmodyfikować wiele wskaźników. Rysunek poniżej pokazuje jak ta operacja wygląda:             Usuwanie węzła z listy dwukierunkowej.        Należy w odpowiedni sposób obsłużyć usuwanie pierwszego i ostatniego elementu. Odpowiednio pierwszy i drugi blok if obsługują te przypadki:   public E remove(int index) {     Node&lt;E&gt; nodeToRemove = getNode(index);     Node&lt;E&gt; previousNode = nodeToRemove.previous;     Node&lt;E&gt; nextNode = nodeToRemove.next;     E removedElement = nodeToRemove.element;      // removing first node     if (previousNode == null) {         if (nextNode == null) {             first = null;             last = null;         }         else {             first = nextNode;             nextNode.previous = null;         }         return removedElement;     }      // removing last node     if (nextNode == null) {         last = previousNode;         previousNode.next = null;         return removedElement;     }      previousNode.next = nextNode;     nextNode.previous = previousNode;      return removedElement; }   Porównanie złożoności obliczeniowych   Poniższa tabela zawiera zestawienie złożoności obliczeniowych podstawowych operacji dla listy wiązanej i tablicy.                  Operacja       Tablica       Lista wiązana                       pobieranie liczby elementów       Ο(1)       Ο(1)                 dodawanie elementu na końcu/początku       Ο(n)       Ο(1)                 dodawanie elementu       Ο(n)       Ο(n)                 usuwanie elementu na końcu/początku       Ο(n)       Ο(1)                 usuwanie elementu       Ο(n)       Ο(n)                 pobieranie elementu z końca/początku       Ο(1)       Ο(1)                 pobieranie elementu       Ο(1)       Ο(n)           Jak widzisz w niektórych przypadkach używając listy wiązanej można uzyskać lepszą złożoność obliczeniową niż w przypadku tablicy.   Najczęściej zadawane pytania   Czym różni się lista wiązana od tablicy   Lista wiązana to struktura, która przetrzymuje elementy rozrzucone w pamięci. Tablica potrzebuje jednolitego obszaru w pamięci komputera. Ponadto tablica ma inne złożoności obliczeniowe niż lista wiązana dla podstawowych operacji pobierania, dodawania czy usuwania elementów.   Kiedy używać listy wiązanej   Na początku mojej przygody z programowaniem mówiono mi, że listy powinno używać się w momencie kiedy nie chcemy zajmować spójnego bloku w pamięci. Nie wydaje mi się, żeby ten argument był nadal bardzo istotny. Dalej jednak ważne są złożoności obliczeniowe zebrane w tabelce wyżej. Jeśli często dodajesz/usuwasz elementy z początku/końca kolekcji i nie potrzebujesz dostępu do innych elementów niż pierwszy/ostatni to lista wiązana jest lepszym wyborem niż tablica.   Czy można odwrócić listę wiązaną   W przypadku listy dwukierunkowej jest to proste. Wystarczy przechodzić po liście od ostatniego elementu do początku. Operacja ta ma złożoność Ο(n). W przypadku listy jednokierunkowej jest to trochę trudniejsze, jednak nadal możliwe do wykonania przy złożoności Ο(n).   Co się dzieje z pominiętymi elementami   W przykładowej implementacji powyżej mogłeś zwrócić uwagę na to, że przepinam wskaźniki na inne elementy. Przez taką manipulację możemy “gubić” instancje klasy Node. Takie instancje nadal zajmują miejsce na stercie. W przypadku Javy z pomocą przychodzi mechanizm “zbierania śmieci” (ang. garbage collection), który wykrywa takie obiekty i usuwa je z pamięci.   Dodatkowe materiały do nauki   Jeśli chcesz spojrzeć na temat z innego punktu widzenia zachęcam Cię do przeczytania materiałów, które zebrałem poniżej:      Artykuł o liście wiązanej na Wikipedii,   Artykuł na temat list na Wikibooks,   Materiały dotyczące list przygotowane przez Jerzego Wałaszka,   Kod źródłowy przykładów użytych w artykule,   Implementacja dwukierunkowej listy wiązanej z OpenJDK.   Zadania do wykonania   Skoro już wiesz jak działa lista wiązana nadszedł czas na Twoją implementację. Przygotowałem dla Ciebie dwa zadania do wykonania:      Zmodyfikuj klasę SingleLinkedList w taki sposób aby dodawanie elementów na koniec listy miało złożoność Ο(1).   Dodaj metodę reversed do klas SingleLinkedList i DoubleLinkedList. Metoda ta powinna zwrócić nową instancję klasy, w której węzły będą w odwróconej kolejności.   Zmodyfikuj klasy SingleLinkedList i DoubleLinkedList w taki sposób aby pobieranie rozmiaru listy miało złożoność Ο(1).   Kod źródłowy klas SingleLinkedList i DoubleLinkedList znajdziesz na samouczkowym githubie.   Na Githubie znajdziesz też testy jednostkowe, pamiętaj o tym żeby sprawdzić czy Twój kod działa poprawnie. Testy powinny Ci w tym pomóc.   Podsumowanie   Po przeczytaniu tego artykułu dokładnie wiesz czym są struktury danych. Poznałeś jednokierunkowe i dwukierunkowe listy wiązane. Zrozumiałeś działanie list na podstawie przykładowej implementacji. Rozwiązując zadania utrwaliłeś swoją wiedzę na temat list. Dobra robota :)!   Jeśli masz jakiekolwiek pytania czy uwagi proszę daj znać w komentarzu, postaram się pomóc. Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Proszę Cię też o podzielenie się linkiem ze znajomymi, może im także przyda się wiedza zgromadzona w tym artykule.                 Oczywiście zależy to od implementacji listy. W przypadku listy wiązanej otrzymanie takiej złożoności nie jest problemem. &#8617;                  Metodę tę można zaimplementować uzyskując złożoność Ο(1), to będzie Twoim zadaniem na koniec artykułu ;). Uzyskanie takiej złożoności wymaga zmian we wszystkich metodach modyfikujących zawartość listy. &#8617;           ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "/struktury-danych-lista-wiazana/",
        "teaser": "/assets/images/2018/01/02_struktury_danych_lista_wiazana_artykul.jpg"
      },{
        "title": "Struktury danych – tablica asocjacyjna",
        "excerpt":"     Artykuł ten opisuje przykładową implementację struktury danych określanej jako tablica asocjacyjna. Tę strukturę nazywa się też słownikiem czy mapą. Sama struktura występuje w wielu językach programowania. Zasada działania tej struktury jest niezależnie od języka programowania.   Przykładową implementację przygotowałem w Javie. Aby wynieść jak najwięcej z tego artykułu powinieneś wiedzieć czym są metody hashCode i equals. Powinieneś też znać kontrakt pomiędzy metodami equals i hashCode.   Do zrozumienia przykładowej implementacji niezbędna będzie też wiedza o typach generycznych.   Może przydać się też wiedza na temat szacowania złożoności obliczeniowej.     Czym jest tablica asocjacyjna   Tablica asocjacyjna to struktura, która pozwala na przechowywanie par. Każda para zawiera klucz i wartość. Dzięki kluczowi jesteś w stanie w prosty sposób znaleźć wartość skojarzoną z danym kluczem. Klucz jest unikalny w ramach całej tablicy asocjacyjnej.   Przykładem tablicy asocjacyjnej może być zwykły słownik wyrazów obcych. Na przykład słownik polsko-angielski. Kluczami w tym przypadku są słowa po polsku, wartościami ich angielskie odpowiedniki.   Istnieje wiele możliwych sposobów na zaimplementowanie tej struktury danych. Jednym z nich jest tablica asocjacyjna oparta o funkcję skrótu. Założeniem tej implementacji jest uzyskanie bardzo dobrych czasów dostępu do danych. Dodawanie nowych elementów do mapy także powinno być szybkie.   Czym jest funkcja skrótu   Funkcja skrótu to funkcja, która z wartości może wyprodukować klucz. Klucz ten jest zawsze ten sam dla danej wartości. Przykładem funkcji skrótu w języku Java jest funkcja hashCode.   Funkcja ta zazwyczaj zwraca liczbę typu int. Jest ona bardzo ważna dla wydajnego działania tej implementacji mapy. Powinna ona zwracać wartości, które są dobrze rozdystrybuowane. Innymi słowy, funkcja skrótu, która zawsze zwraca wartość 1 nie jest najlepszym pomysłem. Zwracane wartości powinny być równomiernie rozrzucone po wszystkich liczbach. W dalszej części artykułu przeczytasz o tym dlaczego jest to ważne.   Wspomniałem już wyżej, że tablicę asocjacyjną nazywa się także słownikiem czy mapą. Od teraz będę posługiwał się określeniem mapa. Dalsza część artykułu opisuje implementację mapy opartą o funkcję skrótu.   Jak działa HashMap   Fragmenty kodu, które prezentuję poniżej pochodzą z uproszczonej implementacji mapy. Nie zmieniają one zasady działania tej implementacji. Te uproszczenia mają pomóc Ci zrozumieć sposób działania tej struktury danych.   Mapa to zestaw par, par kluczy i wartości. Do reprezentacji takiej pary potrzebna jest osobna klasa. Może ona wyglądać następująco:   private static class Entry&lt;K, V&gt; {      private final K key;      private V value;      Entry(K key, V value) {         this.key = key;         this.value = value;     } }   Sama klasa mapy powinna przechowywać te pary. Dobrym sposobem może być użycie tablicy:   public class SimpleHashMap&lt;K, V&gt; {     private Entry&lt;K, V&gt;[] table; }   Tylko jak duża powinna być ta tablica? Ile elementów chcemy przechowywać w mapie? Uniwersalna implementacja nie może tego założyć. Zakłada więc rozsądne wartości domyślne:   public class SimpleHashMap&lt;K, V&gt; {     private static final int INITIAL_CAPACITY = 4;     private Entry&lt;K, V&gt;[] table;      public SimpleHashMap() {         table = new Entry[INITIAL_CAPACITY];     } }             Tablica z dwiema parami        Co jeśli chcemy wrzucić do mapy więcej niż 4 wartości? Implementacja ta zakłada, że tablica ta zostanie rozszerzona. Jak? Opiszę to niżej. Teraz proszę skup się na zmiennej table.   Zmienna table przechowuje instancje klasy Entry&lt;K, V&gt;, czyli pary klucz-wartość. Aby ta struktura pozwalała na szybkie wstawianie/dostęp do elementów musi być prosty sposób na zmapowanie klucza na indeks w tej tablicy. Dochodzimy tu do zastosowania funkcji skrótu.   Zastosowanie funkcji skrótu   Funkcja skrótu pozwala na zmapowanie klucza na indeks w tablicy wspomnianej wyżej. Wartość zwrócona przez metodę hashCode (funkcję skrótu) musi zostać dopasowana do wielkości tablicy. Najprostszym sposobem jest użycie reszty z dzielenia:   private int hash(K key) {     if (key == null) {         return 0;     }     return Math.abs(key.hashCode() % table.length); }   Zakładając, że nasza tablica ma wielkość 4 mapowanie wartości hashCode na indeks tablicy wygląda następująco:                  Wartość hashCode       Indeks w tablicy                       1       1                 3       3                 6       2                 -4       0                 -5       1                 17       1           Funkcja skrótu dzieli cały możliwy zakres liczb na przedziały. Przedziały te nazywa się wiadrami (ang. bucket). Dzięki temu, aby znaleźć interesujący nas element na podstawie klucza, musimy przejrzeć tylko jeden przedział.   Podział na przedziały ma istotny wpływ na wydajność pracy na mapie.   Powtarzające się indeksy   A co jeśli pod danym indeksem występuje już element? Co jeśli dodamy dwa różne klucze, których funkcja hashCode zwróci tę samą wartość? Jeśli klucze są równe (czyli equals potwierdza, że obiekty są sobie równe) wtedy należy nadpisać wartość. Jeśli jednak hashCode jest ten sam a equals mówi, że obiekty są różne mamy problem ;).   Z tego właśnie powodu w tablicy nie trzymamy par. Trzymamy kolekcję par:   public class SimpleHashMap&lt;K, V&gt; {     private static final int INITIAL_CAPACITY = 4;     private List&lt;Entry&lt;K, V&gt;&gt;[] table; }   Dlatego właśnie zmienna table jest tablicą list wiązanych zawierających pary elementów.             Tablica z trzema parami            Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Lepsza wydajność dostępu do danych   Jednak nawet takie zachowanie nie rozwiązuje problemu. Pamiętasz domyślną wielkość tablicy? W przykładzie powyżej było to 4. Oznacza to tyle, że wszystkie możliwe wartości hashCode podzielone są na 4 przedziały. Jeśli w naszej mapie będzie odpowiednio dużo elementów znacząco wydłuży to czas pobierania elementu po kluczu. Poniższy rysunek pokazuje sytuację, w której aż 8 par trafiło do pierwszego przedziału.             Zbyt dużo par w jednym przedziale        Przy takim rozłożeniu par może wystąpić sytuacja, w której będziemy musieli przejrzeć wszystkie aby znaleźć właściwą.   Dlatego właśnie tablica ta jest automatycznie rozszerzana. Powstaje kolejne pytanie. Kiedy należy taką tablicę powiększyć? Tutaj też wprowadza się pewne wartości domyślne. Możemy powiedzieć o czymś co nazywa się współczynnikiem wypełnienia (ang. load factor). Jeśli nasza tablica jest wypełniona w dość dużym stopniu i liczba elementów przechowywanych w mapie przekroczy pewien próg należy rozszerzyć naszą tablicę.   public class SimpleHashMap&lt;K, V&gt; {      private static final float LOAD_FACTOR = 0.75F;     private static final int INITIAL_CAPACITY = 4;      private int size;     private int threshold;      private List&lt;Entry&lt;K, V&gt;&gt;[] table;      public SimpleHashMap() {         table = new List[INITIAL_CAPACITY];         threshold = (int) (INITIAL_CAPACITY * LOAD_FACTOR);     } }   Fragment kodu powyżej zakłada, że współczynnik wypełnienia ma wartość 0.75. Zatem próg, po którym tablica przechowująca pary zostanie rozszerzona wynosi 0.75 * 4 == 3. Innymi słowy, jeśli włożymy do mapy 3 pary, to pierwotna tablica o wielkości 4 zostanie powiększona.   Powiększenie tablicy przechowującej pary   Dobrym sposobem na powiększenie wielkości tablicy jest podwojenie jej rozmiaru. Zauważ, że w przypadku powiększenia wielkości tablicy należy od nowa przyporządkować poszczególne klucze do nowych indeksów w tablicy. Funkcja poniżej podwaja wielkość tablicy table i przepisuje pary w odpowiednie miejsca w nowej tablicy:   private void resize() {     if (table.length == Integer.MAX_VALUE) {         return;     }      List&lt;Entry&lt;K, V&gt;&gt;[] oldTable = table;     table = new List[table.length * 2];     threshold = (int) (table.length * LOAD_FACTOR);      for (List&lt;Entry&lt;K, V&gt;&gt; bucket : oldTable) {         if (bucket == null) {             continue;         }         for (Entry&lt;K, V&gt; entry : bucket) {             int hash = hash(entry.key);             if(table[hash] == null) {                 table[hash] = new LinkedList&lt;&gt;();             }             List&lt;Entry&lt;K, V&gt;&gt; newBucket = table[hash];             newBucket.add(entry);         }     } }   Ilustracja poniżej pokazuje jak po takiej operacji para K: 12, V: \"X\" znalazła się pod zupełnie innym indeksem. Dzieje się tak ponieważ funkcja hash bierze pod uwagę nową wielkość tablicy. W sytuacji gdy tablica miała rozmiar 4 wówczas 12 % 4 == 0. Po rozszerzeniu ta sama wartość klucza ląduje w innym miejscu w tabeli: 12 % 8 == 4.             Powiększenie tablicy        Standardowe operacje   Standardowymi operacjami dostępnymi w mapie są:     dodanie pary klucz, wartość,   pobranie wartości na podstawie klucze,   usunięcie pary klucz, wartość,   sprawdzenie czy dany klucz istnieje,   pobranie rozmiaru mapy.   Po wprowadzeniu powyżej mogę pokazać Ci przykładową implementację tych operacji.   Dodanie pary do mapy   Dodanie pary do mapy może skutkować utworzeniem nowej pary lub nadpisaniem istniejącej już wartości. Proszę spójrz na przykład poniżej:   public V put(K key, V value) {     int hash = hash(key);     if (table[hash] == null) {         table[hash] = new LinkedList&lt;&gt;();     }     V oldValue = null;     boolean keyExist = false;     List&lt;Entry&lt;K, V&gt;&gt; bucket = table[hash];      for (Entry&lt;K, V&gt; entry : bucket) {         if (keysEqual(key, entry.key)) {             oldValue = entry.value;             entry.value = value;             keyExist = true;             break;         }     }      if (!keyExist) {         bucket.add(new Entry&lt;&gt;(key, value));         size++;     }      if (size == threshold) {         resize();     }      return oldValue; }   Funkcja ta pobiera wiadro do którego dana para powinna zostać dodana. Następnie iteruje po wszystkich elementach w tym wiadrze, aby sprawdzić czy dany klucz już istnieje. Jeśli klucz istnieje wartość zostaje nadpisana. W przeciwnym wypadku na koniec przedziału zostaje dodana nowa para klucz/wartość.   Teraz widzisz dlaczego porządna funkcja skrótu jest istotna. Jeśli do jednego przedziału trafia dużo elementów to złożoność obliczeniowa takiej operacji wynosi Ο(n). Jeśli natomiast w danym przedziale nie ma innych par klucz wartość wówczas złożoność tej operacji wynosi Ο(1).   Pobieranie wartości z mapy   Pobieranie elementów z mapy sprowadza się do sprawdzenia czy klucz występuje w tablicy. Funkcja skrótu służy do wskazania przedziału, w którym należy szukać instancji klucza. Przykładowa implementacja niżej pozwala na pobranie wartości z mapy:   public V get(K key) {     int hash = hash(key);     List&lt;Entry&lt;K, V&gt;&gt; bucket = table[hash];     if (bucket != null) {         for (Entry&lt;K, V&gt; entry : bucket) {             if (keysEqual(key, entry.key)) {                 return entry.value;             }         }     }     return null; }   Złożoność obliczeniowa wygląda podobnie jak w przypadku dodawania pary do mapy. Jeśli pary są źle rozdystrybuowane, jeśli wszystkie są w jednym przedziale otrzymujemy złożoność Ο(n). Jeśli natomiast w danym przedziale nie ma innych par klucz wartość wówczas złożoność tej operacji wynosi Ο(1).   Usuwanie wartości z mapy   Usuwanie wartości wygląda podobnie do pobierania. W tym przypadku dodatkowo zmniejszana jest wartość atrybutu size przechowującego liczbę par w mapie.   public V remove(K key) {     List&lt;Entry&lt;K, V&gt;&gt; bucket = table[hash(key)];     if (bucket == null) {         return null;     }      Iterator&lt;Entry&lt;K, V&gt;&gt; bucketIterator = bucket.iterator();     V oldValue = null;     while (bucketIterator.hasNext()) {         Entry&lt;K, V&gt; entry = bucketIterator.next();         if (keysEqual(key, entry.key)) {             oldValue = entry.value;             bucketIterator.remove();             size--;             break;         }     }      if (bucket.isEmpty()) {         table[hash(key)] = null;     }      return oldValue; }  Zwróć uwagę na to, że w przypadku usuwania elementów nie zmniejszam wielkości tablicy z parami – table zostaje bez zmian.   Złożoność obliczeniowa nie różni się od operacji dodawania/pobierania elementów. W zależności od funkcji skrótu i rozłożenia elementów wynosi ona Ο(n) lub Ο(1).   Sprawdzanie rozmiaru mapy   Wszystkie metody modyfikujące zawartość mapy manipulują także atrybutem size. Atrybut ten przechowuje aktualną liczbę elementów.   public boolean isEmpty() {     return size == 0; }  public int size() {     return size; }  Kontrakt hashCode i equals   W artykule opisującym porównywanie obiektów opisałem dokładnie kontrakt pomiędzy tymi metodami. Tutaj na przykładzie wyjaśnię Ci dlaczego jest on tak istotny.   Dla przypomnienia, kontrakt ten sprowadza się do trzech reguł:      Jeśli X.equals(Y) == true wówczas wymagane jest aby X.hashCode() == Y.hashCode(),   Kilkukrotne wywołanie metody hashCode na tym samym obiekcie, który nie był modyfikowany pomiędzy wywołaniami musi zwrócić tę samą wartość,   Jeśli X.hashCode() == Y.hashCode() to nie jest wymagane aby X.equals(Y) == true.   Wyobraź sobie sytuację, w której mamy dwa obiekty. X i Y. Załóżmy, że obiekty te są sobie równe, czyli X.equals(Y) == true. W tej sytuacji metoda hashCode powinna zwrócić tę samą wartość dla obu obiektów. Implementacja jest jednak błędna: X.hashCode() == 4 i Y.hashCode() == 5.   Jeśli użyłbyś obiektów X i Y jako kluczy w mapie wówczas trafiłyby one do różnych przedziałów. Prowadziłoby to złamania założeń mapy. Pamiętaj, że w mapie wszystkie klucze powinny być unikalne. Błędna implementacja hashCode doprowadziłaby do złamania tej reguły.   Jak działa HashMap   Oczywiście HashMap z biblioteki standardowej jest dużo lepszą implementacją niż ta przedstawiona w artykule ;). Poza tym, że jest lepiej przetestowana i posiada dużo więcej przydatnych metod to zawiera także sporo usprawnień, które polepszają jej wydajność.   Dedykowana implementacja kolekcji   Wewnątrz HashMap używa dedykowanej implementacji kolekcji. Nie jest to zwykła lista LinkedList jak w mojej implementacji. Ta kolekcja zmienia swoje właściwości w zależności od liczby elementów znajdujących się w danym przedziale. Standardowo jest to lista wiązana. Jeśli jednak w danym przedziale znajduje się więcej niż 8 elementów wówczas zmienia się w strukturę zwaną drzewem.   Struktura ta pozwala na lepsze wyszukiwanie elementów. Dzięki temu pesymistyczna złożoność obliczeniowa spada z Ο(n) do Ο(log(n)) dla operacji takich jak pobieranie, dodawanie czy usuwanie elementów1.             HashMap z drzewem jako kolekcją do przechowywania par        Porównanie złożoności obliczeniowych   Poniższa tabela zawiera zestawienie złożoności obliczeniowych podstawowych operacji dla mapy:                  Operacja       Mapa (dobra funkcja skrótu)       Mapa (zła funkcja skrótu)                       dodawanie pary klucz/wartość       Ο(1)       Ο(1)                 usuwanie wartości z klucza       Ο(1)       Ο(n) lub Ο(log(n))                 pobieranie wartości dla klucza       Ο(1)       Ο(n) lub Ο(log(n))           Oczywiście należy brać poprawkę na złożoność obliczeniową dodawania elementów do mapy. Należy pamiętać o tym, że niektóre operacje dodawania kończą się powiększeniem tablicy przechowującej pary. Wówczas złożoność obliczeniowa tej operacji spada do Ο(n).   Najczęściej zadawane pytania   Czy mogę modyfikować klucze   Krótka, zwięzła odpowiedź: nie. Klucze powinny być instancjami klas, które są niemutowalne. Załóżmy, że modyfikacja klucza zmieniłaby wartość zwracaną przez metodę hashCode. Zastanów się, co by się stało gdybyś zmodyfikował instancję klasy, która już jest użyta jako klucz?   Czy pary w mapie są posortowane   Implementacja przedstawiona w tym artykule, czy HashMap nie przechowują elementów w żadnym porządku. Istnieją jednak implementacje, które pozwalają na przykład na przechowywanie elementów w porządku alfabetycznym kluczy (TreeMap) czy według kolejności ich dodawania (LinkedHashMap).   Kiedy używać mapy   Jeśli w programie potrzebujesz przechować strukturę podobną do słownika to mapa jest właśnie tym typem, którego chcesz użyć. Mapy pozwalają na uniknięcie rozbudowanych bloków switch. Użycie ich w taki sposób moim zdaniem poprawia czytelność kodu.   Czy mapa może mieć klucz/wartość null   To zależy od implementacji. Interfejs Map daje taką możliwość. HashMap czy moja implementacja pozwalają przechowywać zarówno klucze i wartości null. Oczywiście tylko jeden klucz może mieć wartość null.   Dodatkowe materiały do nauki   Jeśli chcesz spojrzeć na temat z innego punktu widzenia zachęcam Cię do przeczytania materiałów, które zebrałem poniżej. Szczególnie polecam przejrzenie kodu źródłowego implementacji dostarczonej w SDK:      Artykuł o tablicy asocjacyjnej na Wikipedii,   Kod źródłowy przykładów użytych w artykule,   Implementacja HashMap z OpenJDK.   Zadania do wykonania   Dodaj do Klasy SimpleHashMap kilka metod występujących w interfejsie Map:      Dodaj metodę containsKey. Metoda powinna zwrócić true jeśli dany klucz istnieje w mapie.   Dodaj metodę containsValue. Metoda powinna zwrócić true jeśli dany wartość istnieje w mapie.   Jaka jest złożoność obliczeniowa Twojej implementacji metod containsKey i containsValue?   Kod źródłowy klasy SimpleHashMap. Pamiętaj o dodaniu testów jednostkowych, potwierdzających, że Twoja implementacja działa poprawnie.   Podsumowanie   Poznałeś właśnie zasadę działania mapy. Z praktycznej strony poznałeś kontrakt pomiędzy metodami equals i hashCode. Zapoznałeś się z przykładową implementacją mapy. Po rozwiązaniu zadań utrwaliłeś wiedzę z tego zakresu. Powiem Ci w tajemnicy, że o tym jak działa HashMap często pyta się na rozmowach rekrutacyjnych ;). Jesteś zatem o jedno pytanie bliżej otrzymania pracy ;).   Jeśli masz jakiekolwiek pytania czy uwagi proszę daj znać w komentarzu, postaram się pomóc. Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Proszę Cię też o podzielenie się linkiem ze znajomymi, może im także przyda się wiedza zgromadzona w tym artykule.                 Delikatnie pomijam tu pesymistyczną złożoność obliczeniową dla drzewa. &#8617;           ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "/struktury-danych-tablica-asocjacyjna/",
        "teaser": "/assets/images/2018/01/08_struktury_danych_tablica_asocjacyjna_artykul.jpg"
      },{
        "title": "REST web service z Java EE część 2",
        "excerpt":"     To jest jeden z artykułów w ramach darmowego kursu programowania aplikacji webowych w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   W kursie tym zakładam, że znasz język Java. Możesz go poznać w osobnym kursie programowania w języku Java. Do budowania wszystkich projetków używam Gradle, przeczytasz o nim więcej w osobnym artykule.     REST Webservice w Java EE 8   Tematykę REST omówiłem dokładnie w poprzednim artykule. W tym pokażę przykładową implementację webservice’u używającego wyłącznie technologii opisanych w ramach specyfikacji Java EE 8.   Przykładowa aplikacja będzie używała implementacji następujących specyfikacji:      JAX-RS: Java API for RESTful Web Services 2.1,   JSON-B: JavaTM API for JSON Binding 1.0   Java API for JSON Processing 1.1   Context and Dependency Injection for Java 2.0   Java TM Servlet Specification 3.1   W artykule tym rozszerzę przykładowy webservice do zarządzania rezerwacjami. Będzie on posiadał pięć metod odpowiedzialnych odpowiednio za:      pobieranie listy rezerwacji,   pobieranie konkretnej rezerwacji,   tworzenie nowej rezerwacji,   edycja rezerwacji,   usunięcie rezerwacji.   Serwer aplikacji dla JavaEE 8   W poprzednim artykule posłużyłem się kontenerem aplikacji TomEE. Także i tym razem polecam użycie tego kontenera aplikacji. Jeśli chcesz wiedzieć więcej o jego instalacji zapraszam Cię do poprzedniego artykułu.   Wstrzykiwanie zależności   Wstrzykiwanie zależności (ang. dependency injection) pozwala na oddelegowanie zarządzanie zależnościami do kontenera. Dzięki takiemu podejściu programista nie musi samemu tworzyć instancji obiektów, robi to za niego kontener aplikacji. Kontener aplikacji zarządza cyklem życia takich instancji. To kontener wywołuje konstruktor i kontener utrzymuje referencje do tych obiektów. Także kontener ustawia atrybuty jeśli odpowiadają one instancjom, którymi zarządza.   Takie podejście do zarządzania obiektami znacząco upraszcza aplikacje. Pozwala też tworzyć kod, który można w łatwiejszy sposób przetestować przy pomocy testów jednostkowych.   Wstrzykiwanie zależności to funkcjonalność, dzięki której Spring stał się tak popularny. W początkowych fazach istnienia biblioteki Spring jej możliwości sprowadzały się do przyjaznego zarządzania zależnościami.   Proszę spójrz na przykład:   public class ReservationWebservice {     @Inject     private ReservationDAO dao; }  @ApplicationScoped public class ReservationDAO { }   Fragment kodu powyżej używa mechanizmu wstrzykiwania zależności. Klasa ReservationWebservice potrzebuje instancji klasy ReservationDAO1. Atrybut dao może zostać wstrzyknięty dzięki mechanizmowi DI (ang. Dependency Injection). Adnotacja @Inject informuje kontener o tym, że ten atrybut powinien zostać wstrzyknięty.   Klasa ReservationDAO poprzedzona jest adnotacją @ApplicationScoped. Adnotacja ta informuje kontener o tym, że instancja tej klasy powinna być możliwa do wstrzyknięcia. Instancja będzie dostępna w kontekście aplikacji. Oznacza to tyle, że kontener utworzy wyłącznie jedną instancję tej klasy w trakcie działania aplikacji2.   Model – rezerwacja   Rezerwacje, którymi zarządza webservice są reprezentowane przez osobną klasę Reservation:   public class Reservation {      @NotEmpty     private String name;      @NotNull     @Positive     private Integer tableNumber;      @FutureOrPresent     @NotNull     private LocalDateTime start;      @Future     @NotNull     private LocalDateTime end;      // getters/setters }   Klasa ta zawiera atrybuty opisujące rezerwację takie jak nazwisko rezerwującego, numer stolika czy początek i koniec rezerwacji. Rezerwacja jest prawidłowa wyłącznie jeśli atrybuty uzupełnione są poprawnymi danymi. Poprawność instancji klasy Reservation zapewniona jest przez mechanizm walidacji.   Walidacja   Walidacja obiektów dostarczona jest przez implementację specyfikacji Bean Validation. Każdy kontener aplikacji, który jest kompatybilny z Java EE 8 (jak TomEE wspomniany wyżej), musi dostarczać implementację tej specyfikacji.   Samą walidację obiektów omówiłem bardziej szczegółowo w osobnym artykule. Tutaj widzisz jej użycie w kontekście aplikacji webowej.   Instancja walidatora tworzona jest przez kontener automatycznie. Kontener także wywołuje mechanizm walidacji. Mechanizm ten wywoływany jest za każdym razem w metodach obsługujących podstawowe operacje. Przykład poniżej pokazuje użycie adnotacji @Valid w metodzie odpowiedzialnej za tworzenie nowej instancji rezerwacji.   @POST public Response createReservation(@Valid Reservation reservation) {     //... }   Kontener na podstawie zapytania wysłanego przez użytkownika tworzy instancję klasy Reservation, następnie sprawdza czy instancja ta jest poprawna. Jeśli dane przesłane przez użytkownika są poprawne wówczas wywołuje ciało metody. Jeśli dane nie pozwolą na utworzenie poprawnej instancji wówczas zostanie rzucony wyjątekValidationException.   W akapicie opisującym instancje oznaczone adnotacją @Provider opiszę ten mechanizm dokładniej.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Dostęp do danych   W normalnej wersji aplikacji dane zapisywane są w dedykowanej bazie danych3. Na potrzeby tej aplikacji symuluję bazę danych przy pomocy mapy przechowywanej w pamięci. Oczywistym minusem jest to, że dane nie są zachowywane po wyłączeniu aplikacji. Na potrzeby tego artykułu taki mechanizm jest wystarczający:   @ApplicationScoped public class ReservationDAO {     private final Map&lt;Integer, Reservation&gt; reservations = Collections.synchronizedMap(new TreeMap&lt;&gt;());;      private final AtomicInteger lastId = new AtomicInteger(0);      public Collection&lt;Reservation&gt; getAll() {         return reservations.values();     }      public Reservation getById(Integer id) {         return reservations.get(id);     }      public Reservation updateReservation(Integer id, Reservation reservation) {         return reservations.put(id, reservation);     }      public Reservation deleteReservation(Integer id) {         return reservations.remove(id);     }      public int createReservation(Reservation reservation) {         int id = lastId.getAndIncrement();         reservations.put(id, reservation);         return id;     } }   Klasa ReservationDAO pozwala na łatwy dostęp do instancji klasy Reservation przechowywanych w pamięci. Pozwala na utworzenie, pobranie, usunięcie i edycję rezerwacji.   Jak wspomniałem wyżej w akapicie opisującym wstrzykiwanie zależności, instancja klasy ReservationDAO jest zarządzana przez kontener aplikacji. W ramach całej aplikacji zostanie utworzona wyłącznie jedna instancja tej klasy. Ta instancja będzie wykorzystywana przez klasę obsługującą żądania wysyłane przez użytkownika.   Aplikacja   @ApplicationPath(\"/\") public class RegistrationApplication extends Application { }   Adnotacja @ApplicationPath informuje kontener aplikacji o początkowym członie adresu URL pod jakim działa dana aplikacja. W przykładzie wyżej informuję kontener o tym, że adresy URL dla wszystkich webservice’ów w tej aplikacji poprzedzone są /.   Adnotacja ta może zostać dodana wyłącznie do instancji klasy Application. Klasa ta dostarcza dodatkowych metadanych o aplikacji. W moim przypadku jedyną wymaganą informacją dodatkową jest ta dostarczona przez adnotację.   Podobnie jak w poprzednim artykule zakładam, że aplikacja w kontenerze zostanie zainstalowana jako rest.war.   Webservice   Teraz znasz komponenty, które są wykorzystywane przez webservice. Nadszedł czas na klasę obsługują żądania użytkownika:   @Path(\"/reservation\") @Produces(MediaType.APPLICATION_JSON) @Consumes(MediaType.APPLICATION_JSON) public class ReservationWebservice {      @Inject     private ReservationDAO dao;  }   Adnotację @Path znasz z poprzedniej części artykułu. Określa ona ścieżkę, która obsługiwana jest przez daną klasę.   Nowe są dla Ciebie adnotacje @Consumes i @Produces. Odpowiadają one odpowiednio za określenie typu danych konsumowanych i produkowanych przez webservice. W tym przypadku są to dane w formacie JSON.   Jeśli użytkownik wyśle zapytanie zawierające dane w innym formacie wówczas kontener automatycznie odpowie zwracając kod 415. Kod ten informuje klienty o tym, że format danych nie jest wspierany.   Wewnątrz klasy widzisz atrybut, który zostanie wstrzyknięty przez kontener aplikacji. Jest to instancja klasy ReservationDAO pozwalająca na dostęp do aktualnie dostępnych rezerwacji.   Zgodnie ze specyfikacją JAX-RS dla każdego żądania przychodzącego od użytkownika zostanie utworzona nowa instancja klasy ReservationWebservice. Po raz kolejny to kontener aplikacji zajmuje się tworzeniem tych instancji.   Pobranie listy rezerwacji   Kod odpowiedzialny za pobranie wszystkich rezerwacji nie jest zbyt skomplikowany:   @GET public Response listReservations() {     return Response.ok(dao.getAll()).build(); }   Metoda listReservations poprzedzona jest adnotacją @GET. Nie zawiera dodatkowej adnotacji @Path, więc wszystkie żądania wysłane pod adres GET /rest/reservation zostaną obsłużone przez tę metodę. Do sprawdzenia jej działania możesz użyć programu curl   curl -H \"Content-Type: application/json\" http://localhost:8080/rest/reservation   -H \"Content-Type: application/json\" dodaje nagłówek do żądania. Określa on format zawartości zapytania. To właśnie ten nagłówek sprawdzany jest przez adnotację @Consumes.   Wewnątrz metody buduję odpowiedź. Ciałem tej odpowiedzi jest lista rezerwacji zwrócona przez dao. Dzięki adnotacji @Produces JAX-RS wymusza format odpowiedzi. W moim przypadku jest to JSON.   Kontener automatycznie przekonwertuje instancję klasy Reservation do formatu JSON. Dzieje się to dzięki implementacji specyfikacji JSON-B i JSON-P.   Pobieranie pojedynczej rezerwacji   Pobieranie pojedynczej rezerwacji również bazuje na atrybucie dao:   @GET @Path(\"{id}\") public Response getReservation(@PathParam(\"id\") @Min(0) Integer id) {     Reservation reservation = dao.getById(id);     if (reservation != null) {         return Response.ok(reservation).build();     }     return Response.status(Response.Status.NOT_FOUND).build(); }   Dodatkowa adnotacja @Path rozszerza tę umieszczoną nad klasą ReservationWebservice. W wyniku tego metoda getReservation obsługuje wszystkie żądania wysłane przez klienty na adres GET /reservation/{id}. id jest identyfikatorem rezerwacji pobieranym z adresu URL dzięki adnotacji @PathParam.   Zwróć także uwagę na użycie adnotacji @Min. Adnotacja ta uruchomi mechanizm walidacji dla parametru id. Mechanizm ten sprawdzi czy liczba przekazana w adresie ma wartość większą, bądź równą 0. Jeśli wartość parametru jest niepoprawna zostanie rzucony wyjątek.   Wewnątrz ciała metody odwołuję się do atrybutu dao pobierając rezerwację na podstawie identyfikatora pobranego od użytkownika. dao zwróci wartość null jeśli rezerwacja o danym identyfikatorze nie zostanie odnaleziona. W takim przypadku klient uzyska odpowiedź z kodem 404 informującą o braku szukanego elementu.   Jeśli dao znajdzie rezerwację o zadanym identyfikatorze, wówczas zostanie ona przekazana w odpowiedzi. Także tutaj zostanie ona przekształcona do formatu JSON.   Także w tym przypadku curl może pomóc w wysłaniu zapytania:   curl -H \"Content-Type: application/json\" http://localhost:8080/rest/reservation/0    Usuwanie rezerwacji   Usuwanie rezerwacji niewiele różni się od pobierania pojedynczej wartości:   @DELETE @Path(\"{id}\") public Response deleteReservation(@PathParam(\"id\") @Min(0) Integer id) {     Reservation reservation = dao.deleteReservation(id);     if (reservation != null) {         return Response.ok(reservation).build();     }     return Response.status(Response.Status.NOT_FOUND).build(); }   W tym przypadku kombinacja adnotacji @DELETE i @Path wskazuje, że metoda ta zostanie wywołana w przypadku wysłania żądania na adres DELETE /reservation/{id}. Podobnie jak w przypadku pobierania rezerwacji mechanizm walidacja sprawdza poprawność przekazanego parametru id.   W przypadku tej metody dao użyte jest do usunięcia rezerwacji o podanym identyfikatorze.   Przykładowe wywołanie curl usuwające rezerwację o identyfikatorze 0:   curl -H \"Content-Type: application/json\" http://localhost:8080/rest/reservation/0 -X DELETE   Utworzenie rezerwacji   Podczas tworzenia rezerwacji webservice wymusza poprawność danych przekazanych przez użytkownika. To adnotacja @Valid wymusza sprawdzenie poprawności danych:   @POST public Response createReservation(@Valid Reservation reservation) {     int newId = dao.createReservation(reservation);     URI location;     try {         location = new URI(\"reservation/\" + newId);     } catch (URISyntaxException e) {         throw new RuntimeException(e);     }     return Response.created(location).build(); }   Jeśli wszystkie wymagania określone w klasie Reservation zostaną spełnione zostanie wywołana metoda createReservation. W przeciwnym wypadku zostanie rzucony wyjątek ValidationException.   W ciele metody createReservation wywołuję dao.createReservation. To wywołanie zapisuje nową rezerwację w bazie danych. W wyniku wywołania tej metody zwrócony jest nowy identyfikator dla tej rezerwacji. Pomaga on w utworzeniu adresu URL, który zostaje zwrócony w odpowiedzi.   Także i tutaj curl może zostać użyty do wysłania zapytania. Tym razem w ciele zapytania muszę przesłać dane w formacie JSON, które reprezentują nową rezerwację. Przykładowe zapytanie może wyglądać następująco:   curl -H \"Content-Type: application/json\" http://localhost:8080/rest/reservation -X POST -d '{\"start\": \"2018-01-22T20:00\", \"tableNumber\": 1, \"name\": \"Marcin\", \"end\": \"2018-01-22T21:20\"}'   Parametr -d służy do przekazania zawartości zapytania. W tym przypadku jest to JSON, który reprezentuje dane potrzebne do utworzenia instancji klasy Reservation.   {     \"name\": \"Marcin\",     \"tableNumber\": 1,     \"start\": \"2018-01-22T20:00\",     \"end\": \"2018-01-22T21:20\" }   W przykładzie powyżej instancja reprezentowana jest przez mapę. Kluczami są nazwy atrybutów, na przykład name czy start. Atrybuty klasy zostaną uzupełnione wartościami przekazanymi w mapie. Oczywiście format wartości musi być odpowiedni. Automatyczna transformacja pomiędzy formatem JSON a klasą Java możliwa jest dzięki specyfikacjom JSON-B i JSON-P.   Modyfikacja rezerwacji   Modyfikacja rezerwacji nie zawiera nowych mechanizmów. Jest dość podobna do tworzenia nowej instancji:   @PUT @Path(\"{id}\") public Response updateReservation(@PathParam(\"id\") @Min(0) Integer id, @Valid Reservation reservation) {     boolean hasReservation = dao.getById(id) != null;     if (hasReservation) {         dao.updateReservation(id, reservation);         return Response.noContent().build();     }     return Response.status(Response.Status.NOT_FOUND).build(); }   Własna klasa @Provider   W poprzedniej części artykułu użyłem tej adnotacji to utworzenia filtra, który dodawał nagłówki. Tym razem posłuży ona do pomocy przy walidacji.   Specyfikacja JAX-RS pozwala na utworzenie klasy, która będzie odpowiedzialna za obsługę wyjątków, które wystąpiły w trakcie przetwarzania żądania klienta. To zastosowanie idealnie nadaje się do obsługi błędów walidacji:   @Provider public class ValidationExceptionMapper implements ExceptionMapper&lt;ConstraintViolationException&gt; {      public static class ErrorMessage {         public final String error;         public ErrorMessage(String error) {             this.error = error;         }     }      @Override     public Response toResponse(ConstraintViolationException exception) {         return Response                 .status(Response.Status.BAD_REQUEST)                 .entity(new ErrorMessage(exception.getMessage()))                 .build();     } }   Klasa ValidationExceptionMapper implementuje interfejs ExceptionMapper. Interfejs ten zawiera wyłącznie jedną metodę toResponse. Metoda ta zostaje wywołana jeśli zostanie rzucony wyjątek obsługiwany przez daną klasę.   W moim przypadku tworzę nową odpowiedź, która zwraca kod błędu 400 wraz z dodatkowym komunikatem błędu zwróconym przez mechanizm walidacji.         W związku z błędem w bibliotece Jersey musiałem utworzyć klasę, która obsługuje wyjątek ConstraintViolationException. Po rozwiązaniu tego błędu klasa ta powinna obsługiwać wyjątek ValidationException.   Zgodnie ze specyfikacją użycie adnotacji @Priority także powinno pomóc obejść ten problem.     Dodatkowe materiały do nauki   W tym miejscu poproszę Cię o uruchomienie tej aplikacji na swoim komputerze i testowanie jej przy pomocy programu curl. Taka zabawa na żywo potrafi sporo nauczyć. Kod źródłowy aplikacji znajdziesz na samouczkowym githubie.   Zadanie do wykonania   Kod źródłowy aplikacji użytej w artykule znajduje się na samouczkowym githubie. Twoim zadaniem jest rozszerzenie działania tej aplikacji. W obecnym kształcie aplikacja nie sprawdza czy dany stolik nie jest już zarezerwowany. Może to prowadzić do sytuacji, w której ten sam stolik będzie zarezerwowany w tym samym czasie dla więcej niż jednej osoby.   Popraw aplikację w taki sposób, aby nie pozwalała na ponowną rezerwację już zarezerwowanego stolika. Więc jeśli stolik nr 1. jest zarezerwowany w godzinach od 17:00 do 18:30, to rezerwacja na ten sam stolik od 18:10 do 19:00 nie jest możliwa.   Podsumowanie   W artykule przeczytałeś o praktycznym zastosowaniu kilku specyfikacji z parasola Java EE. Na przykładzie mogłeś zobaczyć użycie walidacji czy wstrzykiwania zależności. Poznałeś też mechanizm obsługi wyjątków, w którym użyłem adnotacji @Provider. Użyłeś implementacji specyfikacji JSON-P i JSON-B pozwalających na proste obsługiwanie danych w formacie JSON. Całość opakowana została w webservice, oparty o specyfikację JAX-RS. Mam nadzieję, że przykłady użyte w artykule pozwoliły Ci spojrzeć na Java EE z innej strony.   Jeśli którakolwiek część artykułu nie jest dla Ciebie jasna proszę daj znać. Postaram się pomóc. Jeśli nie chcesz ominąć kolejnych artykułów w przyszłości proszę dopisz się do samouczkowego newslettera i polub stronę Samouczka na Facebooku. Do następnego razu!                 DAO to akronim od Data Access Object. Jest to często spotykany sposób na oznaczenie klas, które odpowiedzialne są za dostęp do danych. &#8617;                  Mam na myśli tutaj jedną instancję klasy na każdą wirtualną maszynę Javy. Jeśli aplikacja uruchomiona jest w kliku kontenerach wówczas każdy z nich będzie miał osobną instancję. &#8617;                  Raz jest to zwykła baza relacyjna, innym razem może to być plik na dysku. W przypadku niektórych aplikacji wymaganiem może okazać się użycie innych mechanizmów jak na przykład bazy “nosql”, czy rozproszone systemy plików. Wszystko zależy od wymagań stawianych przed daną aplikacją. &#8617;           ","categories": ["Kurs aplikacji webowych"],
        "tags": [],
        "url": "/rest-web-service-z-java-ee-czesc-2/",
        "teaser": "/assets/images/2018/01/22_rest_web_service_2_artykul.jpg"
      },{
        "title": "Strumienie w języku Java",
        "excerpt":"       To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   W szczególności potrzebna będzie wiedza na temat kolekcji, typów generycznych i wyrażeń lambda.     Czym są strumienie   Strumienie służą do przetwarzania danych. Zawierają1 dane i pozwalają na opisanie co chcesz zrobić tymi danymi.   Dane mogą być przechowywane w kolekcji, mogą być wynikiem pracy z wyrażeniami regularnymi. W strumień możesz opakować praktycznie dowolny zestaw danych. Strumienie pozwalają w łatwy sposób zrównoleglić pracę na danych. Dzięki temu przetwarzanie dużych zbiorów danych może być dużo szybsze. Strumienie kładą nacisk na operacje jakie należy przeprowadzić na danych.   Niestety pojęcie strumienia jest dość szerokie. Możesz się z nim także spotkać w przypadku pracy z plikami. W tym artykule mówiąc o strumieniach mam na myśli klasy implementujące interfejs Stream.   Strumień na przykładzie   Proszę spójrz na przykład poniżej. Postaram się pokazać Ci dwa różne sposoby na zrealizowanie wymagań. Pierwszy ze sposobów będzie opierał się na pętli, drugi na strumieniach.   public class BoardGame {     public final String name;     public final double rating;     public final BigDecimal price;     public final int minPlayers;     public final int maxPlayers;      public BoardGame(String name, double rating, BigDecimal price, int minPlayers, int maxPlayers) {         this.name = name;         this.rating = rating;         this.price = price;         this.minPlayers = minPlayers;         this.maxPlayers = maxPlayers;     } }   Klasa BoardGame opisuje grę planszową. Przy jej pomocy możesz utworzyć listę gier:   List&lt;BoardGame&gt; games = Arrays.asList(     new BoardGame(\"Terraforming Mars\", 8.38, new BigDecimal(\"123.49\"), 1, 5),     new BoardGame(\"Codenames\", 7.82, new BigDecimal(\"64.95\"), 2, 8),     new BoardGame(\"Puerto Rico\", 8.07, new BigDecimal(\"149.99\"), 2, 5),     new BoardGame(\"Terra Mystica\", 8.26, new BigDecimal(\"252.99\"), 2, 5),     new BoardGame(\"Scythe\", 8.3, new BigDecimal(\"314.95\"), 1, 5),     new BoardGame(\"Power Grid\", 7.92, new BigDecimal(\"145\"), 2, 6),     new BoardGame(\"7 Wonders Duel\", 8.15, new BigDecimal(\"109.95\"), 2, 2),     new BoardGame(\"Dominion: Intrigue\", 7.77, new BigDecimal(\"159.95\"), 2, 4),     new BoardGame(\"Patchwork\", 7.77, new BigDecimal(\"75\"), 2, 2),     new BoardGame(\"The Castles of Burgundy\", 8.12, new BigDecimal(\"129.95\"), 2, 4) );   Lista games zawiera 10 tytułów gier planszowych. Pochodzą one z listy najbardziej popularnych gier według portalu BGG2. Załóżmy, że chciałbyś zrobić znajomemu prezent. Chcesz kupić grę, gra powinna spełniać następujące warunki:      powinna pozwolić na grę w więcej niż 4 osoby,   powinna mieć ocenę wyższą niż 8,   powinna kosztować mniej niż 150 zł.   Następnie chcesz wyświetlić nazwy gier spełniających takie wytyczne wielkimi literami. Warunki te możesz spełnić przy pomocy poniższego fragmentu kodu:   for (BoardGame game : games) {     if (game.maxPlayers &gt; 4) {         if (game.rating &gt; 8) {             if (new BigDecimal(150).compareTo(game.price) &gt; 0) {                 System.out.println(game.name.toUpperCase());             }         }     } }   Prawda, że kod układa się w piękną strzałkę ;)? Taka struktura ma swoją nazwę: Arrow Anti-Pattern. Dobrze jest unikać tego typu zagnieżdżonych warunków. Jednym ze sposobów uniknięcia tego antywzorca może być użycie strumieni:   games.stream()     .filter(g -&gt; g.maxPlayers &gt; 4)     .filter(g -&gt; g.rating &gt; 8)     .filter(g -&gt; new BigDecimal(150).compareTo(g.price) &gt; 0)     .map(g -&gt; g.name.toUpperCase())     .forEach(System.out::println);   Oba sposoby pozwalają na uzyskanie tych samych wyników. Drugi sposób wykorzystuje strumienie i wyrażenia lambda. Operacje na strumieniach wykorzystując wzorzec łączenia metod (ang. method chaining), zwany także płynnym interfejsem (ang. fluent interface).   Rozłożę teraz ten strumień na części pierwsze.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Analiza przykładowego strumienia   Aby w ogóle mówić o operacjach na strumieniu należy go na początku utworzyć. W poprzednim przykładzie użyłem metody stream. Metoda ta jest metodą domyślną zaimplementowaną w interfejsie Collection. Pozwala ona na utworzenie strumienia na podstawie danych znajdujących się w danej kolekcji.   Stream&lt;BoardGame&gt; gamesStream = games.stream();   Strumienie zostały wprowadzone w Java 8. W tej wersji także dodano możliwość dodawania metod domyślnych do interfejsów. Te domyślne implementacje metod pozwoliły na dodanie nowych funkcjonalności nie psując kompatybilności wstecz.   Interfejs Stream jest interfejsem generycznym. Przechowuje on informację o typie, który aktualnie znajduje się w danym strumieniu. W przykładzie powyżej utworzyłem strumień gamesStream zawierający instancje klasy BoardGame. Strumień ten utworzyłem na podstawie listy.   Następnie filtruję strumień używając wyrażeń lambda. Zwróć uwagę na to, że każde wywołanie metody filter tworzy nową instancję klasy Stream. Każda linijka odpowiedzialna jest za filtr innego rodzaju. Pierwszy wybiera wyłącznie te gry, w które może grać więcej niż 4 graczy. Wśród tak odfiltrowanych gier następnie wybieram te, których ocena jest wyższa niż 8. Ostatnim zawężeniem jest wybranie gier, które kosztują mniej niż 150zł:   Stream&lt;BoardGame&gt; filteredStream = gamesStream     .filter(g -&gt; g.maxPlayers &gt; 4)     .filter(g -&gt; g.rating &gt; 8)     .filter(g -&gt; new BigDecimal(150).compareTo(g.price) &gt; 0);   W tym przypadku nie zapisywałem pośrednich strumieni do zmiennych. Zapisałem wyłącznie wynik, który otrzymam po użyciu wszystkich trzech filtrów. Następnie z każdej gry pobieram jej nazwę i zmieniam ją na pisaną wielkimi literami:   Stream&lt;String&gt; namesStream = filteredStream     .map(g -&gt; g.name.toUpperCase());   Strumień filteredStream zawiera instancje klasy BoardGame, z każdej z tych instancji pobieram nazwę. Nazwa ta jest następnie zwracana. Dzięki temu powstaje nowy strumień. Tym razem strumień zawiera zmienne typu String.   Ostatnią fazą jest wyświetlenie tak wybranych danych. Używam do tego odwołania do metody println:   namesStream.forEach(System.out::println);   Operacje na strumieniu   Operacje związane ze strumieniami można podzielić na trzy rozłączne grupy:      tworzenie strumienia,   przetwarzanie danych wewnątrz strumienia,   zakończenie strumienia.   Każdy strumień ma dokładnie jedną metodę, która go tworzy na podstawie danych źródłowych3. Następnie dane te są przetwarzane przez dowolną liczbę operacji. Każda z tych operacji tworzy nowy strumień danych wywodzący się z poprzedniego. Na samym końcu strumień może mieć dokładnie jedną metodę kończącą pracę ze strumieniem.   Wymagania dla operacji   Każda z operacji wykonywanych na strumieniu musi spełniać jasno określone wymagania.   Nie posiada stanu   Operacja nie może posiadać stanu. Przykładem operacji, która taki stan posiada jest metoda modify:   public class StatefullOperation {      private final Set&lt;Integer&gt; seen = new HashSet&lt;&gt;();      private int modify(int number) {         if (seen.contains(number)) {             return number;         }         seen.add(number);         return 0;     }      public static void main(String[] args) {         for (int i = 0; i &lt; 3; i++) {             Stream&lt;Integer&gt; numbers = Stream.of(1, 2, 3, 1, 2, 3, 1, 2, 3);             StatefullOperation requriements = new StatefullOperation();             int sum = numbers.parallel()                 .map(requriements::modify)                 .mapToInt(n -&gt; n.intValue()).sum();             System.out.println(sum);         }     }  }   Jeśli nie spełnisz tego wymagania może to prowadzić do dziwnych, niedeterministycznych wyników w trakcie równoległego przetwarzania strumienia danych (o przetwarzaniu równoległym przeczytasz w jednym z poniższych akapitów). Spróbuj uruchomić ten fragment wiele razy. Czy dostajesz takie same wyniki za każdym razem :)? Uwierz mi, nie chcesz szukać takich błędów w programach uruchomionych na środowisku produkcyjnym. Znam to, byłem tam, nie rób tego.   Nie modyfikuje źródła danych   Operacja nie może modyfikować źródła danych. Taka modyfikacja jest automatycznie wykryta w trakcie pracy ze strumieniem. Pokazuje ją poniższy fragment kodu:   List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;(); numbers.add(1); numbers.add(2);  numbers.stream()     .map(v -&gt; numbers.add(v) ? 1 : 0)     .forEach(System.out::println);   Uruchomienie tego kodu kończy się rzuceniem wyjątku:   1 Exception in thread \"main\" java.util.ConcurrentModificationException 1     at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1380)     at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)     at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)     at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)     at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)     at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)     at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)     at pl.samouczekprogramisty.kursjava.streams.requirements.InterferingOperation.main(InterferingOperation.java:15)   Rodzaje operacji na strumieniach   Tworzenie strumieni   Strumienie można tworzyć na wiele sposobów poniżej pokażę Ci kilka przykładów.      Strumień na podstawie kolekcji:   Stream&lt;Integer&gt; stream1 = new LinkedList&lt;Integer&gt;().stream();      Strumień na podstawie tablicy:   Stream&lt;Integer&gt; stream2 = Arrays.stream(new Integer[]{});      Strumień na podstawie łańcucha znaków rozdzielanego przez wyrażenie regularne:   Stream&lt;String&gt; stream3 = Pattern.compile(\".\").splitAsStream(\"some longer sentence\");     Strumień typów prostych:   DoubleStream doubles = DoubleStream.of(1, 2, 3); IntStream ints = IntStream.range(0, 123); LongStream longs = LongStream.generate(() -&gt; 1L);      Strumień danych losowych:   DoubleStream randomDoubles = new Random().doubles(); IntStream randomInts = new Random().ints(); LongStream randomLongs = new Random().longs();      Pusty strumień:   Stream.empty();      Strumień danych z pliku:   try (Stream&lt;String&gt; lines = new BufferedReader(new FileReader(\"file.txt\")).lines()) {     // do something }   Strumień danych z pliku musi być zamknięty. W przykładzie powyżej użyłem do tego konstrukcji try-with-resources. Strumień możesz także zamknąć wywołując na nim metodę close.   Operacje na strumieniach   Nie opiszę tutaj wszystkich metod dostępnych na strumieniach. Jeśli chcesz poznać ich więcej zachęcam do zapoznania się z dokumentacją interfejsu Stream.      filter – zwraca strumień zawierający tylko te elementy dla których filtr zwrócił wartość true,   map – każdy z elementów może zostać zmieniony do innego typu, nowy obiekt zawarty jest w nowym strumieniu,   peek – pozwala przeprowadzić operację na każdym elemencie w strumieniu, zwraca strumień z tymi samymi elementami,   limit – zwraca strumień ograniczony do zadanej liczby elementów, pozostałe są ignorowane.   Kończenie strumienia   Operacjami kończącymi są wszystkie, które zwracają typ inny niż Stream. Metody tego typu mogą także nie zwracać żadnych wartości.      forEach – wykonuje zadaną operację dla każdego elementu,   count – zwraca liczbę elementów w strumieniu,   allMatch – zwraca flagę informującą czy wszystkie elementy spełniają warunek. Przestaje sprawdzać na pierwszym elemencie, który tego warunku nie spełnia,   collect – pozwala na utworzenie nowego typu na podstawie elementów strumienia. Przy pomocy tej metody można na przykład utworzyć listę. Klasa Collectors zawiera sporo gotowych implementacji.   Właściwości strumieni   Leniwe rozstrzyganie   Strumienie są leniwe :). Oznacza to, że przetwarzają elementy dopiero po wykonaniu metody kończącej. Dodatkowo niektóre operacje powodują wcześniejsze zakończenie czytania danych ze strumienia. Przykładem takiej operacji jest limit. Poniższy przykład pokaże Ci dokładnie te właściwości:   IntStream numbersStream = IntStream.range(0, 8); System.out.println(\"Przed\"); numbersStream = numbersStream.filter(n -&gt; n % 2 == 0); System.out.println(\"W trakcie 1\"); numbersStream = numbersStream.map(n -&gt; {     System.out.println(\"&gt; \" + n);     return n; }); System.out.println(\"W trakcie 2\"); numbersStream = numbersStream.limit(2); System.out.println(\"W trakcie 3\"); numbersStream.forEach(System.out::println); System.out.println(\"Po\");   Po uruchomieniu tego kodu na konsoli będziesz mógł zobaczyć:   Przed W trakcie 1 W trakcie 2 W trakcie 3 &gt; 0 0 &gt; 2 2 Po   Zauważ, że komunikaty “W trakcie X” zostały wyświetlone przed operacją map. Zwróć także uwagę na to, że przetwarzanie skończyło się po dwóch elementach. To sprawka metody limit.   Przetwarzanie sekwencyjne i równoległe   Strumienie mogą być przetwarzane sekwencyjnie bądź równolegle. Metoda stream tworzy sekwencyjny strumień danych. Metoda parallelStream tworzy strumień, który jest uruchamiany jednocześnie na kilku wątkach. To ile wątków zostanie uruchomionych zależy od procesora.   Strumień sekwencyjny można przełączyć na równoległy wywołując na nim metodę parallel. Odwrotna operacja także jest możliwa dzięki metodzie sequential.   Dobre praktyki   W tym paragrafie postaram się zebrać dobre praktyki ułatwiające pracę ze strumieniami danych.   Filtrowanie na początku   W związku z tym, że operacje na strumieniach wykonywane są tylko wtedy gdy jest to konieczne warto ograniczyć liczbę elementów najwcześniej jak to możliwe. Dzięki takiej prostej operacji możemy znacząco ograniczyć liczbę elementów, na których wykonana będzie czasochłonna metoda. W przykładzie poniżej symuluję czasochłonne wykonanie przez Thread.sleep(100). Wywołanie to “usypia” wątek na 100 milisekund 4:   public static int timeConsumingTransformation(int number) {     try {         Thread.sleep(100);     } catch (InterruptedException e) {         e.printStackTrace();     }     return number; }  W pierwszym przykładzie czasochłonna metoda wykonana jest na każdej z liczb:   int slowNumber = IntStream.range(1950, 2150)         .map(StreamsGoodPractices::timeConsumingTransformation)         .filter(n -&gt; n == 2000)         .sum();   Lepszym rozwiązaniem, może być odwrócenie kolejności tych operacji. W tym przypadku czasochłonna metoda zostanie wywołana wyłącznie na przefiltrowanych elementach:   int fastNumber = IntStream.range(1950, 2150)         .filter(n -&gt; n == 2000)         .map(StreamsGoodPractices::timeConsumingTransformation)         .sum();   Unikaj skomplikowanych wyrażeń lambda   Skomplikowane, wieloliniowe wyrażenie lambda może nie być czytelne. W takim przypadku, moim zdaniem, lepiej opakować kod w metodę i użyć odnośnika do metody wewnątrz strumienia. Proszę porównaj dwa poniższe przykłady   IntStream.range(1950, 2150)     .filter(y -&gt; (y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0)     .forEach(System.out::println);   IntStream.range(1950, 2150)     .filter(StreamsGoodPractices::isLeapYear)     .forEach(System.out::println);  public static boolean isLeapYear(int year) {     boolean every4Years = year % 4 == 0;     boolean notEvery100Years = year % 100 != 0;     boolean every400Years = year % 400 == 0;      return (every4Years &amp;&amp; notEvery100Years) || every400Years; }   Chociaż drugi przykład jest zdecydowanie dłuższy wydaje mi się, że jest tez bardziej czytelny. A czytelność kodu ma znaczenie :).   Nie nadużywaj strumieni   Jak ktoś umie obsługiwać młotek to każdy problem wygląda jak gwóźdź. Strumienie są jednym ze sposobów rozwiązania problemu. To nie jest prawda, że znając strumienie powinieneś zapomnieć o pętlach. Dobrze jest znać oba mechanizmy. Poza tym, niektórych konstrukcji nie da się uzyskać przy pomocy strumieni. Przykładem mogą być tu niektóre pętle ze słówkiem kluczowym break.   Strumienie to nie struktury danych   W poprzednich artykułach opisałem kilka struktur danych. Przykładem struktur danych może być lista wiązana czy mapa. Strumienie nie są strukturą danych. W odróżnieniu od struktur nie służą do przechowywania danych. Strumienie jedynie pomagają określić operacje, które na tych danych chcesz wykonać.   Mówi się, że strumienie pozwalają w deklaratywny sposób opisać operacje na danych. Można to uprościć do stwierdzenia, że struktury służą do przechowywania danych a strumienie służą do opisywania algorytmów, operacji na danych.   Zadania   Na koniec przygotowałem dla Ciebie kilka zadań do rozwiązania, które pomogą Ci utrwalić wiedzę zdobytą w tym artykule:      Przerób poniższy fragment kodu tak żeby używał strumieni:     double highestRanking = 0; BoardGame bestGame = null; for (BoardGame game : BoardGame.GAMES) {  if (game.name.contains(\"a\")) {      if (game.rating &gt; highestRanking) {          highestRanking = game.rating;          bestGame = game;      }  } } System.out.println(bestGame.name);           Znajdź minimalny element w kolekcji używając strumieni i funkcji reduce. Twoja funkcja powinna działać jak istniejąca funkcja min.   Używając metody flatMap napisz strumień, który “spłaszczy” listę list.   Jak zwykle zachęcam Cię do samodzielnego rozwiązania zadań, wtedy nauczysz się najwięcej. Jeśli jednak będziesz miał z czymś kłopot możesz rzucić okiem do przykładowych rozwiązań, które przygotowałem.   Dodatkowe materiały do nauki   Poniżej zebrałem dla Ciebie kilka dodatkowych źródeł, które pozwolą spojrzeć Ci na temat strumieni z innej strony.      Bardzo dobra dokumentacja pakietu java.util.stream,   Część I tutoriala dotyczącego strumieni na stronie Oracle,   Część II tutoriala dotyczącego strumieni na stronie Oracle,   Szczegółowy opis strumieni – Baeldung,   Kod źródłowy użyty w tym artykule.   Podsumowanie   Strumienie wraz z wyrażeniami lambda to bardzo użyteczne narzędzie. Po lekturze artykułu wiesz już czym są strumienie i jak z nimi pracować. Potrafisz utworzyć strumień i zaaplikować do niego zestaw operacji. Znasz dobre praktyki pracy ze strumieniami. Rozwiązując ćwiczenia utrwaliłeś wiedzę z artykułu w praktyce.   Na koniec mam do Ciebie prośbę. Podziel się linkiem do artykułu ze swoimi znajomymi jeśli ten artykuł był dla Ciebie wartościowy. Jeśli nie chcesz pominąć kolejnych artykułów na blogu dopisz się do samouczkowego newslettera i polub profil Samouczka Programisty na Facebooku. Do następnego razu!                 To jest pewne uproszczenie. Strumienie nie muszą zawierać danych, które zwracają. Na przykład strumień generujący kolejne liczby pseudolosowe nie zawiera tych liczb, jedynie je generuje. &#8617;                  Sam bardzo często gram w planszówki ;). Grałem w większość wymienionych tu gier – mogę je z czystym sumieniem polecić. &#8617;                  Dane źródłowe mogą także pochodzić z innego strumienia. &#8617;                  To tylko przykładowa metoda, w praktyce taka czasochłonna operacja może polegać na przykład na pobraniu danych z bazy danych czy z pliku na dysku. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/strumienie-w-jezyku-java/",
        "teaser": "/assets/images/2018/01/30_strumienie_w_jezyku_java_artykul.jpg"
      },{
        "title": "Protokół HTTP",
        "excerpt":"Czym jest protokół HTTP   Według słownika języka polskiego protokół to:      zasady wymiany informacji i współpracy programów i urządzeń komputerowych    Zatem protokół HTTP (ang. Hypertext Transfer Protocol) to zasady wymiany informacji i współpracy programów. Programami są serwery i klienty. Programy te wysyłają żądania (klienty) lub odpowiedzi (serwery). Przykładem klienta HTTP może być przeglądarka internetowa1. Klienty mogą interpretować uzyskane odpowiedzi, na przykład przeglądarka internetowa potrafi wyświetlić stronę internetową, która została przesłana przez serwer.   Nawiasem mówiąc przeglądarka robi całkiem sporo rzeczy w tle… Wiesz, że do wyświetlania strony www.amazon.com przeglądarka wykonuje około 300 żądań HTTP? W końcowej części artykułu pokażę Ci jak to się dzieje.   Komunikacja pomiędzy serwerem a klientem oparta jest na wielu innych protokołach. Ten zestaw protokołów nazywa się modelem ISO/OSI. Model ten zawiera warstwy. Każda warstwa, na bazie poprzednich, udostępnia dodatkowe funkcjonalności. Protokół HTTP znajduje się w najwyższej warstwie modelu, warstwie aplikacji.   Klienty wysyłają żądania. Każde żądanie powiązane jest z zasobem. Zasobem może być obrazek, strona HTML czy plik z kodem JavaScript. Sam protokół HTTP nie określa czym dokładnie jest zasób. Określa jedynie sposób w jaki można dostać się do zasobów. Każdy zasób ma swój unikalny identyfikator. Ten identyfikator to URI (ang. Uniform Resource Identifier).   Protokół HTTP dokładnie określa format komunikacji pomiędzy klientami i serwerami. Komunikacja ta oparta jest na wspomnianych już żądaniach i odpowiedziach. Protokół HTTP określa format tych wiadomości.   Protokół HTTP jest bezstanowy. Oznacza to tyle, że każde zapytanie może być interpretowane w oderwaniu od pozostałych.   Poza klientami i serwerami w komunikacji występują dodatkowe węzły. Na przykład mogą to być serwery, które zachowują kopię odpowiedzi przyspieszając komunikację. Mogą to być także elementy sieciowe pozwalające na sprawne dotarcie żądania do serwera. W tym artykule pominę te kwestie, moim zdaniem ich znajomość nie jest niezbędna do tworzenia aplikacji webowych.   Teraz wprowadzę Cię w poszczególne elementy składające się na protokół HTTP.   Adres czyli URL   Wspomniałem wcześniej o URI. Podzbiorem URI są URL (ang. Uniform Resource Locator). URI można traktować jako zbiór znaków który pozwala na unikalną identyfikację zasobu. URL natomiast poza tym unikalnym identyfikatorem zawiera informację dotyczącą “położenia” danego zasobu. Często określenia te stosowane są zamiennie.   Adres URL ma postać:   scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]   Przykładowy adres URL może wyglądać następująco:   http://marcin:tajne@www.samouczekprogramisty.pl:80/nie/ma/tej?strony=1#identyfikator                  Część adresu       Przykładowa wartość                       scheme       http                 user       marcin                 password       tajne                 host       www.samouczekprogramisty.pl                 port       80                 /path       /nie/ma/tej                 ?query       ?strony=1                 #fragment       #identyfikator           Zgodnie ze specyfikacją HTTP wielkość liter nie ma znaczenia w częściach scheme i host. Wielkość liter w pozostałych elementach ma znaczenie2.   Poniżej opiszę poszczególne części adresu URL.   scheme   W praktyce ta część adresu używana jest do określenia protokołu, najczęściej zobaczysz tu http czy https. W uproszczeniu można powiedzieć, że HTTPS (ang. Hypertext Transfer Protocol Secure) jest rozszerzeniem protokołu HTTP. To rozszerzenie pozwala na szyfrowanie połączenia pomiędzy klientem a serwerem.   user:password   user:password służą do uwierzytelniania. Uwierzytelnianie to proces, który polega na udowodnieniu, że klient wysyłający dane żądanie jest tym za kogo się podaje. Mechanizmu uwierzytelniania używasz praktycznie w każdym serwisie gdzie masz założone konto.   W tym przypadku nazwa użytkownika i hasło przesyłane są jako część URL. Nie jest to bezpieczne w przypadku używania protokołu HTTP. Nawet przy komunikacji protokołem HTTPS adres URL może być zapamiętany przez przeglądarkę. Daje to możliwość przechwycenia nazwy użytkownika i hasła. W związku z tym nie jest to bezpieczny sposób na przesyłanie hasła czy nazwy użytkownika i należy go unikać3.   host   W przypadku protokołu HTTP sprowadza się to do nazwy domeny internetowej lub adresu IP. Przykładem domeny może być www.samouczekprogramisty.pl. Przykładowy adres IPv4 to 192.30.253.112. Jaka strona kryje się pod tym adresem :)?   DNS (ang. Domain Name System) jest protokołem, który pozwala na tłumaczenie adresów IP na nazwy domen.   port   Port to numer. Numer ten jest wykorzystywany przez serwer. Serwer nasłuchuje ruch na danym porcie. To tak jak z numerem w bloku, domena to numer klatki a port to numer mieszkania ;).   Protokoły mają swoje standardowe porty. Na przykład standardowym portem protokołu HTTP jest 80. Protokół HTTPS natomiast używa portu 443. W praktyce, ze względu na domyślne wartości, porty te często się pomija. Odpowiednia wartość pola scheme pozwala na określenie czy użytkownikowi chodzi o port 80 czy 443.   Możesz także uruchomić serwer, który nasłuchuje na innym porcie. Przykładem może tu być Tomcat, który domyślnie uruchamia się na porcie 8080. W takim przypadku podanie portu jest konieczne.   path   Ta część adresu URL jest ścieżką, która określa zasób. Na przykład w adresie www.samouczekprogramisty.pl/kurs-programowania-java ścieżką jest /kurs-programowania-java.   query   Zawiera dodatkowe dane identyfikujące dany zasób. Ta część oddzielona jest od ścieżki znakiem ?. W praktyce zawiera pary klucz=wartość połączone znakiem &amp;. Na przykład:   ?parametr=wartosc&amp;format=json   fragment   Ostatnia część adresu URL. W praktyce wykorzystywana jest do określenia fragmentu strony HTML, która powinna zostać pokazana użytkownikowi. Na przykład adres https://www.samouczekprogramisty.pl/strumienie-w-jezyku-java/#właściwości-strumieni przeniesie Cię do sekcji opisującej właściwości strumieni.   Pisząc bardziej formalnie fragment używany jest do określenia „podzbioru” zasobu (ang. secondary resource). W przypadku HTML zasobem jest strona HTML a podzbiorem sekcja tej strony. Zgodnie ze specyfikacją ta część adresu URL służy do identyfikacji zasobu wyłącznie po stronie klienta. Oznacza to tyle, serwer do identyfikacji zasobu nie używa tej części URL.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Żądanie i odpowiedź         W dalszej części artykułu będę używał programu curl jako klienta HTTP. Jest to program, który pozwala na łatwe wysyłanie zapytań do serwerów z linii poleceń.   Jeśli nie chcesz używać tego programu możesz użyć narzędzi dla programistów dostępnych w Twojej przeglądarce:      Chrome,   Firefox,   Safari,   Opera,   Edge.     Teraz przeanalizuję przykładowe zapytanie wraz z odesłaną odpowiedzią. Użyję do tego publicznego API Github’a. Github używa HTTPS, w analizie żądania/odpowiedzi pominę fragmenty dotyczące HTTPS.   Żądanie HTTP   Klient wysyła żądanie do serwera w formie wiadomości. Wiadomość ta ma dokładnie zdefiniowany format:      linia określająca czasownik HTTP, zasób i wersję protokołu,   linie zawierające nagłówki,   pustą linię określającą koniec nagłówków,   ciało wiadomości (jeśli istnieje).   Jak wspomniałem wyżej użyję programu curl. Dodatkowo użyję przełącznika -v. Włącza on tryb lania wody ;). Wtedy curl raportuje dużo więcej informacji. Dane wysłane do serwera poprzedzone są znakiem &gt;. Odpowiedź poprzedzona jest &lt;. Poniżej pokazuję zapytanie do API Githuba. Wysyłam żądanie na adres https://api.github.com/users/kbl:   $ curl -v https://api.github.com/users/kbl // ciach usunąłem część związaną z HTTPS &gt; GET /users/kbl HTTP/1.1 &gt; Host: api.github.com &gt; User-Agent: curl/7.52.1 &gt; Accept: */* &gt;   Zacznę od analizowania pierwszej linijki GET /users/kbl HTTP/1.1. Na początku zawiera ona czasownik HTTP - GET (czasowniki opiszę dokładniej poniżej). Następnie zawiera część adresu URL, wszystko od części path. W moim przypadku jest to /users/kbl. Kolejną częścią jest protokół wraz z wersją HTTP/1.1.   Trzy kolejne linijki zawierają tak zwane nagłówki HTTP, nagłówkom także poświęcę osobny podpunkt poniżej.   W przypadku tego żądania, ciało wiadomości jest puste. Widzisz więc tylko pustą linię oddzielającą nagłówki od pominiętego ciała wiadomości.   Odpowiedź HTTP   Serwer odpowiada na żądanie klienta wysyłając odpowiedź4. Podobnie jak w przypadku zapytania format jest dokładnie określony:      linijka z wersją protokołu i statusem odpowiedzi,   linie zawierające nagłówki,   pustą linię określającą koniec nagłówków,   ciało wiadomości (jeśli istnieje).   Tym razem odpowiedź, jest dużo dłuższa:   &lt; HTTP/1.1 200 OK &lt; Server: GitHub.com &lt; Date: Tue, 06 Feb 2018 19:36:28 GMT &lt; Content-Type: application/json; charset=utf-8 &lt; Content-Length: 1218 &lt; Status: 200 OK &lt; X-RateLimit-Limit: 60 &lt; X-RateLimit-Remaining: 55 &lt; X-RateLimit-Reset: 1517949218 &lt; Cache-Control: public, max-age=60, s-maxage=60 &lt; Vary: Accept &lt; ETag: \"268c03d98e6e20c7824364d61b3f51b0\" &lt; Last-Modified: Mon, 09 Oct 2017 19:42:33 GMT &lt; X-GitHub-Media-Type: github.v3; format=json &lt; Access-Control-Expose-Headers: ETag, Link, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval &lt; Access-Control-Allow-Origin: * &lt; Content-Security-Policy: default-src 'none' &lt; Strict-Transport-Security: max-age=31536000; includeSubdomains; preload &lt; X-Content-Type-Options: nosniff &lt; X-Frame-Options: deny &lt; X-XSS-Protection: 1; mode=block &lt; X-Runtime-rack: 0.030276 &lt; X-GitHub-Request-Id: 8AAA:602C:92D77:140069:5A7A03BC &lt; {   \"login\": \"kbl\",   // ciach   \"created_at\": \"2009-04-14T08:28:56Z\",   \"updated_at\": \"2017-10-09T19:42:33Z\" }   Pierwsza linijka to wspomniany wcześniej protokół HTTP/1.1. Następnie status odpowiedzi 200 OK, podobnie jak w przypadku nagłówków i czasowników więcej o statusie przeczytasz w osobnym podpunkcie.   Kolejne 22 linijki to nagłówki, po których występuje pusta linia. Podobnie jak przy żądaniu oddziela ona nagłówki od ciała wiadomości.   W przypadku odpowiedzi ciało wiadomości zawiera dane w formacie JSON – zasób. Dla czytelności pominąłem tu większość ciała odpowiedzi. Zachęcam Cię do eksperymentowania z własnymi zapytaniami :). Do tych eksperymentów może Ci się przydać dokumentacja API.   Czasowniki HTTP   Specyfikacja HTTP definiuje 8 czasowników5. Każdy z tych czasowników powiązany jest z żądaniem wysyłanym przez klienta. Każde z żądań ma swoje zastosowania.   Zanim przejdę do omówienia poszczególnych czasowników musisz wiedzieć czym jest cache6. Cache to mechanizm, który pozwala na zmniejszenie czasu oczekiwania na odpowiedź. Zakładając, że wykonasz dwa zapytania z rzędu o ten sam zasób wynik pierwszego zapytania może być zapisany w cache’u. W związku z tym drugie zapytanie może nie dotrzeć do serwera, odpowiedź może zostać pobrana z cache’a.   GET   Jest to podstawowe żądanie. Każde otworzenie strony internetowej zaczyna się od zapytania typu GET. Przeglądarka wysyła żądanie typu GET żeby otworzyć stronę internetową. Specyfikacja mówi, że żądanie to służy do pobrania aktualnej reprezentacji zasobu. W praktyce może to oznaczać pobranie aktualnej wersji strony znajdującej się pod danym adresem. Zakłada się, że żądania typu GET nie posiadają dołączonego ciała wiadomości.   Odpowiedź na żądania typu GET może być przechowywana w cache’u.   HEAD   Zapytanie typu HEAD jest podobne do GET. Różni się jednym ważnym szczegółem. W przypadku tego zapytania odpowiedź serwera nie może zawierać ciała wiadomości. Zapytania tego typu są używane do sprawdzenia czy dany zasób się zmienił, czy do sprawdzania poprawności odnośników. Zysk z używania tego zapytania polega na tym, że ciało wiadomości nie jest przesyłane. Wyobraź sobie plik PDF, który zawiera 10MB danych. Można wysłać zapytanie typu HEAD, żeby sprawdzić czy zawartość tego pliku uległa zmianie. To czy plik jest nowszy można określić na podstawie nagłówków, które będą dołączone do odpowiedzi.   Odpowiedź na żądania typu HEAD może być przechowywana w cache’u.   POST   Specyfikacja mówi, że żądania typu POST są przetwarzane przez serwer zgodnie z założeniami dla danego zasobu. Taki skomplikowany opis sprowadza się do:      używania POST do przesyłania zawartości formularzy,   dodawania nowego zasobu,   dodawanie danych do istniejącego zasobu.   Odpowiedzi na żądania typu POST nie są przechowywane w cache’u7.   PUT   W codziennym użytkowaniu żądania typu PUT służą do aktualizacji danego zasobu. Zgodnie ze specyfikacją ciało wiadomości powinno posłużyć do ustawienia stanu zasobu na serwerze. Zatem w przypadku gdy zasób nie istniał żądanie tego typu powinno go utworzyć. Jeśli zasób istnieje wówczas jego stan powinien być ustawiony na ten przekazany w ciele wiadomości.   W większości znanych mi przypadków ten pierwszy aspekt jest pomijany, prawdopodobnie dla uproszczenia logiki aplikacji.   Główna różnica pomiędzy zapytaniami POST i PUT polega na sposobie interpretowania ciała wiadomości. W przypadku zapytania typu POST to zasób decyduje jak przetworzyć otrzymaną wiadomość. W przypadku żądania typu PUT otrzymana wiadomość powinna posłużyć do ustawienia wartość zasobu.   Odpowiedzi na żądanie typu PUT nie powinny być przechowywane w cache’u.   Idempotentność   Oznacza to tyle, że zapytania typu PUT są idempotentne. Zapytania, które są idempotentne można powtarzać wielokrotnie i zawsze doprowadzą one do tego samego stanu danego zasobu.   DELETE   Zapytania tego typu służą do usuwania zasobów. Na przykład w którymś z wcześniejszych zapytań dany zasób może być utworzony przy pomocy żądania typu POST. Następnie może on być usunięty przy pomocy DELETE. Odpowiedzi na żądania tego typu nie powinny zawierać ciała wiadomości.   Odpowiedzi na żądania typu DELETE nie powinny być umieszczane w cache’u.   CONNECT   Żądania tego typu służą do utworzenia połączenia pomiędzy klientem a serwerem docelowym (za pomocą węzłów pośrednich). W praktyce nie będziesz używał tego typu żądań w trakcie pisania aplikacji webowych. Mi się to nigdy do tej pory nie zdarzyło :).   OPTIONS   Żądania typu OPTIONS używane są do pobrania informacji na temat możliwości komunikacji dla danego zasobu. W praktyce żądania tego typu używane są do sprawdzenia jakie żądania są obsługiwane przez serwer. Żądanie tego typu także wykorzystywane jest w mechanizmie CORS.   Odpowiedzi na żądania typu OPTIONS nie powinny być przechowywane w cache’u.   TRACE   Żądanie tego typu służy do testowania. W odpowiedzi na to żądanie serwer powinien wysłać zapytanie, które otrzymał. Możliwa jest drobna modyfikacja otrzymanych nagłówków, na przykład serwer może usunąć nagłówki zawierające dane wrażliwe (na przykład ciasteczka). Żądanie typu TRACE nie może zawierać ciała wiadomości.   Odpowiedzi na żądanie typu TRACE nie powinny być umieszczane w cache’u.   Nagłówki HTTP   Nagłówki dołączane są przez klienty do wysyłanych zapytań i przez serwery do wysyłanych odpowiedzi. Mają one postać nazwa-nagłówka: wartość-nagłówka. Zgodnie ze specyfikacją wielkość liter w nazwach nagłówków nie ma znaczenia. Wielkość liter w wartości nagłówka może mieć znaczenie, zależy to od aplikacji. Chociaż istnieje cała masa standardowych nagłówków możesz tworzyć swoje własne.   Nagłówki wykorzystywane są do przesyłania metadanych na temat zasobów. Mogą zawierać na przykład informacje o formacie, statusie odpowiedzi czy dacie. Poniżej postaram się wyjaśnić kilka najczęściej spotykanych nagłówków:                  Nagłówek       Znaczenie                       Accept       Klient informuje serwer o tym jaki format jest w stanie zrozumieć, może to być na przykład JSON: application/json                 Accept-Encoding       Klient informuje serwer o tym jakie sposoby kodowania ciała wiadomości rozumie, może być użyty do określenia pożądanego algorytmu kompresji odpowiedzi                 Access-Control-Allow-Methods       W odpowiedzi na zapytanie typu OPTIONS serwer informuje jakie inne czasowniki HTTP są dozwolone                 Access-Control-Allow-Origin       Serwer informuje klienta jakie domeny uprawnione są do użycia odpowiedzi                 Cache-Control       Nagłówek służący do zarządzania cache’owaniem. Dotyczy zarówno żądań jak i odpowiedzi                 Connection       Zawiera informacje na temat połączenia pomiędzy klientem a serwerem                 Content-Encoding       Serwer informuje klienta o sposobie kodowania ciała wiadomości                 Content-Type       Odpowiednik nagłówka Accept wysyłany przez serwer informujący o formacie odpowiedzi                 Cookie       Nagłówek służący do przesłania ciasteczka przez klienty do serwera                 Date       Zawiera datę mówiącą o czasie wygenerowania żądania/odwiedzi                 ETag       Zawiera identyfikator zasobu zwróconego przez serwer. Używany przez cache                 Host       Zawiera domenę, do której wysyłane jest żądanie                 Location       Zawiera informacje o położeniu zasobu, może być użyty na przykład przy przekierowaniach i tworzeniu nowych zasobów                 Server       Serwer informuje klienty jakiego oprogramowania używa do obsługi odpowiedzi                 Set-Cookie       Nagłówek służący do ustawienia ciasteczka                 User-Agent       Nagłówek dołączany do zapytania informujący o tym jaki klient został użyty do jego wysłania           Ciasteczka   Co prawda ciasteczka to nic innego jak nagłówki, jednak poświęcę im osobny podpunkt. W osobnym artykule możesz przeczytać o ciasteczkach w kontekście specyfikacji serwletów.   Wiesz już, że protokół HTTP jest bezstanowy. Serwer HTTP nie może powiązać ze sobą zapytań pochodzących od tego samego klienta w jedną paczkę. Z pomocą przychodzą ciasteczka. Ciasteczka to specyficzne nagłówki, które są obsługiwane przez klienty.   Serwer w odpowiedzi może wysłać nagłówek, który utworzy ciasteczko. Ciasteczko to jest przypisane do domeny (część host i path adresu URL). Przykładowy nagłówek do ustawienia ciasteczka może wyglądać następująco:   Set-Cookie: &lt;nazwa ciasteczka&gt;=&lt;wartość ciasteczka&gt;   W każdym kolejnym zapytaniu do tej domeny klient dołącza nagłówki ciasteczek. Dzięki temu aplikacja na serwerze może połączyć pojedyncze zapytania w sesje. Przykładowe ciasteczko w odpowiedzi dołączane jest przy pomocy nagłówka:   Cookie: &lt;nazwa ciasteczka&gt;=&lt;wartość ciasteczka&gt;   Pewnie kojarzysz formularze logowania, w których możesz zaznaczyć “zapamiętaj mnie”. Zaznaczenie tego pola powoduje wysłanie odpowiedzi przez serwer, w której znajduje się nagłówek z ciasteczkiem (nagłówek Set-Cookie). To ciasteczko zawiera unikalny klucz, który później jest dołączany przez klienta do każdego żądania do danej domeny (nagłówek Cookie). Dzięki temu każde kolejne zapytanie ma nagłówek z tym tokenem. Aplikacja na serwerze widząc ten token może potwierdzić tożsamość użytkownika.   Niestety ciasteczka wykorzystywane są także do złych celów. Ciasteczka mogą być wykorzystywane jako jeden ze sposobów do śledzenia Twojego ruchu w sieci. Zdarzyło Ci się kliknąć na reklamę a później ta reklama pokazywała Ci się bez przerwy? Ciasteczka także mogły się do tego przyczynić8.   Statusy HTTP   Wiesz już, że każda odpowiedź od serwera zawiera między innymi informacje o statusie. Status ten jest podstawową informacją o tym czy żądanie się powiodło. Wszystkie statusy podzielone są na pięć grup.   Statusy 1xx   Szczerze nigdy w praktyce nie spotkałem się z użyciem tych statusów. Ta grupa statusów to statusy informacyjne. Informują klienty o tym, że zapytanie zostało otrzymane i jest przetwarzane.   Statusy 2xx   Statusy z tej grupy informują o tym, że zapytanie zostało poprawnie przetworzone. W zależności od kodu odpowiedzi wynik tego przetwarzania może być różny. Najczęściej używane statusy z tej grupy to:      200 OK – zapytanie zostało przetworzone poprawnie,   201 Created – zapytanie zostało przetworzone poprawnie i zasób został utworzony,   202 Accepted – zapytanie zostało przyjęte przez serwer, jednak jego przetwarzanie nie jest jeszcze ukończone,   204 No Content – zapytanie zostało przetworzone, ciało wiadomości jest puste.   Statusy 3xx   Statusy zaczynające się od 3 informują klienty o tym, że musi być podjęta dodatkowa akcja w celu skończenia przetwarzania zapytania. Statusy te wykorzystywane są do ustawiania przekierowań. Na przykład jeśli zmieniłbym adres samouczka z www.samouczekprogramisty.pl na cokolwiek innego wówczas żądanie wysłane pod www.samouczekprogramisty.pl powinno skończyć się statusem z grupy 3xx:      301 Moved Permanently – informuje klienta, że zasób został przeniesiony na stałe w inne miejsce. Ten status ma znaczenie duże dla twórców stron, którzy bazują na ruchu z wyszukiwarek. Taki status informuje wyszukiwarki o tym, że strona, która wcześniej była pod adresem X znajduje się w nowym miejscu.   Statusy 4xx   Statusy z tej grupy informują o błędzie klienta. Pewnie nie raz widziałeś błąd 404 ;). Serwer tymi statusami informuje o tym, że żądanie nie może być poprawnie przetworzone:      400 Bad Request – serwer informuje klienta o błędnym zapytaniu, które nie będzie przetworzone,   403 Forbidden – zasób wymaga uwierzytelnienia, po potwierdzeniu tożsamości może być dostępny,   404 Not Found – to pewnie znasz i widziałeś wielokrotnie, żądany zasób nie istnieje.   Statusy 5xx   Tutaj sprawa jest poważna. Serwer informuje klienty o błędzie po stronie serwera, które uniemożliwiają przetworzenie zapytania:      500 Internal Server Error – informacja dla klienta o tym, że serwer znalazł się w stanie, który uniemożliwia poprawne przetworzenie żądania,   502 Bad Gateway – na początku artykułu wspomniałem o tym, że może być wiele węzłów, które będą przekazywały zapytanie do serwera, który je finalnie obsłuży. Ten status informuje klienta o tym, że jeden z tych pośrednich węzłów dostał błędną odpowiedź od poprzedniego węzła,   503 Service Unavailable – ten błąd może informować klienta o tym, że serwer jest przeciążony. Ponowna próba może kończyć się poprawną odpowiedzią.   Prawie 300 zapytań aby wyświetlić stronę   Teraz jak już wiesz czym jest protokół HTTP wyjaśnię “tajemnicę” około 300 zapytań.             Do wyświetlenia www.amazon.com potrzeba około 300 zapytań        Przeglądarka jest klientem HTTP. Klienty mogą interpretować odpowiedź wysyłaną od serwera. Wpisując w pasek adresu www.amazon.com i naciskając ENTER wysyłasz jedno zapytanie. Jest to zapytanie typu GET o zasób www.amazon.com. W odpowiedzi serwer zwraca dokument HTML.   Dokument ten jest interpretowany przez przeglądarkę, zawiera on znaczniki HTML. Takie jak img, script czy style. Każdy z tych znaczników może kończyć się kolejnym zapytaniem typu GET. Dodatkowo kod JavaScript interpretowany przez przeglądarkę może wykonywać dodatkowe zapytania. W sumie do wyświetlenia strony głównej sklepu Amazon potrzeba tych zapytań około 300. A wszystko zaczęło się od jednego, niewinnego GET :).   Dodatkowe materiały   Odsyłam Cię głównie do źródeł. Mam wrażenie, że artykuł jest na tyle szczegółowy, że bardziej dokładne informacje znajdziesz właśnie tam:      Zbiór materiałów fundacji Mozilla dotyczących HTTP,   Zbiór RFC dla HTTP 1.1:            RFC 7230       RFC 7231       RFC 7232       RFC 7233       RFC 7234       RFC 7235           RFC dla URI   Podsumowanie   Jeśli przeczytałeś i zrozumiałeś ten artykuł to śmiało możesz powiedzieć, że znasz protokół HTTP. Wiesz jak działa ten protokół, wiesz czym są zasoby. Poznałeś różnicę pomiędzy URI a URL. Znasz mechanizm działania nagłówków, poznałeś też główne statusy odpowiedzi. Moim zdaniem, poznając to wszystko wyszedłeś poza podstawową wiedzę na temat tego protokołu.   Zapowiadało się niewinnie a wyszedł tasiemiec. Sporo napracowałem się przy tym artykule, więc będę Ci bardzo wdzięczny za udostępnienie go dalej :).   Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Trzymaj się! :)                 Ot, taki “patriotyzm lokalny” – aktualnie pracuję w firmie Opera Software ;). &#8617;                  To czy wielkość liter jest rozróżniana zależy od aplikacji obsługującej dane żądanie. &#8617;                  Potrafię sobie wyobrazić wyjątki od tej reguły. Na przykład w komunikacji, w której adres URL jest przesyłany zaszyfrowanym kanałem. &#8617;                  Na jedno żądanie serwer może wysłać kilka odpowiedzi, na przykład dzieląc dużą odpowiedź na kilka mniejszych. &#8617;                  RFC5789 rozszerza tę grupę o czasownik PATCH. &#8617;                  Tutaj podobnie jak z webservice’em postanowiłem nie tłumaczyć tego określenia. Jest ono na tyle powszechne, że nawet nie wiem jakie byłoby dobre tłumaczenie. Schowek? Skrytka? ;) &#8617;                  W większości przypadków, specyfikacja dopuszcza wyjątki od tej reguły. &#8617;                  Ciasteczka nie są jedynym narzędziem używanym do śledzenia użytkownika. Podobnie sprawa wygląda z reklamami, to nie tylko ciasteczka mogą służyć do wybierania tych do wyświetlenia dla Ciebie. &#8617;           ","categories": ["Kurs aplikacji webowych"],
        "tags": [],
        "url": "/protokol-http/",
        "teaser": "/assets/images/2018/02/08_protokol_http_artykul.jpg"
      },{
        "title": "Samouczek na rozmowie – czy liczba jest cykliczna",
        "excerpt":"     To jest artykuł z serii “Samouczek na rozmowie”. W ramach tej serii staram się, między innymi, rozwiązywać zadania. Zadania te często zdarzają się na rozmowach kwalifikacyjnych.   W trakcie rozwiązywania takich zadań umiejętność szacowania złożoności obliczeniowej jest niezwykle ważna. Przyda się też umiejętność pisania testów jednostkowych. Dzięki nim bardzo łatwo przetestujesz działanie algorytmu.      Podstawy złożoności obliczeniowej,   Test Driven Development na przykładzie,   Testy jednostkowe z JUnit,   Podstawą jest oczywiście znajomość języka programowania, ja używał będę Javy jednak możesz użyć dowolnego języka programowania. W opisie problemu czasami będę używał “pseudo kodu”. Przykładowe rozwiązania będą w języku Java.      Kurs programowania w języku Java.     Czym jest liczba cykliczna   Zanim przejdę do treści zadania musisz wiedzieć czym jest liczba cykliczna. Liczba cykliczna to liczba całkowita, której cykliczne permutacje cyfr są możliwe do uzyskania przez mnożenie liczby przez kolejne liczby naturalne. Przykładową liczbą cykliczną jest 142857. Wyniki mnożenia tej liczby przez pierwsze 6 liczb naturalnych dają jej permutacje cykliczne:   142857 * 1 = 142857 142857 * 2 = 285714 142857 * 3 = 428571 142857 * 4 = 571428 142857 * 5 = 714285 142857 * 6 = 857142         Permutacja cykliczna może brzmieć jak coś skomplikowanego. W praktyce powstaje ona przez wstawianie pierwszego elementu danego łańcucha na koniec. Na przykład permutacjami cyklicznymi łańcucha znaków abcd są:      abcd   bcda   cdab   dabc     Zadanie do wykonania   Napisz funkcję isCyclic, która jako argument dostaje dowolnie dużą dodatnią liczbę całkowitą w postaci łańcucha znaków. Liczba może być poprzedzona zerami, więc \"0123\" jest poprawnym wejściem programu. Zadaniem jest napisanie funkcji isCyclic, która sprawdzi czy dana liczba jest liczbą cykliczną.   isCyclic(\"142857\") == true isCyclic(\"012233\") == false   W przykładzie pierwsza liczba jest liczbą cykliczną. Druga linijka pokazuje przykład, dla którego isCyclic powinna zwrócić wartość false.   Od czego zależy złożoność   W przypadku tego zadania danymi wejściowymi jest łańcuch znaków. W zadaniach tego typu długość takiego łańcucha używana jest do szacowania złożoności obliczeniowej i pamięciowej. Zatem n użyte poniżej odnosi się właśnie do długości wejściowego łańcucha znaków.   Najprostsze rozwiązanie problemu   Zacznę od najprostszego rozwiązania problemu. Parametrem funkcji jest łańcuch znaków reprezentujący liczbę. Żeby zobaczyć czy ta liczba jest cykliczna wygeneruję wszystkie jej permutacje cykliczne i będę sprawdzał czy mnożąc liczbę przez kolejne wartości od 1 do N wynik będzie znajdował się we wcześniej przygotowanych permutacjach. Proszę spójrz na przykładowe rozwiązanie:   public boolean isCyclicNaive(String number) {     String[] permutations = new String[number.length()];      for (int index = 0; index &lt; permutations.length; index++) {         permutations[index] = number.substring(index) + number.substring(0, index);     }      BigInteger value = new BigInteger(number);     String formatString = \"%0\" + number.length() + \"d\";      outerLoop: for (int multiplicator = 2; multiplicator &lt;= number.length(); multiplicator++) {         BigInteger multiplication = value.multiply(BigInteger.valueOf(multiplicator));         String formattedResult = String.format(formatString, multiplication);         for (String permutation : permutations) {             if (formattedResult.equals(permutation)) {                 continue outerLoop;             }         }         return false;     }      return true; }   Pierwsza pętla odpowiedzialna jest za tworzenie permutacji cyklicznych. Wewnątrz drugiej pętli sprawdzam czy mnożąc liczbę przez kolejne wartości od 2 do N uzyskam jedną z wcześniej przygotowanych permutacji. Posługuję się tutaj typem BigInteger aby móc pracować na liczbach większych niż te, które mogę przechowywać w zmiennej typu long.   Złożoność obliczeniowa   Pierwsza pętla ma złożoność Ο(n^2). Dzieje się tak ponieważ metoda substring ma złożoność Ο(n). Kolejna pętla jest zagnieżdżona i ma złożoność Ο(n^3). Tym razem złożoność “psuje” operacja multiply, która ma złożoność obliczeniową Ο(n^2). Więc finalnie złożoność obliczeniowa tego algorytmu to O(n^3).   Złożoność pamięciowa   W przypadku tego algorytmu przechowuję listę permutacji w tablicy. Tablica zawiera N permutacji. Każda permutacja ma długość N. Zatem finalna złożoność pamięciowa to Ο(n^2).   Rozwiązanie bazujące na właściwościach liczb cyklicznych   Czytając o liczbach cyklicznych dowiedziałem się kilku istotnych rzeczy:      liczby cykliczne tworzone są na podstawie liczb pierwszych,   liczba cykliczna zawiera o jedną cyfrę mniej od wartości liczby pierwsza użytej do jej generacji,   liczba cykliczna jest cyklicznym rozwinięciem ułamka 1/liczba pierwsza do generacji.   Mając takie informacje podszedłem do problemu od drugiej strony. Zamiast sprawdzić czy dana liczba jest cykliczna wygenerowałem liczbę, która powstałaby na podstawie dzielenia 1/liczba pierwsza do generacji. Następnie porównuję tak uzyskaną liczbę z tą przekazaną jako argument metody. Jeśli są sobie równe wówczas przekazana liczba jest liczbą cykliczną. Proszę spójrz na implementację:   public boolean isCyclicGeneration(String number) {     int base = 10;     int generatingPrime = number.length() + 1;      StringBuilder representation = new StringBuilder();      int step = 0;     int reminder = 1;     do {         step++;         int currentValueToDivide = reminder * base;         int currentDigit = currentValueToDivide / generatingPrime;         reminder = currentValueToDivide % generatingPrime;         representation.append(currentDigit);     } while (reminder != 1 &amp;&amp; step &lt; generatingPrime);      return number.equals(representation.toString()); }   Na początku ustawiam niezbędne zmienne. Następnie wewnątrz pętli obliczam kolejne wartości ułamka. Tak uzyskane liczby dodaję do bufora representation, który następnie porównuję z przekazaną liczbą.   Warunek reminder != 1 wykrywa wystąpienie okresu w rozwinięciu dziesiętnym ułamka. Więcej na temat “okresu ułamka” przeczytasz w artykule opisującym liczby zmiennoprzecinkowe.   Warunek step &lt; generatingPrime jest potrzebny, aby uniknąć nieskończonej pętli. Taki przypadek mógłby mieć miejsce jeśli metoda jako parametr otrzymałaby liczbę, która nie jest cykliczna.   Złożoność obliczeniowa   W przypadku tego rozwiązania występuje wyłącznie jedna pętla. Zatem złożoność obliczeniowa tego algorytmu to Ο(n).   Złożoność pamięciowa   Algorytm do działania potrzebuje kilku zmiennych. Jedna z nich, representation, urośnie do długości N. Zatem w tym przypadku złożoność pamięciowa tego algorytmu to O(n).   Bardziej wydajne rozwiązanie problemu   Masz jakiś pomysł? Z chęcią poznam Twoje podejście do rozwiązania tego problemu. Wrzuć swój kod na githuba i podziel się rozwiązaniem. Pamiętaj, żeby przetestować poprawność swojego rozwiązania. Możesz to zrobić przy pomocy testów jednostkowych, które przygotowałem.   Wyślij mi swoje zadanie   Zadanie omówione w tym artykule zostało przesłane przez jednego z czytelników. Jeśli chcesz abym spróbował omówić zadanie, na które Ty trafiłeś daj znać. Zastrzegam jednak, że nie jestem alfą i omegą. Potrafię sobie wyobrazić problemy, na które nie znajdę najlepszego rozwiązania. Niemniej jednak postaram się rozwiązać to zadanie w najlepszy znany mi sposób. Zadania możesz wysłać na mój adres e-mail marcin [małpka] samouczekprogramisty.pl.     Często firmy zastrzegają sobie to, żeby nie rozpowszechniać zadań, które były na rozmowie kwalifikacyjnej. Jeśli tak było w Twoim przypadku proszę uszanuj wolę danej firmy i nie przesyłaj mi takiego zadania.   Dostając zadanie od Ciebie zakładam, że mogę je opublikować na blogu.     Podsumowanie   Po przeczytaniu artykułu znasz dwa sposoby rozwiązania zadanego problemu. Znasz złożoność pamięciową i obliczeniową każdego z rozwiązań. Jesteś o jedno zadanie lepiej przygotowany do rozmowy kwalifikacyjnej ;).   Przykładowe rozwiązania, przedstawione w artykule znajdziesz na samouczkowym githubie. Kod zawiera także testy jednostkowe, których użyłem do weryfikacji poprawności działania algorytmów.   Jeśli nie chcesz pominąć kolejnych artykułów z tej serii dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Jak zwykle, jeśli masz jakiekolwiek pytania proszę zadaj je w komentarzach. Postaram się pomóc ;). Do następnego razu!  ","categories": ["Samouczek na rozmowie","Strefa zadaniowa"],
        "tags": [],
        "url": "/samouczek-na-rozmowie-czy-liczba-jest-cykliczna/",
        "teaser": "/assets/images/2018/02/16_rozmowa_kwalifikacyjna_liczba_cykliczna_zadanie_artykul.jpg"
      },{
        "title": "Wstęp do relacyjnych baz danych",
        "excerpt":"Czym jest baza danych   Baza danych to zbiór danych zapisanych w odpowiednim formacie. Format zapisu danych pozwala na dostęp do danych. W zależności od zastosowania dane zapisywane są w różny sposób. Sposób zapisu danych ma wpływ na wydajność poszczególnych operacji (zapisu, odczytu, usunięcia i modyfikacji danych).   Istnieje wiele rodzajów baz danych. Jednym z najbardziej popularnych jest relacyjna baza danych. Określenie relacyjna baza danych opisuje bazę danych, w której dane zapisane są w postaci tak zwanych krotek. Krotki mają swoje atrybuty. Każda krotka zapisana jest w relacji.   Operacje w relacyjnych bazach danych oparte są o algebrę relacji. Dostęp do danych możliwy jest dzięki użyciu SQL (ang. Structured Query Language). SQL to język charakterystyczny dla baz danych.   Możesz spotkać się z wieloma implementacjami relacyjnych baz danych. Kilka najczęściej używanych implementacji możesz znaleźć poniżej:      PostgreSQL,   MySQL,   SQLite,   Oracle,   SQL Server,   HyperSQL.   Bazy danych różnią się między sobą implementacją. Różnią się także wersją SQL, którą obsługują. Chociaż istnieje standard opisujący język SQL występują drobne różnice pomiędzy SQL obsługiwanym przez poszczególne bazy danych. Różne wersje SQL nazywane są dialektami.     Samouczek Programisty jest jednym z partnerów konferencji infoShare 2018.   infoShare 2018 to konferencja technologiczna odbywająca się 22-23 maja w Gdańsku. Na developerów czekają m.in. prelekcje z obszaru cybersecurity i machine learning, live coding oraz spotkania ze specjalistami, takimi jak: Filip Wolski, Trent McConaghy, Piotr Konieczny, Zbigniew Wojna czy Scott Helme. infoShare to także okazja do networkingu i udziału w imprezach towarzyszących. Sprawdź agendę i zarejestruj się na www.infoshare.pl.        Jak działa relacyjna baza danych   Bazy danych używane w środowiskach produkcyjnych składają się z wielu komponentów. W dużym uproszczeniu można powiedzieć, że zawsze występują dwa: klient bazy danych i serwer bazy danych. Serwer bazy danych to program, który potrafi obsłużyć żądania wysyłane przez klienty. Serwer odpowiedzialny jest za zapisywanie i udostępnianie danych przechowywanych w bazie.   Serwer używa pewnego portu, na którym nasłuchuje żądań od klientów. Na przykład PostgreSQL domyślnie używa portu 5432.   W większości znanych mi przypadków serwery używają protokołu ODBC (ang. Open Database Connectivity) do komunikacji z klientami. Jest to protokół, który zapewnia spójny dostęp do danych, niezależny od serwera bazy danych. Sewery udostępniają także protokół JDBC (ang. Java Database Connectivity).   Klienty wskazują serwer, z którym chcą się połączyć za pomocą URL. W przypadku bazy danych PostgreSQL URL może wyglądać następująco:   jdbc:postgresql://some.server.host:5432/database_name   URL ten służy do połączenia się do serwera some.server.host na porcie 5432 używając protokołu jdbc:postgresql. database_name wskazuje bazę danych do której chcemy się połączyć. Jeśli chcesz przeczytać więcej o URL odsyłam Cię do artykułu na temat protokołu HTTP.   Do obsługi takiego połączenia klient potrzebuje odpowiedniego sterownika. Sterownik to klasa obsługująca połączenie. Producenci bazy danych udostępniają takie sterowniki.   Klienty używając języka SQL wysyłają żądania do serwera. Dotyczą one dostępu do danych zapisanych w bazie. Wcześniej wspomniany sterownik obsługuje komunikację pomiędzy klientem a serwerem.   Serwer interpretuje te zapytania i pobiera dane z plików zachowanych na dysku serwera1. Następnie dane te są zwracane do klienta, po czym sterownik interpretuje dane przekazane zgodnie z protokołem, np. JDBC.   Bardzo często zapytanie SQL zwraca przetworzone dane do klienta. Przetwarzanie surowych danych odbywa się po stronie serwera relacyjnej bazy danych.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Model relacyjny   Za modelem relacyjnym stoi algebra relacji. Jest to matematyczny opis operacji wykonywanych na danych zachowanych w bazie. Możesz w nim przeczytać o sumie zbiorów, iloczynie kartezjańskim etc. Postaram się wytłumaczyć sposób działa baz bez użycia takich pojęć.   Na potrzeby tego artykułu posłużę się wcześniej wspomnianym przykładem magazynu. Załóżmy, że w tym przypadku bazę danych możemy opisać kilkoma zdaniami:      W magazynie przechowujemy różne rodzaje towarów,   Poszczególne towary produkowane są przez różnych producentów,   Różni hurtownicy pobierają różne towary z magazynu,   Każdy producent ma jednego opiekuna handlowego.   Encja   Zrób proste ćwiczenie. Wybierz wszystkie rzeczowniki z listy, którą umieściłem wyżej. Możesz ją porównać z tą listą:      magazyn,   towar,   producent,   hurtownik,   opiekun handlowy.   Można powiedzieć, że encje to rzeczowniki wyjęte z opisu bazy danych ;). Encje to rodzaje “obiektów” przechowywanych w bazie. Na przykład towar, czy producent. Odpowiednikiem encji w programowaniu obiektowym jest klasa. Zatem w przypadku bazy danych opisującej magazyn występuje pięć rodzajów encji.   Sama encja nie jest ściśle związana z modelem relacyjnym. Definicja ta jest jednak używana w trakcie projektowania baz danych.   Atrybut   Każda z encji ma swoje właściwości. Na przykład opiekun handlowy ma numer telefonu, imię czy nazwisko. Każdy z tych elementów to atrybut. Podobnie jak w programowaniu obiektowym instancje mają swoje atrybuty.   Podobnie jak w języku programowania tak i tutaj atrybuty mają swoje typy. Relacyjne bazy danych obsługują różne typy. W większości przypadków typy z języków programowania mają swoje odpowiedniki w typach w bazie danych. Na przykład:                  Typ w języku Java       Typ w PostgreSQL                       String       varchar                 boolean       boolean                 double       double precision                 byte[]       bytea                 int       integer           Istnieją jednak typy, które nie mają swojego dokładnego odwzorowania w niektórych językach programowania, na przykład:      box,   decimal(p, s),   polygon.   Te różnice pokazują, że nie zawsze da się przenieść świat relacyjnej bazy danych do świata programowania obiektowego. Tematyce mapowania obiektowo-relacyjnego (ang. object-relational mapping) poświęcę osobny artykuł.   Krotka   Krotka to zbiór atrybutów. Upraszczając można powiedzieć, że krotka w modelu relacyjnym odpowiada instancji obiektu w programowaniu obiektowym2. Krotki często prezentowane są w postaci wiersza w tabeli gdzie każda kolumna odpowiada poszczególnym atrybutom.   Przykładem krotki zawierającej towar może być:                  Nazwa varchar       Stan magazynowy integer       Cena double precision                       trampki       10       99.99           Relacja   W relacyjnym modelu bazy danych relacją określamy zbiór krotek. Skoro pojedyncza krotka to wiersz w tabeli, to zbiór krotek to cała tabela :). Istnieją różne konwencje nazywania relacji. W dalszej części artykułu będę używał liczby mnogiej od nazwy encji. Dla przykładu relacja przechowująca krotki towar będzie nazywała się towary.   Musisz także wiedzieć, że relacją także możemy określać zależności jakie występują pomiędzy poszczególnymi tabelami. Na przykład tabela towary jest powiązana z tabelą producenci. Producent produkuje różne towary. Zatem pomiędzy producenci a towary występuje relacja jeden do wielu – jeden producent produkuje wiele towarów.   Zbierając kilka krotek, relacja towary może wyglądać następująco:                  Nazwa varchar       Stan magazynowy integer       Cena double precision                       trampki       10       99.99                 sweter       0       299.99                 lizak       2500       0.5                 spinacz       500       0.01           W modelu relacyjnym krotki w relacji nie mogą się powtarzać (elementy w zbiorze są unikalne). W praktyce relacyjne bazy danych posługujące się SQL pozwalają na duplikaty wierszy w tabelach. Sam język SQL pozwala na pobranie unikalnych elementów z danej tabeli.   Klucz główny   Zbiór atrybutów (kolumn w tabeli) tworzy klucz główny. Klucz główny to unikalny identyfikator dla każdego wiersza w tabeli. W większości przypadków tabele zawierają dodatkową kolumnę, która zawiera identyfikator w postaci liczby:                  Id integer (PK)       Nazwa varchar       …                       1       trampki       …                 2       sweter       …                 3       lizak       …                 4       spinacz       …           W tabeli wyżej kolumna Id jest kluczem głównym (ang. primary key). Tworzenie kluczy głównych przy pomocy liczby pozwala na automatyczne tworzenie nowej wartości klucza dla nowego wiersza. Wystarczy podnieść o 1 największą wartość klucza głównego. Klucze główne składające się z wielu kolumn nazywa się kluczami złożonymi.   Bazy danych optymalizują dostęp do danych przy pomocy klucza głównego. Oznacza to tyle, że pobranie wiersza z tabeli towary na podstawie kolumny Id będącej kluczem głównym może być bardziej wydajne niż pobranie tego samego wiersza na podstawie wartości kolumny Nazwa.   Klucz obcy   Wspomniałem wyżej, że tabele mogą być ze sobą powiązane. Te zależności pomiędzy tabelami pokazane są przez klucze obce (ang. foreign key). Klucz obcy to dodatkowa kolumna (lub kolumny), która pokazuje zależność. Na przykład tabela producenci może wyglądać następująco:                  Id integer (PK)       Siedziba varchar       Rok założenia integer                       1       Wrocław       2007                 2       Warszawa       1980                 3       Kraków       1948           Dodatkowa kolumna producent_id znajdująca się wewnątrz tabeli towary pokazuje zależność pomiędzy towarami a producentami:                  Id integer (PK)       Nazwa varchar       Producent id integer (FK)       …                       1       trampki       1       …                 2       sweter       2       …                 3       lizak       3       …                 4       spinacz       3       …           Taka tabela pokazuje, że trampki produkowane są przez producenta z Wrocławia, swetry przez producenta z Warszawy. Producent z Krakowa produkuje lizaki i spinacze.   Rodzaje powiązań   Tabele mogą mieć trzy rodzaje zależności. Każdą z nich opiszę w osobnym podpunkcie.   Jeden do jednego   Przykładem takiej zależności może być samochód – numer rejestracyjny. Każdy numer rejestracyjny przypisany jest do jednego samochodu, podobnie każdy samochód ma tylko jeden numer rejestracyjny. W przypadku magazynu relacją tego typu może być opiekun handlowy – producent. Zależność tego typu reprezentuje dodatkowa kolumna w tabeli:   producenci                  Id integer (PK)       Siedziba varchar       Rok założenia integer                       …       …       …           opiekunowie                  Id integer (PK)       Nazwisko varchar       Producent id integer (FK)                       …       …       …           Kolumna Producent id w tabeli opiekunowie wskazuje na producenta, za którego jest odpowiedzialny dany opiekun.   Jeden do wielu   Przykładem takiej zależności może być producent – towar. Każdy producent produkuje wiele towarów. Innymi słowy każdy towar produkowany jest przez jednego producenta. Podobnie jak w przypadku relacji jeden do jednego zależność tego typu uzyskuje się poprzez dodanie odpowiedniej kolumny:   producenci                  Id integer (PK)       Siedziba varchar       Rok założenia integer                       …       …       …           towary                  Id integer (PK)       Nazwa varchar       …       Producent id integer (FK)                       …       …       …       …           Zauważ, że zarówno zależność jeden do wielu, jak i jeden do jednego możliwa jest przy pomocy pojedynczej kolumny.   Zależność tego typu określa się także jako 1 do n.   Wiele do wielu   Zależność wiele do wielu może występować pomiędzy hurtownikami i towarami. Oznacza ona tyle, że wielu hurtowników zaopatruje się w wiele towarów. Ten sam towar pobierany jest przez wielu hurtowników. W przypadku takiej zależności niezbędna jest dodatkowa tabela, która połączy ze sobą dwie tabele:   towary                  Id integer (PK)       Nazwa varchar       …       Producent id integer (FK)                       …       …       …       …           hurtownicy                  Id integer (PK)       Nazwa hurtowni varchar                       …       …           towary_hurtownicy                  Towar id integer (FK)       Hurtownik id integer (FK)                       …       …           W tym przypadku tabela towary_hurtownicy ma dwa klucze obce. Jeden z nich pokazuje na tabelę towary drugi na hurtownicy. Zauważ, że w przypadku tej tabeli kluczem głównym, który identyfikuje każdy wiersz może być para tych kolumn. Jest to tak zwany klucz złożony.   Zależność tego typu określa się także jako n do m.   Dodatkowe materiały do nauki      Bazy danych – wykłady na UW,   Model relacyjny – artykuł na Wikipedii,   Model relacyjny – wykład na AGH.   Zadanie do wykonania   Dasz radę zaprojektować bazę danych, do przechowania informacji o wykładach w trakcie konferencji? Spróbuj zrobić to na podstawie agendy znajdującej się na stronie infoShare.   Podsumowanie   W dzisiejszym artykule przeczytałeś o bazach danych. Poznałeś sposób komunikacji pomiędzy klientem a serwerem. Dowiedziałeś się czym jest model relacyjny. Wiesz czym jest relacja, krotka czy atrybut w kontekście modelu relacyjnego. Zdobytą wiedzę mogłeś przećwiczyć rozwiązując zadanie do wykonania. Te postawy pozwolą Ci lepiej zrozumieć SQL i mapowanie obiektowo relacyjne.   Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Trzymaj się i do następnego razu!                 Jest to duże uproszczenie. Bazy danych są programami, które są przystosowane do obsługi dużej liczby zapytań. Znane mi relacyjne bazy danych wspierają ACID. Zapytania często podlegają optymalizacji. Przetwarzanie danych zgodnie z zapytaniem SQL to także robota serwera. Czynniki te sprawiają, że dostęp do danych to coś więcej niż zwykłe “pobieranie danych z dysku”. &#8617;                  Nie jest to do końca prawda, na przykład w przypadku relacji wiele do wielu krotki w relacji łączącej nie muszą mieć odpowiadającego im obiektu w języku programowania. &#8617;           ","categories": ["Bazy danych"],
        "tags": [],
        "url": "/wstep-do-relacyjnych-baz-danych/",
        "teaser": "/assets/images/2018/03/06_wstep_do_relacyjnych_baz_danych.jpg"
      },{
        "title": "Projekt Informator wprowadzenie",
        "excerpt":"Projekt Informator   Informator to kolejny większy projekt (po Pogodynce), który będę realizował na blogu. Moim celem jest zaimplementowanie gotowego webservice’u, który przy pomocy REST API będzie zwracał dane w formacie JSON. Projekt będę tworzył w oparciu o biblioteki Spring i Hibernate.   Czym będzie Informator   Informator to projekt, którego głównym celem będzie napisanie webservice’u. Webservice ten będzie miał za zadanie informować o szczegółach konferencji infoShare 2018. Informator za pośrednictwem protokołu HTTP będzie udostępniał dane o wydarzeniu w formacie JSON. Planuję, że będzie on zawierał trzy niezależne “endpoint’y”:      prelegenci,   wykłady/rozmowy/wydarzenia,   sceny.     Samouczek Programisty jest jednym z partnerów konferencji infoShare 2018.   infoShare 2018 to konferencja technologiczna odbywająca się 22-23 maja w Gdańsku. Na developerów czekają m.in. prelekcje z obszaru cybersecurity i machine learning, live coding oraz spotkania ze specjalistami, takimi jak: Filip Wolski, Trent McConaghy, Piotr Konieczny, Zbigniew Wojna czy Scott Helme. infoShare to także okazja do networkingu i udziału w imprezach towarzyszących. Sprawdź agendę i zarejestruj się na www.infoshare.pl.        Prelegenci   Endpoint ten będzie zwracał szczegóły dotyczące prelegentów. Dzięki niemu będzie można dowiedzieć się czegoś więcej o prowadzących.   Wykłady, rozmowy, wydarzenia   Endpoint ten będzie zwracał informacje na temat wydarzeń, które będą miały miejsce w trakcie konferencji. Poza opisem zwracał będzie także informacje takie jak miejsce i czas wydarzenia. Dodatkowo będzie udostępniał informacje o prelegentach/uczestnikach danego wydarzenia.   Sceny   Dzięki temu endpoint’owi będzie można poznać grafik obowiązujący na każdej ze scen.   Architektura i wdrożenie projektu   Ze strony architektonicznej nie jest to skomplikowany projekt. Wręcz przeciwnie, to aplikacja webowa, która wyłącznie serwuje dane zapisane w bazie danych. Celowo nie planuję udostępnienia funkcjonalności modyfikowania czy usuwania danych. Baza danych zasilona będzie statycznymi danymi. Dzięki takiemu podejściu nie muszę implementować mechanizmu uwierzytelniania i autoryzacji. Także walidacja danych wejściowych będzie ograniczona.   Aplikację chcę uruchomić w chmurze. Nie zdecydowałem się jeszcze na konkretnego dostawcę. Na tym etapie nie chcę podejmować decyzji, którego dostawcę wybrać ;). Możliwe, że będzie to Heroku lub Google Cloud.   Prowadzenie projektu   Podobnie jak w przypadku Pogodynki założyłem specjalną listę zadań na Trello. Lista ta będzie ewoluowała w czasie, aktualnie zawiera podstawowe zadania niezbędne do realizacji. Dzięki tej liście i repozytorium kodu na bieżąco będziesz mógł śledzić postęp prac nad projektem.   Zależy mi na uruchomieniu tego projektu do końca kwietnia. Mam nadzieję, że uda mi się dotrzymać terminu, który sobie narzuciłem. Trzymaj kciuki ;).   Testy   Oczywiście projekt zawierał będzie testy jednostkowe, które będą skupiały się na poszczególnych komponentach. Dodatkowo planuję napisać testy integracyjne, które będą sprawdzały poprawność działania mapowania obiektowo-relacyjnego. Założeniem tych testów będzie tworzenie nowej instancji bazy danych w pamięci przed uruchomieniem każdego testu.   Planuję także stworzenie zestawu testów integracyjnych. Utworzę je używając SoapUI. Dzięki takiemu podejściu będę miał kompletny zestaw testów automatycznych potwierdzających poprawność działania aplikacji.   Podsumowanie   Projekt Informator jest w powijakach, dopiero zacząłem nad nim pracę. Mam nadzieję, że tym krótkim artykułem zachęciłem Cię do śledzenia rozwoju projektu. Narzędzia i biblioteki, których użyję w trakcie pracy nad Informatorem są bardzo często wykorzystywane w projektach produkcyjnych.   Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć kolejnych artykułów na blogu dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu!  ","categories": ["Projekty","Projekt Informator"],
        "tags": [],
        "url": "/projekt-informator-wprowadzenie/",
        "teaser": "/assets/images/2018/03/20_projekt_informator_wprowadzenie.jpg"
      },{
        "title": "Projekt Informator wdrożenie w chmurze",
        "excerpt":"Projekt Informator   Projekt informator to REST’owy web service, działający w oparciu o Spring i Hibernate. Jeśli chcesz przeczytać więcej o projekcie i jego założeniach zapraszam do wprowadzenia.     Samouczek Programisty jest jednym z partnerów konferencji infoShare 2018.   infoShare 2018 to konferencja technologiczna odbywająca się 22-23 maja w Gdańsku. Na developerów czekają m.in. prelekcje z obszaru cybersecurity i machine learning, live coding oraz spotkania ze specjalistami, takimi jak: Filip Wolski, Trent McConaghy, Piotr Konieczny, Zbigniew Wojna czy Scott Helme. infoShare to także okazja do networkingu i udziału w imprezach towarzyszących. Sprawdź agendę i zarejestruj się na www.infoshare.pl.        Czym jest chmura   W uproszczeniu można powiedzieć, że chmura to środowisko, w którym uruchamia się aplikacje. Chmura to zestaw dużej liczby maszyn, które można “wynająć” na potrzeby swoich aplikacji.   W takim środowisku dostawca zapewnia mechanizmy administrowania maszynami i aplikacjami, które są na nich wdrażane (ang. deployed). We wszystkich znanych mi chmurach dostawca pobiera opłaty za wykorzystywane zasoby. To znaczy, że jeśli nasza aplikacja potrzebuje większej liczby maszyn/mocniejszych maszyn, wówczas dostaniemy większy rachunek do zapłacenia.   Dostawcy “rozwiązań chmurowych” oferują różne usługi. W przypadku Informatora używał będę wyłącznie podstawowych maszyn. Dodatkowo aplikacja korzystała będzie z bazy danych udostępnionej w chmurze.   Dostawca rozwiązań chmurowych   W przypadku Informatora, zależało mi wyłącznie na cenie. Chciałem, żeby do moich zastosowań chmura była darmowa :). Jednym z dostawców, który udostępnia maszyny za darmo1 jest Heroku.   Oczywiście istnieją też inni dostawcy. Najwięksi z nich to:     Google Cloud Platform,   Amazon Web Services2,   Microsoft Azure Cloud Computing Platform.   Informator – stan projektu   Aplikacja używa najnowszych wersji biblioteki Spring MVC i Hibernate. W trakcie pisania tego artykułu najnowszymi wersjami były:      Spring 5.0.4   Hibernate 5.2.16   Aktualnie aplikacja to wyłącznie szkielet, który pozwala na pobranie encji z bazy danych i wyświetlenie jej w formacie JSON w odpowiedzi. Zachęcam do sprawdzenia źródeł projektu, pozwolą one zobaczyć przykładową konfigurację bez użycia Spring Boot.   Obecnie aplikacja zawiera jeden endpoint /speakers, który pozwala na pobranie informacji o prelegencie na podstawie identyfikatora. Aby aplikacja mogła pobrać dane z bazy muszą one być do niej wrzucone ręcznie. Na potrzeby testów utworzyłem kilka wierszy w tabeli uzupełniając je przykładowymi danymi:             Przykładowe zapytanie do Informatora        Heroku   Nigdy wcześniej nie wdrażałem aplikacji w Javie na Heroku i muszę powiedzieć, że dostawca ten przygotował bardzo dobrą dokumentację. Poniżej postaram się pokazać jak wygląda proces instalacji aplikacji krok po kroku.   Jak wspomniałem wcześniej, Informator to projekt “hobbystyczny”. W związku z tym, używam wyłącznie darmowe usługi Heroku. Na pewno nie sprawdziłyby się one w przypadku produkcyjnych aplikacji.   Wdrożenie aplikacji na Heroku   Cały proces należy zacząć od utworzenia konta na Heroku. Następnie można dodawać nowe aplikacje:             Dodawanie nowej aplikacji w Heroku                  Nazwanie nowej aplikacji        Następnie w zakładce Resources należy dodać komponent bazy danych. W przypadku Informatora jest to PostgreSQL.             Aktywacja PostgreSQL na Heroku        Zdecydowałem się na instalowanie aplikacji prosto z GitHub’a. Heroku domyślnie pozwala na taką integrację. Wymaga to zezwolenia na GitHub’ie do pobierania informacji o repozytoriach przez Heroku:             Połączenie Heroku z GitHub’em        Sam proces instalacji aplikacji sprowadza się do naciśnięcia przycisku Deploy Branch. Wówczas Heroku pobiera aktualną wersję kodu i próbuje go uruchomić. Aby projekt mógł być uruchomiony na Heroku musi być odpowiednio przygotowany. O tym przygotowaniu przeczytasz w jednym z punktów poniżej:            Instalacja z gałęzi Git’a        Przygotowanie aplikacji do Heroku   Gradle   Do budowania Informatora używam Gradle. W przypadku tego projektu użyłem także webapp-runner. Dzięki tej bibliotece można uruchomić aplikację przy pomocy komendy java -jar webapp-runner.jar Informator.war. Właśnie ta komenda uruchamiana jest przez Heroku.   Heroku w trakcie instalowania aplikacji3 wywołuje zadanie stage. Definicja tego zadania w build.gradle wygląda następująco:   task stage() {     dependsOn clean, war } war.mustRunAfter clean  task copyToLib(type: Copy) {     into \"$buildDir/server\"     from(configurations.compile) {         include \"webapp-runner*\"     } }  stage.dependsOn(copyToLib)  tasks.stage.doLast() {     delete fileTree(dir: \"build/distributions\")     delete fileTree(dir: \"build/assetCompile\")     delete fileTree(dir: \"build/distributions\")     delete fileTree(dir: \"build/libs\", exclude: \"*.war\") }   Konfiguracja ta zapewnia, że plik webapp-runner.jar będzie znajdował się w katalogu build/server. Dodatkowo każde uruchomienie stage zapewni zbudowanie pliku war na nowo. Aby biblioteka webapp-runner była dostępna trzeba dodać ją do zależności:   dependencies {     compile 'com.github.jsimone:webapp-runner:8.5.29.0' }   Plik Procfile   Procfile to plik konfiguracyjny wymagany przez Heroku. Wewnątrz tego pliku znajdują się komendy, które określają jak mają zachować się maszyny w trakcie instalowania aplikacji. Heroku działa w oparciu o tak zwane kontenery nazywane “dynosami”. Plik Procfile pokazuje komendy jakie mają być uruchomione na poszczególnych kontenerach.   Dla przykładu, kontener odpowiedzialny za serwer HTTP uruchamia następujące polecenie:   cd build ; java -jar server/webapp-runner-*.jar --expand-war --port $PORT libs/*.war   Polecenie to wywoływane jest po uruchomieniu zadania stage, które opisałem wcześniej. Dzięki tej kolejności na “dynosie” zbudowana jest aplikacja, którą można uruchomić przy użyciu wspomnianego wyżej webapp-runner’a.   Połączenie z bazą danych   Heroku dynamiczne tworzy bazy danych. Informacja gdzie dokładnie ta baza danych się znajduje przechowywana jest w zmiennej środowiskowej. Zmienna środowiskowa, która zawiera URL do bazy danych nazywa się JDBC_DATABASE_URL4. Zmienna ta powinna być użyta do utworzenia instancji DataSource:   @Bean DataSource dataSource() {     DriverManagerDataSource dataSource = new DriverManagerDataSource();     dataSource.setDriverClassName(\"org.postgresql.Driver\");     dataSource.setUrl(System.getenv(\"JDBC_DATABASE_URL\"));      return dataSource; }   Podsumowanie   Aktualnie aplikacja to szkielet, na którym będę dobudowywał kolejne funkcjonalności. Główny etap konfiguracji jest już ukończony. Po przeczytaniu tego artykułu i przejrzeniu kodu źródłowego wiesz w jaki sposób zainstalować aplikację opartą o Spring MVC i Hibernate na Heroku. Jeśli nie robiłeś tego nigdy wcześniej zachęcam do samodzielnych prób, wtedy nauczysz się najwięcej.   Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Proszę podziel się linkiem do artykułu ze znajomymi, którym może on pomóc. Może to dzięki Tobie uda mi się dotrzeć do nowych czytelników? ;)   Do następnego razu!                 Oczywiście są tu ograniczenia, firma też musi na czymś zarabiać ;). &#8617;                  Tak właściwie to Heroku używa AWS do oferowania swoich usług. &#8617;                  Dokładny sposób uruchamiania zależy m.in. od narzędzia użytego do budowania projektu. &#8617;                  W zależności od sposobu łączenia się z bazą danych można użyć jednej z kilku zmiennych, na przykład DATABASE_URL czy SPRING_DATASOURCE_URL. &#8617;           ","categories": ["Projekty","Projekt Informator"],
        "tags": [],
        "url": "/projekt-informator-wdrozenie-w-chmurze/",
        "teaser": "/assets/images/2018/04/03_projekt_informator_wdrozenie_w_chmurze.jpg"
      },{
        "title": "Testy jednostkowe z JUnit 5",
        "excerpt":"     Jest to kolejny artykuł poświęcony tematyce testów, który napisałem na Samouczku. Zachęcam Cię także do przeczytania poprzednich artykułów:      Testy jednostkowe z JUnit 4 – artykuł wprowadza w świat testów. Przeczytasz w nim między innymi o tym czym są asercje czy po co piszemy testy. Jeśli nie pisałeś wcześniej testów to tutaj powinieneś zacząć,   Test driven development na przykładzie – artykuł o podejściu do pisania testów nazywanym test driven development. Opisuję w nim cały cykl RED, GREEN, REFACTOR popierając go przykładami.   W tym artykule będę zakładał, że wiesz czym są testy. W treści artykułu czasami będę porównywał wersję JUnit 5 z poprzednią, jednak znajomość JUnit 4 nie jest niezbędna.     Testy jednostkowe z JUnit 5   Powody powstania JUnit 5   JUnit 4 to monolit. Jeden plik JAR (ang. Java Archive), który zawiera całą bibliotekę. Ten plik zawiera między innymi:      klasy odpowiedzialne za wyszukiwanie testów,   klasy odpowiedzialna za uruchamianie testów,   klasy zawierające API do pisania testów (np. @Test czy implementacje asercji).   Jak widzisz łamie to jedną z podstawowych reguł dobrego podejścia do tworzenia kodu obiektowego: rób jedną rzecz i rób ją dobrze1.   Poza tym IDE do uruchamiania testów i wyświetlania wyników używały prywatnej implementacji. Między innymi z tych powodów ewolucyjne rozwijanie biblioteki JUnit nie było możliwe. Nawet zmiana niektórych atrybutów powodowała, że IDE błędnie wyświetlało wyniki testów. Z tego powodu powstała inicjatywa rozwijania kolejnej wersji tej biblioteki.   JUnit 5 jako platforma   JUnit 5 to trzy niezależne komponenty2:      platforma do uruchamiania testów: JUnit Platform,   API używane do pisania testów: JUnit Jupiter,   API używane do uruchamia testów napisanych w starszych wersjach JUnit na platformie JUnit 5: JUnit Vintage.   W swojej codziennej pracy używa się JUnit Jupiter, czyli samego API, które pozwala na tworzenie testów. To właśnie JUnit Jupiter zawiera adnotacje, który są niezbędne w trakcie pisania testów. W trakcie uruchamiania testów pośrednio używa się też JUnit Platform, na przykład uruchamiając testy w IDE.   Pierwszy test jednostkowy z JUnit 5   Projekt będę budował przy użyciu Gradle. Przykładowy test będzie służył do sprawdzenia, programu odpowiedzialnego za konwersję jednostek wagi. Każda z jednostek implementowała będzie interfejs znacznikowy WeightUnit:   public interface WeightUnit {     int SCALE = 4;     RoundingMode ROUNDING_MODE = RoundingMode.CEILING; }   Klasa Pound reprezentuje funty:   public class Pound implements WeightUnit {     public static final BigDecimal POUND_TO_KILOGRAM_RATIO = new BigDecimal(\"0.453592\").setScale(SCALE, ROUNDING_MODE);      public final BigDecimal value;      public Pound(BigDecimal value) {         if (BigDecimal.ZERO.compareTo(value) &gt; 0) {             throw new IllegalArgumentException(\"Weight can't be negative!\");         }         this.value = value.setScale(SCALE, ROUNDING_MODE);     }      public Kilogram toKilograms() {         return new Kilogram(value.multiply(POUND_TO_KILOGRAM_RATIO).setScale(SCALE, ROUNDING_MODE));     } }   Jej odpowiednik dla kilogramów to klasa Kilogram:   public class Kilogram implements WeightUnit {     public final BigDecimal value;      public Kilogram(BigDecimal value) {         if (BigDecimal.ZERO.compareTo(value) &gt; 0) {             throw new IllegalArgumentException(\"Weight can't be negative!\");         }         this.value = value.setScale(SCALE, ROUNDING_MODE);     }      public Pound toPounds() {         return new Pound(value.divide(Pound.POUND_TO_KILOGRAM_RATIO, SCALE, ROUNDING_MODE));     } }   Przykładowy zestaw testów może wyglądać następująco:   import org.junit.jupiter.api.Test; import java.math.BigDecimal; import static org.junit.jupiter.api.Assertions.assertEquals;  class UnitConverterTest {     @Test     void shouldConvertZeroKilogramValue() {         Pound pounds = new Kilogram(BigDecimal.ZERO).toPounds();         assertEquals(BigDecimal.ZERO.setScale(4), pounds.value);     }      @Test     void shouldConvertZeroPoundValue() {         Kilogram kilograms = new Pound(BigDecimal.ZERO).toKilograms();         assertEquals(BigDecimal.ZERO.setScale(4), kilograms.value);     }      @Test     void shouldConvert1Pound() {         assertEquals(new BigDecimal(\"0.4536\"), new Pound(BigDecimal.ONE).toKilograms().value);     }      @Test     void shouldConvert1Kilogram() {         assertEquals(new BigDecimal(\"2.2046\"), new Kilogram(BigDecimal.ONE).toPounds().value);     } }   Zwróć uwagę na to, że zarówno klasa UnitConverterTest jak i wszystkie metody nie są publiczne. JUnit 5, w odróżnieniu od swojego poprzednika, nie wymaga aby klasa/metody z testami były dostępne publicznie.   Kolejną różnicą jest pakiet, w którym znajdują się klasy użyte do tworzenia testów: org.junit.jupiter.api. Jest to bazowy pakiet zawierający wszystkie elementy niezbędne do pisania testów.   Metody oznaczone adnotacją @Test to testy. Metody te nie mogą zwracać żadnej wartości, nie mogą być prywatne ani statyczne.   Wewnątrz testów używa się asercji. Asercje dostarczone przez JUnit zgrupowane są wewnątrz klasy Assertions. W przykładach powyżej użyłem asercji assertEquals.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Możliwości JUnit 5   Cykl życia testów   Podobnie jak w poprzedniej wersji JUnit 5 określa cykl życia testów. Dzięki temu możesz odpowiednio przygotować warunki do uruchomienia testów. JUnit tworzy nową instancję klasy przed każdym uruchomieniem testu.   Jeśli chcesz zmienić to zachowanie możesz użyć adnotacji @TestInstance, dzięki tej adnotacji możesz wymusić współdzielenie instancji klasy pomiędzy testami. Moim zdaniem, w większości przypadków nie powinieneś jednak tego robić. Dobrą praktyką jest pisanie testów, które są od siebie niezależne.   Do zarządzania cyklem życia służą następujące adnotacje:      @BeforeEach,   @AfterEach,   @BeforeAll,   @AfterAll.   Zmiana nazwy testu   JUnit 5 pozwala na manipulowanie nazwą testu. Dzięki temu możesz opisać test używając znaków, które nie są dopuszczalne w nazwie metody. Służy do tego adnotacja @DisplayName:   @Test @DisplayName(\"0.1 pounds to kilograms ♥ ♦ ♣ ♠\") void shouldConvertFractions() {     assertEquals(new BigDecimal(\"0.0454\"), new Pound(new BigDecimal(\"0.1\")).toKilograms().value); }   Testowanie wyjątków   W odróżnieniu od JUnit 4, JUnit 5 nie pozwala na określenie oczekiwanego wyjątku w elemencie adnotacji @Test. W nowym podejściu użyte są wyrażenia lambda. Kod, który ma rzucić wyjątek powinien implementować interfejs funkcyjny Executable. W najprostszym przypadku jest to wyrażenie lambda.   Metoda assertThrows przyjmuje:     klasę wyjątku, który powinien być rzucony   implementację interfejsu, która powinna ten wyjątek rzucić:   @Test void shouldntAcceptNegativeWeightInPounds() {     IllegalArgumentException exception = assertThrows(         IllegalArgumentException.class,         () -&gt; new Pound(new BigDecimal(-1))     );     assertEquals(\"Weight can't be negative!\", exception.getMessage()); }   assertThrows zwraca instancję wyjątku, który został rzucony.   Ograniczanie czasu działania testów   JUnit 5 pozwala na testowanie czy wykonanie fragmentu kodu będzie trwało krócej niż założony z góry okres. Służą do tego asercje:      assertTimeout,   assertTimeoutPreemptively.   Obie asercje przyjmują argumenty:     instancję klasy Duration określającą maksymalny czas działania,   implementację interfejsu funkcyjnego Executable, to ten sam interfejs, który jest użyty w przypadku assertThrows.   @Test void shouldTransalteUnitsBlazinglyFast() {     assertTimeout(Duration.ofMillis(10), () -&gt; new Kilogram(BigDecimal.TEN).toPounds()); }   assertTimeout uruchamia przekazany fragment kodu w tym samym wątku i czeka na jego zakończenie. Po zakończeniu sprawdza czy założony czas został przekroczony. assertTimeoutPreemptively uruchamia przekazany fragment kodu w innym wątku i kończy go natychmiast po przekroczeniu założonego czasu.   Zagnieżdżanie testów   JUnit 5 pozwala na wykorzystywanie klas wewnętrznych. Wraz z adnotacjami do zarządzania cyklem życia pozwala to na lepszą organizację testów. Służy do tego adnotacja @Nested. Przykład poniżej pokazuje klasę ExceptionHandling, która zawiera jeden test. Klasa ta jest zagnieżdżona wewnątrz UnitConverterTest:   class UnitConverterTest {     @Test     void shouldConvertZeroKilogramValue() {         Pound pounds = new Kilogram(BigDecimal.ZERO).toPounds();         assertEquals(BigDecimal.ZERO.setScale(44), pounds.value);     }      @Nested     class ExceptionHandling {         @Test         void shouldntAcceptNegativeWeightInPounds() {             IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -&gt; new Pound(new BigDecimal(-1)));             assertEquals(\"Weight can't be negative!\", exception.getMessage());         }     } }   Łączenie kilku asercji   Dobrą praktyką pisania testów jest używanie jednej asercji na każdy test. Takie podejście pozwala zobaczyć wszystkie asercje, które nie zostały spełnione. Prosty przykład poniżej pokazuje tę sytuację. Test jednostkowy, który zawiera te dwie linijki nigdy nie dojdzie do uruchomienia drugiej z nich:   assertTrue(false); assertFalse(true);   Przez to zachowanie nie zobaczysz od razu wszystkich błędnych asercji. JUnit 5 pozwala na obejście tego problemu dzięki użyciu asercji assertAll:   @Test void shouldntAcceptNullValue() {     assertAll(         () -&gt; assertThrows(NullPointerException.class, () -&gt; new Kilogram(null)),         () -&gt; assertThrows(NullPointerException.class, () -&gt; new Pound(null))     ); }   assertAll przyjmuje listę3 implementacji interfejsu Executable. Podobnie jak poprzednio zazwyczaj są to wyrażenia lambda.   W przykładzie powyżej niezależnie od wyniku pierwszej asercji druga także zostanie wywołana. Obie zostaną uwzględnione w wynikach działania testów.   Powtarzanie testów   Zdarzyło mi się pisać testy, które zawierały pętle. Pętle te służyły do powtórzenia dokładnie tego samego testu wielokrotnie. Pisałem takie testy w sytuacji gdy dochodziło do wyścigu i czasami dany test przechodził, czasami nie. JUnit 5 umożliwia pisanie tego typu testów bez użycia pętli. Służy do tego adnotacja @RepeatedTest:   @RepeatedTest(3) void shouldAlwaysReturnTheSameValue() {     assertEquals(new BigDecimal(\"29.4840\").setScale(4), new Pound(new BigDecimal(65)).toKilograms().value); }   W przykładzie powyżej test zostanie wywołany trzy razy.   Ignorowanie testów   JUnit 5 pozwala na ignorowanie testów. Najprostszym sposobem jest dodanie adnotacji @Disabled.   Mechanizm rozszerzeń   JUnit 5 w odróżnieniu od JUnit 4 nie posiada @Rule, @ClassRule czy @RunWith. JUnit5 łączy te funkcjonalności w jedną. Ta funkcjonalność nazywa się rozszerzeniami. Główną adnotacją, która zarządza rozszerzeniami jest @ExtendWith.   Adnotacja jako element akceptuje klasę implementującą interfejs Extension.   Mechanizm rozszerzeń jest głównie wykorzystywany wraz z innymi bibliotekami. Na przykład przez Spring do umożliwienia wstrzykiwania zależności czy przez Mockito do tworzenia mocków.   Przykładowe rozszerzenie   Przykład poniżej pokazuje rozszerzenie, które wyświetla na konsoli napis Samouczek extension :). Rozszerzenie to zostało zaaplikowane do jednego z testów:   public class SamouczekExtension implements BeforeEachCallback {     @Override     public void beforeEach(ExtensionContext context) {         System.out.println(\"Samouczek extension :)\");     } }   @Test @ExtendWith(SamouczekExtension.class) void shouldConvertZeroPoundValue() {     Kilogram kilograms = new Pound(BigDecimal.ZERO).toKilograms();     assertEquals(BigDecimal.ZERO.setScale(4), kilograms.value); }   Tworzenie własnych adnotacji   JUnit 5 pozwala na tworzenie własnych adnotacji poprzez łączenie tych dostarczonych przez bibliotekę. W przykładzie poniżej możesz zobaczyć rozszerzenie, które przytoczyłem wyżej. Tym razem rozszerzenie to jest aplikowane przez dodanie własnej adnotacji @SamouczekBefore do metody z testem:   @Target({ ElementType.TYPE, ElementType.METHOD }) @Retention(RetentionPolicy.RUNTIME) @ExtendWith(SamouczekExtension.class) public @interface SamouczekBefore { }   @Test @SamouczekBefore void shouldConvert1Pound() {     assertEquals(new BigDecimal(\"0.4536\"), new Pound(BigDecimal.ONE).toKilograms().value); }   Takie podejście pozwala na tworzenie bardziej czytelnych testów. Moim zdaniem jednak nie powinno się przesadzać z używaniem tej funkcjonalności. Może ona powodować trudności w zrozumieniu kodu przez programistów, którzy są nowi w danym projekcie.   Uruchamianie testów JUnit 5   Jak wspomniałem wyżej różne narzędzia używały wewnętrznego API biblioteki JUnit do uruchamiania i wyświetlania wyników testów. W związku z tym zmiana wersji biblioteki JUnit wymaga także zmiany w różnych narzędziach. Aby używać JUnit 5 w IDE musi się ono poprawnie integrować z nową wersją biblioteki. Od jakiegoś już czasu główne IDE mają takie wsparcie:      IntelliJ Idea 2016.2   Eclipse Oxygen   JUnit 5 z Gradle   Gradle od wersji 4.6 wspiera natywnie uruchamianie testów przy pomocy JUnit Platform. Dodanie kilku linijek do build.gradle pozwala na uruchamianie testów przy pomocy Gradle:   dependencies {     testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: '5.1.0'     testRuntimeOnly group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.1.0' }  test {     useJUnitPlatform() }   Materiały dodatkowe   JUnit 5 ma bardzo dobrą dokumentację. Na YouTube znajdziesz też całkiem sporo prezentacji, które opisują nowe podejście. Poniżej zebrałem dla Ciebie materiały, które są dobrym uzupełnieniem dla treści artykułu:      Dokumentacja biblioteki JUnit,   Prezentacja z Devoxx prowadzona przez Lead Developer’a biblioteki JUnit,   JUnit 5 z innej perspektywy, integracja ze Spring 5,   Kampania na Indiegogo sponsorująca rozwój JUnit 5,   Kod źródłowy przykładów użytych w artykule.   Zadania do wykonania           Napisz program, który będzie pomagał w prowadzeniu kantoru. Kantor powinien obsługiwać wymianę trzech par walutowych:              PLN – EUR,       PLN – USD,       EUR – USD.           Właściciel kantoru z góry określa przelicznik referencyjny i spread dla każdej pary walutowej. W bardziej rozwiniętej wersji kantor powinien pobierać przelicznik referencyjny używając API. Możesz na przykład użyć tego.       Napisz ten program używając podejścia TDD.            Zrefaktoryzuj kod źródłowy przykładów użytych w artykule tak aby Weight było klasą, której konstruktor akceptuje dwa parametry:              WeightUnit unit – typ wyliczeniowy określający rodzaj jednostki. Powinien mieć wartości POUND i KILOGRAM,       BigDecimal value – wartość wagi w danej jednostce.           Dodatkowo klasa ta powinna zawierać metody:              Weight convert(WeightUnit convertTo) – zwraca instancję Weight reprezentującą wagę w nowej jednostce,       BigDecimal getValue() – zwaraca wagę,       WeightUnit getUnit() – zwaraca jednostkę, w której wyrażona jest waga.           Użyj istniejących testów i metodyki TDD do przeprowadzenia refaktoringu kodu.       Zachęcam Cię do samodzielnego rozwiązania zadań, wtedy nauczysz się najwięcej. Podziel się linkiem do swojego rozwiązania w komentarzu :).   Po rozwiązaniu zadań samodzielnie możesz rzucić okiem na przykładowe rozwiązanie pierwszego zadania. Użyłem w nim biblioteki Mockito, więcej o niej przeczytasz w osobnym artykule na temat pisania testów jednostkowych z użyciem mocków.   Podsumowanie   Po lekturze tego artykułu wiesz czym jest JUnit 5. Znasz komponenty składające się na tę bibliotekę. Rozwiązałeś zadanie, które pozwoliło Ci użyć JUnit 5 w praktyce. Od dzisiaj możesz zacząć pisać testy używając wyłącznie JUnit 5 ;). W artykule tym celowo pominąłem część funkcjonalności udostępnionych przez JUnit 5. Zachęcam Cię do zajrzenia do materiałów dodatkowych, szczególnie dokumentacji.   Jeśli masz jakiekolwiek pytania, proszę zadaj je w komentarzu. Jeśli nie chcesz ominąć kolejnych artykułów na blogu dopisz się do samouczkowego newslettera i polub Samouczka na Facebook’u. Do następnego razu!                 W oryginale SRP (ang. Single Responsibility Principle) to pierwsza literka z akronimu SOLID. &#8617;                  Komponenty te są także podzielone na mniejsze elementy dystrybuowane w osobnych plikach JAR. &#8617;                  Metoda assertAll jest przeciążona i akceptuje różne rodzaje parametrów, zaczynając od “varargs” a na strumieniach kończąc. &#8617;           ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "/testy-jednostkowe-z-junit5/",
        "teaser": "/assets/images/2018/04/13_testy_jednostkowe_z_junit5.jpg"
      },{
        "title": "Książki dla programistów",
        "excerpt":"Dlaczego warto czytać książki   W trakcie prowadzenia bloga zauważyłem, że dobre przedstawienie materiału jest kluczowe. Można mieć ogromną wiedzę i jednocześnie nie móc jej sensownie przekazać. Moim zdaniem książki to dobre źródło zorganizowanej wiedzy. Autor książki musi włożyć sporo wysiłku w przygotowanie materiału w taki sposób, aby był przejrzysty i dobrze zorganizowany.   Książki są przydatne, jednak nie powinieneś na nich poprzestawać. Blogi, dokumentacja techniczna, grupy dyskusyjne, praktyczne eksperymentowanie itp. to wszystko powinno pomóc Ci być na bieżąco. Sam pracuję zawodowo jako programista od 2007 roku, cały czas uczę się nowych rzeczy, książki są tu bardzo pomocne.   Po polsku czy po angielsku   Książki techniczne mają to do siebie, że w oryginale pisane są po angielsku (w ogromnej większości). Angielski to język, którego używa się na co dzień w pracy w branży IT. Często książki, które są tłumaczone na język polski są nieaktualne1. W Polsce wychodzi pierwsza edycja po polsku, a po angielsku jest już jej nowsza wersja. Moim zdaniem, właśnie z tego powodu, książki techniczne warto czytać po angielsku. Dodatkowo w trakcie lektury można podszlifować trochę znajomość tego języka i poznać słownictwo techniczne.   Zestaw książek   Książki, które tutaj prezentuję to subiektywny wybór tych, które najbardziej zapadły mi w pamięć. Część z nich to “klasyki”, które ugruntowały swoją pozycję. Nie jest to lista kompletna i zawiera tytuły, na które natknąłem się pracując jako programista Java.   Część z linków do książek to tak zwane linki afiliacyjne. Oznacza to tyle, że jeśli kupisz książkę używając tych odnośników cena książki dla Ciebie się nie zmienia, a ja mogę dostać prowizję za przyprowadzenie nowego klienta do sklepu (jeśli nie miałeś wcześniej konta w sklepie).   Prowadzenie projektu   The Mythical Man-Month – Frederick P. Brooks             The Mythical Man-Month – Frederick P. Brooks        Zgadnij, ile ta książka ma lat?   Przedmowa do pierwszego wydania była napisana w 1974 roku. Bez mała pół wieku. Tak, to książka o IT, gdzie biblioteki i narzędzia zmieniają się częściej niż pory roku. A ta książka cały czas ma rację bytu. To w niej przeczytałem o tym, że dokładanie ludzi do już spóźnionego projektu opóźni go jeszcze bardziej. Przykłady odnoszące się do technologii mogą być przeterminowane, jednak książkę nadal warto przeczytać.   Death March – Edward Yourdon             Death March – Edward Yourdon        Do tej książki mam sentyment :). Opisuje projekt, w którym pracowałem. Tytułowy marsz śmierci, wszyscy wiedzą o nierealnych terminach, wymaganiach itp. a i tak brną dalej.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Architektura i wzorce projektowe   Design Patterns – Gamma, Helm, Johnson, Vlissides             Design Patterns – Gamma, Helm, Johnson, Vlissides        Możliwe, że słyszałeś o GoF albo Gang of Four. Tak właśnie mówi się o autorach tej książki. Klasyk. Ta książka to encyklopedia wzorców projektowych. Każdy wzorzec ma przykładową implementację, diagramy, powody powstania, inne powiązane wzorce, konsekwencje jego użycia itd.   Patterns Of Enterprise Application Architecture – Martin Fowler             Patterns Of Enterprise Application Architecture – Martin Fowler        Ciężka książka. Dosłownie i w przenośni. Delikatnie mniej encyklopedyczne podejście do wzorców projektowych. Mogę się doczepić do słowa Enterprise, które swego czasu było czymś modnym (jak dzisiaj Blockchain, Data Science czy niedawno Big Data).   W tej książce przeczytasz o wzorcach, których używasz na co dzień w wielu popularnych bibliotekach (Spring czy Hibernate to standardowy przykład).   Dobre praktyki   Clean Code – Robert C. Martin             Clean Code – Robert C. Martin        Książka, która pozwala spojrzeć inaczej na swój kod. Niezależnie od tego jak długo programujesz na pewno znajdziesz w niej opis błędów, które popełniasz. Ja znalazłem sporo swoich. Jeśli Design Patterns to encyklopedia wzorców projektowych, to tę książkę nazwałbym encyklopedią dobrych praktyk przy pracy z kodem źródłowym. Chociaż przykłady pokazane są w języku Java mam wrażenie, że programiści innych języków też mogą z tej książki bardzo dużo wynieść.   Jeśli miałbym Ci wskazać wyłącznie jedną książkę spośród wszystkich, które tu wymieniłem to wybór padłby właśnie na Clean Code.   Test-Driven Development By Example – Kent Beck             Test-Driven Development By Example – Kent Beck        Ta książka otworzyła mi oczy ;). Przerabiając przykłady z tej książki nauczyłem się TDD. Jeśli do tej pory nie miałeś styczności z Test Driven Development mogę śmiało polecić tę książkę.   Refactoring – Martin Fowler             Refactoring – Martin Fowler        Kolejne encyklopedyczne zestawienie. Książka zawiera zbiór możliwych refaktoryzacji. Dodatkowo zobaczysz refaktoryzację przykładowej aplikacji, gdzie autor sukcesywnie poprawia jakość kodu. Po przeczytaniu tej książki praca ze starym kodem nie jest już taka straszna, teraz mam wielką frajdę z polepszania jakości kodu :).   Autor na swoim blogu zapowiedział drugą edycję tej książki. Przykłady w drugiej mają być napisane w JavaScript. Autor planuje poświęcić więcej uwagi refaktoryzacji funkcji2.   Różne   Masterminds of Programming – Federico Biancuzzi             Masterminds of Programming – Federico Biancuzzi        Chciałem zajrzeć do głowy programistów, którym nie dorastam do pięt. Ta książka to zestaw wywiadów z twórcami różnych języków programowania. Przydaje się jako odskocznia od ściśle technicznych tytułów.   The Productive Programmer – Neal Ford             The Productive Programmer – Neal Ford        Moim zdaniem ta książka przyda się głównie początkującym programistom. Jeśli nie słyszałeś wcześniej o DRY, czy YAGNI to ta książka może Ci pomóc. Książka opisuje kilka dobrych praktyk, pomagających w organizacji pracy programisty. Jeśli jednak masz już za sobą kilka lat programowania prawdopodobnie znasz większość wspomnianych tu wskazówek.   Książki dotyczące Javy   Poniższych książek nie mam już w swojej prywatnej biblioteczce. Głównie dlatego, że były mi przydatne na etapie uczenia się języka Java, teraz już nie są. Drugim powodem jest to, że się przeterminowały. Jak ja czytałem te książki Java 5 to była nowość ;). Niemniej jednak, opiszę Ci książki, które mi pomogły – może znajdziesz inne pozycje tych samych autorów.           Head First Servlets and JSP – Basham, Sierra, Bates - Książka jest przegadana, ma ponad 900 stron. Przepraszam, przerysowana ;). Jeśli szukasz “łopatologicznego” wytłumaczenia jak działają strony JSP czy serwlety to może to być dobre źródło. Jeśli nie lubisz rysunków w książce pomiń tę pozycję.            Java Puzzlers – Bloch, Gafter – Przypomina mi się moja pierwsza praca. Właśnie tam z kolegami z zespołu przerabialiśmy tę książkę. Książka to zestaw “pułapek”, które pokazują zachowanie Javy, które jest czasami bardzo dziwne. Niestety książka nie doczekała się nowego wydania więc polecam ją jedynie jako ciekawostkę.            Java od podstaw do technologii – Krzysztof Barteczko – Jest to jedyna książka po polsku, którą wspomniałem. To z tej książki nauczyłem się składni języka Java. Szczególnie pierwszy tom był przydatny.       Effective Java – Joshua Bloch   Świetny podręcznik do poznania języka Java. Pamiętam, że czytałem między innymi tę książkę przygotowując się do certyfikatu z języka Java. Jest to wyjątek od trzech tytułów wspomnianych wyżej, ten doczekał się nowego wydania. Niestety nie miałem przyjemności czytać tego najnowszego, jednak tego autora można spokojnie polecić :).   Co teraz czytam?   Do niedawna byłem w trakcie czytania 3 książek jednocześnie. Bardzo mocno staram się oduczyć tego podejścia. Więc na dzisiaj na tapecie mam jedną książkę ;).   The Go Programming Language – Donovan, Kernighan             The Go Programming Language – Donovan, Kernighan        Aktualnie w wolnych chwilach uczę się nowego języka, tym razem padło na Go. Chociaż nie przeczytałem całej książki muszę powiedzieć, że jest świetna. Nie jest ona jednak kierowana do początkujących programistów. Prezentowane przykłady i sposób wprowadzania materiału zakładają, że Go nie jest pierwszym językiem, którym czytelnik się posługuje.   Podsumowanie   W jednym zdaniu: książki warto czytać.   Jeśli Twoim zdaniem pominąłem jakieś ważne pozycje proszę daj znać w komentarzach. Twoja rekomendacja na pewno przyda się nie tylko mi. Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu!                 Oczywiście nie jest to prawda dla niektórych tytułów, które są “ponadczasowe” ;). &#8617;                  W JavaScript funkcje są tak zwanymi obiektami first class, w Javie można porównać je do wyrażeń lambda. &#8617;           ","categories": ["Wiedza ogólna"],
        "tags": [],
        "url": "/ksiazki-dla-programistow/",
        "teaser": "/assets/images/2018/04/23_ksiazki_dla_programistow.jpg"
      },{
        "title": "Zmiana branży – zostań programistą",
        "excerpt":"Zmiana branży, czyli jak zostać programistą   Oto kilka z najczęściej zadawanych mi pytań przez czytelnika Samouczka:      Czy mogę się przebranżowić?   Czy nie jestem na to za stary?   Czy po ukończeniu kursu X będę mógł zostać programistą?   Niestety na pytania tego typu nie mam dobrych odpowiedzi. Głównie dlatego, że sam jestem informatykiem z wykształcenia. Więc moje odpowiedzi na te pytania to domysły1. Nie lubię takich odpowiedzi :). Dlatego właśnie poprosiłem o pomoc osoby, które się przekwalifikowały.   Artykuł jest bardzo długi, jednak gorąco zachęcam do przeczytania całości. Chłopaki mają naprawdę ciekawe historie, którymi chcieli się anonimowo podzielić.   Czasami znajdziesz też mój komentarz dotyczący punktu widzenia prezentowanego przez chłopaków. Będzie on umieszczony w ramce takiej jak ta.   Osoby, którym się udało   Tomek   Tomek ma 32 lata, zanim został programistą był marynarzem z wykształcenia. Sfrustrowany dorywczymi pracami po odejściu z morza zdecydował się zostać programistą. Zaczął od C#, aktualnie pracuje z JavaScript.   O tym jak marynarz został programistą      Czym zajmowałeś się wcześniej? W jakim zawodzie pracowałeś? Kim jesteś z wykształcenia?    Z wykształcenia jestem marynarzem. Skończyłem nawigację w Szkole Morskiej w Gdyni, przez siedem lat pracowałem aktywnie w zawodzie. Najpierw jako marynarz pokładowy, później jako oficer. Oprócz tego pracowałem też w handlu, na infolinii i nawet jako picker w magazynie w Wielkiej Brytanii.      Miałeś wcześniej styczność z programowaniem?    Minimalną. W liceum napisałem kilka aplikacji w C++ uruchamianych w linii poleceń. Zrobiłem też jakiś podstawowy kurs online HTML i CSS, który sobie odświeżyłem rok przed rozpoczęciem przebranżawiania.      Ile czasu poświęciłeś na przekwalifikowanie się (ile godzin dziennie/tygodniowo się uczyłeś)?    Przez pierwsze 5 miesięcy poświęcałem na naukę od 4 do 12 godzin dziennie. Przez następne dwa miesiące, około 20 godzin tygodniowo.   5 * 30 * 8h + 2 * 4 * 20h = 1200h + 160h = 1360h. W pierwszych siedmiu miesiącach swojej nauki poświęcił na nią około 1400 godzin. Przebranżowienie jest możliwe, ale wymaga dużo pracy.      Jak długo przygotowywałeś się przed wysłaniem pierwszego CV?    W ogóle. Pełen żywioł. Zadanie rekrutacyjne robiłem trzy dni, poznając przy okazji cud natury jakim jest Stack Overflow oraz ból związany z szukaniem dangling comma przez dwie doby. Czytanie konsoli to była dla mnie magia, której wówczas nie znałem.         Tutaj Tomek miał na myśli prosty błąd, jeden przecinek za dużo. Takie błędy to zmora początkujących programistów. Chociaż bardziej zaawansowani też czasami na coś takiego trafią.   Upór i wytrwałość to cechy, które moim zdaniem są bardzo pożądane u każdego programisty. Przykład Tomka właśnie to pokazuje. Szukanie przecinka przez dwa dni potrafi naprawdę wkurzyć. Znam to, byłem tam…        Kiedy zacząłeś pracować jako programista?    Pierwszą pracę jako Junior Web Developer podjąłem siedem miesięcy po rozpoczęciu nauki.      Dlaczego zdecydowałeś się przekwalifikować?    Po odejściu z morza podejmowałem się każdej pracy, w tym śmieciowej. Pracując na infolinii jednego z operatorów komórkowych stwierdziłem, że naprawdę jestem więcej wart niż te 1400 zł na rękę przy umowie-zlecenie.      Od czego zacząłeś naukę programowania?    Robiłem to bardzo chaotycznie. Od podjęcia decyzji o zmianie branży do faktycznego podjęcia pierwszej pracy minęło siedem i pół miesiąca. Zaczynałem chcąc nauczyć się C#2 i ekosystemu .NET, który miał mi dać podstawy do nauki Javy. Wybrałem te języki, bo bardzo wzbraniałem się przed programowaniem aplikacji webowych, zupełnie nie znając realiów branży, chciałem pisać aplikacje desktop’owe3 i zupełnie nie miałem pojęcia co robię. Nie wiedziałem, że Java to back-end4. Wtedy nie wiedziałem nawet co to back-end!   Myślałem, że rynek jest przesycony, a JavaScript to nie jest “prawdziwe” programowanie. Pech chciał, że mniej więcej po trzech miesiącach nauki znalazłem ogłoszenie na Junior Support Developera ze znajomością jQuery5. Jedno z zadań wymagało użycia jQuery. Pracy nie dostałem, ale spojrzałem na język.   Później pojechałem na wspomniany kurs Javy, absolutne podstawy z linią poleceń. Tak naprawdę nic, czego nie przerobiłem już w C#. Tam też dowiedziałem się, jak rynek wygląda naprawdę i że web, czy to na front-end’zie, czy to na back-end’zie, jest najbardziej rozwojową gałęzią. Dowiedziałem się również, że Javą gardzę absolutnie i nie zamierzam ruszać jej długim kijem. Zostałem przy .NET ;).   Tak szczerze to tego rodzaju “święte wojny” w IT zdarzają się bardzo często. Na początku mojej drogi miałem podobnie jak Tomek, z tym, że odwrotnie. Nie chciałem dotykać niczego co wypuścił Microsoft. Teraz już nie podchodzę do tego tak restrykcyjnie, ale stare przyzwyczajenia zostały.   Następne dwa miesiące spędziłem na dużo mniej intensywnej nauce, około 20 godzin tygodniowo. Nie byłem pewien tego C#, brakowało mi kierunku i miałem wrażenie, że niczego się nie nauczyłem. Poza tym jednym zadaniem rekrutacyjnym w jQuery, nie ruszałem JavaScript’u w ogóle. Podstaw potrzebnych na przebrnięcie rozmowy kwalifikacyjnej nauczyłem się w pociągu relacji Toruń – Szczecin.   Ta podróż trwa około sześciu godzin. To pokazuje, że po zdobyciu podstaw w jednym języku nauka kolejnych jest dużo łatwiejsza. Oczywiście Tomek po tych sześciu godzinach nie był biegłym w JavaScript, ale znał podstawy.      Z jakimi technologiami aktualnie pracujesz?    Jestem Full-stack JavaScript Developerem. Pracuję z JavaScript w dialekcie ES2015+. Znam i nie znoszę TypeScript.  Technologie i biblioteki, które używam to:     front-end – React/Redux + Native, AngularJS, Angular (2+), Cordova, Electron,   back-end – Node.js + Express, Hapi, Sails. Ruszam GraphQL.   Oprócz tego staram się pozostać na bieżąco z katalogiem NPM i miałem różnego rodzaju przygody z rxJS, D3 czy nawet Phaser.      Co sprawiało Ci największe problemy w trakcie przekwalifikowania się? Jak te problemy rozwiązałeś?    Brak kierunku i mentora. Nie miałem nikogo, kto by mi powiedział co dalej. Również tak dość metafizycznie. Stack Overflow wszystkiego nie załatwi, a z doświadczenia wiem, że nic nie zastąpi gumowej kaczki, programowania w parach i sprawdzania kodu (ang. code review).      Jak i gdzie zdobywałeś materiały do nauki? Czy możesz polecić źródła z których korzystałeś? Dlaczego akurat te?       Google, Google i jeszcze raz Google. Trzeba jedynie nauczyć się poprawnego stawiania pytań,   Ucząc się C# korzystałem z legendarnego już (i moim zdaniem słabego) kursu Boba Tabora na Channel 9,   Codeschool nauczyło mnie AngularJS’a,   YouTube,   Pluralsight,   Microsoft daje darmowy, czasowy dostęp do kosmicznej ilości usług (od Azure po właśnie Pluralsight). Jedyny warunek, to mieć konto MS, które zresztą polecam. Głównie ze względu na darmowe Visual Studio For Team and Services. Dzięki temu dostajesz dostęp do prywatnego, nieograniczonego repozytorium Git.      Co ułatwiało Ci naukę? Miałeś jakieś sposoby na łatwiejsze zapamiętywanie?    Godzina nauki, fajka, godzina nauki, pół godziny w HearthStone.   Nie przyznam się ile godzin spędziłem na tej grze, albo na oglądaniu rozgrywek na YouTube… ;)      Jak poszły Ci pierwsze rozmowy? Co sprawiło Ci największy problem?    Wyłganie jakiejkolwiek wiedzy. Nie oszukujmy się – nasza branża cierpi na krytyczny niedobór ludzi, więc samouków są masy. Możliwe, że większość. Praktycznie każdy z nas, prędzej czy później, będzie mieć syndrom oszusta. 90% CV Junior Developer’ów, które widziałem, to stek kłamstw. Sztuka tkwi w zamaskowaniu tego. Nauczysz się tego w trakcie.   To muszę jasno powiedzieć. Uważam, że nie można kłamać w CV. Kłamstwo ma krótkie nogi i nie popłaca. Masz za mało w CV? Popracuj solidnie kolejny miesiąc, dwa i dodaj projekt, który w tym czasie zrealizujesz. Dalej mało? Popracuj kolejny miesiąc, ukończ darmowy kurs na Coursera/Udemy. Dalej mało? Wystąp na lokalnym spotkaniu dla programistów i opowiedz o czymś, czego się nauczyłeś itp.      Gdzie wysłałeś 5-10 pierwszych CV? Jak wybierałeś te firmy?    Nie miałem wówczas konta na LinkedIn, więc wrzuciłem swoje CV na Monster Polska. Dziś “szukam” pracy tylko za pomocą LinkedIn. W profilu mam zaznaczoną otwartość na oferty, więc oferty płyną wartkim strumieniem.   W swojej karierze wysłałem CV na JEDNO ogłoszenie – to z zadaniem rekrutacyjnym w jQuery.   Wiele firm wykorzystuje LinkedIn jako bazę kandydatów. Bardzo często wyszukują potencjalnych pracowników na tym portalu. Otrzymywanie ofert zatrudnienia w ten sposób to norma w branży IT.      Jakie masz wskazówki, rady dla osób, które chcą się przekwalifikować?    Nic odkrywczego. Cierpliwość i wytrwałość. Jeśli masz ten komfort, który miałem ja – potraktuj naukę jak pracę i podchodź do niej tak, jak do etatu: określony z góry czas CODZIENNIE. Opanuj też słowa-klucze, żebyś chociaż brzmiał, że wiesz o co chodzi. Bo przez pierwszy rok i tak nie będziesz wiedział, a cała praca - czy to nauka, czy to etat - będzie przypominać błądzenie pijanego dziecka z nożem we mgle.      Jakie masz plany dotyczące dalszej nauki/rozwoju?       Architektura JavaScript i pełne przekwalifikowanie na NodeJS Developera   uczenie innych,   powrót do C#/.NET,   może Python?      Jak oceniasz pracę jako programista?    Nie wyobrażam sobie robić nic innego.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Szymon   Szymon ma 28 lat. Z wykształcenia jest matematykiem, jednak postanowił spróbować swoich sił jako programista. Pracuje jako programista od trzech lat. Zrezygnował ze swojej pierwszej pracy jako programista na rzecz bardziej rozwojowego stażu.   O tym jak matematyk został programistą      Czym zajmowałeś się wcześniej? W jakim zawodzie pracowałeś?    Wcześniej pracowałem 11 miesięcy jako informatyk, totalny wyzysk. Zdecydowałem się przez to przebranżowić.      Kim jesteś z wykształcenia?    Z wykształcenia jestem matematykiem. Studiowałem matematykę na Politechnice.      Miałeś wcześniej styczność z programowaniem?    Pierwszą styczność z programowaniem miałem właśnie podczas studiów (Pascal, programowanie obiektowe w C#, podstawy relacyjnych baz danych, strony internetowe z HTML i CSS, algorytmy z Matlab’em, witryny internetowe z C# i .NET).   Po trzecim roku studiów zdecydowałem się bardziej dokształcić w kierunku IT w Policealnej Szkole Weekendowej jako technik informatyk. Szkoła trwała dwa lata. Miałem tam między innymi bazy danych (PostgreSQL), HTML, CSS, JavaScript oraz troszeczkę PHP.   Po studiach zacząłem pracę jako informatyk taki à la helpdesk. Pół roku później skończyłem zaoczną szkołę. Załapałem się na dwa kursy/szkolenia finansowane ze środków Unii Europejskiej. Jeden był 10 dniowym kursem po 8 godzin dziennie “Programowanie w języku Java”. Drugie szkolenie trwało bodajże 5 dni “Przygotowanie do certyfikatu OCPJP6”. Niestety go nie zdałem, nikt go w sumie z naszej grupie nie zdał.      Ile czasu poświęciłeś na przekwalifikowanie się (ile godzin dziennie/tygodniowo się uczyłeś)?    Na naukę programowania starałem się poświecić minimum godzinne dziennie co nie zawsze mi wychodziło.      Jak długo przygotowywałeś się przed wysłaniem pierwszego CV?    Do wysłania pierwszego CV nie przygotowałem się zbyt długo. Przez co myślę, że nie byłem na zbyt wysokim poziomie, co skutkowało negatywnymi decyzjami na rozmowach.      Kiedy zacząłeś pracować jako programista?    Pracę jako programista zacząłem w 25 urodziny. Obecnie mam 28 lat.      Dlaczego zdecydowałeś się przekwalifikować?    Zdecydowałem się przekwalifikować, gdyż wiedziałem, że programowanie jest bardziej dochodowe niż inne zawody w IT.      Od czego zacząłeś naukę programowania?    Samodzielną naukę programowania zacząłem od przerabiania zagadnień ze szkoleń, w których wziąłem udział w ramach projektów z UE.      Z jakimi technologiami aktualnie pracujesz?    Obecnie pracuję z Java 8, Java EE, HTML, CSS, JavaScript, TypeScript, Angular, EclipseLink, PostgreSQL, Oracle, tak w skrócie. Jako środowiska używam IntelliJ Idea.      Co sprawiało Ci największe problemy w trakcie przekwalifikowania się?    Największą trudnością w nauce programowania było moje lenistwo oraz to, że jak najszybciej chciałem zmienić pracę. Przez kolejne odmowy podczas rozmów kwalifikacyjnych odechciewało mi się coraz bardziej.      Jak i gdzie zdobywałeś materiały do nauki? Czy możesz polecić źródła z których korzystałeś? Dlaczego akurat te?    Materiały do nauki pozyskiwałem z YouTube. Jest tam pełno darmowych szkoleń. Niestety większość kursów, które znajdowałem, tworzyli/prowadzili Hindusi. Moim zdaniem ich angielski akcent pozostawia wiele do życzenia.      Co ułatwiało Ci naukę? Miałeś jakieś sposoby na łatwiejsze zapamiętywanie?    Nie miałem sposobów na zapamiętywanie, ani niczego co by mi ułatwiało naukę.      Jak poszły Ci pierwsze rozmowy? Co sprawiło Ci największy problem?    Chodziłem na rozmowy (spokojnie szacuję, że było ich około 20) i bez skutku. Zawsze czegoś mi brakowało pod względem technicznym. Wysłałem CV do mojej obecnej firmy, zaprosili mnie na rozmowę. Pierwszy etap to wstępna rozmowa przez telefon po niemiecku, którą przeszedłem pozytywnie.   Powtarzam to wszystkim, którzy pytają się czy łatwo jest znaleźć pierwszą pracę. W moim przypadku wysłałem chyba z 40 CV, żeby zdobyć pierwszą pracę. Dzisiaj zrobiłbym to inaczej, ale wtedy masowo wysyłałem CV. W odróżnieniu od Szymona, mnie firmy nawet nie chciały zapraszać na rozmowy kwalifikacyjne. Jeśli dobrze pamiętam byłem wtedy na trzech.   Drugi etap rozmowy trwał około dwóch godzin. Różne zadania na kartce, pytania o moje wcześniejsze doświadczenie. Na rozmowie okazało się tak samo jak na wcześniejszych rozmowach, że za mało umiem między innymi  z Javy, ale nie dyskredytowało mnie to. Firma bowiem oferuje staże dla świeżych absolwentów oraz studentów ostatnich lat studiów.   Sporo firm początkujących programistów zatrudnia nie za posiadaną wiedzę, a za potencjał. Jeśli pracodawca zobaczy, że kandydat ma braki, ale ma też chęć do nauki, to może przymknąć oko na niektóre niedociągnięcia. Technologii można się nauczyć. Szczególnie jeśli w zespole będzie osoba, która chętnie dzieli się wiedzą.   Po sześciu miesiącach opuściłem swoją pierwszą firmę, w której pracowałem jako programista na rzecz obiecująco zapowiadającego się stażu. Java, AngularJS to było coś.   Po trzech miesiącach płatnego stażu przyjęli mnie na umowę o prace. Jednak przez pierwsze trzy miesiące w godzinach pracy odbywałem kurs niemieckiego, co było wymagane przez pracodawcę. Potem zaczął się pierwszy projekt, potem kolejny. Siedzę w obecnej firmę już ponad dwa lata.      Gdzie wysłałeś 5-10 pierwszych CV? Jak wybierałeś te firmy?    Zacząłem wysyłać CV do różnych firm, które poszukiwały młodszego programisty Java. Niestety poza znajomością Javy wymagana była ode mnie np. znajomość baz danych.   Między innymi tę umiejętność wspomniałem w artykule Od zera do developera. Duża liczba pracodawców szuka początkujących programistów, którzy znają coś więcej niż tylko składnię języka programowania.   Odezwał się do mnie mój przyszły pracodawca. Mała firemka, wówczas trzyosobowa wliczając szefa. Na rozmowie kwalifikacyjnej nie weryfikował specjalnie mojej wiedzy technicznej. Przyjął mnie do pracy. Po 2 tygodniach opanowałem podstawy Hibernate (konfiguracja w XML). Po czasie widziałem, że nie nauczę się tutaj za dużo i szukałem dalej.      Jakie masz wskazówki, rady dla osób, które chcą się przekwalifikować?    Młodszym kolegom mogę polecić wybór studiów informatycznych. Sam poszedłem na matematykę, ale jak miałbym możliwość ponownego wyboru to wybrałbym informatykę.  Kolegom, którzy chcą się przekwalifikować, systematyczną naukę, wytrwałość i cierpliwość. Mi niestety brakowało cierpliwości. Gdybym był bardziej cierpliwy z tym co robiłem, uniknąłbym rozczarowań związanych z nieudanymi rozmowami.   Zauważyłeś tu wzorzec? Szymon podobnie jak Tomek polecają cierpliwość i systematyczną naukę. To naprawdę jest klucz. Ja zawsze powtarzam, że nic “samo się nie zrobi”. Do przekwalifikowania potrzebna jest Twoja ciężka i systematyczna praca.      Jakie masz plany dotyczące dalszej nauki/rozwoju?    Na chwilę obecną pracuję jako Full-stack Developer. W przyszłości chciałbym powrócić do większego wykorzystania tego, czego się nauczyłem na studiach więc coś z Big Data: Scala i Apache Spark. Chyba, że do tego czasu trendy się zmienią. Może już się zmieniły?      Jak oceniasz pracę jako programista?    Pracę jako programista oceniam bardzo pozytywnie. Nie ma co jej porównywać do poprzedniego stanowiska jakim było informatyk na helpdesku. Dużo przeróżnych i ciekawych zadań, nowe wyzwania i nieustanna nauka.   Programista to zawód, w którym moim zdaniem musisz się ciągle rozwijać. Jeśli oczekujesz, że nauczysz się programować i masz spokój to jesteś w błędzie. Pracuję ponad dziesięć lat i bez przerwy widzę braki w swojej wiedzy, bez przerwy uczę się czegoś nowego.   Marek   Marek postanowił zostać programistą w wieku 24 lat będąc już po studiach na Politechnice Wrocławskiej na wydziale Mechaniki i Budowy Maszyn.   O tym jak projektant-konstruktor został programistą   Jako programista zacząłem pracować w styczniu 2017 roku. Wcześniej ukończyłem studia na Politechnice Wrocławskiej – Mechanikę i Budowę Maszyn. Zawód postanowiłem zmienić w wieku 24 lat. Czyli w sumie, ani specjalnie późno, ani specjalnie wcześnie.   Warto powiedzieć, że na Mechanice i Budowie Maszyn styczności z programowaniem nie miałem praktycznie żadnej. Mogę nawet powiedzieć, że kiedy jako przedmiot dodatkowy miałem na pierwszym roku programowanie C++, to go nie zaliczyłem. Totalnie nie ogarniałem o co chodzi w programowaniu.   Właściwie moje jedyne doświadczenie z programowaniem czegokolwiek to było tworzenie prostych programów do sterowników PLC w graficznym interfejsie. Czyli coś takiego jak Scratch, tylko że wersja bardziej “inżynierska”. Czyli zamiast funkcji do wykonania, zawory do zamknięcia. A zamiast zmiennych podanych przez użytkownika, jakieś czujniki, które pobierały dane. Oczywiście bez żadnego wnikania w sprzętowe szczegóły, po prostu kwadracik który podaje bieżące wyniki pomiarów.   Na zmianę ścieżki zawodowej zdecydowałem się po prawie dwóch latach pracy w zawodzie. Najpierw pracowałem jako pracownik (stażysta) działu R&amp;D6. A potem jako projektant-konstruktor.   Na podjęcie decyzji o zmianie zawodu miało wpływ kilka czynników. Między innymi to, że podczas poszukiwania nowej pracy (dalej jako mechanik) kilka razy odbiłem się od oferty pracy poprzez swoje wymagania finansowe, które nie były jakoś specjalnie wygórowane.   Więc podjąłem decyzję, że spróbuję się przebranżowić. Na samym początku głównie ze względu na zarobki i perspektywy rozwoju, które dla inżynierów mechaników w naszym kraju niestety są dość mizerne i obarczone dużą odpowiedzialnością. Na sam początek chciałem zacząć dość klasycznie, czyli od C++.       Praca jako programista rzeczywiście jest dość dobrze płatna. Co więcej w miastach gdzie jest duża konkurencja pracownicy dostają szereg dodatkowych profitów. Na przykład firma Opera Software, w której pracuję oferuje swoim pracownikom:      dostęp do piłkarzyków, bilarda, konsol do gier, flippera, planszówek etc. w trakcie pracy,   fundusze na materiały do nauki (książki, konferencje),   budżet na integrację zespołu,   prywatną opiekę medyczną (także dla rodziny pracownika),   dopłatę do parkingu,   kartę Multisport,   dopłaty do innych aktywności sportowych,   kanapki w pracy,   masaże w trakcie pracy,   owoce w pracy,   soki/napoje energetyczne w pracy,   różne rodzaje darmowych kaw, herbat, ziół, płatków, mleko, wodę etc.     Tutaj znowu pojawiła się dla mnie pewna bariera poznawcza. Warto powiedzieć, że na samym początku nie potrafiłem rozróżnić int od float, a samo wykonywanie czegokolwiek w IDE stanowiło dla mnie czarną magię, serio. Byłem totalnym programistycznym tłukiem. Umiałem obchodzić się z komputerem, ale cokolwiek związanego z programowaniem było dla mnie czarną magią.   Wiedza wymagana do efektywnej pracy jako programista jest olbrzymia. Często początkujący nie wiedzą nawet od czego zacząć. W jednym z artykułów zebrałem listę wymaganych umiejętności aby rozpocząć pracę.   Na całe szczęście na weselu mojego kolegi udało mi się trafić na kogoś, kto siedział w branży IT przez kilka lat. Tak od słowa do słowa polecił mi, żeby zamiast uczyć się C++ spróbować Javy. I dzięki Bogu za to!   Nie dość, że Java ma dużo niższy próg wejścia (niż C czy C++), to jeszcze na chwilę obecną jest dużo więcej ofert pracy z nią związanych. A tym samym dużo większe szanse na staż czy jakikolwiek start.   Doszło więc do tego, że musiałem zdecydować z czego się uczyć. Oczywiście Google.pl “best sources to learn Java” i wertowanie Quory, Stack Overflow etc. Na tym etapie cały czas jeszcze zastanawiałem się nad jakimś bootcamp’em czy ewentualnie studiami z zakresu programowania. Całe (nie)szczęście na jedno i drugie nie było mnie w danym momencie stać. Zacząłem więc od darmowych kursów Javy dostępnych w internecie. Z tego co pamiętam pierwszy z kursów dostępny był chyba na stronie Coursera – beznadziejny. Wystarczy nadmienić, że programowania uczono w nim w IDE (werble…) BlueJ, co było totalną masakrą.   Jednak i tym razem miałem farta i po chwili trafiłem na kurs Javy na Udemy od Johna Purcella, który zresztą cały czas polecam wszystkim znajomym próbującym zacząć przygodę z programowaniem. Tutaj było już o niebo lepiej. Starałem się programować 3-4 godziny dziennie. Miałem zamiar jak najszybciej zacząć pracować w zawodzie. Uczyłęm się w domu i w wolnych chwilach w pracy oglądałem jego filmiki i próbowałem pisać własne programy.   Takie pisanie programów równolegle z prowadzącym kurs, pomagało mi zapamiętać to, co robiłem. Dodatkowo robiłem sobie jakieś małe zadania, żeby przypomnieć sobie co było na poprzednich lekcjach. Po tym pierwszym kursie było już tylko lepiej. Od tego samego autora znalazłem więcej kursów, które dotyczyły innych zagadnień w Javie.   Wystarczy powiedzieć chociażby o Spring’u, Swing’u, wielowątkowości, wzorcach projektowych. Dodatkowo okazało się, że sam autor kursów jest bardzo pomocną osobą. Zawsze odpowiadał na maile i pomagał w sprawach, w których miałem problemy. Ba, nawet raz dał mi darmowy dostęp do jednego ze swoich kursów, gdy nie miałem kasy, aby go wykupić. Za to do dzisiaj wysyłam mu donate’y na PayPal’a.   Starałem się też jak najwięcej czytać o programowaniu. Nie tylko o samej Javie, ale ogólnie o architekturze komputera etc. Wiadomo, trochę pomogła elektronika, która była na studiach, ale ogólnie to i tak jak uczenie od zera. Pomocny okazał się też darmowy kurs Harvardu CS50. Serio, świetnie są tam omówione podstawowe zagadnienia.   Jeśli szukasz książek dla programistów zapraszam do artykułu. Znajdziesz w nim listę kilkunastu książek, które przydadzą się na różnych poziomach zaawansowania.   Po jakichś 5 miesiącach takiej nauki podjąłem decyzję, że czas zacząć próbować startować na staż/juniorskie pozycje. Mimo, iż w sumie moja wiedza nie była jakaś zabójcza. Poprzeglądałem oferty pracy z Javy i słałem CV gdzie popadnie, gdzie w miarę spełniałem wymagania.   Dodatkowo zauważyłem, że do programowania jest mi potrzebne coś więcej niż Java. Czyli np. SQL, XML, HTML, CSS, JavaScript. Starałem się więc dodatkowo ogarnąć coś, chociaż powierzchownie, z tych tematów, aby na rozmowach nie wychodzić na totalnego ignoranta.   Wcześniej wspomniałem o tym, że pracodawcy często patrzą na potencjał. Właśnie takie przygotowywanie się do rozmowy przez “liźnięcie” tematu może pomóc. Pokazujesz w ten sposób, że zależy Ci na tej pozycji. Powinieneś jasno powiedzieć, że nie znasz tematu, ale niedawno zacząłeś się go uczyć.   W międzyczasie podjąłem też studia informatyczne na prywatnej uczelni, ale okazały się one totalną stratą czasu i pieniędzy. Dobra rada dla przekwalifikowujących się, olejcie uczelnie, ogarnijcie dobrze jeden język. Znajdźcie jakąś pracę i dopiero potem idźcie na studia.   Szczerze to nie wiem czy wyciągnąłby tak ogólne wnioski na podstawie jednej uczelni. Zgadzam się z Markiem, co do tego, że “sprzedawcy marzeń” to strata czasu i pieniędzy. Jeśli ktoś mówi Ci, że po trzymiesięcznym kursie będziesz programistą, nie mając wcześniej doświadczenia, to moim zdaniem kłamie.   Udało mi się dostać na kilka rozmów kwalifikacyjnych. Tutaj poszło już w miarę z górki. Z trzech rozmów, na których byłem, jedna zakończyła się propozycją pracy, druga propozycją stażu. Doszedł do tego jeszcze świetny szef, który rzeczywiście chciał dać mi szansę i pomagał mi przy rozwoju w początkowych fazach mojej pracy.   No i w tej pierwszej pracy siedzę do dzisiaj. Projektuję wewnętrzny system banku w nowej Javie EE, w oparciu o REST i utrzymując jeszcze starą wersję zbudowaną na Struts.   Chociaż większość programistów to introwertycy, to staramy się być naprawdę pomocni. Jest spora szansa, że w pracy znajdziesz kogoś kto chętnie odpowie na Twoje pytania.   Cały czas uczę się dodatkowych rzeczy. “Łyknąłem” trochę uczenia maszynowego, uczę się Androida. W tym momencie staram się ogarnąć libGDX, żeby zacząć robić proste gierki na Androida. Jako następne na celowniku mam Unity i naukę C# przy okazji. W międzyczasie pogłębiam wiedzę z Javy i ogarniam Springa 5.   Już wspominałem, że programowanie to ciągła nauka. Jak tylko dowiesz się więcej z jednego zakresu zauważysz braki w innym miejscu.   Mogę powiedzieć, że znalazłem w programowaniu coś dla siebie. Mimo, że początkowo do zmiany branży skłoniły mnie zarobki. Jako konstruktor z perspektywy czasu mogę powiedzieć, że byłem dosyć kiepski. Jako programista czuję się zdecydowanie pewniej w zawodzie. Rozwinęło się to w pewien rodzaj pasji. Sam w wolnych chwilach piszę artykuły o programowaniu i rzeczach związanych z programowaniem na blogu it-leaders.   Tomasz   Tomasz to dwudziestopięciolatek, który w lutym 2018 roku zaczął pracę jako programista. Ukończył studia z tytułem magistra inżyniera budownictwa ze specjalizacją inżynieria mostowa. Poniżej możesz przeczytać jego historię.   O tym jak budowniczy mostów został programistą      Czym zajmowałeś się wcześniej? W jakim zawodzie pracowałeś?    Wcześniej pracowałem jako asystent projektanta mostowego. Do moich zadań należało przygotowywanie obliczeń nośności mostów. Obliczenia te wykonywałem w Excelu. Potem, by je przyśpieszyć, zacząłem używać C++ i tak już zaczęła się moja przygoda z programowaniem. Odkryłem, że programowanie można wykorzystać nie tylko w branży budowlanej.      Miałeś wcześniej styczność z programowaniem?    Pierwsza moja styczność z programowaniem to czasy gimnazjum, czyli budowanie stron w HTML i CSS. W liceum mieliśmy na informatyce proste zadania do rozwiązania w Pascalu. Nie byłem tak bardzo zakręcony na punkcie programowania, żeby każdą chwile wolną w gimnazjum i liceum spędzać przed komputerem. Większość czasu wolnego spędzałem grając w nogę z kolegami z osiedla.      Ile czasu poświęciłeś na przekwalifikowanie się, ile godzin dziennie/tygodniowo się uczyłeś?    Ciężko powiedzieć ile czasu poświeciłem. Po pracy siadałem codziennie tak na 2 godzinki i robiłem kursy online albo pisałem własne programy. W sobotę lubiłem wybrać się do swojej ulubionej kawiarni i tam ćwiczyć swój warsztat.      Jak długo przygotowywałeś się przed wysłaniem pierwszego CV?    Myślę, że potrzebowałem mniej więcej rok czasu. Oczywiście pierwsza rozmowa kwalifikacyjna musiała pójść źle :). Na pytania teoretyczne odpowiedziałem poprawnie, ale niestety nie dałem rady z napisaniem programu, zabrakło mi wiedzy praktycznej.   Prezentowanie siebie na rozmowach kwalifikacyjnych, to też umiejętność. Jak wszystkiego, uczymy się jej przez praktykę. Innymi słowy każda kolejna rozmowa to więcej doświadczeń, które pozwolą Ci lepiej wypaść na kolejnych rozmowach.      Dlaczego zdecydowałeś się przekwalifikować?    To w sumie wyszło bardzo naturalnie. Zawsze interesowałem się informatyką, bardzo lubię sobie upraszczać życie, a jeszcze bardziej jak coś się samo robi. Jestem samoukiem, a co jest wspaniałe w nauce programowania to to, że wszystko jest na wyciągnięcie ręki. To znaczy, że potrzebne materiały znajdziesz w większości za darmo. Jedyne czego potrzebujesz to czasu i dużej motywacji.      Od czego zacząłeś naukę programowania?    Od rozmów, wielu rozmów. Wielu moich dobrych kolegów jest z wykształcenia informatykami. Jak się spotykaliśmy to często temat schodził na programowanie. Czasem udało nam się nawet coś razem popisać. I tak od rozmowy do rozmowy odkryłem, że programowanie ma olbrzymi potencjał. Potem pojawiły się kursy na Udemy i Pluralsight, ale tak na poważnie to zacząłem swoje programowanie od książki “Symfonia C++”.   Chyba do końca życia nie zapomnę tej książki. Gwiazdkolot do tłumaczenia wskaźników, “Można żyć bez Coca-Coli, ale po co?” itp. Książka jest bardzo popularna wśród studentów. Autor w bardzo przystępny sposób tłumaczy podstawy C++. Bardziej zaawansowane konstrukcje omówione są w kontynuacji “Pasja C++”. Tę drugą zostawiłem sobie po studiach z sentymentu :).      Z jakimi technologiami aktualnie pracujesz?    Obecnie pracuję z takimi technologiami jak C# i SQL do ogarniania backend’u aplikacji webowej oraz React z TypeScript’em po stronie front-end’u.      Co sprawiało Ci największe problemy w trakcie przekwalifikowania się?    Największym problemem był wybór materiałów do nauki, ponieważ istnieje tak wiele źródeł, że teraz nie sztuką jest odszukanie materiałów, ale jak myślę trafna selekcja tych informacji.      Jak i gdzie zdobywałeś materiały do nauki? Czy możesz polecić źródła z których korzystałeś? Dlaczego akurat te?    Tak jak wcześniej pisałem, głównie kursy online na Udemy albo Pluralsight. Warto zwrócić uwagę czy kurs jest aktualny, jaką ma ocenę i ile widzów. Z całego serca radzę by samemu spróbować napisać coś choćby bardzo małego, prostego. Nie bójcie się kompilatora, on podpowiada, gdzie jest błąd :). Jest bardzo pomocny.   Podpisuję się pod tym obiema rękami i nogami. Programowania uczymy się programując. Im więcej praktyki tym lepiej, praktykę można zdobyć właśnie przez pisanie programów.      Co ułatwiało Ci naukę? Miałeś jakieś sposoby na łatwiejsze zapamiętywanie?    W programowaniu ważniejsze od zapamiętywania, jest nauczenie się szukania informacji. Niestety system edukacji w jakim zostałem wychowany nakładał wielki nacisk na zapamiętywanie. Nikt nas nie uczył, jak mamy się uczyć, jak szukać informacji, a wydaje mi się, że byłoby to bardzo pomocne. Nie przejmuj się, jeśli czegoś nie pamiętasz, jak tylko potrafsz to znaleźć w Internecie :).      Jak poszły Ci pierwsze rozmowy? Co sprawiło Ci największy problem?    O tym już wyżej pisałem. Pierwsza poszła średnio-dobrze. Dzięki niej już na kolejnej dużo mniej się stresowałem i wiedziałem czego się spodziewać.      Jakie masz wskazówki, rady dla osób, które chcą się przekwalifikować?    Życzę Wam dużo motywacji, czasu i czerpania radości z programowania, bo to naprawdę fajne! :)      Jakie masz plany dotyczące dalszej nauki/rozwoju?    Chciałbym pisać więcej po stronie backend’u. Poznać nowe możliwości C# których jeszcze nie znam.      Jak oceniasz pracę jako programista?    Jest to praca, która wymaga ciągłej gotowości do rozwoju. Codziennie może zaskoczyć Cię jakiś problem, którego w tym momencie nie potrafisz rozwiązać i musisz szukać. Koledzy z zespołu i w większości programiści są bardzo otwarci i gotowi do pomocy. Zdajemy sobie sprawę ze ktoś może czegoś nie wiedzieć. Informatyka jest tak wielką dziedziną, że jedna osoba nie jest w stanie wszystkiego wiedzieć.   I to jest super! Bo dzięki temu łatwiej prosić o pomoc drugą osobę. To jest też trudne, bo trzeba się przyznać, że się czegoś nie wie, ale warto pytać.   Jak dla mnie nie ma lepszej pracy, niż praca jako programista. Codziennie uczysz się czegoś nowego, nowe wyzwania, wspaniali ludzie, świetna atmosfera w zespole. Bardzo się cieszę z decyzji jaką podjąłem by zakończyć karierę mostową i rozpocząć karierę jako programista :).   Ania   Nie rozmawiałem z Anią na temat przekwalifikowania. Jednak jej historia jest dostępna w internecie ;). Jeśli chcesz ją przeczytać to zapraszam na blog, którego prowadzi razem z Jakubem Kobiety do kodu. Jeśli nie znałeś go wcześniej to znajdziesz tam sporo artykułów wartych przeczytania.   Podsumowanie   Mam nadzieję, że historie, które przeczytałeś będą dla Ciebie dobrą motywacją. Postaram się zebrać najważniejsze punkty:      przebranżowienie jest możliwe,   przebranżowienie wymaga bardzo dużo konsekwentnej, regularnej pracy i nauki,   żaden płatny kurs nie zrobi z nikogo programisty bez jego własnej pracy,   posiadanie mentora, osoby bardziej doświadczonej znacząco przyspiesza naukę,   programowanie to ciągła nauka, nawet po zdobyciu pracy w zawodzie,   zdobycie pierwszej pracy jest ciężkie, sam wysłałem blisko 40 CV zanim dostałem tę pierwszą,   pieniądze też mogą być dobrym motywatorem, jednak na dłuższą metę może być ciężko ze znalezieniem chęci do dalszej nauki, która jest kluczowa.   A teraz jeszcze kilka łyżek dziegdziu, tak żeby zgasić huraoptymizm:      przytoczyłem historię osób, którym się udało. Pamiętaj jednak, że ludzie nie lubią się dzielić swoimi porażkami. Innymi słowy na każdą osobę, której się udało przypada X, które nie dały rady,   nikt nie potrafi przewidzieć jak ta branża będzie wyglądała za 5, 10 czy 15 lat. Może uczenia maszynowe i sztuczna inteligencja rozwiną się na tyle, że praca niektórych programistów będzie zbędna i koniunktura się odwróci?   pamiętaj, że przebranżawiając się rywalizujesz z osobami, które kształcą/kształciły się w tym kierunku,   często jest tak, że osoby będące na studiach nie mają tak dużych zobowiązań jak osoba, która chce się przebranżowić. Studenci przeważnie nie mają rodziny na utrzymaniu, czy dużych zobowiązań finansowych7. Innymi słowy przebranżawiając się możesz sporo ryzykować.   Jeśli myślisz, że chcę Cię odwieść od przebranżowienia, to masz rację. Jeśli mimo tego zostaniesz, to osiągniesz to co sobie założyłeś. Tylko będąc wystarczająco zdeterminowanym możesz to osiągnąć. To jak będzie? Dasz radę przekwalifikować się na programistę? Wiesz już, że to nie jest łatwe. Wiesz, że wymaga to sporo wysiłku. Podejmiesz wyzwanie? Jakąkolwiek decyzję podejmiesz gratuluję wyboru :). Nikt tej decyzji nie podejmie za Ciebie. Podziel się swoją opinią w komentarzu, a może Tobie już udało się przekwalifikować?   Na koniec mam do Ciebie prośbę. Jeśli artykuł przypadł Ci do gustu proszę podziel się nim ze swoimi znajomymi. W ten sposób pomożesz mi dotrzeć do nowych czytelników – z góry dziękuję. Jeśli chcesz otrzymywać informacje o nowych artykułach proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu!                 Tak swoją drogą, moje domysły okazały się słuszne ;). &#8617;                  Język programowania składniowo bardzo podobny do Javy wypuszczony przez Microsoft. &#8617;                  Aplikacje okienkowe, na przykład przeglądarka internetowa może być aplikacją desktop’ową. &#8617;                  Back-end to programowanie po stronie serwera. Pisanie programów, które będą uruchamiane na serwerze. Dla odróżnienia front-end to część aplikacji, która uruchamiana jest przez klienty. W kontekście aplikacji webowych do front-endu używa się głównie HTML, CSS i JavaScript. Osoba pracująca zarówno z back-end’em i front-end’em często określana jest mianem full stack’a. &#8617;                  jQuery to jedna z popularnych bibliotek napisana w JavaScript, która ułatwia pracę z front-end’em. &#8617;                  można to przetłumaczyć jako dział badań i rozwoju (ang. research and development). &#8617;                  Mam świadomość, że tu mocno generalizuję. Wydaje mi się jednak, że statystycznie tak to właśnie wygląda. Tak jak piszę – wydaje mi się, więc będę wdzięczny jeśli pokażesz dane, które wyprowadzą mnie z błędu. &#8617;           ","categories": ["Różne"],
        "tags": [],
        "url": "/zmiana-branzy-zostan-programista/",
        "teaser": "/assets/images/2018/05/01_zmiana_branzy_zostan_programista.jpg"
      },{
        "title": "Projekt Informator zasilenie bazy, Spring i błędy jako JSON",
        "excerpt":"Projekt Informator   Projekt informator to REST’owy web service, działający w oparciu o Spring i Hibernate. Jeśli chcesz przeczytać więcej o projekcie i jego założeniach zapraszam do wprowadzenia.   W jednym z poprzednich artykułów przeczytasz też o wdrożeniu projektu w chmurze.     Samouczek Programisty jest jednym z partnerów konferencji infoShare 2018.   infoShare 2018 to konferencja technologiczna odbywająca się 22-23 maja w Gdańsku. Na developerów czekają m.in. prelekcje z obszaru cybersecurity i machine learning, live coding oraz spotkania ze specjalistami, takimi jak: Filip Wolski, Trent McConaghy, Piotr Konieczny, Zbigniew Wojna czy Scott Helme. infoShare to także okazja do networkingu i udziału w imprezach towarzyszących. Sprawdź agendę i zarejestruj się na www.infoshare.pl.        Baza danych   W projekcie do mapowania obiektowo relacyjnego używam biblioteki Hibernate jako implementacji JPA (ang. Java Persistence API). W tym przypadku tworzenie schematu bazy danych zostawiam JPA. Poniżej widzisz konfigurację obiektu zarządzanego przez kontener Spring’a. Służy on do tworzenia instancji implementującej interfejs EntityManager:   @Bean LocalContainerEntityManagerFactoryBean entityManagerFactory() {     LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();     factory.setJpaVendorAdapter(new HibernateJpaVendorAdapter());     factory.setPackagesToScan(\"pl.samouczekprogramisty.informator.model\");     factory.setDataSource(dataSource());      Properties jpaProperties = new Properties();     jpaProperties.setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.PostgreSQLDialect\");     jpaProperties.setProperty(\"hibernate.show_sql\", \"true\");     jpaProperties.setProperty(\"hibernate.format_sql\", \"true\");     jpaProperties.setProperty(\"hibernate.hbm2ddl.auto\", \"validate\");     // create database schema if missing     jpaProperties.setProperty(\"javax.persistence.schema-generation.database.action\", \"create\");     factory.setJpaProperties(jpaProperties);      return factory; }       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Zasilenie bazy danych   Niestety organizatorzy konferencji nie przygotowali źródła danych, które w łatwy sposób można użyć do zasilenia bazy danych. Jedyne źródło to oficjalna strona www konferencji. Na początku skupiłem się nad zasileniem tabeli zawierającej dane dotyczące prelegentów. W projekcie Informator prelegent reprezentowany jest przez instancję klasy Speaker:   @Entity public class Speaker {     @Id     @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"speaker_seq\")     @SequenceGenerator(name = \"speaker_seq\")     private Integer id;      private Integer infoshareId;      private Category category;      private String name;      private URL linkedinProfile;     private URL twitterProfile;     private URL facebookProfile;     private URL githubProfile;      @Column(columnDefinition = \"text\")     private String description;      // getters/setters }   Analizując zapytania HTTP, które są wykonywane w tle zauważyłem adres w postaci:   https://infoshare.pl/speaker2.php?cid=48&amp;id=XXX&amp;year=2018&amp;agenda_id=99999&amp;fancybox=true   W adresie tym XXX zastąpione jest identyfikatorem prelegenta. Strona z prelegentami zawiera listę wszystkich osób występujących na każdej ze scen. Żeby wyciągnąć informacje o wszystkich prelegentach potrzeba ponad 200 zapytań.   Z racji tego, że jest to dość żmudne i czasochłonne zadanie napisałem skrypt1, który wyciąga niezbędne dane. W wyniku działania tego skryptu powstał plik speakers.sql. Wewnątrz tego pliku znajdują się instrukcje SQL (ang. Structured Query Language), które dodają wiersze do tabeli speaker. Przykładowe zapytanie z tego pliku wygląda następująco:   INSERT INTO speaker ( \tid, \tinfoshareid, \tcategory, \tdescription, \tfacebookprofile, \tgithubprofile, \tlinkedinprofile, \ttwitterprofile, \tname ) VALUES ( \tnextval('speaker_seq'), \t954, \t0, 'Stephen Haunts is a veteran sof(...)', \tNULL, \tNULL, \tNULL, \t'https://twitter.com/stephenhaunts', \t'Stephen Haunt' );   Formatowanie odpowiedzi   Mając rzeczywiste dane w bazie danych webservice może odpowiadać bardziej sensownymi danymi:   $ curl http://localhost:8080/speakers/7 -s | json_pp {    \"category\" : \"STARTUP\",    \"description\" : \"Kamila Wincenciak is a member of Ali(...)\",    \"name\" : \"Kamila Wincenciak\",    \"githubProfile\" : null,    \"twitterProfile\" : null,    \"facebookProfile\" : null,    \"linkedinProfile\" : \"https://www.linkedin.com/in/kamila-wincenciak-27560130/\" }   Zabrałem się za kolejny etap, czyli obsługę błędów. Przypadkami, które trzeba obsłużyć są brak rekordu w bazie i złe dane wprowadzone przez użytkownika. Oba przypadki pokazane są poniżej. Proszę zwróć uwagę na zwracane nagłówki i status odpowiedzi:   $ curl http://localhost:8080/speakers/-1 -vs | json_pp *   Trying 127.0.0.1... * Connected to localhost (127.0.0.1) port 8080 (#0) &gt; GET /speakers/-1 HTTP/1.1 &gt; Host: localhost:8080 &gt; User-Agent: curl/7.47.0 &gt; Accept: */* &gt;  &lt; HTTP/1.1 404  &lt; Content-Type: application/json &lt; Content-Length: 148 &lt; Date: Wed, 20 Jun 2018 21:09:42 GMT &lt;  { [148 bytes data] * Connection #0 to host localhost left intact {    \"responseCode\" : 404,    \"exceptionClass\" : \"pl.samouczekprogramisty.informator.exceptions.NotFoundException\",    \"message\" : \"Speaker with id -1 wasn't found!\" }   $ curl http://localhost:8080/speakers/aa -vs | json_pp *   Trying 127.0.0.1... * Connected to localhost (127.0.0.1) port 8080 (#0) &gt; GET /speakers/aa HTTP/1.1 &gt; Host: localhost:8080 &gt; User-Agent: curl/7.47.0 &gt; Accept: */* &gt;  &lt; HTTP/1.1 400  &lt; Content-Type: application/json &lt; Content-Length: 108 &lt; Date: Wed, 20 Jun 2018 21:09:16 GMT &lt; Connection: close &lt;  { [108 bytes data] * Closing connection 0 {    \"message\" : \"For input string: \\\"aa\\\"\",    \"responseCode\" : 400,    \"exceptionClass\" : \"java.lang.NumberFormatException\" }   Konfiguracja Spring a obsługa błędów   Aby móc w ten sposób formatować błędy użyłem kombinacji adnotacji ControllerAdvice i ExceptionHandler:   @ControllerAdvice @SuppressWarnings(\"unused\") @ResponseBody public class InformatorExceptionHandler {      private static ObjectMapper mapper = new ObjectMapper();      public static class ErrorResponse {         private static final MultiValueMap&lt;String, String&gt; HEADERS = new LinkedMultiValueMap&lt;&gt;(                 Collections.singletonMap(HttpHeaders.CONTENT_TYPE, Collections.singletonList(MediaType.APPLICATION_JSON_VALUE))         );         private final Exception exception;         private HttpStatus responseStatus;          ErrorResponse(HttpStatus responseStatus, Exception exception) {             this.exception = exception;             this.responseStatus = responseStatus;         }          ResponseEntity&lt;String&gt; buildResponse() {             try {                 return new ResponseEntity&lt;&gt;(mapper.writeValueAsString(this), HEADERS, responseStatus);             } catch (JsonProcessingException e) {                 throw new RuntimeException(e);             }         }          // getters     }      @ExceptionHandler(NotFoundException.class)     public ResponseEntity&lt;String&gt; handleNotFound(NotFoundException exception) {         return new ErrorResponse(HttpStatus.NOT_FOUND, exception).buildResponse();     }      @ExceptionHandler(NumberFormatException.class)     public ResponseEntity&lt;String&gt; handleNumberFormat(NumberFormatException exception) {         return new ErrorResponse(HttpStatus.BAD_REQUEST, exception).buildResponse();     } }   Klasa oznaczona adnotacją ControllerAdvice zawiera w sobie metody, które są użyte w wielu kontrolerach. Możemy powiedzieć, że są to metody przekrojowe. Przykładem takich metod są te oznaczone adnotacją ExceptionHandler. Każda z nich odpowiada za obsługę innego typu wyjątku.   Niestety w tym przypadku Spring nie deserializuje obiektu odpowiedzi do żądanego formatu dlatego napisałem klasę pomocniczą ErrorResponse, która przygotowuje odpowiedź w formacie JSON.   Podsumowanie   Aplikacja aktualnie jest w stanie wyświetlić informacje o prelegencie na podstawie rzeczywistych danych pobranych ze strony organizatora konferencji. Dodatkowo aplikacja poprawnie reaguje na różnego rodzaju błędy odpowiadając w formacie JSON. Zachęcam Cię do przeanalizowania kodu źródłowego aplikacji, w ten sposób utrwalisz zdobytą wiedzę.   Po przeczytaniu tego artykułu i przejrzeniu kodu źródłowego wiesz w jaki sposób można obsługiwać błędy w webservice’ach. Poznałeś też sposób na zasilanie bazy danych na podstawie informacji umieszczonych na innych stronach.   Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Proszę podziel się linkiem do artykułu ze znajomymi, którym może on pomóc. Może to dzięki Tobie uda mi się dotrzeć do nowych czytelników? ;)   Do następnego razu!                 Po godzinach pracy, w wolnym czasie uczę się języka Go. Wiem, że najlepszy sposób na naukę to praktyka. Dlatego właśnie napisałem ten skrypt używając tego języka. Mam świadomość, że nie jest idealny i wymaga sporo poprawek, ale jak na początek nauki jest OK ;). &#8617;           ","categories": ["Projekty","Projekt Informator"],
        "tags": [],
        "url": "/projekt-informator-zasilenie-bazy-spring-i-bledy-jako-json/",
        "teaser": "/assets/images/2018/06/20_projekt_informator_zasilenie_bazy_spring_i_bledy_jako_json.jpeg"
      },{
        "title": "Pobieranie danych z bazy – SELECT",
        "excerpt":"     To jest jeden z artykułów w ramach praktycznego kursu SQL. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Każde zapytanie z kursu możesz wykonać samodzielnie. Potrzebujesz do tego środowiska opisanego w pierwszym artykule kursu. Bardzo mocno Cię do tego zachęcam. Moim zdaniem najwięcej nauczysz się samodzielnie eksperymentując z zapytaniami.     Wprowadzenie do języka SQL   Język SQL (ang. Structured Query Language) powstał kilkadziesiąt lat temu. Służy do pobierania i przetwarzania danych zapisanych w bazie danych. Język ten został ustandaryzowany i na przestrzeni kilkudziesięciu lat powstało wiele wersji tego standardu.       Niestety treść standardów nie jest dostępna bezpłatnie. Jeśli będziesz chcieć uzupełnić swoją wiedzę, to dokumentacja bazy danych, której używasz jest bardzo dobrym źródłem. Popularne bazy danych dokładnie opisują swoją implementację standardu SQL:      SQL implementowany przez SQLite,   SQL implementowany przez PostgreSQL,   SQL implementowany przez MySQL,   SQL implementowany przez Oracle.     Język SQL jest językiem deklaratywnym. Oznacza to tyle, że instrukcje tego języka opisują co chcemy osiągnąć, a nie jak to zrobić. Dla porównania można powiedzieć, że język Java nie jest językiem deklaratywnym. Programując w języku Java mówisz o tym jak chcesz coś zrobić.   Język SQL oparty jest na zapytaniach. Przykładowe zapytanie SQL może wyglądać tak:   SELECT *   FROM genre  WHERE name = 'Rock'    AND genreid &lt; 20;   SQL to nie baza danych   Definicji bazy danych może być wiele. Jednak nie znam żadnej, która mówiłaby, że baza danych to SQL.   SQL to język, który pomaga dogadać się z bazą danych. Baza danych to dane, to ich zbiór. W relacyjnych bazach danych są one zorganizowane w tabele. W jednej bazie danych przeważnie znajduje się wiele tabel.   Tabele zawierają wiersze i kolumny. Na przykład tabela genre zawiera nazwy gatunków muzycznych:   | genreid | name   | |---------|--------| | 1       | 'Rock' | | 2       | 'Jazz' |   Tabela, którą pokazałem wyżej zawiera dwa wiersze i dwie kolumny: genreid i name. Można powiedzieć, że baza danych to zbiór tabel zawierających dane. Język SQL pomaga w łatwym operowaniu na danych. SQL ukrywa w sobie sposób w jaki dane są przetwarzane, zwraca wyłącznie finalny wynik.   Bazy danych także ukrywają sposób przechowywania danych. Użytkownika nie interesuje sposób ich zapisu a jedynie to, co chce uzyskać przy pomocy zapytania SQL1.   Podział SQL   Zapytania w SQL możemy podzielić na kilka rozłącznych grup. Każda z tych grup zawiera różne rodzaje zapytań. Grupy zostały wydzielone na podstawie zadań realizowanych przez poszczególne zapytania. Możemy wyszczególnić następujące grupy:      DQL (ang. Data Query Language)   DML (ang. Data Manipulation Language)   DDL (ang. Data Definition Language)   Dodatkowo czasami wyróżnia się też grupy:      DCL (ang. Data Control Language)   TCL (ang. Transaction Control Language)   DQL   DQL składa się wyłącznie z zapytań typu SELECT. Zapytania te służą do odpytywania (ang. query) bazy danych. Innymi słowy służą do pobierania danych z bazy danych. Zapytania typu SELECT są najczęściej używane. Poniżej możesz zobaczyć zapytanie, które pobiera wszystkie kolumny i wiersze z tabeli genre.   SELECT *   FROM genre;   Na razie nie przejmuj się składnią zapytania, omówię ją szczegółowo poniżej.   DML   DML służy do tworzenie, modyfikowania i usuwania danych. W skład tej grupy wchodzą zapytania:      INSERT – dodaje wiersze do tabeli,   UPDATE – aktualizuje wiersze w tabeli,   DELETE – usuwa wiersze z tabeli.   DDL   Wiesz już, że relacyjne bazy danych składają się z tabel. Dodatkowo w bazach występują inne obiekty jak indeksy (ang. index), klucze obce (ang. foreign key), klucze główne (ang. primary key), ograniczenia (ang. constraint), wyzwalacze (ang. trigger) czy widoki (ang. view). Część języka odpowiedzialna za zarządzanie tymi obiektami to DDL. Zapytania należące do DDL to:      CREATE – tworzą obiekty bazy danych,   ALTER – modyfikują tabele bazy danych,   DROP – usuwają obiekty bazy danych,   TRUNCATE – usuwa wszystkie dane z tabeli2.   DCL   Bazy danych często pozwalają na zarządzanie dostępem do danych. Realizowane jest to przy pomocy kont użytkowników3. DCL służy do manipulacji prawami dostępu do danych przypisanych do poszczególnych kont:      GRANT – nadaje uprawnienia,   REVOKE – usuwa uprawnienia.   TCL   Na początku przygody z SQL nie musisz przejmować się transakcjami. Opiszę je dokładniej w kolejnych artykułach w ramach kursu. Teraz w zupełności wystarczy wiedza o tym, że istnieje coś takiego jak transakcja. Do zarządzania transakcjami służą zapytania:      BEGIN – rozpoczyna transakcję,   COMMIT – zatwierdza transakcję,   ROLLBACK – wycofuje transakcję,   SAVEPOINT – zapisuje punkt przywracania aktualnej transakcji.   SQL a wielkość liter   SQL jest językiem, w którym wielkość liter w słowach kluczowych i identyfikatorach nie ma znaczenia. Wyjątkiem są tu identyfikatory, które są otoczone znakiem cudzysłowu \"4. Na przykład oba poniższe zapytania są równoważne:   SELECT * FROM genre WHERE genreid = 1;   SELECT * frOM geNRe wherE GenReID = 1;   Chociaż wielkość liter nie ma znaczenia, moim zdaniem dobrą praktyką jest pisanie słów kluczowych wielkimi literami. W codziennej pracy także staram się unikać nadawania nazw, które wymagają otoczenia \". Dodatkowo zawsze staram się formatować zapytania żeby były bardziej czytelne:   SELECT *   FROM genre  WHERE genreid = 1;       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Przygotowanie środowiska   Moim zdaniem najlepszym sposobem na naukę jest praktyka. Właśnie z tego powodu chcę pomóc przygotować Ci środowisko, w którym możliwe będzie testowanie zapytań.   Aby móc ćwiczyć na bieżąco wszystkie zagadnienia, które będę opisywał będziesz potrzebować serwera bazy danych. Jak wspomniałem w artykule opisującym relacyjne bazy danych jest wiele silników baz danych.   Ze względu na łatwą instalację (właściwie to jej brak), w kursie używał będę bazy danych SQLite. Baza ta jest w zupełności wystarczająca na potrzeby kursu. Oczywiście, jeśli chcesz wykonywać ćwiczenia używając bardziej zaawansowanych baz danych możesz to zrobić ;).   Instalacja bazy danych   Zacznij od pobrania narzędzi SQLite. W zależności od systemu operacyjnego, na którym pracujesz pobierz odpowiednią wersję:      Windows – Precompiled Binaries for Windows,   Linux – Precompiled Binaries for Linux,   Mac OS X – Precompiled Binaries for Mac OS X (x86).   Plik do pobrania to archiwum zip rozpoczynające się od sqlite-tools-. Wewnątrz tego archiwum znajduje się program sqlite.exe (lub sqlite, w zależności od Twojego systemu operacyjnego). Program ten pozwala na pracę z bazą danych SQLite.   Jak widzisz w tym przypadku właściwie nie ma potrzeby instalacji żadnego programu, wystarczy rozpakować archiwum zip. W przypadku baz danych używanych w środowiskach produkcyjnych proces ten jest dużo bardziej skomplikowany.   Import gotowej bazy danych   W internecie istnieje wiele zbiorów danych. Jednym z nich jest ten udostępniony przez projekt Chinook. Jest to testowa baza danych reprezentująca sklep z muzyką. Sama baza nie jest duża, jednak w zupełności wystarczy na omówienie podstawowych możliwości SQL.   Pobierz przykładową bazę danych i zachowaj ją w pliku Chinook_Sqlite.sqlite, następnie uruchom program sqlite3. Po uruchomieniu wpisz komendę, która otworzy pobraną bazę danych:   .open &lt;ścieżka do pobranego pliku&gt;   Żeby sprawdzić, czy wszystko działa poprawnie możesz wpisać komendę .tables, powinna ona wypisać wszystkie tabele znajdujące się bazie danych.             Otworzenie bazy danych w sqlite        Komendy zaczynające się od . (na przykład .open czy .tables) to wewnętrzne polecenia SQLite. Jest ich dużo więcej. Jeśli chcesz je zobaczyć użyj polecenia .help.   Zapytania SELECT   Założeniem tego kursu jest to, że będzie on praktyczny od samego początku do końca. Wszystkie zapytania, które tutaj pokazuję możesz wykonać samodzielnie używając środowiska, które wcześniej opisałem.   Schemat tabeli   Zanim przejdę do tłumaczenia zapytań SELECT chciałbym zwrócić Twoją uwagę na budowę tabeli. Wiesz już, że tabela składa się z wierszy i kolumn. Każda kolumna przechowuje dane pewnego typu. Mogą to być na przykład łańcuchy znaków czy liczby.   Można powiedzieć, że tabela ma swój schemat. SQLite ma wewnętrzne polecenie, które pozwala pokazać schemat tabeli – .schema. Na przykład schemat tabeli Invoice wygląda tak:   sqlite&gt; .schema Invoice CREATE TABLE [Invoice] (     [InvoiceId] INTEGER  NOT NULL,     [CustomerId] INTEGER  NOT NULL,     [InvoiceDate] DATETIME  NOT NULL,     [BillingAddress] NVARCHAR(70),     [BillingCity] NVARCHAR(40),     [BillingState] NVARCHAR(40),     [BillingCountry] NVARCHAR(40),     [BillingPostalCode] NVARCHAR(10),     [Total] NUMERIC(10,2)  NOT NULL,     CONSTRAINT [PK_Invoice] PRIMARY KEY  ([InvoiceId]),     FOREIGN KEY ([CustomerId]) REFERENCES [Customer] ([CustomerId])                 ON DELETE NO ACTION ON UPDATE NO ACTION ); CREATE UNIQUE INDEX [IPK_Invoice] ON [Invoice]([InvoiceId]); CREATE INDEX [IFK_InvoiceCustomerId] ON [Invoice] ([CustomerId]);   To co widzisz, to zapytania typu DDL, które tworzą tabelę i obiekty z nią powiązane. Powyższe zapytana poza tabelą tworzą indeksy, klucze obce i klucz główny.   Istnieją także bazy danych, które pozwalają przechowywać dane w strukturze, która nie ma sztywno określonego schematu. Podobnie jak relacyjne bazy danych mają one swoje wady i zalety.   Typy danych   Typy obsługiwanych danych mogą znacznie różnić się pomiędzy różnymi silnikami baz danych. Różnice te jednak nie przeszkadzają w nauce języka SQL.   Tabela Invoice składa się z dziewięciu kolumn. Kolumna InvoiceId jest kluczem głównym tabeli. Każda z kolumn ma przypisany typ. Typ określa rodzaj danych przechowywanych w danej kolumnie5. Na przykład kolumna InvoiceDate jest typu DATETIME, kolumny tego typu służą do przechowywania daty i czasu.   Innymi typami, które występują w tej tabeli są:      INTEGER – służy on do przechowywania liczb całkowitych,   NVARCHAR(x) – służy on do przechowywania łańcuchów znaków do długości x,   NUMERIC(x, y) – służy do przechowywania liczb rzeczywistych, które mają do x cyfr z y po przecinku.   Innymi popularnymi typami są6:      BLOB – służy do przechowywania danych binarnych (ang. binary large object),   DATETIME – służy do przechowywania daty i czasu,   DATE – służy do przechowywania daty,   BOOLEAN – służy do przechowywania wartości logicznych,   TEXT – służy do przechowywania łańcuchów znaków gdzie ciężko jest oszacować maksymalną długość tekstu, lub wahania długości tekstu są duże.   Składnia zapytania SELECT   Zapytanie SELECT w swojej najprostszej formie wygląda tak:   SELECT *   FROM invoice;   To zapytanie zawiera dwa słowa kluczowe: SELECT i FROM. Pomiędzy tymi słowami znajduje się lista kolumn, które powinny zostać zwrócone. Znak * w tym kontekście oznacza “pobierz wszystkie”. Po słowie kluczowym FROM występuje nazwa tabeli – invoice. Całe zapytanie jest zakończone średnikiem. Spróbuj wykonać to zapytanie na swojej kopii bazy danych:   sqlite&gt; SELECT * FROM invoice; 1|2|2009-01-01 00:00:00|Theodor-Heuss-Straße 34|Stuttgart||Germany|70174|1.98 2|4|2009-01-02 00:00:00|Ullevålsveien 14|Oslo||Norway|0171|3.96 (...)   Filtrowanie przy pomocy WHERE   Pobieranie całej tabeli nie zawsze jest przydatne. Bardzo często zapytania SELECT filtrują pobierane dane. Aby filtrować dane zwracane przez zapytanie musisz użyć słowa kluczowego WHERE i warunków, które filtrują dane:   SELECT *   FROM invoice  WHERE billingcity = 'Dublin' AND total &gt; 5     OR billingcity = 'Boston' AND total &lt; 3 AND total &gt; 1;   Zapytanie wyżej ma kilka warunków. Każdy z nich oddzielony jest słowem kluczowym OR (logiczne lub) i AND (logiczne i). W tym przypadku zostaną zwrócone wszystkie wiersze dla których spełniony jest jeden z warunków:      kolumna billingcity ma wartość Dublin i kolumna total zawiera liczbę większą od 5,   kolumna billingcity ma wartość Boston i kolumna total zawiera liczbę z przedziału (1, 3).   Słowo kluczowe AND ma wyższy priorytet niż OR. Oznacza to, że warunki pomiędzy AND wykonywane są wcześniej niż OR. Dla przykładu w konstrukcji:   warunek1 OR warunek2 AND warunek3   Na początku zostanie wykonany fragment warunek2 AND warunek3 dając wynik1, następnie warunek1 OR wynik1.  Czasami dla większej czytelności możesz użyć nawiasów. Poniższe zapytanie da dokładnie ten sam wynik co poprzednie:   SELECT *   FROM invoice  WHERE (billingcity = 'Dublin' AND total &gt; 5)     OR (billingcity = 'Boston' AND total &lt; 3 AND total &gt; 1);   Spróbuj wywołać to zapytanie na swojej kopii bazy danych:   sqlite&gt; SELECT * FROM invoice WHERE billingcity = 'Dublin' AND total &gt; 5 OR billingcity = 'Boston' AND total &lt; 3 AND total &gt; 1; 10|46|2009-02-03 00:00:00|3 Chatham Street|Dublin|Dublin|Ireland||5.94 189|23|2011-04-18 00:00:00|69 Salem Street|Boston|MA|USA|2113|1.98 (...)   Magiczna wartość NULL   Każdy wiersz w tabeli może mieć wartość, która pasuje do typu przechowywanego przez daną kolumnę. W SQL jest jeszcze specjalna wartość. Jest nią NULL. Możesz ją porównać do pustej wartości w językach programowania. W Javie i JavaScript byłby to null, w Pythonie None, w Ruby i Go nil itd.   Istotne jest rozróżnienie pomiędzy pustą wartością a NULL. Na przykład pusty łańcuch znaków to zupełnie coś innego niż NULL.   Wartość ta jest traktowana w specyficzny sposób w przypadku porównań. Do sprawdzania czy kolumna w wierszu ma wartość NULL służy wyrażenie IS NULL. Aby sprawdzić, czy dana kolumna nie ma wartości NULL używa się wyrażenia IS NOT NULL.   Na przykład poniższe zapytanie zwróci jedynie te wiersze dla których kolumna billingcountry ma wartość inną niż USA i billingstate nie ma wartości NULL:   SELECT *   FROM invoice  WHERE billingstate IS NOT NULL    AND billingcountry != 'USA';   Wybór kolumn   Użycie klauzuli WHERE pozwala na odfiltrowanie części wierszy. W przypadku kolumn mechanizm jest podobny. Jeśli chcesz wybrać podzbiór kolumn, a nie wszystkie, to musisz wskazać te, które Cię interesują:   SELECT invoicedate       ,billingcity       ,total   FROM invoice  WHERE billingcountry = 'Poland';  Powyższe zapytanie zwróci wyłącznie te faktury, które zostały wystawione w Polsce. Wynik będzie zawierał tylko trzy wskazane kolumny. Zwróć uwagę, że klauzula WHERE może używać kolumn, które nie są zwracane w wyniku wykonania zapytania.   To dopiero początek   Rysunek poniżej pokazuje składnię zapytania SELECT w SQLite. W artykule tym omówiłem wyłącznie podstawowe elementy.             Składania zapytania SELECT        W kolejnych artykułach omówię między innymi pozostałe elementy składni zapytania SELECT.   Zadania do wykonania   Na koniec mam dla Ciebie kilka zadań, w których przećwiczysz materiał z tego artykułu. Postaraj się napisać zapytania samodzielnie, wtedy nauczysz się najwięcej. Żadne z zapytań nie musi zwrócić unikalnych wyników7:      Napisz zapytanie, które zwróci wszystkie gatunki muzyczne z tabeli genre,   Napisz zapytanie, które zwróci wszystkie stany w USA, w których wystawiono fakturę na kwotę większą niż 15,   Napisz zapytanie, które zwróci wszystkie kraje, w których wystawiono fakturę na kwotę mniejszą niż 10 pomiędzy ‘2013-12-05 00:00:00’ i ‘2013-12-09 00:00:00’,   Napisz zapytanie, które zwróci wszystkie miasta i kraje gdzie wartość kolumny billingstate równa się NULL i wartość zamówienia jest większa niż 17 oraz te gdzie wartość zamówienia jest mniejsza niż 1, billingstate nie ma wartości NULL i zostały wystawione po ‘2013-09-20 00:00:00’.   Przykładowe rozwiązania zadań   SELECT name   FROM genre;   SELECT billingstate   FROM invoice  WHERE billingcountry = 'USA'       AND total &gt; 15;   SELECT billingcountry   FROM invoice  WHERE total &lt; 10       AND invoicedate &gt; '2013-12-05 00:00:00'       AND invoicedate &lt; '2013-12-09 00:00:00';   SELECT billingcity, billingcountry   FROM invoice  WHERE (billingstate IS NULL AND total &gt; 17)        OR (total &lt; 1            AND billingstate IS NOT NULL            AND invoicedate &gt; '2013-09-20 00:00:00');   Dodatkowe materiały do nauki   Jeśli chcesz spojrzeć na temat z innej perspektywy polecam przeczytanie poniższych materiałów. Pozwoli Ci to poszerzyć swoją wiedzę związaną z językiem SQL i jego składnią.      Artykuł na temat SQL na Wikipedii,   Dokumentacja SQLite.   Podsumowanie   Po przeczytaniu tego artykułu wiesz czym jest język SQL. Potrafisz podzielić zapytania języka SQL na grupy. Znasz podstawy zapytania typu SELECT. Potrafisz zastosować w praktyce zapytania tego typu do pobrania danych z bazy. Innymi słowy masz solidne podstawy, dzięki którym możesz przejść do kolejnego etapu nauki języka SQL.   Przyznam Ci się, że miałem problem z zakończeniem tego artykułu. Mam świadomość, że nie jest kompletny, ale postanowiłem podzielić go na mniejsze, łatwiejsze do przyswojenia części. W kolejnych artykułach z cyklu możesz spodziewać się pogłębienia tematu.   Na koniec proszę Cię o polecenie tego artykułu Twoim znajomym, którym może się on przydać. Dzięki Tobie uda mi się dotrzeć do nowych czytelników. Z góry dziękuję ;). Jeśli cokolwiek nie będzie dla Ciebie jasne proszę daj znać w komentarzach, postaram się pomóc. Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę polub Samouczka na Facebooku i dodaj swój adres e-mail do samouczkowego newslettera. Do następnego razu!                 Na pewnym etapie zaawansowania znajomość wewnętrznych mechanizmów działania bazy danych jest bardzo ważna. Pozwala ona na tworzenie zapytań, które są bardziej wydajne. &#8617;                  Chociaż TRUNCATE jest podobne do zapytania typu DELETE jest klasyfikowane jako DDL. Wynika to z faktu, że zapytania TRUNCATE nie mogą być cofnięte. Zapytania typu DELETE mogą być cofnięte w ramach trwającej transakcji. &#8617;                  Pomijam tu ustawienia na poziomie konfiguracji silnika bazy danych. Te ustawienia mogą wymagać restartu silnika. Przykładem może tu być plik konfiguracyjny pg_hba.conf istniejący w bazie danych PostgreSQL. &#8617;                  To zachowanie zależy od silnika bazy danych. Niektóre silniki inaczej interpretują identyfikatory otoczone \", inne nie. &#8617;                  To stwierdzenie nie jest do końca prawdziwe dla SQLite, jednak ma zastosowanie w innych silnikach baz danych. W przypadku SQLite typ danych określany jest na podstawie zawartości a nie typu kolumny. To zachowanie jest raczej wyjątkiem w świecie relacyjnych baz danych. Po szczegóły odsyłam Cię do dokumentacji SQLite. &#8617;                  W przypadku SQLite wszystkie typy danych są przekształcane na “typy pierwotne”: NULL, INTEGER, REAL, TEXT, BLOB. Dane na dysku zawsze zapisane są jako jeden z typów pierwotnych. &#8617;                  Mechanizmy, które pozwalają na zwracanie unikalnych wyników omówię w kolejnych artykułach. &#8617;           ","categories": ["Bazy danych","Kurs SQL"],
        "tags": [],
        "url": "/pobieranie-danych-z-bazy-select/",
        "teaser": "/assets/images/2018/06/28_pobieranie_danych_z_bazy_select_artykul.jpeg"
      },{
        "title": "Klauzula WHERE w zapytaniach SQL",
        "excerpt":"     To jest jeden z artykułów w ramach praktycznego kursu SQL. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Każde zapytanie z kursu możesz wykonać samodzielnie. Potrzebujesz do tego środowiska opisanego w pierwszym artykule kursu. Bardzo mocno Cię do tego zachęcam. Moim zdaniem najwięcej nauczysz się samodzielnie eksperymentując z zapytaniami.     Klauzula WHERE   W artykule opisującym podstawy zapytania SELECT wspomniałem o klauzuli WHERE. Po przeczytaniu tamtego artykułu wiesz, że klauzula WHERE służy do filtrowania danych zwróconych przez zapytania typu SELECT.   Klauzula WHERE używana jest także w zapytaniach typu UPDATE, INSERT i DELETE. W pierwszym przypadku ogranicza zbiór wierszy, który powinien zostać zaktualizowany. W przypadku zapytania typu DELETE ogranicza zbiór wierszy, który powinien zostać usunięty. W zapytaniach typu INSERT używany jest z podzapytaniami (o podzapytaniach przeczytasz w jednym z kolejnych artykułów).   Informacje, które przeczytasz w tym artykule można odnieść do wszystkich czterech rodzajów zapytań.   Literały w SQL   Zanim przejdę do omawiania warunków musisz poznać literały. Używałem ich już w poprzednim artykule bez dodatkowego wyjaśnienia. Tutaj poświęcę im osobny paragraf.   Najprostszym rodzajem literałów są liczby, zapisuje się je podobnie jak w językach programowania: 42, 12.34. Liczby mogą być zapisane także w notacji naukowej 1.34E-5 lub szesnastkowo 0xBACA1.   Często będziesz także używać łańcuchów znaków. Łańcuch znaków powinien być otoczony apostrofami, na przykład 'Samouczek Programisty'.   Innym przykładem literału jest NULL, który określa pustą wartość.   Znaki specjalne w SQL   W SQL występują znaki specjalne. Do tej pory wprowadziłem '. Jeśli chcesz aby Twoje zapytanie dotyczyło wierszy, które zawierają ' musisz poprzedzić go drugim znakiem '. Spójrz na przykład poniżej, posługuję się w nim konstrukcją LIKE, którą opisuję w jednym z kolejnych akapitów. Zapytanie zwraca wszystkie wiersze, w których kolumna title zawiera znak ':   SELECT *   FROM album  WHERE title LIKE '%''%';   Warunki   Łączenie warunków   Każdy z warunków, który opiszę można ze sobą łączyć używając operatorów AND lub OR. AND ma pierwszeństwo przed OR. Można także użyć nawiasów (), aby określić pierwszeństwo wykonania warunków. Używanie nawiasów nie zawsze jest obowiązkowe. Jednak moim zdaniem często warto ich używać. Dzięki nim bardziej skomplikowane zapytania mogą być bardziej czytelne. Nawiasy w przykładzie poniżej są zbędne, nie mają wpływu na kolejność wykonywania operacji:   x OR y AND z x OR (y AND z)   Nawiasy w przykładzie poniżej zmieniają kolejność wykonywania operacji, więc nie można ich pominąć bez zmiany znaczenia zapytania:   (x OR y) AND z       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Negacja warunków   Poza operatorami łączenia, które już znasz, istnieje także operator negacji warunku. Służy do tego operator NOT. Ten operator ma wyższy priorytet niż OR czy AND. Także i w tym przypadku możesz użyć nawiasów aby zmienić kolejność wykonywanych operacji. Poniższy przykład pokazuje przypadek, w którym nawiasy nie mają wpływu na kolejność wykonywanych porównań:   (NOT x) OR y NOT x OR y   Jednak umieszczenie nawiasów w innym miejscu zupełnie zmienia warunek, który musi zostać spełniony przez zwracane wiersze:   NOT (x OR y)   &lt;, &lt;=, =, !=, &gt;, &gt;=`   Zacznę od najprostszych typów porównań. Podobne operatory występują także w językach programowania. Operatory porównują ze sobą wartości po obu stronach.      A &lt; B – wiersz spełnia warunek jeśli A jest mniejsze od B,   A &lt;= B – wiersz spełnia warunek jeśli A jest mniejsze bądź równe B,   A = B – wiersz spełnia warunek jeśli A jest równe B,   A != B – wiersz spełnia warunek jeśli A jest różne od B,   A &gt; B – wiersz spełnia warunek jeśli A jest większe od B,   A &gt;= B – wiersz spełnia warunek jeśli A jest większe bądź równe B.   Na przykład zapytanie poniżej wyświetli tylko te wiersze z tabeli invoice, których wartość kolumny total będzie większa niż 14 i mniejsza niż 15:   SELECT invoiceid       ,total   FROM invoice  WHERE total &gt; 14    AND total &lt; 15;   Następne zapytanie zwróci jedynie te wiersze, dla których kolumna total ma wartość 21.68:   SELECT invoiceid       ,total       ,billingcountry   FROM invoice  WHERE total = 21.86;   Operatory = i != mają dwie postacie. W tym samym celu możesz także użyć odpowiednio == i &lt;&gt;.   Porównywanie łańcuchów znaków   W przypadku języka SQL operatory służą do porównywania wartości kolumn. Mogą być użyte nie tylko do typów liczbowych. Dzięki tym operatorom można na przykład porównywać łańcuchy znaków. Zapytanie poniżej zwróci tylko te wiersze dla których kolumna billingcountry będzie większa niż A i mniejsza niż C. Innymi słowy zapytanie to zwróci wiersze, dla których billingcountry zawiera kraje zaczynające się na literę A albo B:   SELECT *   FROM invoice  WHERE billingcountry &gt; 'A'    AND billingcountry &lt; 'C';   Porównywanie dat   SQLite nie ma specjalnego typu do przechowywania dat. Do tego celu używane mogą być łańcuchy znaków lub liczby. W związku z tym porównywanie dat sprowadza się do porównywania tych typów danych. Na przykład zapytanie poniżej zwróci wszystkie wiersze, które zawierają faktury wystawione w Polsce od 26 maja 2012 roku.   SELECT *   FROM invoice  WHERE billingcountry = 'Poland'    AND invoicedate &gt; '2012-05-26';   Przy porównaniach tego typu musisz uważać. Powyższe zapytanie zwróci wiersz, który zawiera datę 2012-05-26 00:00:00. Jeśli zmieniłbym warunek na invoicedate &gt; '2012-05-26 00:00:00' wówczas ten wiersz zostałby pominięty.   BETWEEN   Do określenia zakresu, w którym powinna znaleźć się wartość kolumny możesz użyć BETWEEN. Zapytanie poniżej zwróci wszystkie wiersze, dla których wartość kolumny total jest większa bądź równa 10.91 i mniejsza bądź równa 11.96:   SELECT *   FROM invoice  WHERE total BETWEEN 10.91 AND 11.96;   Porównanie total BETWEEN 10.91 AND 11.96 jest tożsame porównaniu total &gt;= 10.91 AND total &lt;= 11.96. Warunek BETWEEN można poprzedzić NOT   LIKE   SQL pozwala także na bardziej swobodne porównywanie łańcuchów znaków. Do tego celu używa się konstrukcji LIKE. W tym przypadku możesz użyć dwóch symboli, które mają specjalne znaczenie:      % – oznacza dowolną liczbę znaków,   _ – oznacza jeden znak.   Mechanizm ten można porównać do bardzo uproszczonych wyrażeń regularnych:      % odpowiada .* w wyrażeniach regularnych,   _ odpowiada . w wyrażeniach regularnych.   Proszę spójrz na przykład poniżej. W przykładzie tym wyświetlam wyłącznie wiersze, w których wartość kolumny billingcountry pasuje do określenia %land. Innymi słowy wyświetlam wyłącznie te wiersze, które kończą się na land:   SELECT *   FROM invoice  WHERE billingcountry   LIKE '%land';   Poniższe zapytanie jest lekką modyfikacją powyższego. Jak widzisz użyłem w nim % dwa razy. W tym przypadku wyświetlone zostaną wiersze, w których kolumna billingcountry zawiera ciąg znaków land:   SELECT *   FROM invoice  WHERE billingcountry   LIKE '%land%';   Słowo kluczowe LIKE możesz poprzedzić NOT. Warunek NOT x LIKE y jest tożsamy warunkowi x NOT LIKE y.   Jeśli chcesz aby znaki _ czy % były traktowane dosłownie musisz posłużyć się wyrażeniem ESCAPE. Proszę spójrz na przykład poniżej. Zapytanie zwraca wszystkie wiersze, dla których wewnątrz kolumny name występuje znak %:   SELECT *   FROM track  WHERE name LIKE '%e%%' ESCAPE 'e';   Literał po ESCAPE może zawierać pojedynczy znak. Symbol ten jest użyty do poprzedzenia symbolu, który powinien być traktowany dosłownie. W przykładzie powyżej użyłem 'e'.   IS NULL   Niektóre wiersze mogą mieć puste kolumny. Puste, czyli takie, które nie są uzupełnione żadną wartością. W takim przypadku mówi się, że kolumna ma wartość NULL. Aby filtrować wiersze na podstawie tej wartości należy użyć wyrażenia IS NULL. Na przykład zapytanie poniżej pokazuje tylko te kraje, dla których wartość kolumny billingstate ma wartość NULL:   SELECT *   FROM invoice  WHERE billingstate IS NULL;   Zwróć uwagę na to, że kolumna zawierająca łańcuch znaków '' (pusty łańcuch znaków) i wartość NULL to dwie zupełne różne rzeczy.   Podobnie jak w przypadku LIKE także tutaj możesz użyć słowa kluczowego NOT. Warunki NOT x IS NULL i x IS NOT NULL są tożsame.   IN   Jeśli chcesz zwrócić wiersze, dla których kolumna przyjmuje jedną z określonych wartości możesz użyć IN. Zapytanie poniżej zwróci wszystkie wiersze z tabeli invoice, dla których billingcountry ma wartość 'USA' i billingstate jedną z wartości 'CA' lub 'TX':   SELECT *   FROM invoice  WHERE billingcountry = 'USA'    AND billingstate IN ('CA', 'TX');   Użycie IN jest tożsame odpowiedniej liczbie warunków połączonych OR.   Czym jest wstrzykiwanie SQL (ang. SQL Injection)   Wstrzykiwanie SQL jest jednym z podstawowych ataków na aplikacje używające baz danych. Polega on na odpowiednim spreparowaniu danych wejściowych. W takim przypadku poza zapytaniem, które przygotuje programista wykonywane może być także to wprowadzone przez użytkownika.   Proszę spójrz na przykład w języku Java. W ten sposób na pewno będzie Ci łatwiej zrozumieć ten typ ataku.   Załóżmy, że w aplikacji próbujesz zaimplementować moduł logowania2. Użytkownik w formularzu wprowadza swój e-mail i hasło.   Aby upewnić się, że podane dane są prawidłowe pobierane są wiersze, które pasują do przekazanych danych logowania. Programista napisał szablon zapytania, który następnie uzupełniany jest danymi od użytkownika:   String emailProvidedByUser = \"...\"; String passwordProvidedByUser = \"...\"; String queryTemplate = \"SELECT password_hash FROM users WHERE email = '%s';\" String query = String.format(queryTemplate, emailProvidedByUser);  String paswordHashInDatabase = executeQuery(query); boolean loginSuccessfull = magicHash(passwordProvidedByUser).equals(paswordHashInDatabase);   Jeśli użytkownik wprowadzi email zenek@parapet.pl i hasło tajnehaslo to logowanie przebiegnie pomyślnie :). Problem zacznie się jeśli użytkownik zacznie być złośliwy. Co stanie się jeśli użytkownik wprowadzi email '; DELETE FROM users WHERE 1 = 1 OR email = ' i dowolne hasło?   Do bazy zostanie wysłane następujące zapytanie:   SELECT password_hash   FROM users  WHERE email = '';   DELETE FROM users  WHERE 1 = 1     OR email = '';   Właściwie są to dwa zapytania. Bardziej istotne jest drugie z nich. Po jego wykonaniu z tabeli users zostaną usunięte wszystkie wiersze. To raczej nie jest efekt, którego spodziewał się programista ;).   Zapobieganie SQL Injection   Ręczne budowanie zapytań SQL poprzez łączenie łańcuchów znaków przeważnie nie jest dobrym rozwiązaniem. Używaj do tego celu dedykowanych bibliotek. W Języku Java może to być na przykład Hibernate. W Pythonie SQLalchemy też świetnie daje sobie z tym radę. Jestem pewien, że w innych językach programowania istnieją podobne rozwiązania. Biblioteki te domyślnie odpowiednio traktują dane, które służą do wypełniania szablonów zapytań.   Jeśli chcesz budować zapytania “ręcznie”. Pamiętaj o odpowiednim traktowaniu danych pochodzących od użytkownika. Takim danym nigdy nie można ufać. Musisz założyć, że każdy użytkownik jest złośliwy i będzie chciał zepsuć Twoją aplikację. W najprostszym scenariuszu użycie '' w miejscu każdego znaku ' w danych pochodzących od użytkownika powinno pomóc.   Zadania do wykonania   Poniżej znajdziesz zestaw zadań, które pomogą Ci przećwiczyć materiał omówiony w tym artykule.   Napisz zapytanie, które:      zwróci wszystkie wiersze z tabeli track, dla których: unitprice jest mniejsze niż 1 i znak % zawarty jest w kolumnie name oraz kolumna name kończy się na e,   zwróci wszystkie wiersze z tabeli invoice, które mają uzupełnioną kolumnę billingstate i nie są ze Stanów Zjednoczonych,   zwróci wszystkie wiersze z tabeli invoice, które dotyczą Polski, Czech albo Węgier dla których wartość faktury przekracza 10,   zwróci imiona pracowników z tabeli employee, które dotyczą pracowników urodzonych w latach 60.   Przykładowe rozwiązania zadań   SELECT *   FROM track  WHERE unitprice &lt; 1    AND name LIKE '%x%%e' ESCAPE 'x';   SELECT *   FROM invoice  WHERE billingstate IS NOT NULL    AND billingcountry != 'USA';   SELECT *   FROM invoice  WHERE billingcountry IN ('Poland', 'Czech Republic', 'Hungary')    AND total &gt; 10;   SELECT firstname    FROM employee  WHERE birthdate BETWEEN '1960-' AND '1970-';   Podsumowanie   Warunki masz już za sobą. Po rozwiązaniu zadań potrafisz sprawnie posługiwać się różnymi warunkami w języku SQL. Wiesz jak wygląda atak SQL injection i jak można się przed nim bronić. Jeśli znasz kogoś komu ta wiedza może się przydać proszę przekaż odnośnik do tego artykułu. Dzięki temu pomożesz mi dotrzeć do nowych czytelników a na tym właśnie mi zależy. Z góry dziękuję :).   Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę polub Samouczka na Facebooku i dodaj swój adres e-mail do samouczkowego newslettera.   Trzymaj się i do następnego razu!                 To zależy od silnika bazy danych. SQLite wspiera literały tego typu. &#8617;                  Do tej pory nie spotkałem się jeszcze z sytuacją, w której mechanizm logowania musiałbym pisać od podstaw samemu. Nie rób tego samodzielnie, użyj gotowego, sprawdzonego rozwiązania. &#8617;           ","categories": ["Bazy danych","Kurs SQL"],
        "tags": [],
        "url": "/klauzula-where-w-zapytaniach-sql/",
        "teaser": "/assets/images/2018/07/13_klauzula_where_w_zapytaniach_sql_artykul.jpeg"
      },{
        "title": "Samouczek na rozmowie – zagnieżdżona struktura",
        "excerpt":"     To jest artykuł z serii “Samouczek na rozmowie”. W ramach tej serii staram się, między innymi, rozwiązywać zadania. Zadania te często zdarzają się na rozmowach kwalifikacyjnych.   W trakcie rozwiązywania takich zadań umiejętność szacowania złożoności obliczeniowej jest niezwykle ważna. Przyda się też umiejętność pisania testów jednostkowych. Dzięki nim bardzo łatwo przetestujesz działanie algorytmu.      Podstawy złożoności obliczeniowej,   Test Driven Development na przykładzie,   Testy jednostkowe z JUnit,   Podstawą jest oczywiście znajomość języka programowania, ja używał będę Javy jednak możesz użyć dowolnego języka programowania. W opisie problemu czasami będę używał “pseudo kodu”. Przykładowe rozwiązania będą w języku Java.      Kurs programowania w języku Java.     Do tej pory w ramach zadań rozwiązywanych na rozmowach kwalifikacyjnych pokazywałem wyłącznie problemy algorytmiczne. To zadanie jest inne. W tym przypadku zadaniem nie jest znalezienie wydajnego algorytmu rozwiązującego problem. Tym razem należy napisać program, który realizuje pewną funkcjonalność.   W tym przypadku przyszły pracodawca chce sprawdzić czy znasz składnię języka. Czy potrafisz pisać kod, który jest czytelny, łatwy do rozszerzenia i testowania. Może sprawdzić znajomość zasad SOLID w praktyce. Przy zadaniach tego typu umiejętność pisania wydajnych algorytmów nie jest tak istotna.   Rozwiązując zadania tego typu możesz także pokazać zestaw innych przydatnych umiejętności. Przeczytasz o tym w dalszej części artykułu.   Zadanie do wykonania   Zacznę od pokazania zadania do wykonania. Jak już wiesz to zadanie dostałem od jednego z czytelników. Treść zadania przekazana Mateuszowi byłą następująca:      Przekazuję zadanie z prośbą o analizę poniższego kodu i zaimplementowanie metod findByCode, findByRenderer, count w klasie MyStructure – najchętniej unikając powielania kodu. Proszę uwzględnić w analizie i implementacji interfejs ICompositeNode!    interface IMyStructure {   // zwraca węzeł o podanym kodzie lub null   INode findByCode(String code);   // zwraca węzeł o podanym rendererze lub null   INode findByRenderer(String renderer);   // zwraca liczbę węzłów   int count(); }   public class MyStructure implements IMyStructure {   private List&lt;INode&gt; nodes; }   interface INode {   String getCode();   String getRenderer(); }   interface ICompositeNode extends INode {   List&lt;INode&gt; getNodes(); }   W żaden sposób nie modyfikowałem przekazanego kodu, ani nie zmieniałem treści zadania. Zgodnie z tym co powiedział Mateusz to było wszystko co dostał w ramach zadania do rozwiązania.   Jak rozwiązać takie zadanie   Zanim przejdę do rozwiązania tego zadania chciałbym zwrócić Twoją uwagę na kilka elementów.   Opis nie jest wyczerpujący   Opis tego zadania nie jest wyczerpujący. Nie znajdziesz w nim dokładnych wytycznych jak powinien zachować się kod. Na przykład nie wiesz jak powinna zachować się metoda findByCode jeśli atrybut nodes zawiera więcej niż jeden element, który pasuje do wyszukiwania. Powinieneś zakończyć metodę wyjątkiem? Zwrócić ten, który został dodany jako pierwszy? Czy może ten, który jest najnowszy?   Jak powinna zachować się metoda count jeśli zawiera instancję implementującą ICompositeNode zawierającą samą siebie?   Takie pytania można mnożyć. W takim przypadku moim zdaniem kandydat powinien zrobić jedną z dwóch rzeczy. Pierwszą opcją jest dopytanie się o te szczegóły i czekanie na odpowiedź od potencjalnego pracodawcy. Drugim podejściem jest założenie, co autor zadania miał na myśli.   Oba rozwiązania mają swoje wady i zalety. Zwrócenie się z pytaniem o uszczegółowienie pozwoli zrealizować zadanie dokładnie w taki sposób jak oczekiwał autor zadania. Jednak minusem tutaj jest dodatkowy czas oczekiwania. Dodatkowo takich pytań może pojawić się wiele w trakcie rozwiązywania zadania.   Założenia są dobre   Podejście z przyjęciem pewnych założeń moim zdaniem jest najlepszym rozwiązaniem. Działając w ten sposób pokazujesz pracodawcy wiele ważnych informacji:      potrafisz przewidywać sytuacje, które nie są oczywiste i nie zdarzają się często,   potrafisz samodzielnie podjąć decyzję i ją uargumentować,   wyróżniasz się wśród innych kandydatów, którzy nie zapytali/nie przyjęli żadnych jasnych założeń przy rozwiązywaniu zadania.   Oczywiście w codziennej pracy to klient decyduje o ostatecznym zachowaniu programu, jednak na potrzeby zadania na rozmowie kwalifikacyjnej taki kompromis wydaje mi się najlepszy.   Konwencja nazewnicza   Przyznam, że tutaj mam ciężki orzech do zgryzienia. Konwencja nazewnicza stosowana w kodzie przekazanym Mateuszowi nie jest typowa. Zakłada ona, że interfejsy poprzedzone są wielką literą I.   Są przypadki kiedy po nazwie klasy/interfejsu warto wiedzieć czy jest to interfejs czy klasa, jednak nie jest to częsta sytuacja. Z tego co wiem taka konwencja obowiązuje w C# i .NET. Jednak nie jest powszechnie stosowana w świecie języka Java.   Przy rozwiązywaniu zadań tego typu staram się stosować do konwencji narzuconych przez autora zadania. Czyli w tym przypadku nazwa każdego nowego interfejsu zaczynałaby się od I. W takim przypadku podejrzewałbym, że system, który rozwija potencjalny pracodawca stosuje taką konwencję w swoim kodzie produkcyjnym.   Testy automatyczne   Testy są ważne. Nie pytaj czy masz dostarczyć rozwiązanie z testami. Traktuj testy automatyczne jako część dostarczanego rozwiązania. Rozwiązanie zadania bez testów nie jest kompletne.   Rozwiązując zadania tego typu staraj się rozwiązywać je używając Test Driven Development. Dzięki takiemu podejściu skrócisz czas testowania gotowego rozwiązania. Dodatkowo pokażesz potencjalnemu pracodawcy, że potrafisz pisać testy jednostkowe.   Dokumentacja   Dokumentacja jest ważna. Nie pytaj czy masz dostarczyć rozwiązanie z dokumentacją. Traktuj dokumentację jako część dostarczanego rozwiązania. Rozwiązanie zadania bez dokumentacji nie jest kompletne.   Czy poprzedni akapit brzmi znajomo ;)? W przypadku zadań tego typu dokumentacja jest podobna do testów1. Pokaż pracodawcy, że wiesz jak ważna jest dokumentacja. Nie chodzi mi tu o dokumentowanie każdej linijki kodu. Mam na myśli kilka akapitów, które opiszą dostarczony program. Jeśli opis zadania nie był kompletny i trzeba było przyjąć pewne założenia, to dokumentacja jest świetnym miejscem na ich opisanie.   Dokumentację możesz dostarczyć jako osobny dokument, albo zaszyć ją w kodzie. W języku Java do tego celu używa się notacji javadoc.   Rozwiązanie zadania   Zadanie rozwiązałem używając TDD. Starałem się dodawać zmiany po każdym cyklu więc patrząc w historię repozytorium możesz zobaczyć jak rozwijał się kod. Zanim jednak zajrzysz do przykładowego rozwiązania zachęcam Cię do samodzielnej próby rozwiązania tego zadania.   Możesz później użyć mojego zestawu testów jednostkowych żeby sprawdzić czy Twój kod działa poprawnie2.   Rozszerzenie interfejsu INode   Żeby poprawnie obsłużyć zagnieżdżone elementy rozszerzyłem interfejs INode o dodatkową metodę Stream&lt;INode&gt; toStream(). To jedno z tych założeń, o których pisałem wcześniej. Założyłem, że takie rozszerzenie interfejsu jest dopuszczalne. Jeśli nie byłoby to możliwe, problem można byłoby rozwiązać w inny sposób. Jednak ta droga prowadziła do kodu, który jest bardziej czytelny.   Implementacja tej metody w klasie CompositeNode wygląda następująco:  @Override public Stream&lt;INode&gt; toStream() {     return Stream.concat(             super.toStream(),             nodes.stream().flatMap(INode::toStream)     ); }  Te kilka linijek zapewnia poprawne obsłużenie wielokrotnie zagnieżdżonych struktur.   Usunięcie duplikacji w metodach wyszukujących   Przykładowa metoda służąca do wyszukiwania po atrybucie renderer wygląda następująco:   @Override public INode findByRenderer(String renderer) {     if (renderer == null) {         throw new IllegalArgumentException(\"Renderer is null!\");     }     return findByPredicate(n -&gt; renderer.equals(n.getRenderer())); }  private INode findByPredicate(Predicate&lt;INode&gt; predicate) {     return nodes.stream()             .flatMap(INode::toStream)             .filter(predicate)             .findFirst()             .orElse(null); }  Rzuć okiem na metodę findByPredicate. Jej użycie pozwoli na uniknięcie duplikacji, na którą zwracał uwagę autor zadania. Jak widzisz w kodzie używałem wyłącznie strumieni, zadanie oczywiście można także rozwiązać używając pętli.   Wyślij mi swoje zadanie   Jak już wiesz zadanie to dostałem od jednego z czytelników, od Mateusza. Jeśli chcesz żebym spróbował rozwiązać Twoje zadanie proszę wyślij je na mój adres e-mail marcin małpka samouczekprogramisty.pl. Jeśli tylko będę potrafił je rozwiązać to z chęcią napiszę o tym artykuł.     Często firmy zastrzegają sobie to, żeby nie rozpowszechniać zadań, które były na rozmowie kwalifikacyjnej. Jeśli tak było w Twoim przypadku proszę uszanuj wolę danej firmy i nie przesyłaj mi takiego zadania.   Dostając zadanie od Ciebie zakładam, że mogę je opublikować na blogu.     Podsumowanie   Po przeczytaniu tego artykułu wiesz na co zwracać uwagę przy rozwiązywaniu zadań rekrutacyjnych, które nie są związane z napisaniem wydajnego algorytmu. Wiesz jak ważne są testy jednostkowe i dokumentacja. Artykuł także pokazał Ci, jak ważne jest przyjmowanie założeń dotyczących treści zadania. Innymi słowy udało Ci się przygotować “o jedno zadanie lepiej” do następnej rozmowy kwalifikacyjnej.   Na koniec mam dla Ciebie prośbę. Zależy mi na dotarciu do jak największej grupy czytelników. Jeśli znasz kogoś, komu ten artykuł może się przydać proszę podziel się linkiem do tego artykułu. Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku dopisz się do newslettera i polub samouczkowy profil na Facebook’u.   Do następnego razu!                 Testy także można traktować jako dokumentację, jednak jest to temat na osobny artykuł. &#8617;                  Testy powinny przejść u Ciebie. Chyba, że Twoje założenia dotyczące niejasnych wymagań były inne ;). &#8617;           ","categories": ["Samouczek na rozmowie","Strefa zadaniowa"],
        "tags": [],
        "url": "/samouczek-na-rozmowie-zagniezdzona-struktura/",
        "teaser": "/assets/images/2018/08/26_zadanie_z_rozmowy_kwalifikacyjnej.jpeg"
      },{
        "title": "Sortowanie, aliasy, ograniczanie wyników i zwracanie unikalnych wartości",
        "excerpt":"     To jest jeden z artykułów w ramach praktycznego kursu SQL. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Każde zapytanie z kursu możesz wykonać samodzielnie. Potrzebujesz do tego środowiska opisanego w pierwszym artykule kursu. Bardzo mocno Cię do tego zachęcam. Moim zdaniem najwięcej nauczysz się samodzielnie eksperymentując z zapytaniami.     W poprzednich częściach kursu opisałem klauzulę WHERE wraz z podstawami zapytania typu SELECT. Ten artykuł opisuje kilka dodatkowych mechanizmów, które możesz wykorzystać przy pracy z zapytaniami tego typu.   Kolejność wyrażeń   Zanim przejdę do wyjaśnienia poszczególnych wyrażeń chciałbym zwrócić Twoją uwagę na ich kolejność. Język SQL określa w jakiej kolejności powinny być one używane w zapytaniach. Kolejność ta zawsze wygląda następująco:      SELECT ... (    FROM ...) (   WHERE ...) (ORDER BY ...) (   LIMIT ...)   Elementy otoczone nawiasami () są opcjonalne i mogą być pominięte.   Ograniczanie liczby wyników   Często w trakcie pracy z danymi w bazach relacyjnych chcemy podejrzeć dane zwracane przez zapytanie. W takim przypadku ważnych jest tylko kilka wynikowych wierszy. W takim przypadku z pomocą przychodzi wyrażenie LIMIT, które pozwala na ograniczenie liczby zwracanych wierszy. Na przykład poniższe zapytanie zwróci jedynie pięć wierszy z tabeli genre:   SELECT *    FROM genre  LIMIT 5;   To wyrażenie często jest używane do stronicowania. Wyobraź sobie sytuację, w której sklep na stronie wyświetla dziesięć produktów. Odpowiednio skonstruowane zapytanie z wyrażeniem LIMIT 10 zwróci dokładne te produkty, które powinny być wyświetlone.   Do poprawnego stronicowania używa się także wyrażenia OFFSET, które pozwala na przeskoczenie odpowiedniej liczby wyników. Na przykład wyrażenie poniżej wyświetli pięć wierszy pomijając pierwsze dziesięć. Pamiętaj, że w “produkcyjnych” zapytaniach tego typu powinno używać się sortowania, które opiszę niżej:   SELECT *   FROM genre  LIMIT 5 OFFSET 10;   Wyłącznie unikalne wiersze   W niektórych przypadkach zapytanie SQL powinno zwrócić wyłącznie unikalne wartości. Tabela invoice zawiera między innymi kolumnę billingcountry. W tej kolumnie zawarty jest kraj, w którym wystawiono fakturę. Załóżmy, że Twoim zadaniem jest pobranie listy krajów, w których dokonano jakiegokolwiek zakupu. Tę listę zwróci takie zapytanie:   SELECT billingcountry   FROM invoice   To zapytanie ma jednak pewną wadę. Zwróć uwagę na to, że zwraca ono wartość kolumny billingcountry dla każdego wiersza znajdującego się w tabeli źródłowej. W tym przypadku tabela źródłowa zawiera wiele faktur dla tego samego kraju. Wystarczy spojrzeć na wynik zapytania. Poniżej możesz zobaczyć pierwsze dziesięć wierszy:   Germany Norway Belgium Canada USA Germany Germany France France Ireland   Jak widzisz lista zawiera duplikaty. Germany i France są powielone. Cała lista krajów zawiera jeszcze więcej duplikatów, możesz to sprawdzić uruchamiając zapytanie samodzielnie.   W przypadku tego typu zapytań z pomocą przychodzi wyrażenie DISTINCT. Pozwala ono na odfiltrowanie powielonych wierszy. Proszę spójrz na przykład:   SELECT DISTINCT billingcountry   FROM invoice;   Tym razem pierwsze dziesięć wierszy wygląda inaczej. Zwróć uwagę, że tym razem dzięki DISTINCT żaden wiersz nie jest powielony:   Germany Norway Belgium Canada USA France Ireland United Kingdom Australia Chile   Wiele kolumn z wyrażeniem DISTINCT   Klauzulę DISTINCT możesz stosować także w przypadku wielu kolumn. Załóżmy, że chcesz uzyskać listę wszystkich krajów i miejscowości, w których dokonano zakupu. Aby uzyskać taki wynik wystarczy nieznacznie zmodyfikować poprzednie zapytanie:   SELECT DISTINCT billingcountry       ,billingcity   FROM invoice;   Pierwsze dziesięć wierszy zwrócone przez to zapytanie wygląda tak (znak | służy do oddzielenia kolumn):   Germany|Stuttgart Norway|Oslo Belgium|Brussels Canada|Edmonton USA|Boston Germany|Frankfurt Germany|Berlin France|Paris France|Bordeaux Ireland|Dublin   Zwróć uwagę na to, że kraje się powtarzają. Tym razem to para billingcountry i billingcity jest unikalna.   NULL a DISTINCT   Aby określić czy wartości są unikalne trzeba je ze sobą porównać. Dzięki takiemu porównaniu zwracany wynik nie zawiera duplikatów. Porównywane są wszystkie wartości, NULL nie jest tu wyjątkiem. Proszę rzuć okiem na wynik tego zapytania, zwraca ono unikalne wartości dla pary billingcountry i billingstate:   SELECT DISTINCT billingcountry       ,billingstate   FROM invoice;  Pierwsze dziesięć wierszy zwrócone przez to zapytanie wygląda następująco:   Germany| Norway| Belgium| Canada|AB USA|MA France| Ireland|Dublin United Kingdom| USA|CA USA|WA   Istnieją faktury wystawione w Niemczech, które nie mają uzupełnionej kolumny billingstate. Widać to w pierwszym wierszu wyników. Oznacza to tyle, że DISTINCT wartości NULL traktuje jako równe sobie.   Sortowanie wyników   Język SQL bardzo często używany jest do generowania różnego rodzaju raportów. Raporty te lepiej przegląda się jeśli są odpowiednio uporządkowane. W języku SQL do sortowania wyników używa się wyrażenia ORDER BY. Proszę spójrz na przykład poniżej:     SELECT name     FROM genre ORDER BY name;   To zapytanie pobiera wszystkie wartości kolumny name z tabeli genre. Zwrócony wynik posortowany jest rosnąco według kolumny name. Pierwsze pięć wierszy zwróconych przez to zapytanie wygląda tak:   Alternative Alternative &amp; Punk Blues Bossa Nova Classical   Zmiana kierunku sortowania   Domyślnie ORDER BY sortuje wyniki w porządku rosnącym. Możesz jednak to zmienić używając wyrażenia DESC po nazwie kolumny, która powinna być sortowana. Lekka modyfikacja poprzedniego zapytania zwraca gatunki muzyczne w kolejności malejącej:     SELECT name     FROM genre ORDER BY name DESC;   Tym razem pierwsze pięć wierszy wygląda zupełnie inaczej:   World TV Shows Soundtrack Science Fiction Sci Fi &amp; Fantasy   Istnieje wyrażenie ASC, które mówi o tym, żeby wynik był sortowany rosnąco. Często jest ono pomijane ponieważ, takie właśnie jest domyślne zachowanie ORDER BY. Przykładowe zapytanie bez pominięcia ASC może wyglądać tak:     SELECT name     FROM genre ORDER BY name ASC;       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Sortowanie po wielu kolumnach   Klauzula ORDER BY pozwala na sortowanie po wielu kolumnach jednocześnie. Na początku wynik sortowany jest po pierwszym wyrażeniu. Jeśli występują w nim duplikaty są one sortowane po drugim wyrażeniu, i tak dalej… Proszę spójrz na przykład:     SELECT DISTINCT billingcountry         ,billingstate     FROM invoice ORDER BY billingcountry DESC         ,billingstate;   To zapytanie zwraca unikalne wartości billingcountry i billingstate. Wynik posortowany jest malejąco po billingcountry i rosnąco po billingstate. Pierwsze pięć wierszy wyniku zapytania wygląda następująco:   United Kingdom| USA|AZ USA|CA USA|FL USA|IL   Możesz także sortować po kolumnie, która nie jest uwzględniona w finalnym wyniku. Na przykład zapytanie poniżej zwraca wyłącznie unikalne wartości kolumny billingcountry sortując je po kolumnie billingcity:     SELECT DISTINCT billingcountry     FROM invoice ORDER BY billingcity;   Wynik tego zapytania może wydawać się losowy, jednak podejrzenie miast skojarzonych z wyświetlonymi państwami pozwoli rozwiązać zagadkę sortowania:   Netherlands India USA Belgium Hungary Argentina   Aliasy dla kolumn       W jednym z poprzednich artykułów opisałem przygotowanie środowiska. Zakładam, że w trakcie kursu używasz SQLite.   W przypadku tej bazy danych, klient domyślnie nie wyświetla nazw zwracanych kolumn. Możesz je włączyć używając polecenia .headers on. Polecam także zmianę sposobu prezentacji wyników przy użyciu .mode column. Dzięki temu zwracane dane będą bardziej czytelne.   W tej sekcji kursu będę pokazywał wyniki w postaci kolumn z nagłówkiem zawierającym ich nazwy.     Spójrz na pierwsze pięć wierszy w tabeli genre:   sqlite&gt; SELECT * FROM genre LIMIT 5; GenreId     Name       ----------  ---------- 1           Rock       2           Jazz       3           Metal      4           Alternativ 5           Rock And R   W tym przypadku pierwszy wiersz wyników pokazuje nazwy zwracanych kolumn. Nazwy pod którymi zwracane są wyniki można zmienić używając wyrażenia AS. Spójrz na przykład:   SELECT genreid AS id       ,name AS 'genre name'   FROM genre  LIMIT 5;   Tym razem wyniki poprzedzone są innymi nazwami kolumn, mimo tego, że pochodzą z tego samego źródła.   id          genre name ----------  ---------- 1           Rock       2           Jazz       3           Metal      4           Alternativ 5           Rock And R   Wyrażenie AS najczęściej używane jest przy bardziej skomplikowanych zapytaniach. Na przykład jeśli do otrzymania pewnego wyniku potrzeba złączyć tabelę z samą sobą.  O zapytaniach tego typu przeczytasz w dalszej części kursu.   Scalanie wyników wielu zapytań   Do scalania1 wyników wielu zapytań służy wyrażenie UNION ALL albo UNION. Tym razem zacznę od przykładu:      SELECT name AS xxx      FROM genre UNION ALL    SELECT DISTINCT billingcity      FROM invoice  ORDER BY xxx     LIMIT 10;   To zapytanie zwraca w jednej kolumnie o nazwie xxx wszystkie wartości kolumny name z tabeli genre połączone z unikalnymi wartościami kolumny billingcity z tabeli invoice. Połączone wyniki tych dwóch zapytań posortowane są po kolumnie xxx. Zapytanie zwraca tylko dziesięć pierwszych wartości:   Alternative Alternative &amp; Punk Amsterdam Bangalore Berlin Blues Bordeaux Bossa Nova Boston Brasília   Podzapytania, które są scalane przy użyciu wyrażeń UNION albo UNION ALL muszą zwracać tę samą liczbę kolumn o tym samym typie2.   Wyrażenia LIMIT i ORDER BY mogą być użyte tylko do scalonych zapytań. Nie możesz ich użyć wewnątrz zapytań, które są scalane.   Różnica pomiędzy UNION a UNION ALL   Oba wyrażenia służą do scalenia wyników wielu zapytań. Mają jednak jedną znaczącą różnicę. UNION zwróci unikalną listę wierszy. UNION ALL zwróci wszystkie wiersze, w wyniku mogą być duplikaty.   Wiele podzapytań   W przykładzie powyżej użyłem UNION ALL do scalania wyników dwóch zapytań. Jednak nie jest to koniec możliwości tego wyrażenia. Pozwala ono na scalanie wyników wielu zapytań. Na przykład zapytanie poniżej jest także poprawne:      SELECT genreid          ,name AS xxx      FROM genre UNION ALL    SELECT invoiceid          ,billingcity      FROM invoice     UNION    SELECT albumid          ,title      FROM album  ORDER BY xxx     LIMIT 10;   Zwraca ono dwie kolumny, których zawartość pochodzi z trzech różnych tabel.   Czy UNION jest potrzebne?   Niektóre wyrażenia UNION mogą być zastąpione przy pomocy OR. Zatem kiedy stosować UNION albo UNION ALL? Te klauzule możesz stosować jeśli w wynikowej kolumnie powinny znaleźć się dane z różnych źródeł. Są też inne przypadki, związane z optymalizacją wydajności zapytań. Pominę te drugie bo znacząco wykraczają poza zakres tego kursu i są specyficzne dla różnych silników baz danych.   Zadania do wykonania   Poniżej znajdziesz kilka zadań do wykonania. Każde z nich wymaga napisania jednego zapytania. Napisz zapytanie, które:      zwróci dziesięć najdłuższych ścieżek (tabela track, kolumna milliseconds), weź pod uwagę tylko te, których kompozytor (kolumna composer) zawiera literę b,   zwróci pięć najtańszych ścieżek (tabela track, kolumna unitprice) dłuższych niż minuta,   zwróci unikalną listę dziesięciu kompozytorów których ścieżki kosztują mniej niż 2$ posortowanych malejąco według identyfikatora gatunku (kolumna genreid) i rosnąco według rozmiaru (kolumna bytes),   zwróci dwie kolumny. Pierwsza z nich powinna zawierać ścieżki (kolumna name) droższe niż 1$ i poprawnych kompozytorów (kolumna composer nie ma wartości NULL) pod nazwą magic thingy. Druga powinna zawierać liczbę bajtów. Wynik powinien zawierać dziesięć wierszy i być posortowany rosnąco po liczbie bajtów3,   zwróci piątą stronę z fakturami (tabela invoice) zakładając, że na stronie znajduje się dziesięć faktur i sortowane są według identyfikatora (kolumna invoiceid).   Przykładowe rozwiązania zadań     SELECT name     FROM track    WHERE composer like '%b%' ORDER BY milliseconds DESC    LIMIT 10;     SELECT name         ,unitprice     FROM track    WHERE milliseconds &gt; 60000 ORDER BY unitprice     LIMIT 5;     SELECT DISTINCT composer      FROM track    WHERE unitprice &lt; 2 ORDER BY genreid DESC         ,bytes    LIMIT 10;     SELECT name AS 'magic thingy'         ,bytes     FROM track    WHERE unitprice &gt; 1    UNION   SELECT composer         ,bytes     FROM track    WHERE composer IS NOT NULL ORDER BY bytes ASC    LIMIT 10;     SELECT *     FROM invoice ORDER BY invoiceid    LIMIT 10 OFFSET 40;   Podsumowanie   Kolejną część kursu SQL masz już za sobą. W tym artykule udało Ci się przeczytać o kilku przydatnych konstrukcjach. Wiesz jak sortować wyniki, jak ograniczać liczbę zwracanych wierszy, potrafisz łączyć ze sobą wyniki kilku zapytań i wiesz jak zwracać wyłącznie unikalne wartości. Po rozwiązaniu zadań  wiesz, że potrafisz wykorzystać tę wiedzę w praktyce. Gratulacje! :)   Które z zadań sprawiło Ci największą trudność? Może masz jakiekolwiek pytania dotyczące materiału, który opisałem w tym artykule? Daj znać w komentarzach pod artykułem.   Na koniec mam do Ciebie prośbę. Jeśli znasz kogoś dla kogo treść tego artykułu będzie przydatna proszę podziel się nim z tą osobą. Pomożesz mi w ten sposób dotrzeć do nowych czytelników. Jeśli nie chcesz ominąć kolejnych artykułów na blogu proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebook’u. Do następnego razu!                 Celowo unikam tu słowa złączenie, które bardziej kojarzy mi się z wyrażeniem typu JOIN, które opiszę w jednym z kolejnych artykułów. &#8617;                  Nie jest to do końca prawda. W przypadku relacyjnych baz danych, które znam SQLite jest najbardziej pobłażliwy. SQLite pozwala na łączenie ze sobą różnych typów przy użyciu UNION czy UNION ALL. Na przykład w bazie danych PostgreSQL użycie UNION do złączenia zapytań zwracających różne typy danych kończy się wyjątkiem. &#8617;                  W codziennym programowaniu raczej nie zdarza się sytuacja, w której w jednej wynikowej kolumnie łączy się zupełnie różne dane. &#8617;           ","categories": ["Bazy danych","Kurs SQL"],
        "tags": [],
        "url": "/sortowanie-aliasy-ograniczanie-wynikow-i-zwracanie-unikalnych-wartosci/",
        "teaser": "/assets/images/2018/09/04_sortowanie_aliasy_distinct_sql.jpg"
      },{
        "title": "Format JSON w języku Java",
        "excerpt":"Czym jest JSON   JSON (ang. JavaScript Object Notation) to format zapisu i wymiany danych. Jest to format tekstowy. Uważany jest za format czytelny zarówno dla maszyn jak i dla ludzi.   Dane formatowane przy użyciu JSON mogą być określane się jako application/json. Ta wartość może być zawarta w nagłówkach HTTP określając typ akceptowanych/wysyłanych danych.   Poniżej możesz zobaczyć prawidłowy dokument w formacie JSON:   {    \"timestamp\" : 1536731522,    \"event_type\" : \"jump-to-menu-activation\",    \"measures\" : {       \"filter_count\" : 77,       \"result_count\" : 25,       \"display_count\" : 7    },    \"dimensions\" : {       \"query\" : \"test\",       \"actor_id\" : 73585,       \"session_id\" : \"b5c50e56-75ce-50cb-9d44-7cbba93b00e5\",       \"display_set\" : [          [             \"Repository\",             106327483          ],          [             \"Repository\",             42456996          ]       ]    } }   To co widzisz powyżej to część zapytania, które wysyłane jest w trakcie wyszukiwania na Github’ie. W momencie wpisywania czegokolwiek w wyszukiwarkę strona wysyła zapytanie, którego ciało jest w formacie JSON. Fragment powyżej zawiera obiekt, który ma 4 atrybuty:      timestamp, którego wartością jest liczba,   event_type, którego wartością jest łańcuch znaków,   measures i dimensions, których wartościami są inne obiekty.   W związku ze swoją prostotą JSON nie wspiera przestrzeni nazw (ang. namespace). Weryfikacja schematu dokumentu możliwa jest przy użyciu dodatkowych narzędzi: JSON Schema lub JSchema. JSON często porównywany jest z formatem XML gdzie zarówno schemat jak przestrzenie nazw są wspierane. Faktem jest, że format JSON zawojował Internet. Stało się tak między innymi dzięki popularności języka JavaScript, z którego ten format się wywodzi.   Opis formatu JSON   JSON to bardzo prosty format zapisu/wymiany danych. Specyfikacja formatu JSON to jedna z przyjemniejszych specyfikacji jakie czytałem, jest przyjemna bo zawiera jedynie 5 stron tekstu ;). W formacie występuje sześć symboli, które określają strukturę dokumentu:      { i },   [ i ],   :,   ,.   W formacie tym występują tylko trzy “słowa kluczowe”, literały:      true,   false,   null.   Białe znaki (tabulator, znak nowej linii1 czy spacja) są ignorowane. Zatem dwa poniższe dokumenty JSON są równoważne:   {     \"coś\": \"jeszcze coś\" }  {\"coś\":\"jeszcze coś\"}   Wspierane typy danych   Łańcuch znaków   Łańcuchy znaków jakie są każdy widzi ;). Łańcuch znaków to ciąg znaków otoczony \". Dodatkowo znak \\ pozwala na wprowadzenie znaków specjalnych. Na przykład \\\" oznacza cudzysłów, a \\ ukośnik. Kilka przykładowych wartości:      \"some value\",   \"zażółć gęślą jaźń\",   \"true\",   \"\\\\\"\", reprezentuje łańcuch znaków \\\".   Obiekt   Element tego typu składa się z nawiasów { i }. Wewnątrz nawiasów umieszczone są pary w postaci: \"nazwa atrybutu\": &lt;wartość atrybutu&gt;. &lt;wartość atrybutu&gt; może być dowolną wspieraną wartością. Nazwa atrybutu przedstawiona jest jako łańcuch znaków. Pary oddzielone są od siebie ,. Kolejność par nie ma znaczenia. Specyfikacja nie narzuca unikalności kluczy2.   {     \"attribute\": \"value\",     \"other attribute\": 123 }   Lista   Element tego typu grupuje uporządkowaną listę wartości. Składa się on z nawiasów [ i ]. Wewnątrz nich znajdują się wartości oddzielone ,. Wartości wewnątrz listy mogą być różnych typów3:   [1, true, \"true\"]   Liczba   Liczby w formacie JSON to ciąg cyfr. Opcjonalnie poprzedzony znakiem -. Do oddzielenia części ułamkowej od całkowitej służy .. Notacja naukowa jest dopuszczalna. Oto kilka prawidłowych liczb w formacie JSON:      123,   123.123,   -123,   1.23123e2,   1.23123E-2.   Literały   W formacie JSON występują trzy literały:      true – reprezentuje wartość logiczną – prawdę,   false – reprezentuje wartość logiczną – fałsz,   null – reprezentuje wartość pustą, brak wartości.   Element główny   Specyfikacja formatu JSON nie narzuca typu elementu głównego. Oznacza to tyle, że zgodnie ze specyfikacją poniższe dokumenty są poprawne:   [1, 2, 3]   true   \"some string\"   Mimo braku takiego wymogu przyjęło się, że elementem głównym dokumentu w tym formacie zawsze jest obiekt. Poniżej znajdziesz “poprawną” reprezentację przykładów, które przytoczyłem wyżej:   {     \"x\": [1, 2, 3] }   {     \"y\": true }   {     \"z\": \"some string\" }   JSON-P       Wszystkie fragmenty kodu użyte w tym artykule udostępnione są na Samouczkowym Githubie. Zachęcam Cię do eksperymentów i uruchomienia kodu samodzielnie.   Zwróć też uwagę na zależności wspomniane w pliku build.gradle. Część klas użytych we fragmentach poniżej nie jest dostępna w standardowej bibliotece Javy.     JSON-P jest specyfikacją, która opisuje przetwarzanie formatu JSON. Zakłada przetwarzanie dokumentów JSON zarówno w całości jak i w trybie strumieniowym (nie trzeba załadować całego dokumentu do pamięci). Pozwala na parsowanie i generowanie dokumentów w formacie JSON. Specyfikacja JSON-P 1.1 jest częścią JEE 8.   Tryb “obiektowy”   Decydując się na tryb obiektowy musisz zbudować cały obiekt przed przekształcaniem go do formatu JSON.   Zapis   Tworzenie instancji klas odpowiadających typom formatu JSON polega na wywołaniu odpowiednich metod udostępnionych przez klasy JsonArrayBuilder i JsonObjectBuilder. Instancje tych klas tworzone są przez JsonBuilderFactory. Proszę spójrz na przykład poniżej:   JsonBuilderFactory builderFactory = Json.createBuilderFactory(Collections.emptyMap()); JsonObject publicationDateObject = builderFactory.createObjectBuilder()         .add(\"rok\", 2018)         .add(\"miesiąc\", 9)         .add(\"dzień\", 13).build();  System.out.println(publicationDateObject.toString());   W przykładzie tym tworzę obiekt, który ma trzy atrybuty: rok, miesiąc i dzień. Po uruchomieniu takiego fragmentu kodu na konsoli wyświetli się dokument w formacie JSON:   {\"rok\":2018,\"miesiąc\":9,\"dzień\":13}   Bardziej skomplikowany przykład możesz zobaczyć poniżej. Używam w nim dokładnie tego samego API łącząc ze sobą różne obiekty. W wyniku działania tego kodu powstaje zagnieżdżona struktura obiektów:   JsonBuilderFactory builderFactory = Json.createBuilderFactory(Collections.emptyMap()); JsonObject publicationDateObject = builderFactory.createObjectBuilder()         .add(\"rok\", 2018)         .add(\"miesiąc\", 9)         .add(\"dzień\", 13).build();  JsonObject articleObject = builderFactory.createObjectBuilder()         .add(\"tytuł\", \"Format JSON w języku Java\")         .add(\"data publikacji\", publicationDateObject).build();  JsonArray articlesArray = builderFactory.createArrayBuilder().add(articleObject).build();  JsonObject webPageObject = builderFactory.createObjectBuilder()         .add(\"adres www\", \"https://www.samouczekprogramisty.pl\")         .add(\"artykuły\", articlesArray).build();  JsonObject authorObject = builderFactory.createObjectBuilder()         .add(\"imię\", \"Marcin\")         .add(\"nazwisko\", \"Pietraszek\")         .add(\"strona\", webPageObject).build();   Tym razem użyję trochę innej metody wypisywania obiektu. Tworząc instancję JsonWriterFactory mogę przekazać konfigurację. Konfiguracja wpływa na zachowanie tej klasy.   Map&lt;String, ?&gt; config = Collections.singletonMap(JsonGenerator.PRETTY_PRINTING, true); JsonWriterFactory writerFactory = Json.createWriterFactory(config); writerFactory.createWriter(System.out).write(authorObject);   Dzięki takiemu podejściu wynik wypisywany na konsoli jest sformatowany w bardziej czytelny sposób:   {     \"imię\": \"Marcin\",     \"nazwisko\": \"Pietraszek\",     \"strona\": {         \"adres www\": \"https://www.samouczekprogramisty.pl\",         \"artykuły\": [             {                 \"tytuł\": \"Format JSON w języku Java\",                 \"data publikacji\": {                     \"rok\": 2018,                     \"miesiąc\": 9,                     \"dzień\": 13                 }             }         ]     }                                                                                                                                     }       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Odczyt   Każdy z przykładów poniżej używa instancji InputStream, którą tworzę w sposób pokazany poniżej. Metoda buildObject zwraca JsonObject, który pokazałem w poprzednim paragrafie:   String jsonObject = buildObject().toString(); InputStream inputStream = new ByteArrayInputStream(jsonObject.getBytes());   Odczyt dokumentów w formacie JSON używa podobnego API. Tym razem tworzę instancję klasy JsonReaderFactory. Używam jej do utworzenia instancji JsonReader:   JsonReaderFactory readerFactory = Json.createReaderFactory(Collections.emptyMap()); JsonReader jsonReader = readerFactory.createReader(inputStream);   Klasa JsonReader udostępnia kilka metod, które pozwalają na odczyt danych w formacie JSON:      readObject,   readArray,   readValue,   read.   Używając publicznych metod udostępnionych w klasach JsonObject i JsonArray poruszam się po dokumencie JSON:   try (JsonReader jsonReader = readerFactory.createReader(new ByteArrayInputStream(jsonDocument.getBytes()))) {     JsonObject jsonObject = jsonReader.readObject();     System.out.println(jsonObject                     .getJsonObject(\"strona\")                     .getJsonArray(\"artykuły\")                     .get(0).asJsonObject()                     .getJsonObject(\"data publikacji\")     ); }   Powyższy fragment kodu wyświetli na konsoli jeden z zagnieżdżonych obiektów:   {\"rok\":2018,\"miesiąc\":9,\"dzień\":13}   Istnieje jednak prostszy sposób na dotarcie do tego samego obiektu. Można posłużyć się ścieżką jak w przykładzie poniżej:   JsonReaderFactory readerFactory = Json.createReaderFactory(Collections.emptyMap()); try (JsonReader jsonReader = readerFactory.createReader(new ByteArrayInputStream(jsonDocument.getBytes()))) {     JsonStructure jsonStructure = jsonReader.read();     System.out.println(jsonStructure.getValue(\"/strona/artykuły/0/data publikacji\")); }   Tryb strumieniowy   Tryb strumieniowy pozwala na odczyt/zapis dokumentów w formacie JSON bez ładowania ich w całości do pamięci. Dane są odczytywane lub zapisywane na bieżąco.   Zapis   W przypadku zapisu fabryka JsonGeneratorFactory pomaga w tworzeniu JsonGenerator. Instancja tej klasy pisze do strumienia poszczególne tokeny (elementy składowe dokumentu w formacie JSON). metody write* pozwalają na zapis danych do strumienia. Przykład poniżej zapisuje do strumienia dokładnie ten sam dokument JSON jaki użyłem w podejściu obiektowym:   JsonGeneratorFactory generatorFactory = Json.createGeneratorFactory(Collections.singletonMap(JsonGenerator.PRETTY_PRINTING, true)); JsonGenerator generator = generatorFactory.createGenerator(System.out); generator     .writeStartObject()         .write(\"imię\", \"Marcin\")         .write(\"nazwisko\", \"Pietraszek\")         .writeStartObject(\"strona\")             .write(\"adres www\", \"https://www.samouczekprogramisty.pl\")             .writeStartArray(\"artykuły\")                 .writeStartObject()                     .write(\"tytuł\", \"Format JSON w języku Java\")                     .writeStartObject(\"data publikacji\")                         .write(\"rok\", 2018)                         .write(\"miesiąc\", 9)                         .write(\"dzień\", 13)                     .writeEnd()                 .writeEnd()             .writeEnd()         .writeEnd()     .writeEnd().flush();   Odczyt   W przypadku czytania dokumentu w trybie strumieniowym przydadzą się klasy JsonParserFactory i JsonParser. Instancja tej ostatniej pozwala na sprawdzenie czy w strumieniu znajduje się kolejny token. Jeśli tak, można go pobrać i odpowiednio na niego zareagować. Poniżej możesz zobaczyć przykład odczytywania dokumentu JSON w trybie strumieniowym:   JsonParserFactory parserFactory = Json.createParserFactory(Collections.emptyMap()); JsonParser parser = parserFactory.createParser(buildObject());  while (parser.hasNext()) {     JsonParser.Event event = parser.next();     switch (event) {         case START_OBJECT:             System.out.println(\"{\");             break;         case END_OBJECT:             System.out.println(\"}\");             break;         case START_ARRAY:             System.out.println(\"[\");             break;         case END_ARRAY:             System.out.println(\"]\");             break;         case KEY_NAME:             System.out.print(String.format(\"\\\"%s\\\": \", parser.getString()));             break;         case VALUE_NUMBER:             System.out.println(parser.getBigDecimal());             break;         case VALUE_STRING:             System.out.println(String.format(\"\\\"%s\\\"\", parser.getString()));             break;         default:             System.out.println(\"true, false or null\");     } }   W wyniku działania tego kodu na konsoli wyświetli się dokument:   { \"imię\": \"Marcin\" \"nazwisko\": \"Pietraszek\" \"strona\": { \"adres www\": \"https://www.samouczekprogramisty.pl\" \"artykuły\": [ { \"tytuł\": \"Format JSON w języku Java\" \"data publikacji\": { \"rok\": 2018 \"miesiąc\": 9 \"dzień\": 13 } } ] } }   Jak widzisz formatowanie tu kuleje :). Może spróbujesz napisać to w taki sposób, żeby dokument był bardziej czytelny?   JSON-B   JSON-B to specyfikacja, która pozwala na mapowanie dokumentów w formacie JSON i obiektów w języku Java. Pozwala na konfigurowanie sposobu mapowania obiektów na dokumenty przy pomocy adnotacji. Specyfikacja JSON-B 1.0 jest częścią JEE 8.   JSON-B pozwala na serializację i deserializację stanu obiektu używając formatu JSON.   Zapis obiektu   Zacznę od zwykłej klasy, dla czytelności usunąłem metody dostępowe (gettery i settery):   public class Newspaper {     private String title;     private int circulation;     private LocalDate issueDate;      @SuppressWarnings(\"unused\")     public Newspaper() {     }      public Newspaper(String title, int circulation, LocalDate issueDate) {         this.title = title;         this.circulation = circulation;         this.issueDate = issueDate;     }      // getters &amp; setters }   Aby zapisać instancję tego obiektu do formatu JSON należy użyć JsonBuilder do stworzenia instancji klasy Jsonb. W większości przypadków ta instancja powinna być współdzielona w całej aplikacji.   Klasa Jsonb posiada zestaw przeciążonych metod toJson, które pozwalają na serializację obiektu. Przykład poniżej używa jednej z tych metod:   Newspaper newspaper = new Newspaper(\"Samouczek Programisty\", 100_000, LocalDate.of(2018, 9, 13)); Jsonb jsonb = JsonbBuilder.create(); String newspaperRepresentation = jsonb.toJson(newspaper); System.out.println(newspaperRepresentation);   Po wykonaniu tego fragmentu kodu na konsoli wyświetli się tekst:   {\"circulation\":100000,\"issueDate\":\"2018-09-13\",\"title\":\"Samouczek Programisty\"}   Odczyt obiektu   Odczyt (deserializacja) przebiega w podobny sposób. Tym razem należy użyć metody fromJson do odczytania dokumentu JSON. Zauważ, że drugim parametrem przekazywanym do tej metody jest klasa/typ nowotworzonego obiektu:   Newspaper newspaper = new Newspaper(\"Samouczek Programisty\", 100_000, LocalDate.of(2018, 9, 13)); Jsonb jsonb = JsonbBuilder.create(); String newspaperRepresentation = jsonb.toJson(newspaper);  Newspaper otherNewspaper = jsonb.fromJson(newspaperRepresentation, Newspaper.class); System.out.println(otherNewspaper.getIssueDate());   W wyniku działania tego kodu na konsoli wyświetli się data pobrana z dokumentu JSON:   2018-09-13   Modyfikacja zachowania JSON-B   JSON-B pozwala na modyfikację jego zachowania. Dzięki temu dokument, który jest tworzony/czytany może różnić się od obiektu w języku Java. Klasa AnnotationExamples zawiera kilka adnotacji wpływających na kształt dokumentu JSON:   @JsonbPropertyOrder({\"ccc\", \"bbb\"}) public class AnnotationExamples {     @JsonbTransient     private String skipped;      @JsonbProperty(nillable=true)     private String a1;      private String a2;      @JsonbNumberFormat(\"0.0000\")     private double bbb;      @JsonbProperty(\"other_name\")     private String ccc;      // getters &amp; setters }      @JsonbTransient – atrybut powinien zostać pomięty,   @JsonbProperty – pozwala na ustawienie nowej nazwy atrybutu. Zmienia zachowanie (de)serializacji jeśli atrybut ma wartość null (domyślnie takie wartości są pomijane),   @JsonbNumberFormat – określa format w jakim powinna być zapisana liczba,   @JsonbDateFormat – określa format w jakim powinna być zapisana data.   @JsonbPropertyOrder – określa kolejność w jakiej atrybuty powinny być serializowane.   Pozostałe adnotacje znajdziesz w dokumentacji.   Miejsce umieszczenia adnotacji ma znaczenie:      adnotacja nad atrybutem – ma wpływ zarówno na serializację jak i deserializację atrybutu,   adnotacja nad getterem – ma wpływ wyłącznie na serializację atrybutu,   adnotacja nad setterem – ma wpływ wyłącznie na deserializację atrybutu.   Proszę spójrz jak adnotacje wpływają na kształt generowanego dokumentu:   AnnotationExamples annotationExamples = new AnnotationExamples(); annotationExamples.setBbb(123.45); annotationExamples.setCcc(\"ccc\"); annotationExamples.setSkipped(\"skipped\");  WithoutAnnotationExamples withoutAnnotationExamples = new WithoutAnnotationExamples(); withoutAnnotationExamples.setBbb(123.45); withoutAnnotationExamples.setCcc(\"ccc\"); withoutAnnotationExamples.setSkipped(\"skipped\");   Klasa z adnotacjami:  {\"other_name\":\"ccc\",\"bbb\":\"123.4500\",\"a1\":null}   Klasa bez adnotacji:  {\"bbb\":123.45,\"ccc\":\"ccc\",\"skipped\":\"skipped\"}   Adnotacje pozwalają na zmianę zachowana JSON-B w trakcie kompilacji. Istnieje także metoda na wprowadzenie takich zmian wyłącznie w trakcie uruchomienia programu.   json_pp   Nie mogę tu pominąć json_pp. Jest to narzędzie używane w linii poleceń. Co prawda nie jest ono bezpośrednio związane z Javą ani specyfikacjami, które tu opisałem, jednak jest bardzo przydatne. Program ten formatuje dokument JSON wyświetlając go w bardziej czytelnej formie. Nie raz pomogło mi przy pracy z tym formatem:   $ echo '{\"some\":\"magic\",\"json\":true,\"values\":123}' | json_pp {    \"json\" : true,    \"values\" : 123,    \"some\" : \"magic\" }   Dodatkowe materiały do nauki   Jeśli chcesz dowiedzieć się czegoś więcej na temat formatu JSON zachęcam Cię do sięgnięcia po materiały dodatkowe:      Specyfikacja JSON specyfikacja ma kod 404 – kod odpowiedzi Not Found w specyfikacji protokołu HTTP :),   Artykuł o JSON na Wikipedii,   Specyfikacja JSON-P,   Dokumentacja API JSON-P,   Specyfikacja JSON-B,   Dokumentacja API JSON-B.   Na pewno przyda Ci się też kod źródłowy przykładów użytych w artykule.   Zadanie do wykonania   Znajdź API udostępnione za pośrednictwem protokołu HTTP(S), które używa formatu JSON. Napisz program, który wyśle zapytanie do wybranego przez Ciebie API i przetworzy otrzymaną odpowiedź. Proszę daj znać w komentarzach, które API chcesz użyć. Jeśli masz problem ze znalezieniem API możesz użyć jednego z tych, które są zebrane na samouczkowym Github’ie.   Możesz także rzucić okiem na przykładowe rozwiązanie, w którym użyłem API NBP. Program, który napisałem pobiera średni kurs wymiany waluty dla zadanego dnia. Dzięki niemu możesz na przykład sprawdzić jaki był średni kurs USD/PLN w zadanym dniu.   Podsumowanie   Po przeczytaniu tego artykułu wiesz już czym jest JSON. Potrafisz stworzyć poprawny dokument w tym formacie. Wiesz jak używać specyfikacji z parasola JEE odpowiedzialnych za pracę z formatem JSON. Obecnie większość znanych mi API udostępnionych za pośrednictwem HTTP używa formatu JSON do wymiany danych. Po lekturze możesz swobodnie używać tych API z poziomu języka Java. Gratulacje! :)   Na koniec mam do Ciebie prośbę. Proszę podziel się linkiem do artykułu ze znajomymi, którym może się on przydać. Dzięki Tobie uda mi się dotrzeć do nowych czytelników. Jeśli nie chcesz ominąć kolejnych artykułów proszę dopisz się do samouczkowego newslettera i polub stronę Samouczka na Facebook’u. Do następnego razu!                 Chodzi tu o dwa osobne znaki: nową linię i powrót karetki. &#8617;                  W praktyce nie spotkałem się ze zduplikowanymi kluczami. &#8617;                  Tutaj sprawa wygląda podobnie jak w obiektach, specyfikacja dopuszcza takie zachowanie jednak w praktyce nie jest to często spotykane. &#8617;           ","categories": ["Narzędzia","Kurs aplikacji webowych"],
        "tags": [],
        "url": "/format-json-w-jezyku-java/",
        "teaser": "/assets/images/2018/09/13_format_json_w_jezyku_java.jpg"
      },{
        "title": "Testy jednostkowe z użyciem mock i stub",
        "excerpt":"Wprowadzenie   Zanim przejdę do omówienia obiektów pomocniczych mock1 i stub, muszę wyjaśnić kilka pojęć związanych z testami jednostkowymi.   Jednostka w testach jednostkowych   W artykule wprowadzającym do testów jednostkowych wspomniałem o definicji jednostki. Jednostka to fragment kodu, który testowany jest przy pomocy testów jednostkowych. W większości przypadków jest to pojedyncza klasa.   Projekty programistyczne zawierają wiele klas. Klasy te, zgodnie z zasadą pojedynczej odpowiedzialności (ang. Single Responsibility Principle) będącą częścią SOLID, powinny być odpowiedzialne za jedną funkcjonalność. W praktyce sprowadza się to do tego, że klasa posiada zależności, które pomagają tę funkcjonalność wykonać.   Na przykład klasa odpowiedzialna za wyszukanie najtańszego połączenia lotniczego pomiędzy Wrocławiem a Barceloną zależna jest od innych klas, które udostępniają ceny połączeń u różnych operatorów.   Klasa odpowiedzialna za wyszukanie najtańszego samochodu do wynajęcia porównuje oferty różnych agencji zajmujących się wynajmem.   Z kolei klasa odpowiedzialna za znalezienie najtańszej podróży może korzystać z obu wcześniej wspomnianych klas. Może to prowadzić do skomplikowanej sieci zależności.             Przykładowy diagram zależności klas        Granice jednostki   W takiej sieci każda klasa może być jednostką, która ma swój zestaw testów jednostkowych. Zależności klasy są poza granicami jednostki.   Szczególnie jeśli wymagają dostępu do zewnętrznych źródeł danych, takich jak baza danych, pliki na dysku twardym czy zewnętrze API udostępniane przez HTTP.   Test jednostkowy powinien testować wyłącznie jednostkę. Zależności będące poza nią nie powinny być testowane w testach jednostkowych 2. Innymi słowy wszystko co jest poza granicami jednostki powinno być w trakcie testów “wyłączone”.   Biorąc pod uwagę diagram, który pokazałem wcześniej testy jednostkowe klasy TripPlanner powinny odpowiednio obsłużyć zależność od klas FlightScanner i CarRental. Do odpowiedniego obsłużenia tego typu zależności w testach jednostkowych służą obiekty typu mock czy stub.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Bohaterowie testów jednostkowych – mock i stub   Poniżej możesz zobaczyć przykładową klasę, która może być użyta do agregowania lotów udostępnianych przez różnych przewoźników:   public interface Airline {     List&lt;Flight&gt; findFlight(String departureAirport,                             String destinationAirport,                             LocalDate flightDate) throws FlightException; }   public class FlightScanner {      private final Airline[] airlines;      public FlightScanner(Airline... airlines) {         this.airlines = airlines;     }      public Flight findCheapestFlight(String departure, String destination, LocalDate flightDate) {         Optional&lt;Flight&gt; cheapestFlight = Arrays.stream(airlines)                 .map(a -&gt; {                     try {                         return a.findFlight(departure, destination, flightDate);                     } catch (FlightException e) {                         // log                         List&lt;Flight&gt; empty = Collections.emptyList();                         return empty;                     }                 })                 .flatMap(List::stream)                 .min(Comparator.comparing(Flight::getPrice));          return cheapestFlight.orElse(null);     } }   Klasa FlightScanner używa wielu przewoźników. Zależność ta dostarczona jest w konstruktorze w formie tablicy obiektów implementujących interfejs Airline. Następnie w metodzie findCheapestFlight loty zwracane przez różnych przewoźników są agregowane. Metoda zwraca najtańszy lot spełniający warunki, albo null jeśli lot nie zostanie znaleziony.   Do utworzenia testów jednostkowych dla klasy FlightScanner potrzebne są instancje implementujące interfejs Airline. Rzeczywiste obiekty, które pobierają dane z linii lotniczych nie są dobrym pomysłem z kilku powodów:      testy jednostkowe stają się testami integracyjnymi,   testy jednostkowe zależą od stanu zewnętrznych usług, które czasami mogą nie działać,   zewnętrzne usługi mogą zwracać różne dane w zależności od czasu ich wywołania,   wydłuża się czas trwania testów jednostkowych (odpytywanie zewnętrznego API zabiera czas).   W związku z tymi wadami powstaje potrzeba zastąpienia rzeczywistej implementacji interfejsu Airline obiektem pomocniczym używanym wyłącznie w trakcie testów.   Samodzielne pisanie klas stub’ów czy mock’ów nie jest potrzebne. Przykłady, które tu pokazuję mają służyć wyłącznie zrozumieniu co dzieje się w trakcie użycia obiektów tego typu. W praktyce klasy te tworzone są w dużo prostszy sposób przy użyciu dedykowanych bibliotek. Jedną z nich, Mockito, opisuję w dalszej części artykułu.   Czym jest stub?   Stub to obiekt, który w testach służy do imitowania właściwej implementacji. Jego zadaniem jest wyłącznie zwrócenie zadanej wartości. Przykładowy test jednostkowy używający kilku obiektów typu stub może wyglądać następująco:   class FlightScannerTestStubs {      private Airline stub1 = (departureAirport, destinationAirport, flightDate) -&gt; Collections.singletonList(         new Flight(\"AB1234\", new BigDecimal(100), \"WRO\", \"BCN\")     );      private Airline stub2 = (departureAirport, destinationAirport, flightDate) -&gt; Collections.singletonList(         new Flight(\"AB2345\", new BigDecimal(200), \"WRO\", \"BCN\")     );      private Airline stub3 = (departureAirport, destinationAirport, flightDate) -&gt; { throw new FlightException(\"BOOM!\"); };      @Test     void shouldFindLowestPrice() {         FlightScanner flightScanner = new FlightScanner(stub1, stub2, stub3);         assertThat(flightScanner.findCheapestFlight(\"not\", \"important\", null).getFlightNumber(), is(\"AB1234\"));     } }   Interfejs Airline jest interfejsem funkcyjnym. Dzięki temu w przykładzie mogłem użyć wyrażeń lambda. Instancje stub1, stub2 i stub3 zachowują się w ten sam sposób przy każdym ich wywołaniu.   Dzięki tym obiektom zastąpiłem zależności klasy FlightScanner. Wartości zwracane przez te obiekty użyte są do wyszukania najtańszego lotu. W tym przypadku kod najtańszego lotu to AB1234. Lot ten zwrócony jest przez obiekt stub1.   Czym jest mock?   Mock to obiekt, którego używa się zamiast rzeczywistej implementacji w trakcie testów jednostkowych. Pozwala on na określenie jakich interakcji spodziewamy się w trakcie testów. Następnie można sprawdzić czy spodziewane interakcje rzeczywiście wystąpiły.   Przykładowa implementacja mock’a interfejsu Airline może wyglądać następująco:   private static final class AirlineMock implements Airline {      private static final class MethodInvocation {         String departureAirport;         String arrivalAirport;         LocalDate flightDate;          MethodInvocation(String departureAirport, String arrivalAirport, LocalDate flightDate) {             this.departureAirport = departureAirport;             this.arrivalAirport = arrivalAirport;             this.flightDate = flightDate;         }          @Override         public boolean equals(Object o) {             if (this == o) {                 return true;             }             if (o == null || getClass() != o.getClass()) {                 return false;             }             MethodInvocation methodInvocation = (MethodInvocation) o;             return Objects.equals(departureAirport, methodInvocation.departureAirport) &amp;&amp;                     Objects.equals(arrivalAirport, methodInvocation.arrivalAirport) &amp;&amp;                     Objects.equals(flightDate, methodInvocation.flightDate);         }          @Override         public int hashCode() {             return Objects.hash(departureAirport, arrivalAirport, flightDate);         }     }      private final Set&lt;MethodInvocation&gt; invocations = new HashSet&lt;&gt;();      void verifyCalled(String departureAirport, String destinationAirport, LocalDate flightDate) {         boolean wasCalled = invocations.contains(new MethodInvocation(departureAirport, destinationAirport, flightDate));         if (!wasCalled) {             throw new AssertionError(\"One of the expected invocations wasn't called!\");         }     }      @Override     public List&lt;Flight&gt; findFlight(String departureAirport, String destinationAirport, LocalDate flightDate) {         invocations.add(new MethodInvocation(departureAirport, destinationAirport, flightDate));         return Collections.emptyList();     } }   Teraz rozbiję ten kod na mniejsze fragmenty.   Klasa AirlineMock reprezentująca mock’a zawiera jeden atrybut – zbiór. Wewnątrz tego zbioru trzymane są parametry wywołań mock’a. Wartości zbioru reprezentowane są przez klasę wewnętrzną MethodInvocation. Ta klasa grupuje parametry przekazywane do metody findFlight interfejsu Airline.   private final Set&lt;MethodInvocation&gt; invocations = new HashSet&lt;&gt;();   Klasa AirlineMock implementuje interfejs Airline. Implementacja metody interfejsu Airline bazuje na wcześniej opisanym zbiorze. Każde wywołanie metody dodaje do tego zbioru parametry wywołania metody:   @Override public List&lt;Flight&gt; findFlight(String departureAirport, String destinationAirport, LocalDate flightDate) {     invocations.add(new MethodInvocation(departureAirport, destinationAirport, flightDate));     return Collections.emptyList(); }   Kluczowa w tej klasie jest metoda verifyCalled. To właśnie możliwość weryfikowania wywołań odróżnia mock’i od stub’ów:   void verifyCalled(String departureAirport, String destinationAirport, LocalDate flightDate) {     boolean wasCalled = invocations.contains(new MethodInvocation(departureAirport, destinationAirport, flightDate));     if (!wasCalled) {         throw new AssertionError(\"One of the expected invocations wasn't called!\");     } }   Użycie mock’a w kodzie testu może wyglądać następująco:   @Test void shouldFindLowestPrice() {     String departureAirport = \"departure\";     String destinationAirport = \"arrival\";     LocalDate day = LocalDate.of(2018, 9, 22);     AirlineMock mock1 = new AirlineMock();     AirlineMock mock2 = new AirlineMock();      FlightScanner flightScanner = new FlightScanner(mock1, mock2);     flightScanner.findCheapestFlight(departureAirport, destinationAirport, day);      mock1.verifyCalled(departureAirport, destinationAirport, day);     mock2.verifyCalled(departureAirport, destinationAirport, day); }   Jak widzisz w teście sprawdzam czy zależności klasy FlightScanner zostały wywołane z odpowiednimi parametrami. Zależności w tym przypadku zastąpione były mock’ami:   mock1.verifyCalled(departureAirport, destinationAirport, day); mock2.verifyCalled(departureAirport, destinationAirport, day);   Musisz wiedzieć, że ta implementacja mock’a jest uproszczona. Biblioteki takie jak Mockito dostarczają implementacji mock’ów, która ma dużo większe możliwości. Przeczytasz o nich w dalszej części artykułu.   Jaka jest różnica pomiędzy mock i stub?   Mock to stub na sterydach ;).   Wiesz już, że stub to obiekt, który podstawiasz w teście za właściwą implementację. Stub pozwala jedynie na określenie zachowania obiektu, który imituje.   Mock to  także obiekt, który podstawiasz w teście za właściwą implementację. W tym przypadku, poza określeniem zachowania3 masz możliwość jego weryfikacji. Innymi słowy mock’i pozwalają sprawdzać czy dany obiekt został użyty, jakie metody były wywołane w trakcie testu, jakie parametry były użyte w trakcie tych wywołań.   Te informacje pozwalają na pisanie testów, które sprawdzają otoczenie testowanej jednostki. Na przykład w trakcie wyszukiwania najtańszego lotu mock, który reprezentuje dostawcę połączeń pozwoli sprawdzić czy rzeczywiście dany dostawca został użyty, jakie parametry zostały mu przekazane.   Samodzielne pisanie klas mock’ów czy stub’ów jest uciążliwe, z pomocą przychodzą liczne biblioteki, które robią to automatycznie. Jedną z takich bibliotek jest Mockito.   Biblioteka Mockito   Zanim przejdę do omówienia możliwości biblioteki Mockito proszę spójrz na ten sam test z jej wykorzystaniem:   class FlightScannerTestMockito {     @Test     void shouldFindLowestPrice() throws FlightException {         String departureAirport = \"departure\";         String destinationAirport = \"arrival\";         LocalDate day = LocalDate.of(2018, 9, 22);         Airline mock1 = Mockito.mock(Airline.class);         Airline mock2 = Mockito.mock(Airline.class);          FlightScanner flightScanner = new FlightScanner(mock1, mock2);         flightScanner.findCheapestFlight(departureAirport, destinationAirport, day);          Mockito.verify(mock1).findFlight(departureAirport, destinationAirport, day);         Mockito.verify(mock2).findFlight(departureAirport, destinationAirport, day);     } }   Celowo nie zastosowałem tu importów statycznych. W praktyce, po ich zastosowaniu test jest jeszcze krótszy. Cały narzut pisania dedykowanych klas spada na bibliotekę Mockito.   Tworzenie mock’ów   Tworzenie mock’ów sprowadza się do wywołania metody metodę Mockito.mock(). Metoda ta przyjmuje klasę albo interfejs. Utworzony mock będzie miał typ przekazanej klasy albo interfejsu. Na przykład utworzenie mock’a dla interfejsu Airline sprowadza się do jednej linijki kodu:   Airline mockedAirline = Mockito.mock(Airline.class);   Mockito wspiera także tworzenie mocków używając adnotacji @Mock. W zależności od wersji biblioteki JUnit do poprawnego działania tej adnotacji potrzebne są:      JUnit 4: @RunWith(MockitoJUnitRunner.class) albo @Rule wraz z MockitoJUnit.rule(),   Junit 5: @ExtendWith(MockitoExtension.class).   W przykładzie poniżej Mockito automatycznie utworzy mock’a interfejsu Airline:   @ExtendWith(MockitoExtension.class) class MockitoExamplesTest {      @Mock     Airline airlineMock;      @Test     void shouldCreateMockInstance() {         assertThat(airlineMock, is(notNullValue()));     } }   Weryfikacja wywołań metod   Mockito pozwala na weryfikację wywołań utworzonych mock’ów. Służy do tego metoda Mockito.verify.  Proszę spójrz na przykład poniżej:   @Test void verifyExamples1() throws FlightException {     airlineMock.findFlight(\"exactValue\", \"exactValue\", LocalDate.now());      verify(airlineMock).findFlight(\"exactValue\", \"exactValue\", LocalDate.now()); }   Wewnątrz testu wywołuję metodę findFlight. Następnie weryfikuję wywołanie tej metody przekazując konkretny zestaw parametrów. Ten test się powiedzie ponieważ metoda z takimi parametrami została wywołana. Mockito pozwala na dużą dowolność w specyfikowaniu parametrów akceptowanych przez mock’i.   W tym przykładzie sprawdzam, czy metoda findFlight została wykonana co najwyżej 10 razy z dowolnymi argumentami:   @Test void verifyExamples2() throws FlightException {     airlineMock.findFlight(\"exactValue\", \"exactValue\", LocalDate.now());      verify(airlineMock, atMost(10)).findFlight(anyString(), any(), any(LocalDate.class)); }   Tym razem sprawdzam, czy metoda findFlight została wywołana co najmniej raz z parametrami, które pasują do wymagań:   @Test void verifyExamples3() throws FlightException {     airlineMock.findFlight(\"exactValue\", \"exactValue\", LocalDate.now());      verify(airlineMock, atLeastOnce()).findFlight(contains(\"Val\"), startsWith(\"ex\"), eq(LocalDate.now())); }   Do weryfikacji liczby wywołań mogą służyć następujące metody:      Mockito.atMost,   Mockito.atLeastOnce,   Mockito.atLeast,   Mockito.never,   Mockito.times,   Mockito.calls.   Do weryfikacji parametrów mogą służyć następujące metody:      Mockito.anyString,   Mockito.any,   Mockito.contains,   Mockito.matches,   Mockito.startsWith,   Mockito.anyCollection,   Mockito.anyIterable.   Metod tego typu jest dużo więcej. Po ich pełną listę odsyłam Cię do dokumentacji biblioteki Mockito.   Stub czy mock?   Wiesz już, że mock to stub na sterydach. Mockito pozwala także na określanie zachowania mocków, nie tylko weryfikację wywołań. Mockito domyślnie tworzy stub’y dla wszystkich metod. Domyślnie zwracają one “wartości zerowe” (pusta kolekcja, 0, null). Przykład poniżej, pokazuje domyślne zachowanie Mockito:   @Test void whenExamples1() throws FlightException {     List&lt;Flight&gt; flight = airlineMock.findFlight(\"a\", \"b\", LocalDate.now());     assertThat(flight, is(notNullValue()));     assertThat(flight, is(empty())); }   Możesz zmienić to w jaki sposób mock ma zareagować na wywołanie metody używając Mockito.when. Poniższy przykład pokazuje jak przekonać Mockito do rzucenia wyjątku w odpowiednim momencie. Zwróć uwagę, że także tutaj użyłem metod do określania parametrów:   @Test void whenExamples2() throws FlightException {     when(airlineMock.findFlight(any(), any(), any())).thenThrow(new FlightException(\"some message\"));      assertThrows(FlightException.class, () -&gt; airlineMock.findFlight(\"a\", \"b\", LocalDate.now())); }   Poza rzucaniem wyjątków możesz określić właściwą wartość zwróconą po wywołaniu metody:   @Test void whenExamples3() throws FlightException {     Flight someFlight = new Flight(\"ABC123\", BigDecimal.TEN, \"departure\", \"arriva\");     when(airlineMock.findFlight(\"a\", \"b\", LocalDate.now()))             .thenReturn(Collections.singletonList(someFlight));      List&lt;Flight&gt; flight = airlineMock.findFlight(\"a\", \"b\", LocalDate.now());     assertThat(flight.size(), is(1));     assertThat(flight.get(0), is(someFlight)); }   Do określenia zachowania mock’a możesz także użyć metod:     Mockito.doReturn,   Mockito.doThrow,   Mockito.doNothing,   Mockito.doAnswer.   Używanie mock’ów a higiena   Wszystko jest dla ludzi, jeśli stosowane jest w rozsądnych ilościach. Jeśli Twój test jednostkowy w przerażającej większości składa się z przygotowania obiektów typu mock czy stub to warto się mu bliżej przyjrzeć. Może jest tak, że Twoja klasa ma zbyt szeroką odpowiedzialność? Może warto wprowadzić dodatkowy typ, który będzie grupował część tych zadań? Może liczba zależności klasy jest zbyt duża?   Niestety nie potrafię podać Ci jasnej reguły, która mówi: jeśli obiektów mock masz więcej niż X to jest coś źle. Wydaje mi się, że takiej reguły nie ma. Jednak wiem, że testy jednostkowe, które naszpikowane są obiektami tego typu mogą być ciężkie w utrzymaniu.   Dlatego właśnie stosuj zasady higieny w pracy z mock’ami :). Jeśli Twoim subiektywnym zdaniem przygotowanie testu jednostkowego jest zbyt pracochłonne, wymaga zbyt dużo przygotowania, to zabierz się za refaktoring. Oczywiście sam refaktoring będzie łatwiejszy jeśli kod, który chcesz zmienić będzie już pokryty testami.   Dodatkowe materiały do nauki   Jeśli chcesz poszerzyć wiedzę zdobytą po przeczytaniu tego artykułu zachęcam Cię do zajrzenia do tych źródeł:      Strona biblioteki JUnit,   Strona biblioteki Mockito,   Kod źródłowy przykładów użytych w artykule.   Zadanie do wykonania   Napisz program, który będzie implementował następujący interfejs:   public interface ExchangeApi {     /**      * @param date date for which exchange rate should be returned      * @param currencyCode currency code that should be checked, for example USD      * @return exchange rate between PLN and currencyCode on date      */     BigDecimal exchangeRate(LocalDate date, String currencyCode); }   Twój program powinien używać API z historycznymi kursami walut udostępnionymi przez NBP. Dokumentacja API dostępna jest na stronie NBP. W praktyce potrzebny będzie wyłącznie ten adres: http://api.nbp.pl/api/exchangerates/rates/a/&lt;kod&gt;/&lt;data&gt;/?format=json   Na przykład, żeby pobrać kurs dla dolara amerykańskiego (kod waluty USD) dla 5 IV 2016 trzeba wysłać zapytanie typu GET pod adres http://api.nbp.pl/api/exchangerates/rates/a/usd/2016-04-05/?format=json. Odpowiedź, którą dostaniesz będzie wyglądać następująco:   {     \"table\": \"A\",     \"currency\": \"dolar amerykański\",     \"code\": \"USD\",     \"rates\": [{         \"no\": \"065/A/NBP/2016\",         \"effectiveDate\": \"2016-04-05\",         \"mid\": 3.7337     }] }   Do parsowania odpowiedzi tego typu przydatna jest biblioteka, która obsługuje parsowanie formatu JSON.   Postaraj się napisać program używając TDD. Testy jednostkowe powinny używać obiektów typu mock i stub do symulowania zachowania API.   Jeśli będziesz mieć jakiekolwiek problemy zawsze możesz rzucić okiem na przykładowe rozwiązanie.   Podsumowanie   Po przeczytaniu tego artykułu wiesz czym jest mock i stub. Na przykładzie potrafisz pokazać różnicę pomiędzy obiektami tego typu. Po rozwiązaniu zadania udało Ci się w praktyce sprawdzić swoją wiedzę zdobytą w tym artykule.   Mam nadzieję, że artykuł przypadł Ci do gustu, daj znać w komentarzach jak użycie mock’ów i stub’ów wpływa na Twoje testy jednostkowe. Jeśli nie chcesz pominąć kolejnych wpisów proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebook’u.                 Nie podoba mi się nadużywanie nazw anglojęzycznych w branży IT. Zawsze staram się znaleźć polskie odpowiedniki używanych słów. Są jednak takie sytuacje, w których terminy angielskie są tak rozpowszechnione, że nawet nie silę się na znajdowanie polskich odpowiedników. Przykładem takich słów są mock (atrapa?) czy stub (zaślepka?). Jeśli znasz dobre tłumaczenia tych określeń proszę podziel się nimi w komentarzach. Z chęcią zacznę stosować polskie słowa, które będą zrozumiałe w branżowych rozmowach. &#8617;                  Służą do tego inne rodzaje testów, na przykład testy integracyjne czy systemowe. &#8617;                  Przykładowa implementacja mock’a zawiera jedynie możliwość weryfikacji wywołania metody. W ramach ćwiczeń możesz napisać klasę mock’a, która będzie pozwalała zarówno na określenie zachowania jak i sprawdzenie wywołań. &#8617;           ","categories": ["Testy jednostkowe","Dobre praktyki"],
        "tags": [],
        "url": "/testy-jednostkowe-z-uzyciem-mock-i-stub/",
        "teaser": "/assets/images/2018/09/22_testy_z_mock_i_stub_w_jezyku_java.jpeg"
      },{
        "title": "Jakość kodu a oschłe pocałunki Jagny",
        "excerpt":"Coś o powtarzaniu – DRY   Reguła DRY (ang. Don’t Repeat Yourself) zostało opisana w książce “The Pragmatic Programmer” autorstwa Andrew’a Hunt’a i David’a Thomas’a. Autorzy wprowadzają regułę, która mówi, że każdy fragment wiedzy powinien mieć pojedynczą, jednoznaczną i uznaną reprezentację w systemie. Regułę tę można zastosować zarówno do konfiguracji jak i kodu programu.   Utrzymywanie kodu kosztuje. Kod, wraz z dodawaniem nowych funkcjonalności koroduje, psuje się z czasem. Im więcej kodu tym więcej potencjalnych błędów. A jeśli kod jest powielany w wielu miejscach, to jest to dobry przepis na tragedię. Wyobraź sobie sytuację, w której podobny fragment kodu jest kopiowany wielokrotnie. Po pewnym czasie okazuje się, że w tym właśnie fragmencie jest błąd, lub trzeba wprowadzić w nim pewną zmianę.   Taka sytuacja prosi się o popełnienie błędu w trakcie wprowadzania niezbędnej zmiany. Wystarczy ominąć jedną z kopii kodu i błąd gotowy. Przypomina mi się mem z piosenką:      99 little bugs in the code.  99 little bugs in the code.  Take one down, patch it around.  127 little bugs in the code.    Reguła DRY ma zastosowanie zarówno do mniejszych fragmentów kodu jak i dużych części systemu. Jeśli widzisz duplikację, którą można wyeliminować, zrób to :). Zanim jednak zajmiesz się refaktoryzacją kodu upewnij się, że posiadasz dobry zestaw testów jednostkowych. Testy pomogą Ci upewnić się, że po zlikwidowaniu duplikacji kod nadal działa jak powinien.   Przykład zastosowania reguły   Załóżmy, że zadaniem jest napisanie algorytmu, który liczbę w notacji dziesiętnej zapisze w innym systemie, na przykład binarnie. Akurat to zadanie jest do wykonania w artykule opisującym system binarny. Jeden z czytelników zaproponował takie rozwiązanie (jeszcze raz dziękuję za pozwolenie na jego publikację):   public static String convert(int decimalNumber, int toBase) {     StringBuilder binaryRepresentation = new StringBuilder();     int currentNumber;         if (decimalNumber == 0) {         binaryRepresentation.append(decimalNumber);     }     else if (decimalNumber &gt; 0) {         while (decimalNumber &gt; 0) {             currentNumber=decimalNumber % toBase;             decimalNumber=decimalNumber / toBase;             binaryRepresentation.append(currentNumber);             }     }     else if (decimalNumber &lt; 0) {         decimalNumber = decimalNumber * -1;         while (decimalNumber &gt; 0) {             currentNumber=decimalNumber % toBase;             decimalNumber=decimalNumber / toBase;             binaryRepresentation.append(currentNumber);         }         binaryRepresentation.append(\"-\");     }     return binaryRepresentation.reverse().toString(); }   Można powiedzieć, że rozwiązanie spełnia wymagania. Poprawnie przekształca liczby na wartość binarną1. Jednak od razu można zwrócić uwagę na duplikację. Proszę spójrz na moją propozycję refaktoringu tego kodu gdzie duplikacja została usunięta. Algorytm zachowuje się dokładanie tak samo, jednak moim zdaniem jest o wiele bardziej przejrzysty. Do tego nie łamie zasady DRY.   public static String convert(int decimalNumber, int toBase) {     StringBuilder representation = new StringBuilder();     int numberToConvert = Math.abs(decimalNumber);      do {         int divisionReminder = numberToConvert % toBase;         numberToConvert = numberToConvert / toBase;         representation.append(divisionReminder);     } while (numberToConvert != 0);      if (decimalNumber &lt; 0) {         representation.append(\"-\");     }     return representation.reverse().toString(); }   Jeśli widzisz duplikację w kodzie, warto zastanowić się nad jej usunięciem. Zastanów się czy sesja refaktoringu kodu nie byłaby potrzebna. Może proste wydzielenie metody rozwiąże problem? Może fragment kodu jest na tyle rozbudowany, że potrzeba osobnej klasy? Ta klasa będzie miała wtedy swój zakres odpowiedzialności i koniecznie swój zestaw testów jednostkowych.   Nie pamiętam gdzie, ale usłyszałem kiedyś, że przeciwnością DRY jest WET (ang. We Enjoy Typing, We Edit Terribly, etc.). W moim przypadku często łączę te akronimy ;). Na początku piszę coś co spełnia wymagania, powtarzając niektóre fragmenty. Taki początkowy kod jest brzydki, ale działa. Jednak po tym etapie przychodzi czas na chwilę zastanowienia. Nie bez powodu pojedyncza runda TDD nie jest kompletna bez refaktoringu. Właśnie wtedy można uprościć kod usuwając zbędną duplikację. Zestaw wcześniej napisanych testów jednostkowych pozwala na swobodną zmianę struktury kodu.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Coś o prostocie – KISS   Według Wikipedii reguła KISS (ang. Keep It Simple, Stupid) wspomniana została już w 1960 roku przez marynarkę Stanów Zjednoczonych jako wytyczna dotycząca projektowania. Ja poznałem ją w kontekście projektów informatycznych.   KISS sprowadza się do unikania złożoności projektów informatycznych. Im mniej ruszających się części tym mniej rzeczy może się zepsuć. Wychodzę z założenia, że kod, który ma mniej linijek przeważnie jest lepszym rozwiązaniem. Głośno mówię o tym, że bardzo lubię usuwać kod. Im go mniej, tym lepiej. Nie jest sztuką napisać obszerny kod, który realizuje wymagania. Sztuką jest napisanie czytelnego fragmentu kodu, z którego nic nie można usunąć. Nie można nic usunąć, ponieważ każdy element jest potrzebny i realizuje część funkcjonalności.   Podobnie jak przy regule DRY. Jeśli zobaczysz coś co można uprościć, zrób to. Powtarzam też z uporem maniaka, operacje tego typu powinno się przeprowadzać mając pod sobą siatkę bezpieczeństwa w postaci testów jednostkowych.   KISS a Python   Python idzie o krok dalej. Istnieje coś takiego jak “manifest Python’a”2. Jest to kilka reguł, które opisują w jaki sposób powinno się pisać kod. Całość sprowadza się do 19 linijek tekstu. Aż cztery z nich powiązane są regułą KISS:      Simple is better than complex.  Complex is better than complicated.  (…)  If the implementation is hard to explain, it’s a bad idea.  If the implementation is easy to explain, it may be a good idea.    Tłumaczę to jako:      Proste jest lepsze od złożonego.  Złożone jest lepsze od skomplikowanego.  Jeśli implementacja jest trudna do wytłumaczenia, to jest to zły pomysł.  Jeśli implementacja jest łatwa do wytłumaczenia, to może to być dobry pomysł.    Inne spojrzenie na KISS   Podejście tego typu znane było długo przed KISS używanym przez amerykańską marynarkę wojenną. Istnieje zasada nazywana brzytwą Ockhama. Mówi ona o tym żeby nie mnożyć bytów ponad potrzebę.   W kontekście oprogramowania mniej bytów sprowadza się do mniejszej ilości kodu. Mniej kodu to mniej potencjalnych błędów do popełnienia. Mniej kodu to mniejszy system, który prawdopodobnie będzie łatwiejszy do zrozumienia i utrzymania.   Coś o wyobraźni – YAGNI   Na pewno zdarzyło Ci się kiedyś zastanawiać się nad tym jak zaimplementować jakieś rozwiązanie. Wpadasz wtedy w wir tworzenia. Potrafisz wymyślić piękne struktury danych. Algorytmy takie, że płaczesz jak commit‘ujesz. Tutaj nowy manager, tam kolejny helper. Oczywiście Twoje rozwiązanie przewiduje to, że klient będzie chciał obsługiwać kwoty reprezentowane w liczbach urojonych.   Każda ewentualność jest obsłużona. Wszystkie ekstremalne przypadki zaimplementowane. Po prostu niezatapialny fragment kodu. Kod tak generyczny, że jak zostawisz go przez noc to w wyniku ewolucji przejmie władzę nad światem…   Całość zajęła Ci trzy miesiące. Przez ten czas nawet nie było kiedy porozmawiać z klientem o jego wymaganiach. Przecież Twoja wyobraźnia wie lepiej. Wszystkie funkcjonalności, o których klient jeszcze nie pomyślał są gotowe. Wiesz co? YAGNI (ang. You Aren’t Gonna Need It). Nie będziesz tego potrzebować.   Łatwo rozszerzalny kod a nowe funkcjonalności   Oczywiście nie mam nic przeciwko pisaniu solidnego kodu, który spełnia wymagania użytkownika. Nie mam nic przeciwko temu, żeby przewidywać sytuacje, o których nie poinformował klient. W pełni zgadzam się na sugerowanie przydatnych funkcjonalności. Do tego uważam, że pisanie kodu łatwego do rozszerzenia zgodnie z zasadami SOLID jest dobrym posunięciem.   Jest jednak jedno małe “ale”. Z doświadczenia wiem, że wymyślanie czegoś na siłę nie ma sensu. Klient nie chciał funkcjonalności X? Jeśli Twoim zdaniem to głupi pomysł to z nim o tym porozmawiaj. Przekonaj go do swojego zdania. Jeśli uda Ci się go przekonać – brawo! Jeśli nie, to pogódź się z faktem, że nie możesz wiedzieć wszystkiego najlepiej.   YAGNI sprowadza się do hamowania swojej fantazji. Nie wprowadzaj bytów, funkcjonalności, metod, itp., które nie są w danym momencie potrzebne. Dodawanie zbędnych elementów komplikuje kod. Do tego podnosi koszty realizacji projektu. Dodatkowo może stawiać Cię w złym świetle jako programistę. Po płodnej sesji pisania kodu może okazać się, że udało Ci się wykonać kawał solidnej, porządnej i nikomu niepotrzebnej pracy.   Akronimy na ratunek   Żaden akronim nie sprawi, że Twój kod automatycznie będzie lepszy. Nie ważne czy jest to SOLID, KISS, YAGNI czy DRY. Dobry kod to moim zdaniem efekt wielu sesji refaktoringu, ciągłej pracy nad jego polepszaniem.   Spotkałem się też z zasadą, którą opisuje się jako zasadę “amerykańskiego skauta”. Sprowadza się ona do tego, żeby kod, który zastaliśmy zostawić chociaż odrobinę lepszym kiedy kończymy z nim pracę. W ten sposób małymi kroczkami można dążyć do polepszenia jakości kodu.   Pamiętaj też, że “lepszy kod” jest określeniem czysto subiektywnym. Dla jednej osoby kod podzielony na malutkie metody będzie lepszy. Inna powie, że metody mające jedną linijkę kodu to przesada.   Materiały dodatkowe   Jeśli masz ochotę spojrzeć na temat z innej strony zachęcam Cię do rzucenia okiem na poniższe materiały:      Definicja DRY na Wikipedii,   Definicja KISS na Wikipedii,   Definicja YAGNI na Wikipedii,   Artykuł o YAGNI na stronie Martin’a Fowler’a.   Podsumowanie   Po lekturze tego artykułu wiesz czym jest DRY, KISS i YAGNI. Wiesz, że powtórzenia należy eliminować. Wiesz, że zbędne komplikowanie implementacji jest złym podejściem. W końcu, wiesz też, że funkcjonalności powinny być implementowane nie wcześniej niż są potrzebne.   Opisane tu akronimy KISS i YAGNI odnoszą się do zwinnego sposobu wytwarzania oprogramowania, które moim zdaniem jest lepszym podejściem w większości przypadków. A Ty co o tym sądzisz? Który z tych akronimów stosujesz najczęściej?   Na koniec mam do Ciebie prośbę, jeśli znasz kogoś komu ten tekst może być pomocny proszę podeślij mu adres tego artykułu. Dzięki Tobie uda mi się dotrzeć do nowych czytelników. Pamiętaj też, że dopisanie się do samouczkowego newslettera i polubienie Samouczka na Facebooku pomoże Ci śledzić nowe artykuły na blogu.                 Pominę tu kodowanie liczb ujemnych, załóżmy, ze znak - jest dopuszczalny. &#8617;                  Możesz go zobaczyć wpisując import this w interpreterze. &#8617;           ","categories": ["Dobre praktyki","Programista rzemieślnik"],
        "tags": [],
        "url": "/jakosc-kodu-a-oschle-pocalunki-jagny/",
        "teaser": "/assets/images/2018/09/28_jakosc_kodu_a_oschle_pocalunki_jagny_artykul.jpeg"
      },{
        "title": "Trzy lata samouczka",
        "excerpt":"Jak ten czas leci… Nawet się nie obejrzałem a minęły już ponad trzy lata od kiedy prowadzę Samouczka Programisty.   Zaczęło się na Engineering seminar   Opera, firma w której pracuję, organizuje od czasu do czasu spotkania dla całej firmy. Takie spotkania nazywane są engineering seminar. Jedno z nich miało miejsce w październiku 2015 roku w Nicei. Pamiętam, jak siedząc na jednym z wykładów postanowiłem, że zacznę prowadzić blog. Blog, który przeznaczony będzie dla początkujących i w przystępny sposób będzie wprowadzał ich w świat programowania.   Wybór nazwy bloga   Po powrocie do domu zacząłem zastanawiać się nad nazwą bloga. Jej wybór nie był trywialny :). Znalezienie czegoś co jest proste do zapamiętania, unikalne i ma wolną domenę jest nie lada wyzwaniem. Zależało mi na tym, żeby nie łączyć się z konkretną technologią. Więc wszystko co miało jakiś język programowania w nazwie od razu odpadało.   Niestety nie mam zdjęcia kartki z nazwami, które brałem pod uwagę :(. Pamiętam, że na pewno były wśród nich sylabusprogramisty.pl, odzeradodevelopera.pl itp. Finalnie stanęło na samouczekprogramisty.pl i myślę, że był to dobry wybór. Widzę, że Czytelnicy szukają tej nazwy w wyszukiwarkach, więc myślę, że zapadała Wam już w pamięć.   Zacząłem od Javy   Zacząłem przygotowywać materiały o języku Java. Na wcześniej wspomnianym seminarium zdarzało mi się siedzieć z laptopem na kolanach, tam powstawały pierwsze artykuły. Pierwsze materiały dotyczyły języka Java, bo to właśnie ten język nadal cieszy się największym zainteresowaniem. Różne rankingi popularności pokazywały ten język jako ten, który cały czas jest na pierwszym miejscu.   Dodatkowo sprawdzając ogłoszenia o pracę w tamtym okresie nadal przeważały te, które związane były właśnie z językiem Java. W ten sposób początki bloga związane były z tym językiem. Nadal większość treści dotyczy właśnie Javy.   Samouczek w liczbach   Ostatni miesiąc   Jakby ktoś powiedział mi trzy lata temu, że blog będzie odwiedzany miesięcznie przez ponad 30’000 użytkowników to uśmiechnąłbym się z politowaniem :). 34’136 unikalnych użytkowników. Tylu Samouków odwiedziło Samouczka we wrześniu tego roku. Ci sami Czytelnicy odwiedzili stronę 105’509 razy, spędzając na niej średnio 2 minuty i 21 sekund. Sumując te czasy wygląda na to, że w zeszłym miesiącu Czytelnicy poświęcili w sumie 172 dni na czytanie treści na blogu. 172 dni, pełne 24 godziny, bez przerwy.   Oleśnica, w której mieszkam ma około 37’000 mieszkańców. Gdy pomyślę sobie, że prawie każda osoba, którą mijam na ulicy czyta artykuły, które tworzę to od razu pojawia mi się uśmiech na twarzy.   Trzy lata   Od jego powstania do dzisiaj Samouczka odwiedziło 309’891 Czytelników. Ci sami Czytelnicy wyświetlili różne artykuły na blogu 1’382’171 razy. Te liczby przyprawiają mnie o lekki zawrót głowy ;).             Trzy lata Samouczka Programisty        Czytelnicy w samouczkowym newsletterze   Prawie 1500 Czytelników zdecydowało się podzielić się ze mną swoim adresem e-mail. Sam nie lubię otrzymywać niechcianej poczty. Przytłacza mnie ogrom e-maili, które chcą tylko i wyłącznie coś mi sprzedać. Po pewnym czasie przestaję otwierać takie e-maile. Szybko też wypisuję się z takich list. W przypadku samouczkowego newslettera jest inaczej. Czytelnicy newslettera otwierają listy, które do Nich piszę.   Współczynnik otworzonych e-maili na poziomie około 50% nie jest czymś powszechnym. Jeśli jesteś jednym z subskrybentów newslettera jestem Ci ogromnie wdzięczny za zaufanie.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Zaskakujące fakty   Blog polecany na uczelniach wyższych   Blog polecany jest w materiałach dla studentów na uczelniach wyższych. Od czasu do czasu strony uczelni wyższych zdarzają się w witrynach odsyłających.   Szczerze mówiąc największy banan na twarzy pojawił się gdy dowiedziałem się, że dr Paweł Rogaliński. Poleca bloga w swoich materiałach. Najciekawsze w tym wszystkim jest to, że to właśnie na laboratoriach prowadzonych przez dra Rogalińskiego nauczyłem się programować.   Blog polecany przez pracodawców   Czytelnicy dają mi też znać, że blog polecany jest przez pracodawców w materiałach dla początkujących. Mam tu na myśli firmę Capgemini. Capgemini poleca Samouczka Programisty w swoich materiałach. To jest naprawdę bardzo miłe, kiedy dostaję informację, że ktoś dostał się do pracy między innymi dzięki artykułom, które publikuję1.   A może jesteś takim właśnie pracodawcą? Proszę daj znać, z chęcią postaram się przygotować materiały dla nowych pracowników w Twojej firmie. Na stronie o mnie znajdziesz kilka sposobów jak możesz się ze mną skontaktować.   Na równi z Wikipedią?   Mam świadomość, że nie dorastam Wikipedii do pięt, że ten podtytuł to lekka profanacja. Niemniej jednak prawdą jest, że niektóre treści na blogu wyświetlane są w wynikach wyszukiwania wyżej niż materiały z Wikipedii. Przyznam, że jest to dla mnie nie lada wyróżnienie. Jednym z przykładów może być artykuł dotyczący liczb zmiennoprzecinkowych.             Samouczek przed Wikipedią        Najczęściej odwiedzane strony   W życiu nie pomyślałbym, że artykuł dotyczący liczb binarnych będzie tak wysoko na tej liście ;). Pominąłem tutaj sporo artykułów dotyczących Javy. Liczby nie są ważone, mam na myśli to, że pokazują liczbę odwiedzin od czasu publikacji. Siłą rzeczy artykuły, które są na blogu dłużej będą miały więcej odwiedzin, niż te publikowane ostatnio. Poniżej możesz zobaczyć część zestawienia popularnych stron wraz z liczbą odwiedzin:      Kurs programowania Java – 184’929 odwiedzin,   System binarny – 55’580 odwiedzin,   Zestaw ćwiczeń dla początkujących programistów – 31’421 odwiedzin,   Testy jednostkowe z JUnit 4 – 31’038 odwiedzin,   Kurs aplikacji webowych – 23’200 odwiedzin,   Złożoność obliczeniowa – 20’457 odwiedzin,   Wstęp do Gradle – 16’279 odwiedzin,   Mam nadzieję, że kurs gita nad którym pracuję też niedługo znajdzie się w tym zestawieniu ;).   Co dalej?   Planów jest sporo, poniżej zdradzę Ci część z nich.   Po tym jak ukończę kurs SQL na pewno powstanie osobna seria poświęcona JPA, pewnie skupię się na bibliotece Hibernate.   Duża liczba Czytelników chciałaby przeczytać więcej materiałów związanych z aplikacjami webowymi. Do tej pory w kursie aplikacji webowych omówiłem podstawy podstawy kilku specyfikacji z parasola JEE. W przyszłości planuję serię materiałów dotyczących Spring’a. Jednak zabieranie się za tę część bez materiałów dotyczących JPA moim zdaniem nie ma sensu.   Planuję z Samouczka zrobić stronę, która pomoże kandydatom lepiej przygotować się do rozmów kwalifikacyjnych. Z tego powodu na pewno pojawią się artykuły dotyczące pytań i odpowiedzi zdarzających się na takich rozmowach.   Bez wątpienia poświęcę trochę czasu na architekturę i wzorce projektowe. Planuję serię artykułów dotyczących wzorców projektowych prezentowanych w książce GoF.   W swoim czasie Samouczek przestanie być skupiony wyłącznie na języku Java. Kwestią czasu jest powstanie kursu dotyczącego języka Python.   Zależy mi na tym żeby Czytelnicy, którzy zaczęli swoją przygodę z Samouczkiem znaleźli na nim treści, które będą odpowiednie na dalszych etapach kariery. Dlatego właśnie w przyszłości może powstać seria artykułów dotyczących “rozwiązań chmurowych”.   A może w końcu zabiorę się za przygotowanie loga dla Samouczka Programisty? Z grafiką stoję na bakier, jeśli możesz mi w tym pomóc będę wdzięczny ;).   Planów mam sporo, pokazałem Ci część z nich. Wszystko jednak musi poczekać na kurs gita, który obiecałem już części Czytelników ;).   Podsumowanie   Wszystko co wspomniałem w tym artykule pokazuje mi, że materiały, które tworzę są dobrej jakości i warte uwagi. Bardzo dziękuję Ci za to, że poświęcasz swój czas na czytanie treści, które tworzę. Jestem Ci ogromnie wdzięczny za polecanie bloga dalej. Ankieta, którą przeprowadzam wśród subskrybentów newslettera pokazuje mi, że coraz więcej Czytelników dowiaduje się o Samouczku od swoich znajomych. To jest naprawdę bardzo miłe. Dziękuję!   Przy okazji proszę Cię o Twoją opinię. Daj znać w komentarzach co sądzisz o planach rozwoju Samouczka. Może pominąłem coś, co Twoim zdaniem jest bardzo ważne?                 Oczywiście same artykuły nic nie dadzą, to tylko i wyłącznie ciężka praca tej osoby. &#8617;           ","categories": ["Różne"],
        "tags": [],
        "url": "/trzy-lata-samouczka/",
        "teaser": "/assets/images/2018/10/10_trzy_lata_samouczka.jpeg"
      },{
        "title": "Funkcje i grupowanie wierszy w SQL",
        "excerpt":"     To jest jeden z artykułów w ramach praktycznego kursu SQL. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Każde zapytanie z kursu możesz wykonać samodzielnie. Potrzebujesz do tego środowiska opisanego w pierwszym artykule kursu. Bardzo mocno Cię do tego zachęcam. Moim zdaniem najwięcej nauczysz się samodzielnie eksperymentując z zapytaniami.     Funkcje   Na pewno znasz różne funkcje. Mogą kojarzyć Ci się z matematyką czy językami programowania. Okazuje się, że funkcje występują też w języku SQL. Funkcja w przypadku SQL zaimplementowana jest przez silnik bazy danych1. Funkcje udostępnione przez silnik SQL możesz użyć w zapytaniach.   Proszę spójrz na przykład:   SELECT LENGTH('abcd');   Tak, to jest poprawne zapytanie SQL. Wyrażenia FROM czy WHERE są opcjonalne w zapytaniach typu SELECT.   W przykładzie tym wywołuję funkcję LENGTH, która jako parametr przyjmuje łańcuch znaków abcd. Wynikiem działania tego zapytania jest jeden wiersz, który zawiera długość przekazanego parametru:   4   Funkcja operująca na tabeli   Teraz zobacz jak wygląda wywołanie tej samej funkcji na wartościach kolumny z tabeli:   SELECT LENGTH(billingstate)   FROM invoice  LIMIT 5;   W wyniku zapytania możesz zobaczyć długość kolumny billingstate dla pięciu wierszy. Ograniczenie liczby wierszy jest możliwe dzięki wyrażeniu LIMIT:      2 2   Dodam teraz kolejny element, który wprowadziłem poprzednio. Chodzi mi tu o wyrażenie DISTINCT. Wiesz pewnie, że zapewnia ono zwrócenie unikalnych wartości. W następnym przykładzie zapytanie zwraca unikalne długości wartości w kolumnie billingstate w tabeli invoice. Wynikiem działania tego zapytania są cztery wiersze:   SELECT DISTINCT LENGTH(billingstate)   FROM invoice;    2 6 3   Pierwszy pusty wiersz zawiera kolumnę z wartością NULL. Odpowiada on wszystkim wierszom z tabeli invoice, które w kolumnie billingstate mają wartość NULL.   Wyniki tego zapytania można zrozumieć jako: w tabeli invoice istnieją wiersze, których wartość kolumny billingstate jest pusta, ma długość 2, 6 albo 3.   Użycie wyniku funkcji w wielu miejscach   A co jeśli chcesz uzyskać posortowany wynik? Możesz powtórzyć wywołanie funkcji w wyrażeniu ORDER BY:     SELECT DISTINCT LENGTH(billingstate)     FROM invoice ORDER BY LENGTH(billingstate);   Jednak w tym przypadku lepszym rozwiązaniem jest użycie aliasów:     SELECT DISTINCT LENGTH(billingstate) AS len     FROM invoice ORDER BY len;   W obu przypadkach zapytania zwrócą cztery posortowane rosnąco wiersze:    2 3 6   Funkcje można łączyć   Funkcje przyjmują parametry. Wiesz już, że funkcja LENGTH przyjmuje łańcuch znaków. Przykładem innej funkcji może być MAX. Funkcja ta wybiera maksymalną wartość dla danej grupy (o grupach przeczytasz więcej w dalszej części artykułu):   SELECT MAX(LENGTH(billingstate))   FROM invoice;   Przykład powyżej zwróci jeden wiersz, zawierający maksymalną wartość zwróconą przez funkcję LENGTH:   6   Kilka przykładowych funkcji   Do tej pory pokazałem Ci tylko dwie funkcje MAX i LENGTH. Niżej pokażę Ci kilka innych.  Proszę pamiętaj o tym, że dużo funkcji jest charakterystycznych dla poszczególnych silników baz danych. W artykule starałem się opisać wyłącznie te, które są dostępne powszechnie. Zachęcam Cię do sprawdzenia dokumentacji Twojej bazy danych, żeby sprawdzić całą listę dostępnych funkcji.      ABS – zwraca wartość bezwzględną przyjmowanego argumentu,   LENGTH – tę funkcję już znasz, zwraca długość łańcucha znaków,   LOWER – zwraca kopię łańcucha znaków przekazanego jako parametr, w którym wszystkie litery zamienione są na małe2,   RANDOM – zwraca losową liczbę całkowitą,   SUBSTR3 – SUBSTR(x, y, z) pobiera podzbiór znaków parametru x od litery y o długości z. Parametr z może być pominięty, wtedy funkcja zwraca podzbiór znaków od znaku y do końca. Pierwsza litera ma indeks 1,   TRIM – usuwa spacje z obu stron przekazanego parametru,   UPPER – funkcja działa podobnie jak LOWER, tym razem zwracany łańcuch znaków składa się z wielkich liter.   Poza funkcjami, które wspomniałem wyżej istnieją też funkcje, które operują na grupach. Zanim jednak je omówię muszę powiedzieć Ci coś więcej o grupowaniu wierszy w SQL.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Grupowanie wierszy przy pomocy GROUP BY   Wiesz już, że tabela invoice zawiera dane o fakturach. Załóżmy, że zadaniem jest przygotowanie raportu, w którym znajdzie się największa faktura dla każdego kraju. Żeby zrealizować takie wymaganie musisz pogrupować ze sobą wszystkie wiersze dotyczące danego kraju i znaleźć wśród nich ten, który ma największą wartość. W tym przypadku będziesz potrzebować wyrażenia GROUP BY. Proszę spójrz na przykład poniżej:     SELECT billingcountry         ,MAX(total)     FROM invoice GROUP BY billingcountry    LIMIT 5;   To zapytanie zwróci pięć wierszy. Każdy z nich zawierał będzie kraj i największą wartość faktury dla danego kraju:   Argentina 13.86 Australia 13.86 Austria   18.86 Belgium   13.86 Brazil    13.86   Grupowanie kilku kolumn   Podobnie jak w przypadku sortowania w SQL tak i przy grupowaniu możesz określić wiele kolumn. Proszę spójrz na przykład poniżej:     SELECT billingcountry         ,billingstate         ,MAX(total)     FROM invoice GROUP BY billingcountry         ,billingstate    LIMIT 5;   Tym razem zapytanie zwróci pięć wierszy, które będą zawierały maksymalną wartość faktury dla pary billingcountry i billingstate:   Argentina                     13.86 Australia       NSW           13.86 Austria                       18.86 Belgium                       13.86 Brazil          DF            13.86   Uważaj na grupowanie w SQLite   Zachowanie SQLite w przypadku grupowania i brakującego wyrażenia GROUP BY jest dziwne. Oznacza to tyle, że poniższe zapytanie SQLite uzna za poprawne:   SELECT billingcountry       ,MAX(total)   FROM invoice;   Wywołanie takiego zapytania w bazie PostgreSQL kończy się błędem:   ERROR:  column \"invoice.billingcountry\" must appear in the GROUP BY clause or be used in an aggregate function   Zapamiętaj, że każda kolumna, która jest zwracana powinna być albo uwzględniona w wyrażeniu GROUP BY, albo użyta w funkcji grupującej.   Funkcje grupujące   W artykule pokazałem Ci już kilka funkcji dostępnych w SQL. Istnieje odrębna grupa funkcji, która używana jest przy grupowaniu wartości. Znasz już jedną z nich, MAX. Nadszedł czas na poznanie kolejnych:      AVG – zwraca średnią wartość,   MIN – zwraca minimalną wartość,   SUM – zwraca sumę wartości,   TOTAL – działa podobnie jak SUM, jedyna różnica polega na tym, że jeśli wszystkie wartości to NULL, wówczas TOTAL zwróci 0, a SUM zwróci NULL.   Jest jeszcze jedna funkcja grupująca, która jest bardzo popularna. Jest nią COUNT.   Funkcja grupująca `COUNT   Funkcja COUNT służy do zliczania wierszy, które mają wartość inną niż NULL. Jej najprostsza postać może wyglądać jak w przykładzie poniżej. To zapytanie zwróci liczbę wierszy, dla których wartość kolumny customerid nie ma wartości NULL:   SELECT COUNT(customerid)   FROM invoice;  Jeśli chcesz policzyć ogólną liczbę wierszy możesz użyć * jako argumentu:   SELECT COUNT(*)   FROM invoice;   W obu przypadkach zapytanie zwróci jeden wiersz:   412  W przypadku funkcji COUNT  możesz także użyć wyrażenia DISTINCT:   SELECT COUNT(DISTINCT customerid)   FROM invoice;   W tym przypadku zapytanie zwróci liczbę unikalnych wartości kolumny customerid:   59   Klauzula HAVING   Załóżmy tym razem, że potrzebujesz raport, w którym pokażesz sumaryczny przychód dla poszczególnych krajów. Poniższe zapytanie da Ci odpowiednie wyniki:     SELECT billingcountry         ,SUM(total)     FROM invoice GROUP BY billingcountry;  Może zdarzyć się sytuacja, w której nie potrzebujesz całej listy. W tym przypadku raport powinien zawierać wyłącznie te kraje, dla których suma sprzedaży była większa niż 100. Z pomocą w tego typu zapytaniach przychodzi klauzula HAVING:     SELECT billingcountry         ,SUM(total) AS summed_total     FROM invoice GROUP BY billingcountry   HAVING summed_total &gt; 100;   Wynikiem tego zapytania będzie poniższe sześć wierszy:   Brazil          190.1 Canada          303.96 France          195.1 Germany         156.48 USA             523.06 United Kingdom  112.86   Czym różni się WHERE od HAVING?   Jest to jedno z popularnych pytań, które pojawiają się na rozmowach rekrutacyjnych. Pomogę Ci na nie odpowiedzieć :). Odpowiadając jednym zdaniem możesz powiedzieć, że klauzula WHERE służy do filtrowania wyników zapytania biorąc pod uwagę pojedynczy wiersz, natomiast klauzula HAVING pozwala na filtrowanie wyników na podstawie zgrupowanych wartości.   Jeśli otrzymasz tego typu pytanie na rozmowie kwalifikacyjnej posłuż się jakimś prostym przykładem, w którym pokażesz tę różnicę w praktyce.   Połączenie WHERE i HAVING w jednym zapytaniu często pozwala lepiej zrozumieć różnicę pomiędzy nimi. W przykładzie poniżej zmodyfikowałem poprzednie zapytanie, tak żeby nie uwzględniało stolicy Kanady:     SELECT billingcountry         ,SUM(total) AS summed_total     FROM invoice    WHERE billingcity != 'Ottawa' GROUP BY billingcountry   HAVING summed_total &gt; 100;   Wyniki tym razem są inne. Proszę zwróć uwagę na sumę dla Kanady w obu przypadkach:   Brazil          190.1        Canada          266.34       France          195.1        Germany         156.48       USA             523.06       United Kingdom  112.86     Zadania do wykonania   Przygotowałem dla Ciebie kilka zadań do wykonania. Każde z nich możesz wykonać używając wcześniej przygotowanego środowiska. Jak zawsze zachęcam Cię do eksperymentowania, wtedy nauczysz się najwięcej.   Napisz zapytanie, które zwróci:      średnią, minimalną i maksymalną wartość kolumny total w tabeli invoice,   liczbę wierszy w tabeli invoice w których długość kolumny billingcountry jest większa niż 5,   liczbę unikalnych dat (kolumna invoicedate), w których wystawiono faktury (tabela invoice),   daty (kolumna invoicedate), w których wystawiono co najmniej dwie faktury (tabela invoice),   pięć losowych wierszy z tabeli genre (wywołania tego zapytania wiele razy powinno zwrócić różne wyniki),   miesięczną (kolumna invoicedate) sumę faktur (kolumna total w tabeli invoice) od kupujących z identyfikatorem (kolumna customerid) mniejszym niż 30, wynik powinien być posortowany po miesięcznej sumie faktur i zawierać jedynie te miesiące dla których suma jest większa od 40.   Przykładowe rozwiązania zadań   SELECT AVG(total)       ,MIN(total)       ,MAX(total)   FROM invoice;   SELECT count(*)   FROM invoice  WHERE LENGTH(billingcountry) &gt; 5;   SELECT COUNT(DISTINCT invoicedate)   FROM invoice;     SELECT invoicedate      FROM invoice GROUP BY invoicedate   HAVING count(*) &gt;= 2;     SELECT *     FROM genre ORDER BY RANDOM()    LIMIT 5;     SELECT SUBSTR(invoicedate, 1, 7) AS invoice_month         ,SUM(total) AS monthly_total     FROM invoice    WHERE customerid &lt; 30 GROUP BY invoice_month   HAVING monthly_total &gt; 40 ORDER BY monthly_total;   Podsumowanie   Po lekturze artykułu wiesz czym jest grupowanie wierszy. Znasz kilka przydatnych funkcji w SQL. Potrafisz powiedzieć jaka jest różnica pomiędzy wyrażeniami HAVING i WHERE. Po rozwiązaniu zadań wiesz, że umiesz zastosować tę wiedzę w praktyce. Gratuluję! :)   Daj znać w komentarzach jak udało Ci się rozwiązać zadania, może Twoje zapytania wyglądają trochę inaczej?   Na koniec mam do Ciebie standardową prośbę. Jeśli znasz kogoś, komu ten artykuł może pomóc proszę przekaż tej osobie linka do artykułu. Dzięki temu pomożesz mi dotrzeć do nowych czytelników – z góry dziękuję za Twoją pomoc. Jeśli nie chcesz ominąć kolejnych artykułów dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu!                 Różne silniki baz danych pozwalają na definiowanie własnych funkcji. Na przykład SQLite udostępnia tę funkcjonalność poprzez funkcję sqlite3_create_function. Odsyłam Cię do dokumentacji twojej bazy danych jeśli chcesz poznać więcej szczegółów. &#8617;                  W przypadku SQLite zamieniane są tylko litery kodowane w ASCII, niestety funkcja ta nie działa poprawnie dla polskich znaków. &#8617;                  Wspominałem, że funkcje mogą być specyficzne dla różnych silników baz danych. Na przykład odpowiednikiem SUBSTR w Postgresql jest SUBSTRING. &#8617;           ","categories": ["Bazy danych","Kurs SQL"],
        "tags": [],
        "url": "/funkcje-i-grupowanie-wierszy-w-sql/",
        "teaser": "/assets/images/2018/10/20_funkcje_i_grupowanie_wierszy_w_sql.jpeg"
      },{
        "title": "Dependency Inversion Principle, Dependency Injection i Inversion of Control",
        "excerpt":"Moim zdaniem wokół tych pojęć narosło sporo różnych teorii i wyjaśnień. Każdy na swój sposób stara się je przełożyć na praktykę programowania. W tym artykule postaram się pokazać Ci definicje możliwe najbliższe oryginałowi. Dla pełnego obrazu postaram się także cytować oryginalną definicję, dzięki czemu będziesz mieć okazję wyrobić sobie własne zdanie.   Dependency Inversion Principle   Zasada odwrócenia zależności (ang. Dependency Inversion Principle) to literka D w akronimie SOLID. Akronim ten grupuje pięć różnych wytycznych pomagających pisać kod wysokiej jakości. W dalszej części artykułu będę się do niej odnosił także jako DIP.   W 2002 roku Robert C. Martin, znany także jako Uncle Bob opublikował książkę Agile Software Development, Principles, Patterns and Practices w 2013 książka doczekała się nowego wydania. W książce tej opisał wcześniej wspomniany akronim SOLID. Literka D została opisana w osobnym rozdziale. Ogólną definicję tej zasady autor przedstawił jako:      The Dependency-Inversion Principle  A. High-level modules should not depend on low-level modules. Both should depend on abstractions.  B. Abstractions should not depend upon details. Details should depend upon abstractions.     Punkty tej zasady można przetłumaczyć jako:      A. Moduły wysokiego poziomu nie powinny zależeć od modułów niskiego poziomu. Oba powinny zależeć od abstrakcji.  B. Abstrakcje nie powinny zależeć od detali. Detale powinny zależeć od abstrakcji.    Przykład zastosowania Dependency Inversion Principle   Wyobraź sobie klimatyzator, który reaguje na temperaturę powietrza. Jeśli temperatura jest wyższa od założonego poziomu klimatyzator włącza się automatycznie. Wyłącza się, jeśli osiągnie temperaturę niższą o 3 stopnie niż założony poziom. Naiwna implementacja może wyglądać tak (zauważ, że tego klimatyzatora nie da się wyłączyć ;)):   public class AirConditioner {     private static final float THRESHOLD = 3;      private final float desiredTemperature;     private final Thermometer thermometer;      public AirConditioner(float desiredTemperature, Thermometer thermometer) {         this.desiredTemperature = desiredTemperature;         this.thermometer = thermometer;     }      public void start() throws InterruptedException {         while (true) {             if (thermometer.measure() &gt; desiredTemperature) {                 coolDown();             }             System.out.println(\"It's cool.\");             TimeUnit.SECONDS.sleep(5);         }     }      private void coolDown() throws InterruptedException {         while (thermometer.measure() &gt; desiredTemperature - THRESHOLD) {             System.out.println(\"Cooling down\");             // cooling down somehow ;)             TimeUnit.SECONDS.sleep(5);         }     } }  public class Thermometer {     public float measure() {         return new Random().nextFloat();     } }   W tym przypadku klasa AirConditioner jest “modułem wysokiego poziomu”. Klasa Thermometer to “moduł niskiego poziomu”. Zatem ten przykład nie spełnia DIP, bo klasa AirConditioner zależy bezpośrednio od Thermometer. To co proponuje Uncle Bob sprowadza się do wprowadzenia nowej abstrakcji. Istotne jest to, że to moduł wysokiego poziomu powinien być właścicielem tej abstrakcji.   Rozwiązaniem w tym przypadku może być wprowadzenie abstrakcji, interfejsu Sensor. Interfejs ten byłby implementowany przez Thermometer. Aby DIP była spełniona, klasa AirConditioner powinna być właścicielem interfejsu Sensor. Kod spełniający DIP może wyglądać tak:   public interface Sensor {     float measure(); }  public class AirConditioner {     private static final float THRESHOLD = 3;      private final float desiredTemperature;     private Sensor temperatureSensor;      public AirConditioner(float desiredTemperature, Sensor temperatureSensor) {         this.desiredTemperature = desiredTemperature;         this.temperatureSensor = temperatureSensor;     }     // ... }  public class Thermometer implements Sensor {     @Overrides     public float measure() {         return new Random().nextFloat();     } }   Co to znaczy być właścicielem abstrakcji?   Można powiedzieć, że komponent jest właścicielem abstrakcji, jeśli kontroluje sposób w jaki ta abstrakcja jest zdefiniowana. W przypadku interfejsów oznacza to tyle, że moduł określa metody dostępne w tym interfejsie. Stosując to do przykładu wyżej, aby DIP była spełniona to AirConditioner musi być właścicielem interfejsu Sensor.   W aplikacjach, które cały kod źródłowy mają w jednym pliku jar jest to kwestia umowna. Zdarzają się jednak sytuacje, w których kod źródłowy rozdzielony jest pomiędzy kilka plików.   Diagramy poniżej pokazują przykładowe sposoby podziału. Białe prostokąty reprezentują pliki JAR. Prostokąty z zaokrąglonymi rogami to klasy/interfejsy:             Podział komponentów na osobne pliki JAR, sposób 1.                  Podział komponentów na osobne pliki JAR, sposób 2.        Zachęcam Cię do rzucenia okiem na kod źródłowy na Github’ie. Pokazuję tam przykładowe sposoby rozdzielenia poszczególnych elementów pomiędzy pliki JAR.   Moje trzy grosze   Na początku chciałbym zaznaczyć, że nie dorastam do pięt Robert’owi C. Martin’owi. Po tym wstępie mogę dodać moje trzy grosze ;).   Moim zdaniem, czasami jest tak, że nie ma sensu na siłę wprowadzać dodatkowego interfejsu. Czasami refaktoryzacja, która wydzieli dodatkową klasę, która opakowuje niskopoziomowe szczegóły jest wystarczająco dobra. Pozwala na uzyskanie kodu lepszej jakości. Bardzo mocno wierzę w zmiany wprowadzane małymi krokami. Dobrym pierwszym krokiem jest właśnie wydzielenie klas. Kolejnym etapem jest zastanowienie się na interfejsem pomiędzy nimi.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Inversion of Control   W swoim artykule Martin Fowler wspomina, że pierwsza wzmianka o odwróceniu kontroli (ang. Inversion of Control) miała miejsce 1988 roku. Ten sam koncept opisany był także w 1985 roku w artykule opisującym środowisko programowania Mesa chwaląc się tym, że posiada więcej niż 500 użytkowników :).   Ta druga wzmianka nazywa to podejście prawem Hollywood’u (ang. Hollywod’s Law):      Don‘t  call  us,  we’ll  call  you  (Hollywood’s  Law).  A tool should arrange for Tajo to notify it when the user wishes to communicate some event to the tool, rather than adopt an “ask the user for a command and execute it” model.    Można to przetłumaczyć jako:      Narzędzie powinno (…) wspierać użytkownika kiedy on chce wydać narzędziu polecenie, a nie stosować się do podejścia “zapytaj użytkownika o polecenie i wykonaj je”.    O odwróceniu kontroli wspomina też inna, klasyczna już książka Design Patterns: Elements of Reusable Object-Oriented Software:      A framework dictates the architecture of your application. It will define the overall structure, its partitioning into classes and objects, the key responsibilites thereof, how the clases and objects collaborate, and the thread of control. (…) Frameworks thus emphasize design reuse over code reuse (…). Reuse on this level leads to an inversion of control between the application and the software on which it’s based. When you use a toolkit (…), you write the main body of the application and call the code you want to reuse. When you use a framework, you reuse the main body and write the code it calls.    Ten dłuższy fragment można przetłumaczyć jako1:      Biblioteka (ang. framework) narzuca architekturę aplikacji. Definiuje także jej strukturę, podział na klasy i obiekty, ich zakres odpowiedzialności, jak klasy i obiekty współdziałają oraz sposób ich wywoływania. (…) Zatem biblioteka podkreśla wielokrotne użycie architektury a nie wielokrotne użycie kodu. Wielokrotne użycie na tym poziomie prowadzi do odwrócenia kontroli pomiędzy aplikacją i jej zależnościami. Kiedy używasz zestawu narzędzi, piszesz główne ciało aplikacji i wywołujesz kod, który chcesz używać wielokrotnie. Kiedy używasz biblioteki, używasz jej mechanizmów, które wywołują kod, który napiszesz.    W dalszej części artykułu czasami będę nazywał tę regułę jako IOC.   Przykłady odwrócenia kontroli   Przykładem takiego odwrócenia kontroli może być cykl życia serwletu. Bazując na specyfikacji serwletów masz pewność, że kontener wywoła odpowiednie metody w odpowiednim czasie. Nie ty je wywołujesz, robi to za Ciebie kontener serwletów. Na przykład nie Ty wywołujesz metodę init, robi to kontener serwletów wtedy, kiedy jest taka potrzeba.   Innym przykładem odwrócenia kontroli są kontenery IOC, na przykład Guice czy Spring2. Nie Ty tworzysz zależności, te zależności tworzone są przez kontener i wstrzykiwane do Twoich obiektów.   Poniżej pokażę Ci też odwrócenie kontroli na trochę mniejszym fragmencie kodu. Zwróć uwagę na implementację metody toString. W pierwszym przykładzie klasa HtmlTag wymaga wszystkich informacji w trakcie tworzenia obiektu:   public class HtmlTag {      private final String tag;     private final String body;      public HtmlTag(String tag, String body) {         this.tag = tag;         this.body = body;     }      @Override     public String toString() {         return String.format(\"&lt;%s&gt;%s&lt;/%s&gt;\", tag, body, tag);     } }   W drugim zastosowałem wzorzec template meethod. Metoda stosuje odwrócenie kontroli, w trakcie swojego działania prosi o niezbędne informacje wywołując metody getTag i getBody:   public abstract class HtmlTag {      protected abstract String getTag();     protected abstract String getBody();      @Override     public String toString() {         String tag = getTag();         String body = getBody();         return String.format(\"&lt;%s&gt;%s&lt;/%s&gt;\", tag, body, tag);     } }  public class EmTag extends HtmlTag {      private String body;      public EmTag(String body) {         this.body = body;     }      @Override     protected String getTag() {         return \"em\";     }      @Override     protected String getBody() {         return body;     } }   Dependency Injection   Niestety tutaj nie udało mi się dotrzeć do “pierwotnej” definicji tego pojęcia.   Można powiedzieć, że wstrzykiwanie zależności (ang. Dependency Injection) to praktyka wspomagająca pisanie kodu lepszej jakości.   Jest to mechanizm, który pozwala na dostarczenie zależności niezbędnych do poprawnego działania danego obiektu. Zależności mogą być dostarczane (wstrzykiwane) na wiele sposobów. Na przykład poprzez wywołanie “seterów”, dostarczenie niezbędnych parametrów konstruktora czy korzystając z mechanizmu refleksji.   Bez wstrzykiwania wszystkie zależności tworzone są przez obiekt, który ich wymaga3. Prowadzi to do kodu, który jest trudny do testowania i mocno związany z konkretną implementacją zależności.   W dalszej części artykułu czasami będę nazywał tę praktykę jako DI.   Przykład użycia Dependency Injection   Proszę spójrz na przykład poniżej. Jest to klasa, która jest odpowiedzialna za tworzenie losowego łańcucha znaków o zadanej długości. Zauważ, że klasa RandomString wymaga generatora liczb losowych. W tym przykładzie tym generatorem jest instancja klasy Random. Głównym problemem tego kodu jest to, że używając klasy RandomString nie masz żadnego wpływu na sposób jej działania. Wszystkie jej zależności tworzone są w trakcie tworzenia instancji.   public class RandomString {      private final Random generator = new Random();      public String getString(int length) {         return generator.ints(length, 'a', 'z' + 1)                 .mapToObj(i -&gt; (char) i)                 .reduce(new StringBuilder(), StringBuilder::append, StringBuilder::append)                 .toString();     } }   Pozornie niewielka zmiana bardzo mocno podnosi jakość kodu. Tą zmianą jest dodanie do konstruktora parametru, który inicjalizuje generator. Takie podejście pozwoli w łatwy sposób wstrzykiwać zależności tej klasy. Dzięki temu na przykład w trakcie testów możesz dostarczyć taką instancję Random, która za każdym razem będzie zwracała takie same wyniki:   public class RandomString {      private final Random generator;      public RandomString(Random generator) {         this.generator = generator;     }      // implementation of getString is the same }   Tak zwane kontenery DI odpowiedzialne są za tworzenie sieci obiektów. Taki kontener wstrzykuje poszczególne zależności. W naszym przykładzie to kontener stworzyłby instancję klasy Random i RandomString. Ta druga utworzona zostałaby przy pomocy wcześniej utworzonej instancji klasy Random. Innymi słowy instancja klasy Random byłaby wstrzyknięta do instancji klasy RandomString.   Porównanie DIP, IOC i DI   Porównanie Dependency Inversion Principle i Inversion of Control   Zasada odwrócenia zależności sprowadza się do dodawania nowych abstrakcji, które pozwolą tworzyć kod wyższej jakości. Odwrócenie kontroli może być stosowane na różnych poziomach.   Zwróć uwagę na to, że DIP wspomina o interfejsach pomiędzy poszczególnymi modułami. Opisując tę zasadę wspomniałem także o tym, że to moduł wysokiego poziomu jest właścicielem tego interfejsu.   Takie podejście Uncle Bob uznaje jako odwrócenie kontroli. Po zastosowaniu zasady odwrócenia zależności moduł wyższego poziomu staje się właścicielem interfejsu. W przeciwnym przypadku to moduł niższego poziomu jest właścicielem tego interfejsu. Ta subtelna różnica prowadzi do odwrócenia kontroli.   Porównanie Dependency Inversion Principle i Dependency Injection   Zasada odwrócenia zależności wprowadza nowe abstrakcje. Można powiedzieć, że te nowe abstrakcje to zależności. Zależności te mogą być wstrzykiwane. Zatem użycie DIP pozwala na łatwe zastosowanie DI.   Te dwa pojęcia są także podobne pod względem nazwy ;). Wydaje mi się, że to właśnie ta zbliżona nazwa powoduje tyle zamieszania i powoduje mieszanie tych dwóch pojęć.   Porównanie Inversion of Control i Dependency Injection   IOC odwraca kontrolę. Objawia się to na wielu poziomach. Czasami może to być odwrócenie tego kto jest właścicielem interfejsu. Czy odwrócenie kolejności, w której generowane są obiekty.   Kontenery DI to nic innego jak kontenery, które wspierają IOC. Istnieje także pojęcie kontenerów IOC. Z mojego punktu widzenia kontenery IOC i kontenery DI określają to samo. To samo czyli mechanizm, który w łatwy sposób pozwala na wstrzykiwanie zależności.   Zauważ, że w przypadku tych kontenerów odwrócona jest kolejność wywoływania konstruktorów obiektów. Muszę tu też dodać, że stosowanie IOC wcale nie wymaga użycia DI. Jednak użycie DI wymaga użycia IOC.   Dodatkowe materiały do nauki   Materiałów związanych z tymi trzema pojęciami jest sporo. Poniżej zebrałem kilka z nich:      Artykuł dotyczący Dependency Inversion Principle na Wikipedii,   Artykuł dotyczący Inversion of Control na Wikipedii,   Artykuł dotyczący Inversion of Control na stronie Martin’a Fowler’a,   Artykuł na temat Inversion of Control i wzorca Dependency Injection na stronie Martin’a Fowler’a.   Ciekawostka, wzmianka z 1985 o Hollywood’s Law,   Kod źródłowy przykładów użytych w artykule   Dodatkowo odsyłam Cię do źródeł w postaci książek, o których pisałem w artykule. Niestety ich minusem jest wysoka cena:      Agile Software Development, Principles, Patterns and Practices,   Design Patterns: Elements of Reusable Object-Oriented Software.   Podsumowanie   Po przeczytaniu tego artykułu wiesz czym jest DIP, IOC i DI. Na przykładach pokazałem Ci jak wygląda kod przed i po zastosowaniu tych zasad. Mam nadzieję, że teraz nie będziesz już mieć problemu ze wskazaniem różnic pomiędzy tymi pojęciami, które są często mylone.   Na koniec proszę Cię o podzielenie się tym artykułem ze swoimi znajomymi. Dzięki temu pozwolisz dotrzeć mi do szerszego grona Czytelników, a na tym właśnie mi zależy. Z góry dziękuję! Jeśli nie chcesz pominąć kolejnych artykułów polub Samouczka na Facebook’u i dopisz się do samouczkowego newslettera. Do następnego razu!                 Mam świadomość, że framework i library to dwie różne rzeczy. Niestety nie znam lepszego tłumaczenia framework niż biblioteka. Może powinienem użyć określenia rusztowanie? ;) &#8617;                  Spring jest wielki. To słowo wytrych, które zawiera w sobie wszystko. Tutaj mam na myśli wyłącznie podzbiór Spring Core. &#8617;                  Jest to pewne uproszczenie. Możliwa jest sytuacja, w której kod napisany jest w sposób pozwalający na użycie DI, jednak tego nie robi. &#8617;           ","categories": ["Dobre praktyki","Programista rzemieślnik"],
        "tags": [],
        "url": "/dependency-inversion-principle-dependency-injection-i-inversion-of-control/",
        "teaser": "/assets/images/2018/11/03-dependency-inversion-principle-dependency-injection-inversion-of-control.jpg"
      },{
        "title": "Samouczek na rozmowie – kalkulator",
        "excerpt":"     To jest artykuł z serii “Samouczek na rozmowie”. W ramach tej serii staram się, między innymi, rozwiązywać zadania. Zadania te często zdarzają się na rozmowach kwalifikacyjnych.   W trakcie rozwiązywania takich zadań umiejętność szacowania złożoności obliczeniowej jest niezwykle ważna. Przyda się też umiejętność pisania testów jednostkowych. Dzięki nim bardzo łatwo przetestujesz działanie algorytmu.      Podstawy złożoności obliczeniowej,   Test Driven Development na przykładzie,   Testy jednostkowe z JUnit,   Podstawą jest oczywiście znajomość języka programowania, ja używał będę Javy jednak możesz użyć dowolnego języka programowania. W opisie problemu czasami będę używał “pseudo kodu”. Przykładowe rozwiązania będą w języku Java.      Kurs programowania w języku Java.     W artykule tym pokazuję kolejne zadanie, które nie jest algorytmiczne. W tym przypadku zadanie ma sprawdzić głównie umiejętność pisania kodu wysokiej jakości.   W artykule dotyczącym zadania z zagnieżdżoną strukturą dokładnie opisywałem moje podejście do rozwiązania tego typu zadań. Zachęcam Cię do przeczytania tego artykułu. Poniżej tylko krótkie przypomnienie wskazówek, które tam zebrałem:      w przypadku niepełnego opisu zadania załóż coś. W rozwiązaniu zadania opisz swoje założenia,   staraj się zawsze dostarczać testy automatyczne razem ze swoim rozwiązaniem, nawet jeśli nie są wymagane,   dokumentuj swój kod tam gdzie jest to niezbędne, używanie docstring’ów może być dobrym rozwiązaniem.   Zadanie do wykonania   Wiesz już, że dzisiejsze zadanie podesłał mi jeden z Czytelników – Łukasz (jeszcze raz wielkie dzięki). Łukasz dostał następujące instrukcje:      Przygotowanie kompletnego rozwiązania powinno zająć około dwóch godzin. Dostarczone rozwiązanie powinno mieć jakość, którego możemy się spodziewać w trakcie normalnej pracy. Używanie narzędzi do budowania jest mile widziane, nie jest to wymóg konieczny. Dostarczenie testów jednostkowych także nie jest wymagane, jednak jest mile widziane i będzie wzięte pod uwagę podczas oceniania zadania. Rozwiązanie powinno zawierać także instrukcję jak uruchomić zadanie z linii poleceń. Rozwiązanie może założyć, że dane wejściowe są w poprawnym formacie. W przypadku niejasnych wymagań przyjęte założenia powinny być dostarczone razem z rozwiązaniem. Dopuszczalne jest użycie zewnętrznych bibliotek. Należy je dołączyć do dostarczonego rozwiązania. Jakość dostarczonego kodu jest równie istotna jak dostarczenie działającego rozwiązania.    Poza ogólną instrukcją dostał także oczywiście treść zadania do wykonania:      Napisz program, który zwróci wynik otrzymany na podstawie zestawu instrukcji. Instrukcje składają się ze słowa kluczowego i liczby oddzielonych spacją. Instrukcje oddzielone są znakiem nowej linii. Zestaw instrukcji pobierany jest z pliku, a wynik obliczeń powinien być wypisany na ekranie. Plik może zawierać dowolną liczbę instrukcji. Instrukcje mogą być dowolną operacją przyjmującą dwa argumenty (np. add, subtract, multiply, divide itp.). Instrukcje powinny być interpretowane w kolejności wprowadzenia (kolejność operacji w matematyce powinna być ignorowana). Ostatnią instrukcją powinna być apply i liczba. Na przykład apply 3. Ta liczba powinna być użyta w trakcie tworzenia instancji kalkulatora. Następnie kalkulator powinien wykonać po kolei wszystkie wcześniej podane operacje.    Tutaj pracodawca zachował się wzorowo, dostarczając dodatkowo przykłady działania programu:      wejście:  add 2  multiply 3  apply 10  wyjście: 36  wyjaśnienie: ((10 + 2) * 3) = 36       wejście:   multiply 3   add 2   apply 10  wyjście: 32  wyjaśnienie: ((10 * 3) + 2) = 32       wejście:  apply 1  wyjście: 1    Pochwała dla pracodawcy   Często w artykułach w tej serii wspominam o dobrych praktykach, które warto stosować przy rozwiązywaniu zadań tego typu. Przytoczyłem część z nich na początku tego artykułu.   W tym przypadku pracodawca w treści zadania dokładnie je wypunktował. Z mojego punktu widzenia pracodawca, który dokładnie opisuje zadanie do wykonania i z góry odpowiada na pytania, które mogą się pojawić ma dużego plusa.   Jeśli zobaczysz tak opisane zadanie, to moim zdaniem masz do czynienia z firmą, która ma doświadczenie w rekrutowaniu programistów przy pomocy zadań tego typu.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Rozwiązanie zadania   Zadanie rozwiązałem używając TDD. Starałem się dodawać zmiany po każdym cyklu. Patrząc w historię repozytorium1 możesz zobaczyć jak rozwijał się kod. Zanim jednak zajrzysz do przykładowego rozwiązania zachęcam Cię do samodzielnej próby rozwiązania tego zadania. Wtedy nauczysz się najwięcej.   Muszę też zaznaczyć, że moje rozwiązanie nie zadziała w przypadku gdy lista poleceń będzie bardzo długa. Dzieje się tak, ponieważ wczytuję całą listę instrukcji do pamięci przed rozpoczęciem jakichkolwiek obliczeń. Bardzo długa lista poleceń skończyłaby się wówczas wyjątkiem OutOfMemoryError.   Obejściem tego problemu byłoby przeczytanie odpowiedniej ilości danych z końca pliku (żeby znaleźć instrukcję apply). Przy takim podejściu złożoność pamięciowa programu wynosiłaby Ο(1), a nie Ο(n).   Dopuszczalne operacje   W moim rozwiązaniu wszystkie dopuszczalne operacje zdefiniowałem jako elementy typu wyliczeniowego. Posłużyłem się tutaj także odwołaniem do metod w klasie BigDecimal. Ten mechanizm opisałem dokładnie w artykule na temat wyrażeń lambda:   public enum Operation {      ADD(BigDecimal::add),     SUBTRACT(BigDecimal::subtract),     MULTIPLY(BigDecimal::multiply),     DIVIDE(BigDecimal::divide);      private final BinaryOperator&lt;BigDecimal&gt; command;      Operation(BinaryOperator&lt;BigDecimal&gt; command) {         this.command = command;     }      public BigDecimal apply(BigDecimal value1, BigDecimal value2) {         return command.apply(value1, value2);     }      // ... }   Elementy programowania funkcyjnego   W swoim rozwiązaniu użyłem elementy programowania funkcyjnego. Rozwijanie funkcji (ang. currying) pozwala mi utworzyć odpowiednią funkcję na etapie parsowania każdej instrukcji, nie muszę znać obu parametrów. Tutaj także użyłem wyrażeń lambda i tak zwanych domknięć2:   public enum Operation {     // ...     public static Function&lt;BigDecimal, BigDecimal&gt; parse(String line) {         String[] tokens = line.split(\" \");         if (tokens.length != 2) {             throw new IllegalArgumentException(\"Line (\" + line + \") has illegal format!\");         }         BigDecimal operand = new BigDecimal(tokens[1]);         return x -&gt; Operation.valueOf(tokens[0].toUpperCase()).apply(x, operand);     } }   Dodatkowo klasa Calculator dostając kolejne instrukcje w formie funkcji do wykonania łączy je ze sobą używając metody andThen:   public class Calculator {      private final BigDecimal initialValue;     private Function&lt;BigDecimal, BigDecimal&gt; linkedOperations = Function.identity();      public Calculator(BigDecimal initialValue) {         this.initialValue = initialValue;     }      public void execute(Function&lt;BigDecimal, BigDecimal&gt; operation) {         linkedOperations = linkedOperations.andThen(operation);     }      public BigDecimal compute() {         return linkedOperations.apply(initialValue);     } }   Dzięki takiemu podejściu wywołanie linkedOperations.apply(initialValue) pozwala na sekwencyjne uruchomienie wszystkich wprowadzonych instrukcji.   Wyślij mi swoje zadanie   Jeśli chcesz żebym spróbował rozwiązać Twoje zadanie proszę wyślij je na mój adres e-mail marcin małpka samouczekprogramisty.pl. Jeśli tylko będę potrafił je rozwiązać to z chęcią napiszę o tym artykuł.     Często firmy zastrzegają sobie to, żeby nie rozpowszechniać zadań, które były na rozmowie kwalifikacyjnej. Jeśli tak było w Twoim przypadku proszę uszanuj wolę danej firmy i nie przesyłaj mi takiego zadania.   Dostając zadanie od Ciebie zakładam, że mogę je opublikować na blogu.     Podsumowanie   Po lekturze tego artykułu i samodzielnej próbie rozwiązania zadania jesteś o krok bliżej do dobrego przygotowania do rozmowy kwalifikacyjnej.   Dzisiejszy artykuł pokazał Ci zadanie, które moim zdaniem jest jasno opisane. Zawiera wszystkie niezbędne informacje do jego rozwiązania. Dobrze jest trafić na zadania tego typu na rozmowach kwalifikacyjnych. Propozycja rozwiązania zawiera bardziej zaawansowane konstrukcje, dzięki którym możesz zobaczyć jak może wyglądać czytelny kod wysokiej jakości.   Jeśli ktoś z Twoich znajomych przygotowuje się do rozmowy kwalifikacyjnej na stanowisko programisty możesz podzielić się linkiem do tego artykułu, z góry dziękuję. Jeśli nie chcesz pomiąć kolejnych artykułów możesz dopisać się do samouczkowego newslettera i polubić Samouczka na Facebook’u.   Do następnego razu!                 Jeśli nie wiesz czym jest repozytorium zapraszam Cię do kursu Git’a :) &#8617;                  Wyrażenia lambda w języku Java nie są czystymi domknięciami, jednak w tym przypadku takie uproszczenie jest dopuszczalne :). &#8617;           ","categories": ["Samouczek na rozmowie","Strefa zadaniowa"],
        "tags": [],
        "url": "/samouczek-na-rozmowie-kalkulator/",
        "teaser": "/assets/images/2018/11/12_zadanie_z_rozmowy_kwalifikacyjnej_kalkulator.jpg"
      },{
        "title": "Klauzula JOIN w zapytaniach SQL",
        "excerpt":"     To jest jeden z artykułów w ramach praktycznego kursu SQL. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Każde zapytanie z kursu możesz wykonać samodzielnie. Potrzebujesz do tego środowiska opisanego w pierwszym artykule kursu. Bardzo mocno Cię do tego zachęcam. Moim zdaniem najwięcej nauczysz się samodzielnie eksperymentując z zapytaniami.     W tym artykule, jeśli wyraźnie nie zaznaczyłem inaczej, korzystam z bazy danych SamouczekJoin.sqlite.   Odrobina teorii   Zanim przejdę do omówienia klauzuli JOIN. Muszę powiedzieć Ci coś więcej na temat modelu relacyjnego. Jeśli nie udało Ci się przeczytać artykułu dotyczącego wprowadzenia do relacyjnych baz danych to najwyższy czas to nadrobić. Ten artykuł będzie wymagał materiału, który tam opisałem.   Poza materiałem z tamtego artykułu musisz poznać jeszcze jedno pojęcie. Mam na myśli iloczyn kartezjański.   Iloczyn kartezjański   Wyobraź sobie dwie tabele. Jedna zawiera imiona męskie:   SELECT *   FROM imiona_meskie;   id          imie ----------  ---------- 1           Piotr 2           Tomasz 3           Jan   SQLite pozwala na takie formatowanie wyników po użyciu .header on in .mode column   Druga żeńskie:   SELECT *   FROM imiona_zenskie;   id          imie ----------  ---------- 11          Anna 12          Monika 13          Zofia   Iloczynem kartezjańskim będzie zbiór, w którym każdy wiersz z pierwszej tabeli połączony będzie z każdym wierszem w drugiej tabeli. W związku z tym, że w każdej z tabel są 3 wiersze, wynikowa tabela1 będzie miała ich 9:   id          imie        id          imie ----------  ----------  ----------  ---------- 1           Piotr       11          Anna 1           Piotr       12          Monika 1           Piotr       13          Zofia 2           Tomasz      11          Anna 2           Tomasz      12          Monika 2           Tomasz      13          Zofia 3           Jan         11          Anna 3           Jan         12          Monika 3           Jan         13          Zofia   Taki iloczyn kartezjański możesz wyprodukować używając zapytania:   SELECT *   FROM imiona_meskie       ,imiona_zenskie;   Nazwy kolumn   Jak widzisz nazwy kolumn są w nim powtórzone. Pierwsze dwie id i imie pochodzą z tabeli imiona_meskie. Dwie kolejne, o tych samych nazwach pochodzą z tabeli imiona_zenskie.   W takim przypadku aby wybrać kolumnę, z konkretnej tabeli konieczne jest poprzedzenie jej nazwą tabeli. Na przykład:   SELECT imiona_meskie.id AS id_m       ,imiona_zenskie.imie AS imie_z       ,imiona_zenskie.*   FROM imiona_meskie       ,imiona_zenskie;   id_m        imie_z      id          imie ----------  ----------  ----------  ---------- 1           Anna        11          Anna 1           Monika      12          Monika 1           Zofia       13          Zofia 2           Anna        11          Anna 2           Monika      12          Monika 2           Zofia       13          Zofia 3           Anna        11          Anna 3           Monika      12          Monika 3           Zofia       13          Zofia   W przykładzie tym użyłem także konstrukcji imiona_zenskie.*, która zwraca wszystkie kolumny z tabeli imiona_zenskie.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Typy złączeń   Złączenia będę omawiał na przykładzie dwóch tabel bajka i postac. bajka zawiera dwie kolumny:      id identyfikator bajki, klucz główny,   tytul tytuł bajki.   SELECT *   FROM bajka;   id          tytul ----------  -------------------- 1           101 Dalmatyńczyków 2           Flinstonowie 3           Jetsonowie 4           Epoka lodowcowa 5           Rozbójnik Rumcajs 6           Muminki 7           Smerfy   postac to tabela z trzema kolumnami:      id identyfikator postaci, klucz główny,   bajka_id identyfikator bajki, w której postać występuje, klucz obcy do tabeli bajka,   imie imię postaci.   SELECT *   FROM postac;   id          bajka_id    imie ----------  ----------  ---------- 1           1           Czika 2           1           Pongo 3           2           Wilma 4           2           Fred 5           4           Elka 6           4           Maniek 7           6           Migotka 8           6           Muminek 9                       Maja 10                      Gucio 11                      Fiona 12                      Shrek   W złączeniach tabel istotne są klucze główne i klucze obce. Tutaj jeszcze raz odsyłam Cię do artykułu opisującego model relacyjny2.   Znasz już dwa sposoby łączenia danych z wielu tabel. Iloczyn kartezjański i klauzule UNION oraz UNION ALL. O ile wyniki uzyskiwane przez złączenie wyników kilku zapytań przy pomocy UNION lub UNION ALL mogą być przydatne to iloczyn kartezjański zbyt użyteczny nie jest. SQL daje możliwość łączenia danych z wielu tabel na kilka innych sposobów.   Do uzyskania wszystkich rodzajów złączeń podstawą jest iloczyn kartezjański. Z takiego iloczynu odrzucane są następnie wiersze, które “nie pasują” do złączenia danego typu3.   INNER JOIN   Podstawowym rodzajem złączenia jest INNER JOIN. Z iloczynu kartezjańskiego wybiera ono te wiersze, dla których warunek złączenia jest spełniony. W żadnej z łączonych tabel kolumna użyta do łączenia nie może mieć wartości NULL. Na przykład:   SELECT *   FROM bajka INNER JOIN postac              ON bajka.id = postac.bajka_id;   To zapytanie zwraca wszystkie kolumny z tabel bajka i postac. Zwrócone są tylko te wiersze, dla których wartość kolumn bajka.id i postac.bajka_id jest równa:   id          tytul                 id          bajka_id    imie       ----------  --------------------  ----------  ----------  ---------- 1           101 Dalmatyńczyków    1           1           Czika      1           101 Dalmatyńczyków    2           1           Pongo      2           Flinstonowie          3           2           Wilma      2           Flinstonowie          4           2           Fred       4           Epoka lodowcowa       5           4           Elka       4           Epoka lodowcowa       6           4           Maniek     6           Muminki               7           6           Migotka    6           Muminki               8           6           Muminek      W zrozumieniu tego co się tutaj stało może pomóc rzucenie okiem na iloczyn kartezjański (jakie zapytanie wyprodukuje taki iloczyn kartezjański?):   id          tytul                 id          bajka_id    imie       ----------  --------------------  ----------  ----------  ---------- 1           101 Dalmatyńczyków    1           1           Czika      1           101 Dalmatyńczyków    2           1           Pongo      1           101 Dalmatyńczyków    3           2           Wilma      1           101 Dalmatyńczyków    4           2           Fred       1           101 Dalmatyńczyków    5           4           Elka       1           101 Dalmatyńczyków    6           4           Maniek     1           101 Dalmatyńczyków    7           6           Migotka    1           101 Dalmatyńczyków    8           6           Muminek    1           101 Dalmatyńczyków    9                       Maja       1           101 Dalmatyńczyków    10                      Gucio      1           101 Dalmatyńczyków    11                      Fiona      1           101 Dalmatyńczyków    12                      Shrek      2           Flinstonowie          1           1           Czika      2           Flinstonowie          2           1           Pongo      2           Flinstonowie          3           2           Wilma      2           Flinstonowie          4           2           Fred       2           Flinstonowie          5           4           Elka       2           Flinstonowie          6           4           Maniek    ...   Wynik złączenia, zawiera tylko cztery wiersze z tych, które pokazałem wyżej:   id          tytul                 id          bajka_id    imie       ----------  --------------------  ----------  ----------  ---------- 1           101 Dalmatyńczyków    1           1           Czika      1           101 Dalmatyńczyków    2           1           Pongo      2           Flinstonowie          3           2           Wilma      2           Flinstonowie          4           2           Fred       ...   Zwróć uwagę na wartości kolumn id (tej pierwszej, z tabeli bajka) i bajka_id (z tabeli postac). Jak widzisz zapytanie używające złączenia typu INNER JOIN zwraca wyłącznie te wiersze dla których kolumny użyte do złączenia mają tę samą wartość.   Innym sposobem na uzyskanie tego samego wyniku jest zapytanie:   SELECT *   FROM bajka       ,postac  WHERE bajka.id = postac.bajka_id;   Wybieranie kolumn   Rzadko pobranie wszystkich kolumn po złączeniu tabel jest potrzebne. Bardzo często zwracane wiersze zawierają tylko niezbędny podzbiór kolumn:   SELECT bajka.tytul       ,postac.imie   FROM bajka INNER JOIN postac              ON bajka.id = postac.bajka_id;   tytul                 imie       --------------------  ---------- 101 Dalmatyńczyków    Czika      101 Dalmatyńczyków    Pongo      Flinstonowie          Wilma      Flinstonowie          Fred       Epoka lodowcowa       Elka       Epoka lodowcowa       Maniek     Muminki               Migotka    Muminki               Muminek      A co z brakującymi postaciami i bajkami? Zauważ, że wynik nie zawiera bajek takich jak “Jetsonowie”, “Rozbójnik Rumcajs” czy “Smerfy”. Brakuje także postaci “Maja”, “Gucio”, “Fiona” i “Shrek”. Z pomocą przychodzą złączenia typu OUTER JOIN.   OUTER JOIN   Istnieją trzy rodzaje złączeń typu OUTER:      LEFT OUTER JOIN,   RIGHT OUTER JOIN,   FULL OUTER JOIN.   LEFT OUTER JOIN   Tym razem zacznę od przykładu. Zapytanie używające złączenia tego typu może wyglądać tak:   SELECT *   FROM bajka LEFT OUTER JOIN postac              ON bajka.id = postac.bajka_id;   W wyniku działania tego zapytania zwrócone zostaną następujące wiersze:   id          tytul                 id          bajka_id    imie       ----------  --------------------  ----------  ----------  ---------- 1           101 Dalmatyńczyków    1           1           Czika      1           101 Dalmatyńczyków    2           1           Pongo      2           Flinstonowie          3           2           Wilma      2           Flinstonowie          4           2           Fred       3           Jetsonowie                                               4           Epoka lodowcowa       5           4           Elka       4           Epoka lodowcowa       6           4           Maniek     5           Rozbójnik Rumcajs                                       6           Muminki               7           6           Migotka    6           Muminki               8           6           Muminek    7           Smerfy              W tym przypadku zapytanie zwróciło wszystkie bajki. Zarówno te, dla których istnieją odpowiadające im postaci jak i te, które nie mają odpowiadających wierszy w tabeli postac. Widzisz różnicę? W złączeniu typu LEFT OUTER JOIN znajdują się dodatkowe wiersze. Te wiersze zawierają wartości NULL w kolumnach tabeli postac. Pokazuje to tyle, że dla bajek “Jetsonowie”, “Rozbójnik Rumcajs” i “Smerfy” nie udało się znaleźć odpowiadających wierszy w tabeli postac.   Innymi słowy złączenie typu LEFT OUTER JOIN zwraca:      wiersze dla których warunek złączenia jest spełniony,   wiersze z “lewej tabeli” dla których nie ma odpowiedników w prawej (*bajka* LEFT OUTER JOIN postac).   Wybieranie kolumn   Także tutaj ograniczenie liczby kolumn jest przydatne:   SELECT bajka.tytul       ,postac.imie   FROM bajka        LEFT OUTER JOIN postac        ON bajka.id = postac.bajka_id;   To zapytanie zwróci następujące wiersze:   tytul                 imie       --------------------  ---------- 101 Dalmatyńczyków    Czika      101 Dalmatyńczyków    Pongo      Flinstonowie          Fred       Flinstonowie          Wilma      Jetsonowie                       Epoka lodowcowa       Elka       Epoka lodowcowa       Maniek     Rozbójnik Rumcajs               Muminki               Migotka    Muminki               Muminek    Smerfy                       RIGHT OUTER JOIN   Niestety SQLite nie wspiera RIGHT OUTER JOIN. Wyniki, które tu pokazuję możesz uzyskać w innych silnikach baz danych lub obchodząc ograniczenia SQLite.   RIGHT OUTER JOIN jest złączeniem podobnym do LEFT OUTER JOIN. Złączenie typu RIGHT OUTER JOIN zwraca:      wiersze dla których warunek złączenia jest spełniony,   wiersze z “prawej tabeli” dla których nie ma odpowiedników w lewej (bajka RIGHT OUTER JOIN *postac*).   SELECT *   FROM bajka RIGHT OUTER JOIN postac              ON bajka.id = postac.bajka_id;   id          tytul                 id          bajka_id    imie       ----------  --------------------  ----------  ----------  ---------- 1           101 Dalmatyńczyków    1           1           Czika      1           101 Dalmatyńczyków    2           1           Pongo      2           Flinstonowie          3           2           Wilma      2           Flinstonowie          4           2           Fred       4           Epoka lodowcowa       5           4           Elka       4           Epoka lodowcowa       6           4           Maniek     6           Muminki               7           6           Migotka    6           Muminki               8           6           Muminek                                      9                       Maja                                         10                      Gucio                                        11                      Fiona                                        12                      Shrek      W tym przypadku zapytanie zwróciło wszystkie postaci. Zarówno te, dla których istnieją odpowiadające im bajki jak i te, które nie mają odpowiadających wierszy w tabeli bajka. W tym przypadku dla postaci “Maja”, “Gucio”, “Fiona” i “Shrek” nie udało znaleźć się odpowiadających bajek.   Jak uzyskać RIGHT OUTER JOIN w SQLite   Tutaj sprawa jest banalnie prosta bajka RIGHT OUTER JOIN postac zwraca te same wyniki co postac LEFT OUTER JOIN bajka :). Zatem zwykłe odwrócenie tabel wystarczy:   SELECT bajka.*       ,postac.*    FROM postac LEFT OUTER JOIN bajka               ON bajka.id = postac.bajka_id;   FULL OUTER JOIN   Niestety SQLite nie wspiera FULL OUTER JOIN. Wyniki, które tu pokazuję możesz uzyskać w innych silnikach baz danych lub obchodząc ograniczenia SQLite.   FULL OUTER JOIN jest złączeniem które zwraca:      wiersze dla których warunek złączenia jest spełniony,   wiersze z “lewej tabeli” dla których nie ma odpowiedników w prawej (*bajka* LEFT OUTER JOIN postac),   wiersze z “prawej tabeli” dla których nie ma odpowiedników w lewej (bajka RIGHT OUTER JOIN *postac*).   SELECT *   FROM bajka FULL OUTER JOIN postac              ON bajka.id = postac.bajka_id;   id          tytul                 id          bajka_id    imie       ----------  --------------------  ----------  ----------  ---------- 1           101 Dalmatyńczyków    1           1           Czika      1           101 Dalmatyńczyków    2           1           Pongo      2           Flinstonowie          3           2           Wilma      2           Flinstonowie          4           2           Fred       3           Jetsonowie                                               4           Epoka lodowcowa       5           4           Elka       4           Epoka lodowcowa       6           4           Maniek     5           Rozbójnik Rumcajs                                       6           Muminki               7           6           Migotka    6           Muminki               8           6           Muminek    7           Smerfy                                                                                     9                       Maja                                         10                      Gucio                                        11                      Fiona                                        12                      Shrek      Jak uzyskać FULL OUTER JOIN w SQLite   FULL OUTER JOIN jest złączeniem, która zwraca wiersze z połączenia LEFT OUTER JOIN i RIGHT OUTER JOIN. Klauzula WHERE bajka.id IS NULL odpowiada za odfiltrowanie części wspólnej. Bez tego warunku wynik zawierałby powielone wiersze wspólne dla LEFT OUTER JOIN i RIGHT OUTER JOIN:   SELECT *   FROM bajka LEFT OUTER JOIN postac              ON bajka.id = postac.bajka_id UNION ALL SELECT bajka.*       ,postac.*   FROM postac LEFT OUTER JOIN bajka               ON bajka.id = postac.bajka_id  WHERE bajka.id is NULL;   JOIN tu, JOIN tam   Pamiętam, że na początku mnogość pojęć robiła mi niezły mętlik w głowie. Do tego wszystkiego silniki bazy danych pozwalające na opuszczanie niektórych słów kluczowych nie pomagały. Lista niżej powinna Ci pomóc się w nich odnaleźć:      JOIN to to samo co INNER JOIN,   LEFT JOIN to to samo co LEFT OUTER JOIN,   RIGHT JOIN to to samo co RIGHT OUTER JOIN,   FULL JOIN to to samo co FULL OUTER JOIN,   CROSS JOIN to to samo co iloczyn kartezjański.   Zadania do wykonania   Poniżej przygotowałem dla Ciebie kilka zadań do wykonania. Pomogą Ci one przećwiczyć sporą część materiału opisanego w kursie do tej pory. Wszystkie zapytania powinny być wywołane na bazie danych Chinook.   Jak zwykle zachęcam Cię do samodzielnego eksperymentowania zanim rzucisz okiem na przykładowe rozwiązania.   Napisz zapytanie, które zwróci:      liczbę wierszy w iloczynie kartezjańskim tabel track, invoice i invoiceline (UWAGA! to zapytanie może trochę potrwać),   tytuł albumu (kolumna title w tabeli album) i nazwę artysty (kolumna name w tabeli artist) dla wszystkich nazw artystów zaczynających się od s,   identyfikator i nazwę list utworów (tabela playlist), które są puste,   nazwy trzech najczęściej występujących gatunków muzycznych (kolumna name w tabeli genre) wraz z odpowiadającą im liczbą utworów (tabela track) posortowaną malejąco po liczbie utworów,   tytuły pięciu najdłuższych albumów (kolumna title w tabeli album) posortowanych malejąco po ich długości (kolumna milliseconds w tabeli track),   tytuły albumów, na których występują utwory z gatunku “Reggae”,   pięć nazw list utworów, które są najdroższe (suma cen wszystkich ścieżek jest największa),   Przykładowe rozwiązania zadań   SELECT COUNT(*)   FROM track       ,invoice       ,invoiceline;   SELECT album.title       ,artist.name    FROM album JOIN artist               ON album.artistid = artist.artistid  WHERE artist.name LIKE 's%';   SELECT playlist.*    FROM playlist LEFT JOIN playlisttrack                 ON playlisttrack.playlistid = playlist.playlistid  WHERE playlisttrack.trackid IS NULL;     SELECT genre.name         ,count(*) AS how_many     FROM genre LEFT JOIN track                ON genre.genreid = track.genreid GROUP BY genre.name ORDER BY how_many DESC    LIMIT 3;     SELECT album.title     FROM track JOIN album                ON track.albumid = album.albumid GROUP BY album.albumid ORDER BY SUM(track.milliseconds) DESC    LIMIT 5;   SELECT DISTINCT album.title   FROM track JOIN genre              ON track.genreid = genre.genreid              JOIN album              ON track.albumid = album.albumid  WHERE genre.name = \"Reggae\";   SELECT playlist.name   FROM playlist JOIN playlisttrack                 ON playlist.playlistid = playlisttrack.playlistid                 JOIN track                 ON playlisttrack.trackid = track.trackid GROUP BY playlist.name         ,playlist.playlistid ORDER BY SUM(track.unitprice) DESC    LIMIT 5;   Podsumowanie   Po lekturze tego artykułu wiesz już czym są złączenia. Znasz wszystkie typy złączeń występujące w zapytaniach SQL. Po przerobieniu przykładowych zadań wiesz jak połączyć w całość wiedzę zdobytą do tej pory na kursie. Gratuluję!   Muszę, Ci powiedzieć, że moim zdaniem ta część materiału jest zdecydowanie najtrudniejsza dla początkujących, na pewno dla mnie taka była. Daj sobie trochę czasu na przetrawienie wiedzy z tego artykułu :). Jeśli nie wszystko jest dla Ciebie zrozumiałe daj znać w komentarzach, postaram się pomóc.   Jeśli uważasz, że artykuł może przydać się komuś z Twoich znajomych, proszę przekaż mu linka. W ten sposób pomożesz mi dotrzeć do nowych Czytelników, z góry dziękuję!   Jeśli nie chcesz ominąć kolejnych artykułów polub Samouczka na Facebooku i dopisz się do samouczkowego newslettera.   Trzymaj się!                 W kontekście modelu relacyjnego powinienem raczej użyć pojęcia relacja. Mam wrażenie, że tabela jest jednak łatwiejsze do zrozumienia. &#8617;                  Złączeń można dokonywać na tabelach, które nie są połączone między sobą kluczami obcymi. W praktyce nie zdarza się to za często. Upraszczając można powiedzieć, że klucze główne i klucze obce pomagają silnikom baz danych wykonywać złączenia, które są bardziej wydajne. &#8617;                  Bazy danych mogą tu sporo optymalizować, dzięki czemu czasochłonne tworzenie iloczynu kartezjańskiego nie zawsze jest wykonywane. Jednak z punktu widzenia algebry relacji, podstawy modelu relacyjnego to właśnie iloczyn kartezjański jest punktem wyjścia. &#8617;           ","categories": ["Bazy danych","Kurs SQL"],
        "tags": [],
        "url": "/klauzula-join-w-zapytaniach-sql/",
        "teaser": "/assets/images/2018/11/22_kauzula_join_w_zapytaniach_sql_artykul.jpg"
      },{
        "title": "Wzorzec projektowy adapter",
        "excerpt":"Czytasz jeden z artykułów opisujących wzorce projektowe. Jeśli interesuje Cię ten temat zapraszam Cię do lektury pozostałych artykułów, które powstały w ramach tej serii – wzorce projektowe   Problem do rozwiązania   Pewnie wiesz, że w różnych krajach gniazdka mogą wyglądać inaczej niż to, co możesz zobaczyć na co dzień. Charakterystyka prądu w takim gniazdku także może być różna. Załóżmy, że jedziesz do Wielkiej Brytanii, albo do Stanów Zjednoczonych. Zabierasz ze sobą laptopa i ładowarkę. Bateria wystarcza Ci na czas lotu. Po przylocie na miejsce chcesz uzupełnić baterię w pierwszym wolnym gniazdku na lotnisku.   Tu pojawia się problem. Wtyczka z Twojej ładowarki nie pasuje do gniazdka. Można powiedzieć, że gniazdko i wtyczka nie są ze sobą kompatybilne. Przypominasz sobie jednak, że przezornie udało Ci się zapakować przejściówkę. Przejściówka sprawi, że możesz podłączyć swoją ładowarkę do gniazdka.   Problem tego typu może także występować w projektach informatycznych. Przejściówka, która pozwala włączyć wtyczkę do innego gniazdka to nic innego jak adapter.   Problemem do rozwiązania jest zatem użycie obiektu, w miejscu gdzie jego interfejs nie jest obsługiwany. Adapter rozwiązuje ten problem “tłumacząc” go na coś zrozumiałego dla klienta.   Błyskawiczny kurs UML   Jeśli chcesz dowiedzieć się więcej o UML, to zapraszam Cię do przeczytania osobnego artykułu na temat podstaw UML’a.   Zanim przejdę do omówienia diagramów, które pokazują powiązania klas i interfejsów w tym wzorcu projektowym musisz dowiedzieć się czegoś o UML’u.   UML (ang. Unified Modeling Language) składa się z kilkunastu rodzajów diagramów. Jest to zestaw, który pozwala na wizualną reprezentację projektu informatycznego. W ramach serii opisującej wzorce projektowe będę korzystał z zupełnych podstaw tej notacji. Będę używał głównie diagramów klas. Chociaż nie jestem wielkim fanem UML’a, to taki sposób prezentacji w tym przypadku wydaje mi się najlepszy.   Do zrozumienia diagramów z tego artykuły wystarczy Ci ten przykład:             Przykładowy diagram UML.        Na tym diagramie możesz zobaczyć:      trzy klasy – prostokąty z napisami User, LinkedList, Object,   dwa interfejsy – prostokąty oznaczone adnotacją &lt;&lt;interfejs&gt;&gt; z napisami List, Collection,   dziedziczenie – strzałka z ciągłą linią i z pustym grotem, na przykład pomiędzy LinkedList a Object czy List a Collection,   implementację interfejsu – strzałka z przerywaną linią i z pustym grotem pomiędzy LinkedList a List,   zależność – strzałkę z ciągłą linią pomiędzy User a LinkedList.   Kod w języku Java zgodny z tym diagramem może wyglądać tak (część diagramu dotycząca elementów biblioteki standardowej nie jest tu widoczna):   public class User extends Object {     private LinkedList&lt;String&gt; notes; }   Te podstawy w zupełności wystarczą Ci do zrozumienia poniższych przykładów.   Wzorzec adapter   Diagramy klas   Istnieją dwa sposoby implementacji adaptera. Jeden z nich używa kompozycji, drugi dziedziczenia. Diagramy poniżej pokazują tę subtelną różnicę:             Wzorzec adapter zaimplementowany przy pomocy kompozycji.                  Wzorzec adapter zaimplementowany przy pomocy dziedziczenia.        W obu przypadkach klasa DoAdaptacji nie implementuje bezpośrednio interfejsu Zależność. Ten interfejs implementuje klasa Adapter. Także w obu przypadkach Klient reprezentuje klasę, która używa interfejsu Zależność. Zatem użycie klasy Adapter pozwala na pośrednie użycie klasy DoAdaptacji przez klasę Klient.   Zaletą stosowania tego wzorca projektowego jest to, że klasa DoAdaptacji nie musi być modyfikowana, aby spełnić interfejs wymagany przez klasę Klient. Czasami nawet taka modyfikacja nie jest możliwa.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Przykładowa implementacja adaptera   Wyobraź sobie sytuację, w której mamy macierz kwadratową. Macierz reprezentowana jest przez obiekt implementujący interfejs Matrix:   public interface Matrix {     int get(int x, int y);     int size(); }   Dodatkowo istnieje klasa MatrixOperations, która definiuje zestaw metod operujących na takich macierzach. Przykład poniżej pokazuje metodę largest, która zwraca największy element z macierzy:   public class MatrixOperations {     public static int largest(Matrix m) {         if (m.size() == 0) {             throw new IllegalArgumentException(\"Matrix is empty!\");         }         int largest = m.get(0, 0);         for (int x = 0; x &lt; m.size(); x++) {             for (int y = 0; y &lt; m.size(); y++) {                 if (m.get(x, y) &gt; largest) {                     largest = m.get(x, y);                 }             }         }         return largest;     } }   Przekładając to na diagramy, które pokazałem wyżej to:      Klient – MatrixOperations,   Zależność – Matrix.   Adapter przy użyciu kompozycji   Standardowo macierz można reprezentować przez tablicę dwuwymiarową. ArrayMatrix to adapter, który wykorzystuje kompozycję. W tym przypadku opakowuje on tablicę dwuwymiarową – int[][], udostępniając interfejs Matrix:   public class ArrayMatrix implements Matrix {     private final int[][] matrix;      public ArrayMatrix(int[][] matrix) {         this.matrix = matrix;     }      @Override     public int get(int x, int y) {         return matrix[y][x];     }      @Override     public int size() {         return matrix.length;     } }   W tym przypadku:      Adapter – ArrayMatrix,   DoAdaptacji – int[][].   Wszystko ładnie działa. Do czasu. Pojawiło się wymaganie, które zakłada, że musisz przechować bardzo dużą i rzadką macierz. Rzadka macierz to taka, w której większość elementów ma wartość 0. Jest to problem, ponieważ ArrayMatrix wymaga ciągłych obszarów pamięci. Dodatkowo marnuje ją przechowuje wartości 0, które można pominąć.   Z pomocą przychodzi inna implementacja adaptera.   Adapter przy użyciu dziedziczenia   Tym razem adapter wykorzystuje dziedziczenie:   public class MapMatrix extends HashMap&lt;String, Integer&gt; implements Matrix {     private final int size;      public MapMatrix(int size) {         this.size = size;     }      @Override     public int get(int x, int y) {         assertBoundaries(x, y);         return this.getOrDefault(key(x, y), 0);     }          public void set(int x, int y, int value) {         assertBoundaries(x, y);         put(key(x, y), value);     }      @Override     public int size() {         return size;     }      private String key(int x, int y) {         return x + \",\" + y;     }      private void assertBoundaries(int x, int y) {         if (x &lt; 0 || x &gt; size || y &lt; 0 || y &gt; size) {             throw new IllegalArgumentException(key(x, y));         }     } }   W tym przypadku:      Adapter – MapMatrix,   DoAdaptacji – HashMap.   Ćwiczenie do wykonania   Ćwiczenie polega na zaimplementowaniu adaptera. Przerób adapter MapMatrix w taki sposób, aby wykorzystywał kompozycję.   Dodatkowe materiały do nauki   Bez wątpienia klasyką tematu jest książka Design Patterns – Gamma, Helm, Johnson, Vlissides. Jeśli miałbym polecić wyłącznie jedno źródło to poprzestałbym na tej książce.   Zachęcam Cię też do zajrzenia do kodu źródłowego, który użyłem w tym artykule.   Podsumowanie   Po przeczytaniu tego artykułu wiesz czym jest wzorzec projektowy adapter. Znasz przykłady zastosowania tego wzorca. Rozwiązując ćwiczenie udało Ci się zastosować tę wiedzę w praktyce.   Mam nadzieje, że artykuł przypadł Ci do gustu. Na koniec mam do Ciebie prośbę. Jeśli ktoś z Twoich znajomych mógłby skorzystać z tego artykułu proszę przekaż mu linka. Dzięki temu pomożesz mi dotrzeć do nowych Czytelników. Z góry dziękuję!   Jeśli nie chcesz pominąć nowych artykułów polub Samouczka na Facebook’u i zapisz się do samouczkowego newslettera. Trzymaj się!  ","categories": ["Wzorce projektowe"],
        "tags": [],
        "url": "/wzorzec-projektowy-adapter/",
        "teaser": "/assets/images/2019/01/26_wzorzec_projektowy_adapter_artykul.jpg"
      },{
        "title": "Wątki w języku Java",
        "excerpt":"W artykule w zupełności pomijam zagadnienie procesów i zrównoleglania wykonywania zadań przy ich pomocy. Nie poruszam też tematu “event-loop” i przetwarzania asynchronicznego, które niejako związane są z wątkami. Pomijam także dokładny opis klas biblioteki standardowej z pakietu java.util.concurrent czy temat programowania reaktywnego. Każde z tych zagadnień to temat na co najmniej jeden osobny artykuł.   Stwórz swój pierwszy wątek   Zacznę od przykładu. Poniższy fragment kodu tworzy nowy wątek. Wewnątrz tego wątku znajduje się pętla, która wypisuje wszystkie liczby od 0 do 4, po czym kończy swoje działanie. Dokładnie taka sama pętla znajduje się w wątku głównym:   public static void main(String[] args) {     System.out.println(\"MT start\");     Thread thread = new Thread(() -&gt; {         System.out.println(\"T0 start\");         for (int i = 0; i &lt; 5; i++) {             System.out.println(\"T0 \" + i);         }         System.out.println(\"T0 stop\");     });     thread.start();     for (int i = 0; i &lt; 5; i++) {         System.out.println(\"MT \" + i);     }     System.out.println(\"MT stop\"); }   Wynik działania tej metody może być następujący. W Twoim przypadku może on być zupełnie inny. Uruchom tę metodę kilka razy porównując otrzymany wynik:   MT start MT 0 T0 start MT 1 T0 0 T0 1 T0 2 MT 2 T0 3 MT 3 T0 4 T0 stop MT 4 MT stop   Zanim przejdę do dokładnego omówienia tego fragmentu kodu musisz dowiedzieć się czegoś więcej o wątkach i sposobie ich działania.   Wątki w teorii   Program bez wątków   Wyobraź sobie problem, którego rozwiązanie wymaga wykonania trzech zadań. Udało Ci się napisać program, który ten problem rozwiązuje. Uruchamiasz ten program na komputerze. Każde z zadań uruchamiane jest po zakończeniu poprzedniego. Na diagramie może wyglądać to tak:             Trzy zadania uruchomione sekwencyjne na jednym procesorze.        Gwiazdka reprezentuje rdzeń procesora. Różnokolorowe prostokąciki reprezentują trzy zadania do wykonania. Długość prostokącików reprezentuje czas trwania poszczególnych zadań. Zadania uruchamiane są po kolei. Po tym jak skończy się zadanie zielone rozpoczyna się zadanie niebieskie. Można powiedzieć, że zadania uruchamiane są sekwencyjnie.   Program wielowątkowy   Przed procesorami wielordzeniowymi wątki były “oszustwem”. Procesor był jeden, mógł pracować wyłącznie nad jednym zadaniem. Wymyślono jednak inne rozwiązanie.   Szatkowanie czasu :)   Mam na myśli time slicing. Mechanizm dzięki, któremu jeden rdzeń procesora może uruchamiać wiele wątków. Nie dzieje się to jednak równolegle.   Diagram poniżej prezentuje dokładnie te same zadania. Tym razem każde z nich uruchamiane jest w osobnym wątku, mamy zatem trzy wątki. Mechanizm nadzorujący ich pracę zapewnia, że co jakiś czas aktualny wątek zostanie zatrzymany. Mówi się wtedy, że wątek został wywłaszczony. Kolejny wątek zostaje wybudzony, dostaje czas procesora i jest przez niego wykonywany. Suma długości prostokącików w danym kolorze jest dokładnie taka sama jak w poprzednim przykładzie:             Trzy zadania uruchomione w wątkach na jednym procesorze.        Takie podejście ma swoje zalety, jednak nie prowadzi do krótszego czasu działania programu. Wręcz przeciwnie, zatrzymywanie i wybudzanie wątków zajmuje czas. Proszę spójrz na diagram poniżej, który pokazuje czas trwania obu podejść:             Porównanie czasu trwania dwóch podejść na jednym procesorze.        Po co zatem stosować takie podejście? Najważniejszym argumentem jest to, że w tym przypadku każde z zadań jest delikatnie popychane do przodu. Wyobraź sobie inną sytuację. Załóżmy, że dwa zadania zajmują wyraźnie mniej czasu niż trzecie:        W takim przypadku zadania niebieskie i białe muszą czekać na zakończenie zadania zielonego. Zastosowanie wątków w tym przypadku może prowadzić do dużo szybszego zakończenia zadań niebieskiego i białego (chociaż nadal sumaryczny czas, wraz z przełączeniami wątków, będzie dłuższy):        Takie podejście pozwala na uniknięcie tak zwanego zagłodzenia (ang. starving) wątków. W powyższym przykładzie bez szatkowania czasu wątek z zadaniem zielonym zagłodziłby wątki z zadaniami niebieskim i białym.   “Szatkowanie czasu” daje wrażenie równoległej pracy wielu wątków, jednak w rzeczywistości w danym momencie tylko jedno zadanie jest uruchomione. Inaczej wygląda sytuacja w przypadku procesorów mających wiele rdzeni.   Procesory wielordzeniowe   Procesory wielordzeniowe dają rzeczywistą możliwość uruchamiania wielu zadań równolegle. W takim przypadku, jeśli każde z zadań uruchomione zostanie w osobnym wątku wówczas sytuacja wygląda jak na diagramie poniżej1:        Uruchomienie programu bez wątków na komputerze z procesorem wielordzeniowym nie przyspieszyłoby jego działania – jeden rdzeń sekwencyjnie realizowałby każde z zadań.   Połączenie obu podejść   W rzeczywistości spotkasz się połączeniem obu podejść2. Proszę spójrz na diagram poniżej. Pokazuje on przykładowe wykonanie zadania na dwóch rdzeniach. Dla porównania pokazałem też sekwencyjne wykonanie tych samych zadań:             Trzy zadania uruchomione w wątkach na dwóch procesorach.        Wspólne dane   Wątki korzystają z tych samych danych. Mówi się, że wątki współdzielą przestrzeń adresową. Oznacza to tyle, że obiekty dostępne dla jednego wątku są widoczne także w innych wątkach3.   Proszę pamiętaj, że zmienne dostępne są dla wszystkich wątków. W związku z tym wszystkie wątki mogą te zmienne modyfikować. Pociąga to za sobą bardzo poważne konsekwencje. Opiszę je dokładniej w dalszej części artykułu.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Tworzenie nowego wątku   Każdy wątek w języku Java związany jest z klasą Thread. Wątek można utworzyć na dwa sposoby.   Dziedziczenie po klasie Thread   Pierwszym ze sposobów jest utworzenie własnej klasy, która dziedziczy po klasie Thread:   public class MyThread extends Thread {     @Override     public void run() {         System.out.println(\"I'm inside thread!\");     } }  Thread thread = new MyThread();   W tym przypadku należy nadpisać metodę run – to właśnie ona zostaje wykonana jako ciało wątku.   Implementacja interfejsu Runnable   Drugim sposobem jest utworzenie wątku przy pomocy konstruktora, który przyjmuje obiekt implementujący interfejs Runnable:   public static class MyRunnable implements Runnable {     @Override     public void run() {         System.out.println(\"I'm inside runnable!\");     } }  Thread thread = new Thread(new MyRunnable());   Tym razem ciałem wątku jest implementacja metody run z interfejsu Runnable.   Zauważ, że możesz utworzyć wątek posługując się klasami anonimowymi:   Thread thread = new Thread(new Runnable() {     @Override     public void run() {         System.out.println(\"I'm inside runnable!\");     } });   Interfejs Runnable jest interfejsem funkcyjnym. W związku z tym zapis ten można uprościć stosując wyrażenia lambda:   Thread thread = new Thread(() -&gt; System.out.println(\"I'm inside runnable!\"));   Cykl życia wątku   Utworzenie instancji wątku to dopiero początek. Każdy wątek ma swój cykl życia. Wątki mogą znajdować się w jednym z sześciu stanów. Dopuszczalne stany wątku znajdują się w klasie wyliczeniowej Thread.State:      NEW – nowy wątek, który nie został jeszcze uruchomiony,   RUNNABLE – wątek, który może wykonywać swój kod,   TERMINATED – wątek, który zakończył swoje działanie,   BLOCKED – wątek zablokowany, oczekujący na zwolnienie współdzielonego zasobu,   WAITING – wątek uśpiony,   TIMED_WAITING – wątek uśpiony na określony czas.   Poniższy diagram pokazuje możliwe przejścia pomiędzy stanami:             Diagram stanów wątku        Przejście ze stanu NEW do stanu RUNNABLE odbywa się po wywołaniu metody start() na instancji wątku. Dopiero wtedy wątek może być wykonywany, samo utworzenie instancji nie powoduje jego uruchomienia. Każdy wątek może być uruchomiony dokładnie raz – dokładanie jeden raz może być na nim wywołana metoda start().   Zwróć uwagę na to, że ciałem wątku jest metoda run a do jego uruchomienia niezbędne jest wywołanie metody start. Oczywiście możesz uruchomić metodę run samodzielnie, jednak nie spowoduje to uruchomienia nowego wątku – kod metody run będzie wykonywany w aktualnym wątku.   Wątek, który skończy swoje działanie, przechodzi do stanu TERMINATED.   Omówienie stanów BLOCKED, WAITING i TIMED_WAITING wymaga osobnych sekcji. Zanim jednak do tego przejdę szczegółowo omówię przykład, który pokazałem na początku artykułu.   Omówienie przykładu   Skoro już znasz podstawy teorii związanej z wątkami mogę przejść do omówienia przykładu z początku artykułu. Dla przypomnienia:   public static void main(String[] args) {     System.out.println(\"MT start\");     Thread thread = new Thread(() -&gt; {         System.out.println(\"T0 start\");         for (int i = 0; i &lt; 5; i++) {             System.out.println(\"T0 \" + i);         }         System.out.println(\"T0 stop\");     });     thread.start();     for (int i = 0; i &lt; 5; i++) {         System.out.println(\"MT \" + i);     }     System.out.println(\"MT stop\"); }   Druga linijka metody main to utworzenie instancji wątku. W tym przypadku użyłem konstruktora przyjmującego obiekt implementujący interfejs Runnable. Ten obiekt utworzyłem przy pomocy wyrażenia lambda. W ciele tego wyrażenia znajduje się pętla wypisująca liczby.   Kolejna linijka kodu, thread.start();, uruchamia wątek. Bez niej kod wewnątrz interfejsu Runnable nie zostałby wykonany. Po uruchomieniu wątku znajdziesz kolejną pętlę wypisującą liczby. Powyższy fragment kodu działa w dwóch wątkach:     wątku o domyślnej nazwie main, który tworzony jest automatycznie. Wewnątrz niego uruchomiona jest metoda main,   wątku o domyślnej nazwie Thread-04, który utworzyłem i uruchomiłem samodzielnie.   Kilkukrotne uruchomienie tego kodu pokazuje Ci, że działanie tych dwóch wątków może przeplatać się na różne sposoby.   Wątek w stanie BLOCKED   Wątek, który znajduje się w stanie BLOCKED oczekuje na pewien zablokowany zasób. W języku Java blokowanie odbywa się przy pomocy tak zwanych monitorów, które służą do synchronizacji wątków. Zanim powiem Ci jak synchronizować wątki między sobą muszę pokazać Ci dlaczego taka synchronizacja jest czasami niezbędna.   Dlaczego synchronizacja jest potrzebna?   Wiesz już, że wątki współdzielą przestrzeń adresową. Wspomniałem już, że ma to bardzo istotne konsekwencje. Pokażę Ci je na poniższym przykładzie:   class Counter {     private int value;      public void increment() {         value += 1;     }      public int getValue() {         return value;     } }  public class RaceCondition {     public static void main(String[] args) throws InterruptedException {         Counter c = new Counter();         Runnable r = () -&gt; {             for (int i = 0; i &lt; 100_000; i++) {                 c.increment();             }         };          Thread t1 = new Thread(r);         Thread t2 = new Thread(r);         Thread t3 = new Thread(r);          t1.start();         t2.start();         t3.start();          t1.join();         t2.join();         t3.join();          System.out.println(c.getValue());     } }   Tutaj nowością dla Ciebie jest metoda Thread.join(). Metoda ta zapewnia, że aktualny wątek czeka na zakończenie się wątku, na którym join zostało wywołane. W przykładzie powyżej domyślny wątek main czeka na zakończenie się wątku t1, jak ten się skończy czeka na zakończenie wątku t2 i następnie t3.   Tutaj drobna dygresja. To, że main czeka na wątki w kolejności t1, t2 i t3 nie oznacza, że te wątki skończą się w tej kolejności. W praktyce kolejność ta może być dowolna, w szczególności może także być odwrotna.   W powyższym fragmencie kodu tworzę obiekt r, który implementuje interfejs Runnable. Następnie używając tej instancji tworzę trzy wątki, uruchamiam je i czekam na ich zakończenie. r używa zmiennej lokalnej c typu Counter. Używa jej do zwiększenia wartości atrybutu value o 100’000.   Skoro są trzy wątki, każdy z nich zwiększa wartość zmiennej o 1 i robi to 100’000 razy to wartość value powinna wynosić 300’000, prawda? Spróbuj uruchomić ten kod kilka razy. Jakie wyniki otrzymujesz? W moim przypadku pięć kolejnych uruchomień zwróciło takie wyniki:   235239 296424 300000 281814 300000   Wyścig   To co udało Ci się zaobserwować wyżej to tak zwany wyścig (ang. race condition). Taka sytuacja zachodzi jeśli kilka wątków jednocześnie modyfikuje zmienną, która do takiej równoległej zmiany nie jest przystosowana. Tylko dlaczego wartość atrybutu value miała tak różne wartości? Działo się tak dlatego, że operacja value += 1 nie jest operacją atomową.   Tutaj należy Ci się kolejne wyjaśnienie. Operacja atomowa to taka operacja, która jest niepodzielna. Operacja atomowa realizowana jest przy pomocy jednej instrukcji w bytecode (w skompilowanej klasie). Operacja value += 1 nie jest operacją atomową, jest ona równoważna z value = value + 1. Wykonanie tej operacji składa się z kilku kroków:      pobrania aktualnej wartości value do zmiennej tymczasowej (niewidocznej w kodzie źródłowym)5,   dodania 1 do zmiennej tymczasowej,   przypisanie powiększonej wartości do value.   W bytecode ten fragment wygląda tak:   GETFIELD pl/samouczekprogramisty/kursjava/treads/Counter.value : I ICONST_1 IADD PUTFIELD pl/samouczekprogramisty/kursjava/treads/Counter.value : I   Przykład zachowania wątków   Pamiętasz szatkowanie czasu, które opisałem na początku artykułu? Odgrywa ono tu kluczową rolę. Wyobraź sobie sytuację, w której wątek zielony wykonał krok 1., 2. i 3. po czym został wywłaszczony. Następnie wątki niebieski i biały wykonały krok 1. Po czym wątek niebieski wykonał kroki 2. i 3. Po chwili to samo stało się z wątkiem białym. Taką sytuację pokazuje poniższy diagram:             Przykład zachowania wątków        Biorąc pod uwagę takie zachowanie wątków, jaką wartość wątek biały przypisał do value? Była to wartość 2, przez co cała praca wątku niebieskiego została nadpisana. Proszę spójrz na tabelkę niżej, która pokazuje tę sytuację:                  Operacja       Wątek       Krok       Wartość value       Wartość zmiennej tymczasowej                       1.       zielony       1.       0       0                 2.       zielony       2.       0       1                 3.       zielony       3.       1       1                 4.       niebieski       1.       1       1                 5.       biały       1.       1       1                 6.       niebieski       2.       1       2                 7.       niebieski       3.       2       2                 8.       biały       2.       2       2                 9.       biały       3.       2       2           Jest to jeden z możliwych scenariuszy. W przykładzie powyżej operacja 9. ustawiają wartość value na 2 w wątku białym ignorując zwiększenie wartości wykonane przez wątek niebieski w operacji 7.   Aby uniknąć takich sytuacji, uniknąć wyścigów, niezbędna jest synchronizacja pracy wątków.   Synchronizacja wątków   Każdy obiekt w języku Java powiązany jest z tak zwanym monitorem. Każdy monitor może być w jednym z dwóch stanów: odblokowany albo zablokowany. Monitor może być zablokowany wyłącznie przez jeden wątek w danym momencie. Dzięki tej właściwości to obiekty używane są do tego, żeby synchronizować wątki ze sobą. Służy do tego słowo kluczowe synchronized.   Blok synchronized   Proszę spójrz na delikatnie zmodyfikowany kod klasy Counter:   class Counter {     private int value;      public void increment() {         synchronized (this) {             value += 1;         }     }      public int getValue() {         return value;     } }   Spróbuj jeszcze raz uruchomić RaceCondition po wprowadzeniu takiej modyfikacji. Jak z wynikami? Tym razem na pewno za każdym razem na konsoli pokaże się liczba 300’000. Dzieje się tak ponieważ ciało metody increment objęte jest blokiem synchronized. W tym przypadku obiektem, który został użyty jako monitor jest this – instancja Counter. Blok synchronized ma następujący format:   synchronized (obiekt) {     // synchronizowany kod }   Masz pewność, że wszystko co znajduje się wewnątrz bloku w każdym momencie uruchomione jest przez maksymalnie jeden wątek.   Metoda synchronized   Słowo kluczowe synchronized może być także użyte w innym kontekście. Może także oznaczyć metody, które są synchronizowane. Na przykład:   public synchronized void increment() {     value += 1; }   W praktyce obie wersje metody increment są równoważne. Oznaczenie metody słowem kluczowym synchronized równoznaczne jest w umieszczeniem całego ciała metody w bloku synchronized. To jaki obiekt użyty jest w roli monitora zależy od rodzaju metody:      standardowa metoda – jako monitor użyta jest instancja klasy – this,   metoda statyczna – jako monitor użyta jest klasa.   Na przykład dwa poniższe fragmenty kodu są równoważne:   class Counter {     public synchronized static void sampleStaticMethod() {         System.out.println('xxx');     } }   class Counter {     public static void sampleStaticMethod() {         synchronized (Counter.class) {             System.out.println('xxx');         }     } }   Nie synchronizuj wszystkiego   Synchronizacja wątków pozwala na uniknięcie wielu problemów związanych na przykład z wyścigami. Niestety ma też swoje słabe strony. Pamiętaj, że cały kod, który jest w bloku synchronized w danym momencie może być uruchomiony przez maksymalnie jeden wątek. W związku z tym ten fragment kodu traci możliwość równoczesnego uruchomienia na kilku procesorach – spowalnia wykonanie programu wielowątkowego.   Taki fragment kodu, który w danym momencie może być użyty przez maksymalnie jeden wątek nazywany jest sekcją krytyczną. Dobrą zasadą jest ograniczanie sekcji krytycznej – im mniej w niej kodu tym większy zysk z użycia wielu wątków.   Synchronizacja wątków przy pomocy synchronized to nie wszystko. Wszystkie obiekty w języku Java, poza monitorami, zawierają specjalny zbiór wątków (ang. wait set). Elementami tego zbioru są wątki, które czekają na powiadomienia dotyczące tego obiektu.   Wątek w stanie WAITING   Jednym ze sposobów aby wątek znalazł się w tym stanie jest wywołanie metody Thread.join(). Wiesz już, że w takim przypadku aktualny wątek czeka na zakończenie swojego kolegi.   Wątek znajdzie się w stanie WAITING także jeśli w trakcie jego działania zostanie wywołana metoda Object.wait()6.   Na Samouczku Programisty takie lakoniczne wytłumaczenie nie przejdzie ;). Zapraszam Cię do przykładu, opisującego drugą sytuację.   Komunikacja pomiędzy wątkami   Wyobraź sobie sytuację, w której masz dwa wątki. Jeden produkuje pewne dane, drugi je konsumuje. Tego typu mechanizm jest dość często spotykany. Naiwna implementacja tego typu zachowania może wyglądać tak:   Ten przykład pokazuje złe praktyki, zanim zaczniesz pisać wielowątkowy kod w ten sposób przeczytaj wyjaśnienie poniżej wraz z poprawną wersją implementacji!   public class NaiveConsumerProducer {     private static final Random generator = new Random();     private static final Queue&lt;String&gt; queue = new LinkedList&lt;&gt;();      public static void main(String[] args) {         int itemCount = 5;         Thread producer = new Thread(() -&gt; {             for (int i = 0; i &lt; itemCount; i++) {                 try {                     Thread.sleep(Duration.ofSeconds(generator.nextInt(5)).toMillis());                 } catch (InterruptedException e) {                     throw new RuntimeException(e);                 }                 synchronized (queue) {                     queue.add(\"Item no. \" + i);                 }             }         });         Thread consumer = new Thread(() -&gt; {             int itemsLeft = itemCount;             while (itemsLeft &gt; 0) {                 String item;                 synchronized (queue) {                     if (queue.isEmpty()) {                         continue;                     }                     item = queue.poll();                 }                 itemsLeft--;                 System.out.println(\"Consumer got item: \" + item);             }         });          consumer.start();         producer.start();     } }   W przykładzie tym użyłem listy wiązanej jako kolejki. Obiekt queue będzie służył jako narzędzie do wymiany danych pomiędzy wątkami.   Producent   Zacznę od wątku produkującego dane:   Thread producer = new Thread(() -&gt; {     for (int i = 0; i &lt; itemCount; i++) {         try {             Thread.sleep(Duration.ofSeconds(generator.nextInt(5)).toMillis());         } catch (InterruptedException e) {             throw new RuntimeException(e);         }         synchronized (queue) {             queue.add(\"Item no. \" + i);         }     } });   W ciele wątku znajduje się pętla, która produkuje zadaną liczbę elementów. Nowością dla Ciebie jest metoda Thread.sleep(). Służy ona do uśpienia wątku7. Przekazany parametr mówi o minimalnym czasie, przez który dany wątek będzie uśpiony – nie będzie zajmował czasu procesora. W ten sposób symuluję opóźnienia związane z produkcją elementów. To opóźnienie może być różne dla poszczególnych elementów. Użyłem tu instancji klasy Random, żeby to symulować.   Na razie pominę obsługę wyjątku InterruptedException. Nie jest ona istotna w tym przykładzie, omówię ją dokładnie w jednym z kolejnych akapitów.   Następnie w bloku synchronized dodaje nowy element. Zwróć uwagę, że do synchronizacji używam tu obiektu queue. Dzięki temu mam pewność, że nie nastąpi wyścig podczas dodawania czy usuwania elementów z kolejki.   Wątek kończy swoje działanie po wyprodukowaniu wszystkich elementów.   Konsument   Wątek konsumujący wyprodukowane elementy wygląda tak:   Ten przykład pokazuje złe praktyki, zanim zaczniesz pisać wielowątkowy kod w ten sposób przeczytaj wyjaśnienie poniżej wraz z poprawną wersją implementacji!   Thread consumer = new Thread(() -&gt; {     int itemsLeft = itemCount;     while (itemsLeft &gt; 0) {         String item;         synchronized (queue) {             if (queue.isEmpty()) {                 continue;             }             item = queue.poll();         }         itemsLeft--;         System.out.println(\"Consumer got item: \" + item);     } });   Wątek konsumujący dane także używa pętli. Tym razem jest to pętla while, która wykonuje się dopóki oczekiwana liczba elementów nie zostanie pobrana z kolejki. Także tutaj wątek używa bloku synchronized, w który sprawdza czy elementy są w kolejce i do ewentualnego ich pobrania.   Program działa. Ma jednak pewien subtelny błąd. Zwróć uwagę na wątek konsumenta. Wątek ten działa bez przerwy. Bez przerwy zajmuje czas procesora8. Co więcej, przez większość swojego czasu kręci się wewnątrz pętli sprawdzając czy kolejka jest pusta. Jako drobne ćwiczenie dla Ciebie zostawiam dodanie licznika iteracji – ile razy pętla wykonała się w Twoim przypadku?   Jak można ten problem rozwiązać? Jednym ze sposobów może być usypianie wątku konsumenta używając metody Thread.sleep(), którą już znasz. To także byłoby marnowanie zasobów – skąd możesz wiedzieć jak długo zajmie produkowanie kolejnego elementu?   Z pomocą przychodzi mechanizm powiadomień.   Jak działa mechanizm powiadomień   Wiesz już, że każdy obiekt powiązany jest z monitorem używamy w trakcie synchronizacji. Podobnie wygląda sprawa w przypadku mechanizmu powiadomień. Każdy obiekt w języku Java posiada zbiór   powiadamianych wątków (ang. waiting set).   Wewnątrz tego zbioru znajdują się wątki, które czekają na powiadomienie dotyczące danego obiektu. Jedynym sposobem, żeby modyfikować zawartość tego zbioru jest używanie metod dostępnych w klasie Object:      Object.wait() – dodanie aktualnego wątku do zbioru powiadamianych wątków,   Object.notify() – powiadomienie i wybudzenie jednego z oczekujących wątków,   Object.notifyAll() – powiadomienie i wybudzenie wszystkich oczekujących wątków.   Poprawny producent   Poprawna wersja producenta używa metody notify albo notifyAll informując w ten sposób konsumentów o nowym elemencie:   Thread producer = new Thread(() -&gt; {     for (int i = 0; i &lt; itemCount; i++) {         try {             Thread.sleep(Duration.ofSeconds(generator.nextInt(5)).toMillis());         } catch (InterruptedException e) {             throw new RuntimeException(e);         }         synchronized (queue) {             queue.add(\"Item no. \" + i);             queue.notify();         }     } });   Poprawny konsument   Poprawna wersja konsumenta oczekuje pasywnie na informację od producenta o nowym elemencie:   Thread consumer = new Thread(() -&gt; {     int itemsLeft = itemCount;     while (itemsLeft &gt; 0) {         String item;         synchronized (queue) {             while (queue.isEmpty()) {                 try {                     queue.wait();                 } catch (InterruptedException e) {                     throw new RuntimeException(e);                 }             }             item = queue.poll();         }         itemsLeft--;         System.out.println(\"Consumer got item: \" + item);     } });   Należy Ci się drobne wyjaśnienie nowego fragmentu:   while (queue.isEmpty()) {     try {         queue.wait();     } catch (InterruptedException e) {         throw new RuntimeException(e);     } }   Specyfikacja języka Java pozwala na fałszywe wybudzenia (ang. spurious wake-ups). Są to wybudzenia, które mogą wystąpić nawet gdy nie było odpowiadającego im powiadomienia – wywołania metody notify. Dlatego właśnie sprawdzenie warunku (queue.isEmpty()) musi być wykonane w pętli.   Wątek w stanie TIMED_WAITING   Tym razem będzie krótko ;). Stan TIMED_WAITING jest podobny do stanu WAITING. W tym przypadku wątek oczekuje przez pewien czas, nie krótszy niż podany jako argument do jednej z metod9:      Object.wait() – dodanie aktualnego wątku do zbioru powiadamianych wątków i wybudzenie go po określonym czasie,   Thread.sleep() – wątek wywołujący tę metodę usypia na określony czas,   Thread.join() – oczekiwanie na zakończenie wątku przez określony czas.   Przerywanie wątku   W jednym z poprzednich przykładów wspomniałem o wyjątku InterruptedException. Wyjątek ten sygnalizuje sytuację, w której wątek został przerwany. Wątek może zostać przerwany po wywołaniu na jego instancji metody Thread.interrupt.   W momencie kiedy wątek zostaje przerwany ustawiana jest na nim specjalna flaga, która o tym informuje.   Jeśli chcesz sprawdzić, czy aktualny wątek jest przerwany możesz wywołać statyczną metodę Thread.interrupted. Wywołanie tej metody zwraca true jeśli wątek był przerwany jednocześnie usuwając flagę, o której wspomniałem przed chwilą.   Synchronizacja inaczej – volatile   Java udostępnia jeszcze jeden mechanizm, który pozwala na synchronizację. Mam tu na myśli słowo kluczowe volatile. Specyfikacja języka Java mówi, że każdy odczyt atrybutu poprzedzonego tym słowem kluczowym następuje po jego zapisie. Innymi słowy, modyfikator volatile gwarantuje, że każdy wątek czytający dany atrybut zobaczy najnowszą zapisaną wartość tego atrybutu.   Dzięki temu możesz osiągnąć synchronizację wartości danego pola pomiędzy wątkami. Musisz jednak uważać na modyfikacje, które nie są atomowe – przed zmianami tego typu volatile niestety Cię nie uchroni. W takim przypadku niezbędna będzie synchronizacja, którą opisałem wcześniej.   Poniższy fragment kodu pokazuje poprawne użycie modyfikatora volatile:   public class VolatileExample {     private static volatile boolean isDone = false;      public static void main(String[] args) {         Thread backgroundJob = new Thread(() -&gt; {             try {                 Thread.sleep(Duration.ofSeconds(2).toMillis());             } catch (InterruptedException e) {                 throw new RuntimeException(e);             }             System.out.println(\"I'm done with my job!\");             isDone = true;         });         Thread heavyWorker = new Thread(() -&gt; {             LocalDateTime start = LocalDateTime.now();             while (!isDone) {                 // constantly doing some important stuff             }             long durationInMillis = ChronoUnit.MILLIS.between(start, LocalDateTime.now());             System.out.println(\"I've been notified about finished job after \" + durationInMillis + \" milliseconds.\");         });          heavyWorker.start();         backgroundJob.start();     } }   W ramach ćwiczenia możesz spróbować uruchomić powyższy kod usuwając modyfikator volatile dla pola isDone. Jak zachowuje się ten program po takiej modyfikacji?   Wątki są skomplikowane   Tworzenie programów wielowątkowych jest trudne. Unikanie zakleszczeń, odpowiednia synchronizacja, unikanie wyścigów nie jest trywialne. Nie przejmuj się, jeśli nie zrozumiesz tego zagadnienia od razu. Pisanie wydajnego, bezpiecznego kodu wielowątkowego to coś, z czym nawet bardzo doświadczeni programiści mogą mieć sporo problemów.   Odnajdowanie i naprawianie błędów w programach, które używają wielu wątków to także ciężkie zadanie. Sytuacja, w której kod działa idealnie w trakcie testów, a zachowuje się dziwnie w środowisku wielowątkowym jest czymś powszechnym.   Zanim zaczniesz pisać kod, który ma być wielowątkowo bezpieczny spróbuj znaleźć gotową implementację w pakiecie java.util.concurrent. Używając klas z tego pakietu na pewno unikniesz sporo ciężkich do zdiagnozowania błędów.   Dodatkowe materiały do nauki   Przygotowałem dla Ciebie zestaw linków, które mogą pomóc Ci spojrzeć na temat wątków z innej strony:      Tutorial na stronie Oracle’a dotyczący wątków,   Rozdział w Java Language Specification dotyczący wątków,   Sekcja w Java Language Specification dotycząca metod synchronizowanych,   Sekcja w Java Language Specification dotycząca bloku synchronizowanego,   Artykuł opisujący użycie zmiennych volatile,   Kod źródłowy przykładów użytych w artykule   Jeśli znasz źródło, które Twoim zdaniem warte jest uwagi daj znać – dodam je do listy.   Zadania   Przygotowałem dla Ciebie zadania, które pomogą Ci przećwiczyć wiedzę przedstawioną w artykule w praktyce. Pamiętaj, że zawsze możesz rzucić okiem na przykładowe rozwiązania. Jak zwykle zachęcam Cię do samodzielnej próby rozwiązania tych zadań, w ten sposób nauczysz się najwięcej.   Przedstaw się   Napisz metodę, która przyjmuje liczbę całkowitą. Wywołanie metody powinno uruchomić wątek 0., wewnątrz tego wątku powinien zostać uruchomiony wątek 1. Wątek 1. powinien uruchomić wątek 2. itd. do osiągnięcia zadanej liczby wątków. Każdy z wątków powinien wypisać na konsolę swoją domyślną nazwę.   Na przykład wywołanie metody:   startNestedThreads(3);   Powinno skończyć się uruchomieniem 3 wątków i wypisaniem tekstu na konsolę:   Thread-0 Thread-1 Thread-2   Przedstaw się II   Zmodyfikuj program z poprzedniego punktu w taki sposób, aby wątki wypisywały swoją nazwę w kolejności odwrotnej do ich tworzenia. Tzn. wątek uruchomiony jako pierwszy powinien wypisać swoją nazwę jako ostatni. Na przykład wywołanie metody:   startNestedThreads(3);   Powinno skończyć się uruchomieniem 3 wątków i wypisaniem tekstu na konsolę:   Thread-2 Thread-1 Thread-0   Wielowątkowe Hello world!   Napisz program, który uruchomi trzy wątki. Pierwszy z nich będzie wypisywał w pętli ciąg znaków Hello , drugi world, trzeci !\\n (wykrzyknik ze znakiem nowej linii). Na przykład:   Thread t1 = new Thread(() -&gt; {     for(int i = 0; i &lt; 4; i++) {         System.out.print(\"Hello \");     } }); t1.start();  Thread t2 = new Thread(() -&gt; {     for(int i = 0; i &lt; 4; i++) {         System.out.print(\"world\");     } }); t2.start();  Thread t3 = new Thread(() -&gt; {     for(int i = 0; i &lt; 4; i++) {         System.out.println(\"!\");     } }); t3.start();   Uzupełniając powyższy kod o podstawowe mechanizmy synchronizacji wątków spraw, że program po zakończeniu wypisze linijki tekstu zawierające Hello world!:   Hello world! Hello world! Hello world! Hello world!   Czy Twój program nadal będzie dział poprawnie jeśli będzie wypisywał “Hello world!” 10’000 razy?   Podsumowanie   Po lekturze tego artykułu wiesz czym są wątki. Wiesz jak je tworzyć i uruchamiać. Znasz podstawowe mechanizmy ich synchronizacji. Udało ci się też poznać kilka definicji związanych z programowaniem współbieżnym. Po wykonaniu zadań wiesz, że potrafisz wykorzystać tę wiedzę w praktyce – gratulacje!   Bałem się tego artykułu. Od samego początku pracy nad kursem Javy przesuwałem go w czasie. Teraz, po jego ukończeniu wiem dlaczego ;). Żaden artykuł na blogu nie kosztował mnie tyle pracy. Mam nadzieję, że efekt przypadł Ci do gustu. Proszę podziel się nim z osobami, którym może pomóc. Dzięki temu uda mi się dotrzeć do nowych Czytelników, a na tym właśnie mi zależy – z góry bardzo dziękuję!   Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do samouczkowego newsletter’a i polub Samouczka na Facebook’u. To tyle na dzisiaj, trzymaj się i do następnego razu!                 Możesz założyć, że program został uruchomiony na procesorze czterordzeniowym. Czwarty rdzeń nie był uwzględniony na diagramie. &#8617;                  Raczej mało prawdopodobne jest to, że masz komputer, który ma tylko jeden rdzeń procesora. &#8617;                  Dla uproszczenia pomijam tutaj ThreadLocal. &#8617;                  Tworząc nowe wątki masz możliwość nadawania im nazw, jeśli tego nie zrobisz dostają domyślną w formacie Thread-&lt;kolejny numer&gt;. Masz także możliwość pobrania nazwy aktualnie uruchomionego wątku używając Thread.currentThread().getName(). &#8617;                  W rzeczywistości zmienną tymczasową jest stos, na którym ląduje wartość atrybutu. &#8617;                  Pomijam tu trzeci możliwy przypadek – wywołanie metody LockSupport.park. &#8617;                  Metoda ta sprawia, że wątek jest w stanie TIMED_WAITING o czym przeczytasz za chwilę. &#8617;                  Pomijam wywłaszczenia, które znasz z początku artykułu. &#8617;                  Także tutaj pomijam metody z klasy LockSupport: LockSupport.partNanos i LockSupport.parkUntil. &#8617;           ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "/watki-w-jezyku-java/",
        "teaser": "/assets/images/2019/02/02_watki_w_jezyku_java_artykul.jpg"
      },{
        "title": "Samouczek na rozmowie – łańcuchy białkowe",
        "excerpt":"     To jest artykuł z serii “Samouczek na rozmowie”. W ramach tej serii staram się, między innymi, rozwiązywać zadania. Zadania te często zdarzają się na rozmowach kwalifikacyjnych.   W trakcie rozwiązywania takich zadań umiejętność szacowania złożoności obliczeniowej jest niezwykle ważna. Przyda się też umiejętność pisania testów jednostkowych. Dzięki nim bardzo łatwo przetestujesz działanie algorytmu.      Podstawy złożoności obliczeniowej,   Test Driven Development na przykładzie,   Testy jednostkowe z JUnit,   Podstawą jest oczywiście znajomość języka programowania, ja używał będę Javy jednak możesz użyć dowolnego języka programowania. W opisie problemu czasami będę używał “pseudo kodu”. Przykładowe rozwiązania będą w języku Java.      Kurs programowania w języku Java.     W artykule tym pokazuję zadanie, które przesłał mi jeden z Czytelników – Marek. Marku, jeszcze raz bardzo dziękuję!   W artykule dotyczącym zadania z zagnieżdżoną strukturą dokładnie opisywałem moje podejście do rozwiązania tego typu zadań. Zachęcam Cię do przeczytania tego artykułu. Poniżej tylko krótkie przypomnienie wskazówek, które tam zebrałem:      w przypadku niepełnego opisu zadania załóż coś. W rozwiązaniu zadania opisz swoje założenia,   staraj się zawsze dostarczać testy automatyczne razem ze swoim rozwiązaniem, nawet jeśli nie są wymagane,   dokumentuj swój kod tam gdzie jest to niezbędne, używanie docstring’ów może być dobrym rozwiązaniem,   jeśli nie masz pomysłu na optymalne rozwiązanie zadania zacznij od najprostszego podejścia.   Treść zadania   Genetycy zajmują się nowym typem łańcuchów białkowych, które składają się z ciągu aminokwasów pewnego typu. Wyróżniono 20 rodzajów tych aminokwasów i oznaczono je dużymi literami alfabetu angielskiego – od litery A do T. Łańcuch białkowy można zatem zapisać jako słowo składające się z dużych liter od A do T, na przykład “BDDFPQPPRRAGGHPOPDKJKPEQAAER”.   Mając dany łańcuch białkowy genetycy mogą zamienić w nim dwa dowolne aminokwasy miejscami, na przykład łańcuch “AABBCC” mogą zamienić na “ACBBCA”, a ten z kolei na przykład na “BCBACA”.   Genetyk posiada komputerowy zapis dwóch łańcuchów białkowych i zastanawia się, czy drugi z nich mógł powstać z pierwszego poprzez wykonywanie dowolnej liczby zamian miejsc aminokwasów.   Napisz program, który będzie posiadał funkcję:   boolean changePossible(String s1, String s2)   Powinna ona sprawdzić, czy możliwe jest uzyskanie łańcucha białkowego s2 z łańcucha białkowego s1.   Ponieważ rzeczywiste łańcuchy białkowe składają się z około 108 aminokwasów, należy zadbać o dobrą wydajność algorytmu.   Dane są zapisane w pliku tekstowym. Każdy z łańcuchów jest zapisany w osobnej linii. Porównujemy łańcuch z linii nieparzystej z łańcuchem z linii parzystej. Przykładowy plik:   ACBBCA BCBACA   Można założyć, że liczba linii będzie zawsze parzysta. Można także założyć, że plik wejściowy jest poprawny i nie zawiera żadnych białych znaków poza znakami końca linii. Napisz  program  w popularnym języku programowania (C,  C++,  Java,  C#,  Python), który wczyta plik wejściowy z danymi, obliczy i wypisze wynik. Najlepiej będzie, jeśli program będzie czytać dane ze standardowego wejścia i wypisywać wynik na standardowe wyjście, dzięki czemu będzie go można wywołać poleceniem:   program.exe &lt; dane.txt    Jeśli nie potrafisz korzystać ze standardowego wejścia, możesz wczytać plik z danymi w inny sposób. Ważna jest wydajność zastosowanego algorytmu. W rozwiązaniu możesz korzystać z bibltioteki standardowej dostępnej na platformie, w której będziesz programować.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Rozwiązanie zadania   Zadanie można podzielić na dwie części:      algorytmiczne rozwiązanie problemu,   spełnienie wymagań związanych z interfejsem użytkownika.   Zacznę od dokładnego omówienia pierwszej części – sposobu implementacji algorytmu.   Algorytm – naiwne rozwiązanie zadania   Chociaż jest to naiwne rozwiązanie, nie jest trywialne w implementacji. Opiera się ono na przeglądzie zupełnym. Pomysł polega na wygenerowaniu wszystkich możliwych permutacji jednej z sekwencji i sprawdzenia czy druga znajduje się wśród tych permutacji. W przykładowej implementacji użyłem rekurencji:   boolean naiveChangePossible(String sequence1, String sequence2) {     List&lt;String&gt; peramutationsCache = new LinkedList&lt;&gt;();     permutations(peramutationsCache, \"\", sequence1);     return peramutationsCache.contains(sequence2); }  private void permutations(List&lt;String&gt; permutationsCache, String currentPermutation, String leftCharacters) {     if (leftCharacters.length() == 0) {         permutationsCache.add(currentPermutation);     }     for (int i = 0; i &lt; leftCharacters.length(); i++) {         permutations(             permutationsCache,             currentPermutation + leftCharacters.charAt(i),             leftCharacters.substring(0, i) + leftCharacters.substring(i + 1)         );     } }   Złożoność obliczeniowa   Łańcuch znaków o długości n posiada n! wszystkich permutacji. Zatem złożoność obliczeniowa potrzebna do ich wygenerowania to Ο(n!). Dodatkowo dla każdej z nich przeprowadzam operację łączenia łańcuchów znaków wewnątrz pętli. Ta operacja ma złożoność Ο(n). Zatem finalna złożoność obliczeniowa tego rozwiązania to Ο(n^n!).   Spróbuj uruchomić to rozwiązanie kilka razy. Za każdym razem dodawaj po jednej literze do łańcucha znaków. Na ile liter masz cierpliwość ;) ? Pamiętaj, że dla dużych wartości n nie masz szans na doczekanie się rozwiązania.   Złożoność pamięciowa   W przypadku tego rozwiązania każda permutacja jest dodawana do permutationsCache. Każda z permutacji ma tę samą długość – n. W związku z tym złożoność pamięciowa tego rozwiązania to Ο(nn!).   Algorytm – Znacząco lepsze rozwiązanie   Chociaż poprzedni algorytm jest poprawny nie ma szans działać dla większych instancji problemu. Nie wspominając nawet o łańcuchach o długości 108 wspomnianych w treści zadania. Można podejść do rozwiązania tego problemu w trochę inny sposób. Proszę spójrz na przykład poniżej:   boolean slightlyBetterChangePossible(String sequence1, String sequence2) {     char[] s1 = sequence1.toCharArray();     char[] s2 = sequence2.toCharArray();     Arrays.sort(s1);     Arrays.sort(s2);     return Arrays.equals(s1, s2); }   To rozwiązanie jest lepsze od poprzedniego pod każdym względem. Wykorzystuje ono fakt, że istnieje możliwość otrzymania sequence2 w wyniku przekształceń sequence1 jeśli obie sekwencje składają się dokładnie z tych samych liter.   Złożoność obliczeniowa   Łatwym sposobem na sprawdzenie czy ta zależność jest spełniona jest sprawdzenie posortowanych liter, które wchodziły w skład łańcuchów. W tym przypadku do sortowania użyłem algorytmu z biblioteki standardowej, którego złożoność obliczeniowa wynosi Ο(nlog(n)) – złożoność obliczeniowa tego podejścia wynosi Ο(nlog(n)).   Złożoność pamięciowa   W tym przypadku potrzebna jest tablica zawierająca wszystkie znaki obu łańcuchów. Zatem złożoność pamięciowa tego rozwiązania wynosi Ο(n).   Algorytm – optymalne rozwiązanie i tablice   Poprzednia wersja algorytmu jest zadowalająca. Można ją uruchomić dla dużych instancji problemu i doczekać się rozwiązania ;). Jest jednak jeszcze lepszy sposób. Proszę spójrz na przykład poniżej:   boolean optimalChangePossible(String sequence1, String sequence2) {     return Arrays.equals(countLetters(sequence1), countLetters(sequence2)); }  private int[] countLetters(String sequence) {     int[] counters = new int['T' - 'A' + 1];      for (char c : sequence.toCharArray()) {         counters[c - 'A']++;     }      return counters; }   To rozwiązanie wykorzystuje dokładnie ten sam fakt, na który zwróciłem uwagę poprzednio. Mianowicie istnieje możliwość przekształcenia sequence1 do sequence2 jeśli oba łańcuchy składają się dokładnie z tych samych liter.   Złożoność obliczeniowa   Kolejność tych liter nie ma znaczenia. Istotna jest jedynie ich liczba. Zatem wystarczy zliczyć wystąpienia każdej z możliwych liter. Taka statystyka zwracana jest przez funkcję countLetters. Funkcja ta wykonuje operację dla każdej z n liter, zatem jej złożoność obliczeniowa to Ο(n). Funkcja ta wykonana jest dwa razy, w związku z tym złożoność obliczeniowa tego algorytmu to Ο(n).   Złożoność pamięciowa   Z treści zadania wiadomo, że litery są z zakresu A-T, zatem tablica do pomieszczenia licznika wystąpień dla każdej z liter wymaga dokładnie 'T' - 'A' + 1 elementów — 20. Z racji tego, że jest to stała, niezależna od długości łańcucha wejściowego złożoność pamięciowa tego rozwiązania wynosi Ο(1).   Algorytm – optymalne rozwiązanie i strumienie   Tym razem jest to wariacja poprzedniego pomysłu. W tym przypadku implementację opartą o tablice zastąpiłem strumieniami:   boolean changePossible(String sequence1, String sequence2) {     Map&lt;Character, Long&gt; s1Counters = countLettersWithStreams(sequence1);     Map&lt;Character, Long&gt; s2Counters = countLettersWithStreams(sequence2);     return s1Counters.equals(s2Counters); }  private Map&lt;Character, Long&gt; countLettersWithStreams(String sequence1) {     return sequence1.chars()             .mapToObj(c -&gt; (char) c)             .collect(Collectors.groupingBy(c -&gt; c, Collectors.counting())); }   Złożoność pamięciowa i obliczeniowa nie zmieniły się w stosunku do poprzedniego rozwiązania.   Interfejs użytkownika   Treść zadania zakłada uruchomienie programu w następujący sposób:   program.exe &lt; dane.txt    Przekładając to na realia Javy uruchomienie programu może wyglądać następująco   java -cp 12_dna-1.0-SNAPSHOT.jar pl.samouczekprogramisty.szs.dna.DNASequencer &lt; dane.txt   Jeśli do tej pory nie udało Ci się przeczytać artykułu o użyciu Javy w linii poleceń to chyba właśnie nadszedł na to czas ;).   Standardowe wejście w języku Java reprezentowane jest przez obiekt System.in. Do czytania wejścia linia po linii użyłem klasy BufferedReader:   public static void main(String[] args) throws IOException {     BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));     while (true) {         String line = reader.readLine();         if (line == null) {             break;         }         System.out.println(changePossible(line, reader.readLine()));     } }   Wyślij mi swoje zadanie   Jeśli chcesz żebym spróbował rozwiązać Twoje zadanie proszę wyślij je na mój adres e-mail marcin małpka samouczekprogramisty.pl. Jeśli tylko będę potrafił je rozwiązać to z chęcią napiszę o tym artykuł.     Często firmy zastrzegają sobie to, żeby nie rozpowszechniać zadań, które były na rozmowie kwalifikacyjnej. Jeśli tak było w Twoim przypadku proszę uszanuj wolę danej firmy i nie przesyłaj mi takiego zadania.   Dostając zadanie od Ciebie zakładam, że mogę je opublikować na blogu.     Podsumowanie   Po lekturze tego artykułu i samodzielnej próbie rozwiązania zadania jesteś o krok bliżej do dobrego przygotowania do rozmowy kwalifikacyjnej. Udało Ci się poznać kilka sposobów rozwiązania tego samego problemu, a może Twoje rozwiązanie jest jeszcze inne?   Nawet jeśli udało Ci się rozwiązać zadanie samodzielnie proszę rzuć okiem na moją implementację. Czytając kod innych programistów możesz nauczyć się jeszcze więcej. Nie zapomnij rzucić okiem na testy jednostkowe!   Jeśli ktoś z Twoich znajomych przygotowuje się do rozmowy kwalifikacyjnej na stanowisko programisty możesz podzielić się linkiem do tego artykułu, z góry dziękuję. Jeśli nie chcesz pomiąć kolejnych artykułów możesz dopisać się do samouczkowego newslettera i polubić Samouczka na Facebook’u.   Do następnego razu!  ","categories": ["Samouczek na rozmowie","Strefa zadaniowa"],
        "tags": [],
        "url": "/samouczek-na-rozmowie-lancuchy-bialkowe/",
        "teaser": "/assets/images/2019/02/25_zadanie_z_rozmowy_kwalifikacyjnej_lancuchy_bialkowe_artykul.jpg"
      },{
        "title": "Początki pracy z wierszem poleceń",
        "excerpt":"To jest jeden z artykułów omawiających pracę z wierszem poleceń. Omawiam w nim podstawy niezbędne do wydajnej pracy. Dalsze artykuły z cyklu opisują bardziej zaawansowane zagadnienia związane z pracą w linii poleceń. Wszystkie artykuły w serii zebrałem w sekcji narzędzia i dobre praktyki.   Wiersz poleceń   W uproszczeniu można powiedzieć, że linia poleceń to program, który służy do komunikacji z systemem operacyjnym zainstalowanym na komputerze. Linia poleceń czasami nazywana może być także konsolą czy powłoką. Istnieją różne rodzaje linii poleceń. Za przykład mogą tu służyć tu bash, sh, fish, ksh, command.com czy PowerShell.   Powłoka pozwala na komunikowanie się z systemem operacyjnym za pomocą tekstu. Pozwala na uruchamianie innych programów. Powłoki mogą posiadać swoje języki skryptowe, pozwalające na pisanie własnych programów.   Dlaczego warto używać wiersza poleceń   Interfejs graficzny służy do tego, żeby ułatwić pracę z danym programem/systemem operacyjnym. Takie podejście jest szczególnie użyteczne dla początkujących użytkowników. Interfejs graficzny w przyjazny dla oka sposób udostępnia najczęściej używane funkcje. Problem zaczyna pojawiać się kiedy chcesz zrobić coś co nie jest standardowe. W takich przypadkach musisz szukać opcji, które są ukryte gdzieś głęboko w czeluściach zagnieżdżonych menu.   Co więcej taką pracę ciężko jest zautomatyzować. Jeśli wykonujesz pewną czynność, która jest powtarzalna to z interfejsem graficznym za każdym razem musisz klikać, nie ma wyjścia1. Pomocne są tu skróty klawiaturowe, jednak nie wszystkie opcje mają swój skrót. Z wierszem poleceń sprawa wygląda trochę inaczej.   Wiersz poleceń to narzędzie przydatne w codziennej pracy programisty. Nie znam żadnego programisty, który w swojej pracy nigdy nie używał wiersza poleceń. Co więcej to narzędzie jest przydatne w trakcie pracy z każdym językiem programowania. Niezależnie od tego w jakim języku chcesz programować umiejętność posługiwania się wierszem poleceń może się przydać.   Co więcej filozofia, która stoi za programami dostępnymi w wierszu poleceń pozwala na ich zgrabne łączenie. W efekcie możesz uzyskać naprawdę potężne narzędzie, które składa się z wielu drobnych klocków.   Jaki wiersz poleceń wybrać   Mam nadzieje, że udało mi się przekonać Cię do tego, że warto używać wiersza poleceń. Teraz pozostaje pytanie, jaki wiersz poleceń wybrać? Nie chcę tu prowadzić świętej wojny i przekonywać Cię o wyższości jednego rozwiązana nad innym. Zachęcam Cię do sprawdzenia kilku rozwiązań i wybrania tego, które w Twoim przypadku sprawdzi się najlepiej. Sam używam bash‘a i to właśnie jego będę używał w dalszej części artykułu.   Jak bezboleśnie zacząć przygodę z bash‘em?   Jeśli używasz systemu Linux/Unix to istnieje duże prawdopodobieństwo, że masz dostęp do bash‘a i możesz pominąć ten podpunkt. Problem pojawia się jeśli używasz Windows’a. Tam niestety bash nie jest dostępny.   Jeśli chcesz sprawdzić czy praca z wierszem poleceń to coś dla Ciebie, to masz do wyboru kilka opcji:      użyć emulatora wiersza poleceń w przeglądarce, na przykład LinuxContainers,   zainstalować emulator wiersza poleceń, na przykład Cygwin,   użyć pełnego systemu operacyjnego uruchamianego z USB/CD – w ten sposób dostaniesz cały system operacyjny, nie tylko wiersz poleceń,   zainstalować narzędzie do wirtualizacji (na przykład VirtualBox) w systemie Windows i utworzyć maszynę wirtualną z systemem Linux. Także tutaj dostajesz do dyspozycji Linux’a, którego możesz przetestować bez dużego nakładu pracy,   użyć narzędzia wspierającego kontenery (na przykład Docker) i uruchomić najprostszy kontener z systemem Linux,   zainstalować drugi system równolegle do Windowsa,   wyrzucić Windows’a do śmieci i pracować na Linux’ie ;).       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Jak wygląda wiersz poleceń   Zacznę od obrazka:             Okno wiersza poleceń        To puste okno wiersza poleceń. Ten migający znaczek to znak zachęty. Tutaj wpisuje się komendy. To co jest przed znakiem zachęty to:      nazwa użytkownika, w moim przypadku jest to marcinek,   @ oddzielająca nazwę użytkownika i kolejny element,   nazwa komputera, w moim przypadku jest to mapiszon-dell,   : oddzielający nazwę komputera i kolejny element,   aktualna ścieżka, w moim przypadku jest to ~ (tylda). Ten znak reprezentuje katalog domowy użytkownika,   $ oddzielający ścieżkę od miejsca do wprowadzania komend.   W dalszych przykładach będę używał skróconego zapisu – $ something. Zapis ten oznacza uruchomienie programu something. Sprowadza się to do uruchomienia procesu, który wykonuje kod programu something.   Podstawy pracy z systemem plików   Nadszedł czas na pokazanie Ci kilku podstawowych programów, które są niezbędne do pracy z linią poleceń.   Tutaj mam do Ciebie prośbę. Eksperymentuj! Otwórz wiersz poleceń i na bieżąco czytając artykuł sprawdzaj jak działają poszczególne programy. Właśnie dzięki takiej praktyce nauczysz się najwięcej.   Ścieżka   Ścieżka jednoznacznie określa plik/katalog w systemie plików. Ścieżki mogą być względne albo bezwzględne. Ścieżka bezwzględna zaczyna się od ukośnika /. Jest to ścieżka od „korzenia” systemu plików. Na przykład /home/mapi/some/file.txt.   Ścieżka względna to ścieżka która wskazuje na plik/katalog względem katalogu, którym się aktualnie znajdujesz. Zakładając, że jesteś w katalogu /tmp to ścieżka some/catalog wskazuje to samo co /tmp/some/catalog.   Ścieżka . (pojedyncza kropka) odnosi się zawsze do aktualnego katalogu. Na przykład ścieżki ./some/file.txt i some/file.txt wskazują to samo miejsce.   Katalog nadrzędny określany jest przez .. (dwie kropki). Zakładając, że jesteś w katalogu /tmp, to ścieżka ../some/other/file.txt wskazuje na /some/other/file.txt.   cd   Nawigowanie po systemie plików w wierszu poleceń to podstawa od której należy zacząć. Służy do tego program cd. Na przykład wywołanie komendy:   $ cd some-directory   Spowoduje przejście do katalogu some-directory. Argumentem przekazanym do programu jest ścieżka reprezentująca katalog. W przykładzie powyżej jest to ścieżka względna. Oznacza to tyle, że zmiana następuje względem katalogu, w którym aktualnie się znajdujesz. Innymi przykładem ścieżki względnej może być dir1/dir2/yet-another-directory. Reprezentuje ona trzy zagnieżdżone katalogi.   Wcześniej wprowadziłem już ~ – symbol ten oznacza katalog domowy. W systemach z rodziny Linux/Unix jest to przeważnie /home/&lt;nazwa użytkownika&gt;, na przykład /home/marcinek. /home/marcinek to przykład ścieżki bezwzględnej. Ścieżka bezwzględna od ścieżki względniej różni się tym, że zaczyna się od /.   A co jeśli chcę przejść do katalogu nadrzędnego? W tym przypadku trzeba użyć .. jako nazwy katalogu2:   $ cd ..   Innym specjalnym symbolem jest . – pojedyncza kropka oznacza aktualny katalog. Zatem dwie poniższe komendy są równoznaczne:   $ cd some-directory   $ cd ./some-directory   Jeśli chcesz zmienić aktualny katalog na swój katalog domowy możesz użyć wcześniej wspomnianego znaku ~. Wywołanie programu cd z pominięciem argumentu także zmienia katalog na domowy. Oba polecenia zaprowadzą Cię do tego samego katalogu:   $ cd ~   $ cd   pwd   Jeżeli chcesz poznać swój aktualny katalog możesz użyć programu pwd. Wypisuje on na konsolę ścieżkę bezwzględną katalogu, w którym aktualnie się znajdujesz:   marcinek@mapiszon-dell:~/private$ pwd /home/marcinek/private   ls   Sprawdzanie zawartości katalogu jest bardzo przydatne. W tym przypadku przyda się program ls:   marcinek@mapiszon-dell:~$ ls Desktop  Documents  Downloads  Dropbox  Music  Pictures  private  Public  snap  Templates  Videos   Program ten wypisuje na konsolę zawartość ścieżki przekazanej jako argument. Domyślną ścieżką jest ., czyli aktualny katalog. W systemie Linux/Unix także istnieją pliki/katalogi ukryte. Domyślnie program ls ich nie pokazuje. Aby je zobaczyć należy użyć przełącznika. Jedną z możliwych opcji jest użycie --all:   marcinek@mapiszon-dell:~$ ls --all .              .bash_profile  .dotfiles  .globalignore  .gradle  .java     Pictures  .rvm       Videos ..             .bashrc        Downloads  .gconf         .gnome2  .local    private   snap       .vimos .bash_aliases  .cache         Desktop    .gem           .gnupg   .mozilla  .profile  .ssh       .viminfo .bash_history  .config        Documents  .gitconfig     .mkshrc  Music     Public    Templates  .vimrc   Przełączniki często występują także w skróconych formach. Na przykład skróconym odpowiednikiem --all jest -a. Program ls ma wiele przełączników, te które używam najczęściej to:      -l – zwróć wynik działania w formie listy,   -a – pokaż także ukryte pliki i katalogi,   -A – pokaż także ukryte pliki i katalogi pomijając katalogi specjalne (. i ..),   -t – posortuj wynik po czasie modyfikacji malejąco,   -r – odwróć sortowanie.   Zaletą skróconych form jest to, że można je ze sobą łączyć. Na przykład poniższe wywołanie pokazuje zawartość katalogu w formie listy (pokazałem tylko część):   marcinek@mapiszon-dell:~$ ls -la total 232 drwxr-xr-x 31 marcinek marcinek  4096 mar 14 23:03 . drwxr-xr-x  4 root     root      4096 mar  9 20:37 .. lrwxrwxrwx  1 marcinek marcinek    37 mar 11 23:38 .bash_aliases -&gt; /home/marcinek/.dotfiles/bash_aliases -rw-------  1 marcinek marcinek 23820 mar 14 15:00 .bash_history -rw-r--r--  1 marcinek marcinek    81 mar 13 21:05 .bash_profile -rw-r--r--  1 marcinek marcinek  4059 mar 13 21:04 .bashrc ...   Ostatnia kolumna to nazwa pliku/katalogu. Wcześniejsze kolumny zawierają metadane dotyczące danego elementu takie jak czas modyfikacji czy prawa dostępu. Pominę tutaj dokładne tłumaczenie tych elementów.   mkdir   Program mkdir służy do tworzenia nowych katalogów. Wywołanie poniżej utworzy katalog o nazwie sample-directory:   $ mkdir sample-directory   Program mkdir pozwala także na tworzenie katalogów zagnieżdżonych:   $ mkdir non/existent/list/of/directories mkdir: cannot create directory ‘non/existent/list/of/directories’: No such file or directory   Pod warunkiem, że cała ścieżka, poza ostatnim katalogiem aktualnie istnieje. Innymi słowy powyższe wywołanie należałoby zastąpić:   $ mkdir non $ mkdir non/existent $ mkdir non/existent/list $ mkdir non/existent/list/of $ mkdir non/existent/list/of/directories   Przyznasz, że nie jest to zbyt efektywne. W takim przypadku pomaga przełącznik -p lub --parents. Powyższą serię można zastąpić poleceniem:   $ mkdir -p non/existent/list/of/directories   rmdir   Usuwanie elementów używając rmdir/rm nie wrzuca ich do Kosza, dany element od razu jest usuwany z dysku. Sprawdź dwa razy zanim usuniesz coś czego możesz potrzebować.   Wiesz już jak utworzyć katalog. Nadszedł czas na jego usunięcie. Służy do tego program rmdir:   $ rmdir sample-directory   Podobnie jak w przypadku mkdir także i tutaj jest możliwość usuwania zagnieżdżonych katalogów. Poniższe dwa zestawy wywołań programu rmdir mają ten sam efekt:   $ rmdir non/existent/list/of/directories $ rmdir non/existent/list/of $ rmdir non/existent/list $ rmdir non/existent $ rmdir non   $ rmdir -p non/existent/list/of/directories   Program rmdir usuwa wyłącznie puste katalogi. Jeśli chcesz usunąć coś więcej użyj programu rm   rm   Program rm służy do usuwania elementów z dysku. Standardowe wywołanie usuwa pojedynczy plik. Przykład poniżej pokazuje usunięcie pliku o nazwie some-file.txt:   $ rm some-file.txt   Jeśli chcesz usunąć zagnieżdżone elementy użyj flagi -r. Tylko bardzo proszę, ostrożnie!   Tym programem można sobie zrobić kuku :). Sam nie raz usunąłem trochę zbyt dużo. Raz nawet udało mi się usunąć katalog domowy użytkownika. Wywołałem polecenie:   $ rm -rf ~   Wszystko dlatego, że dla testów utworzyłem plik o nazwie ~ ;). Uwierz mi, nie chcesz powtórzyć tego błędu. W wywołaniu wyżej przełącznik -f oznacza “wymuś usunięcie”. Od tego czasu, jeśli usuwam cokolwiek rekursywnie, dodaję przełączniki -rf na końcu polecenia długo zastanawiając się przed naciśnięciem Enter ;).   touch   Każdy element na dysku ma datę ostatniego dostępu i modyfikacji (widać ją w jednej z kolumn wyświetlanych przez ls -l). Program touch ustawia te daty na aktualną. Ta funkcjonalność nie jest aż tak istotna w większości przypadków. Ten program ma jeden istotny efekt uboczny. Jeśli plik przekazany jako argument nie istnieje zostanie on domyślnie utworzony:   $ touch non-existent-file.txt   Standardowe wejście i wyjście   Zanim powiem Ci coś więcej o pracy z tekstem w wierszu poleceń musisz poznać kilka pojęć.   Wiesz czym jest aplikacja. Aplikacją może być przeglądarka internetowa. Każda aplikacja to co najmniej jeden proces. Proces można zdefiniować jako kod (program) wykonywany przez komputer. Schodząc jeszcze niżej możemy dojść do wątków, które opisałem niedawno.   Każdy proces ma przypisane zasoby, na przykład RAM (ang. Random Access Memory) czy zestaw deskryptorów plików. Deskryptor pliku to liczba, która jednoznacznie określa plik otworzony w danym procesie, pozwala na dostęp do pliku3. Deskryptory plików to nieujemne liczby całkowite, na przykład 0, 1 czy 123.   Każdy program4 zazwyczaj ma dostęp do co najmniej trzech deskryptorów plików:      standardowego wejścia (ang. stdin),   standardowego wyjścia (ang. stdout),   standardowego wyjścia błędów (ang. stderr).   Ten standardowy zestaw połączony jest z deskryptorami o dobrze znanych numerach:      stdin – 0,   stdout – 1,   stderr – 2.   Programy, które wypisują tekst na konsoli korzystają właśnie z tych standardowych strumieni – stdout i stderr. Na przykład ls wykorzystuje stdout do wypisania zawartości przekazanego argumentu. stderr może być użyty przez mkdir w przypadku, gdy chcesz utworzyć zagnieżdżony katalog bez przełącznika -p – do pokazania błędu.   Innymi słowy jeśli piszę, że „program wypisuje” albo „program wyświetla” tak na prawę mam na myśli to, że program pisze do pliku. W takim przypadku plikiem, do którego pisze dany program jest standardowe wyjście.   echo   Prostym programem, który wykorzystuje standardowe wyjście jest echo. Zasada jego działania jest prosta – wyświetla na konsoli (używając stdout) przekazany tekst:   $ echo Some text to show on a console Some text to show on a console   Jeśli chcesz wyświetlić tekst, który ma więcej niż jedną linię możesz użyć ' albo \"5:   $ echo \"Multiline text to  &gt; show on a console\" Multiline text to  show on a console   Teraz jak znasz już standardowe strumienie (wejście – stdin, wyjście – stdout i wyjście błędów – stderr), mogę powiedzieć Ci coś więcej o przekierowaniach.   Przekierowania   Przekierowania dotyczą standardowych strumieni. W praktyce mogą być wykorzystywane do tego, żeby tworzyć pliki zawierające logi programu. Używane są także po to, żeby dostarczyć dane czytane przez program na standardowym wejściu.   Nadpisywanie   Najprostszym przykładem przekierowania jest:   $ echo some text 1&gt; plik_wyjscia   Taki zapis informuje wiersz poleceń o tym, żeby stdout procesu w którym uruchomiony jest program echo przekierować do pliku plik_wyjscia. 1 w tym zapisie reprezentuje numer deskryptora pliku. W tym przykładzie 1 można pomiąć, poniższy zapis znaczy dokładnie to samo:   $ echo some text &gt; plik_wyjscia   W podobny sposób wygląda przekierowanie stderr:   $ program 2&gt; plik_wyjscia   Możesz też przekierować jeden strumień do drugiego. Na przykład przekierowanie stdout do stderr wygląda tak:   $ program 1&gt;&amp;2   W wyniku takiego wywołania wszystkie komunikaty wypisane przez program do stdout zostaną przekierowane do stderr. Zwróć uwagę na &amp; w komendzie. Bez tego znaku 2 zostałoby potraktowane jako plik o takiej nazwie.   Możesz także przekierować stdout i stderr równocześnie:   $ program &gt; plik_wyjscia 2&gt; plik_bledow   Jeśli w poleceniu występuje więcej przekierowań brane są pod uwagę od lewej do prawej strony. Ma to znaczenie na przykład tutaj:   $ program &gt; plik_wyjscia 2&gt;&amp;1   Polecenie to przekierowuje stdout do plik_wyjacia a stderr “tam gdzie stdout”.   Jeśli plik do którego przekierowywane są wiadomości nie istnieje zostaje utworzony. Dzięki temu zachowaniu możesz w prosty sposób tworzyć pliki. Na przykład poniższa komenda utworzy plik sample_file.txt (jeśli wcześniej plik nie istniał) uzupełniając go testem sample file content:   $ echo sample file content &gt; sample_file.txt   Dołączanie   Przykłady, które pokazałem poprzednio nadpisują zwartość pliku, do którego nastąpiło przekierowanie. Istnieje także możliwość na dołączenie nowych wierszy do pliku:   $ program &gt;&gt; plik_wyjscia   Wszystkie mechanizmy, które opisałem powyżej działają także w przypadku dołączania, na przykład:   $ program 1&gt;&gt; plik_wyjscia 2&gt;&gt; plik_bledow $ program &gt;&gt; plik_wyjacia 2&gt;&amp;1   Potoki   W końcu mogę Ci powiedzieć o potokach! To właśnie one sprawiają, że małe klocki można łączyć w większą całość. Spójrz na przykład:   $ program1 | program2   Pionowa kreska | oznacza potok. No dobrze, ale co to takiego jest? Możesz to sobie wyobrazić jak rurę, która łączy standardowe wyjście jednego procesu ze standardowym wejściem innego procesu. W przykładzie powyżej stdout program1 połączony zostaje z stdin program2.   Niby to nic nadzwyczajnego, jednak pozwala na tworzenie zaawansowanych narzędzi z prostych klocków nie odrywając się od wiersza poleceń. Moim zdaniem to właśnie ta funkcjonalność sprawia, że graficzny interfejs użytkownika nie dorasta do pięt wierszowi poleceń pod kątem możliwości.   Przykład, który pokazałem jest abstrakcyjny. Praktyczne zastosowania pokażę Ci w dalszej części artykułu.   Początki pracy z tekstem   cat   cat jest programem, który służy do wyświetlania danych używając stdout. To co powinno być wyświetlone przekazywane jest to programu jako parametr oznaczający nazwę pliku. Program ten może przyjąć wiele parametrów:   $ echo file1 content &gt; file1 $ echo file2 content &gt; file2 $ cat file2 file1 file2 content file1 content   Program cat domyślnie wypisuje na stdout wszystko co odczyta z stdin. Pokazuje to poniższy przykład:   $ echo some text | cat some text   Fragment powyżej zawiera przykładowe użycie przekierowań. echo wypisuje some text na stdout. | łączy stdout z programu echo z stdin programu cat, i to właśnie cat wypisuje na konsolę (swój stdout) to co przeczytał z programu echo.   W specjalny sposób traktowany jest parametr -, oznacza on stdin. Spójrz na przykład poniżej gdzie używam wcześniej utworzonych plików:   $ echo some text | cat file2 - file1 file2 content some text file1 content   clear   Czasami wygodniej jest zacząć od początku. Pomaga przy tym program clear. Program ten robi co może żeby wyczyścić okno terminala :). Spróbuj go wywołać po serii innych komend.   Dodatkowe materiały   Najlepszym materiałem, który mogę Ci polecić jest dokumentacja poszczególnych programów.   Całość sprowadza się do programu man lub parametru --help. Na przykład jeśli chcesz dowiedzieć się czegoś więcej o programie cd wywołaj komendę cd --help lub man cd. W ten sposób dostaniesz się do dokumentacji danego programu. To naprawdę najlepsze miejsce do szukania szczegółowych informacji o danym programie.   Ćwiczenia do wykonania      Utwórz poniższą strukturę katalogów używając wiersza poleceń:   samouczek/ ├── algorytmy ├── bazy-danych │   └── sql ├── programowanie │   ├── java │   └── python └── struktury-danych      Przekieruj wyjście programu ls do pliku,   Użyj dowolnego programu i przekieruj stderr i stdout do dwóch różnych plików. Dasz radę zrobić to tak, żeby oba pliki nie były puste?,   Jaki przełącznik programu ls pozwala na posortowanie wyników używając rozszerzenia plików (użyj man)?   Napisz program, który pobierze ze standardowego wejścia dwie linijki tekstu. Pierwszą z nich powinien wypisać do standardowego wyjścia, drugą do standardowego wyjścia błędów. Następnie uruchom ten program z linii poleceń na kilka sposobów:            przekieruj na standardowe wejście zawartość pliku z dwoma linijkami,       przekieruj wyjście błędów do pliku error.log i standardowe wyjście do pliku usage.log,       przekieruj zarówno standardowe wyjście jak i wyjście błędów do usage.log.           Jeśli chcesz użyć Javy do rozwiązania tego zadania zachęcam Cię do przeczytania artykułu Java z linii poleceń.   Podsumowanie   Po lekturze tego artykułu znasz podstawowe programy używane w trakcie pracy z linią poleceń. Dzięki artykułowi udało Ci się dowiedzieć czym jest stdout, stderr i stdin. Znasz pojęcia przekierowań i potoków, potrafisz z nimi pracować. Rozwiązane ćwiczenia pozwoliły Ci w praktyczny sposób sprawdzić zdobytą wiedzę. Innymi słowy udało Ci się zdobyć kawał solidnej i przydatnej wiedzy, gratuluję :).   Teraz nie pozostaje mi nic innego jak zachęcić Cię do częstszej pracy z linią poleceń. Takie podejście naprawdę nie gryzie. Wierzę, że w dłuższej perspektywie pozwoli Ci osiągnąć lepszą wydajność. W kolejnym artykule z tej serii poznasz więcej programów, które pozwolą budować Ci bardziej skomplikowane komendy.   Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku proszę dopisz się do samouczkowego newslettera i polub stronę Samouczka na Facebook’u. Jeśli wiesz, że ktoś z Twoich znajomych potrzebuje wiedzy zawartej w tym artykule będę wdzięczny za przekazanie mu odnośnika do tego artykułu – z góry dziękuję.   To tyle na dzisiaj, trzymaj się i do następnego razu!                 Pomijam tutaj rozwiązania, które pozwalają na nagrywanie ekranu i automatyczne wykonywanie tych czynności ponownie. Takie narzędzia często także wymagają użycia specyficznego języka programowania. Tak otrzymane nagrania są ciężkie w utrzymaniu, każda zmiana interfejsu może powodować błędy w ich działaniu. &#8617;                  Możesz także użyć ścieżki bezwzględnej. &#8617;                  Poznając lepiej systemy operacyjne z rodziny Linux/Unix usłyszysz to jeszcze nie raz – wszystko jest plikiem ;). Dysk, plik, katalog, strumień, klawiatura itp. &#8617;                  Demony (ang. deamon) mogą trochę odstawać od tej reguły. &#8617;                  bash inaczej interpretuje tekst pomiędzy ' i \", jednak na tym etapie te różnice nie są istotne. &#8617;           ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "/poczatki-pracy-z-wierszem-polecen/",
        "teaser": "/assets/images/2019/03/12_poczatki_pracy_z_wierszem_polecen_artykul.jpeg"
      },{
        "title": "Pierwszy projekt z Gradle",
        "excerpt":"To jest kolejny artykuł opisujący narzędzie Gradle. Jeśli nie udało Ci się wcześniej z nim pracować, to zachęcam Cię do przeczytania wstępu do Gradle. W tym artykule zakładam, że znasz podstawy, które omówiłem poprzednio.   Odrobina teorii   Gradle bazuje na plikach konfiguracyjnych. Każdy z tych plików konfiguracyjnych powiązany jest z obiektem, który jest tworzony w trakcie inicjalizacji procesu budowania. Na przykład plik build.gradle powiązany jest z instancją klasy Project a plik settings.gradle z instancją klasy Settings.   Konfiguracja używająca DSL zawarta w tych plikach odpowiednio konfiguruje instancje tych obiektów.   Cykl budowania projektu   Gradle jasno określa sposób w jaki budowany jest projekt. Cały proces podzielony jest na trzy fazy:      inicjalizację,   konfigurację,   wykonanie.   W trakcie fazy inicjalizacji Gradle określa jakie projekty wchodzą w skład cyklu budowania. Gradle wspiera proste projekty (składające się wyłącznie z jednego projektu) jak i te złożone (składające się z wielu podprojektów). Jak wspomniałem wcześniej, dla każdego z nich tworzy obiekt, który przechowuje konfigurację danego projektu. W tej fazie wykonywany jest plik settings.gradle.   Faza konfiguracji polega na wykonaniu każdego z plików konfiguracyjnych projektów wchodzących w skład procesu budowania. W wyniku tego wykonania obiekty utworzone w fazie inicjalizacji są odpowiednio konfigurowane (na podstawie wykonywanych plików build.gradle).   Ostatnią fazą jest faza wykonania. To właśnie tutaj Gradle określa zestaw wymaganych zadań do wykonania wraz z ich kolejnością. Zadania pochodzą z obiektów skonfigurowanych w poprzednim kroku.   Wbudowana pomoc   Gradle posiada wbudowaną dokumentację. Możesz się do niej dobrać używając linii poleceń. Pierwszym przydatnym poleceniem może być:   $ gradle tasks   To polecenie wypisze wszystkie możliwe do wykonania zadania, które zawarte są w konfiguracji lub dostarczone są przez wtyczki.   Jeśli chcesz dowiedzieć się czegoś więcej o którymkolwiek z zadań z pomocą przychodzi gradle help. Na przykład do dokumentacji zadania init możesz dobrać się wywołując polecenie:   $ gradle help --task init   Schowek (ang. cache)   Z poprzedniego artykułu wiesz, że Gradle pomaga przy zarządzaniu zależnościami. Odpowiednia konfiguracja pozwala na określenie jakie zależności są niezbędne do działania Twojej biblioteki czy aplikacji. Dodatkowym atutem zarządzania zależnościami przez Gradle jest to, że trzymane one są w schowku na Twoim dysku. Domyślnie znajdziesz je w katalogu ~/.gradle/caches1.   Wewnątrz tego katalogu znajdziesz zależności, które były pobrane przez Gradle. Dzięki takiemu podejściu zależności są współdzielone pomiędzy różnymi aplikacjami. Co więcej nie musisz ich za każdym razem ściągać – zanim Gradle zacznie ich szukać w repozytorium zajrzy do schowka na lokalnym dysku.   Nowy projekt z Gradle   Praktyczną przygodę z Gradle zacznę od utworzenia przykładowej konfiguracji. Do przygotowania projektu może posłużyć polecenie gradle init. Po takim wywołaniu Gradle utworzy odpowiednią strukturę przygotowując podstawową konfigurację. Zanim do tego dojdzie zapyta Cię o kilka ustawień:   $ gradle init  Select type of project to generate:   1: basic   2: cpp-application   3: cpp-library   4: groovy-application   5: groovy-library   6: java-application   7: java-library   8: kotlin-application   9: kotlin-library   10: scala-library Enter selection (default: basic) [1..10] 7  Select build script DSL:   1: groovy   2: kotlin Enter selection (default: groovy) [1..2] 1  Select test framework:   1: junit   2: testng   3: spock Enter selection (default: junit) [1..3] 1  Project name (default: samouczek): Source package (default: samouczek): pl.samouczekprogramisty  BUILD SUCCESSFUL in 24s 2 actionable tasks: 2 executed   Pierwsze pytanie dotyczy typu generowanego projektu. W tym przypadku projekt będzie używał języka Java, więc biorę pod uwagę odpowiedzi 6 albo 7. Główna różnica pomiędzy biblioteką a aplikacją sprowadza się do tego, że aplikację można uruchomić samodzielnie, biblioteka włączana jest do innych bibliotek lub aplikacji. Konfiguracja biblioteki i aplikacji różni się jedynie wtyczkami. W przykładach, które pokazuję w dalszej części te różnice nie są istotne.   Kolejne pytanie dotyczy DSL’a (ang. Domain Specific Language), który powinien być używany w konfiguracji. Od wersji 5.0 Gradle jako DSL można także wybrać język Kotlin.   Następne pytanie dotyczy biblioteki użytej do testów. Ma to wpływ na wygenerowany przykładowy kod i konfigurację.   Ostatnie dwa pytania dotyczą nazwy projektu i nazwy pakietu (domyślnie jest to nazwa katalogu w którym wykonano polecenie gradle init).   Po udzieleniu odpowiedzi na taki zestaw pytań Gradle przygotuje szkielet projektu wraz z przykładową konfiguracją:   $ tree . . ├── build.gradle ├── gradle │   └── wrapper │       ├── gradle-wrapper.jar │       └── gradle-wrapper.properties ├── gradlew ├── gradlew.bat ├── settings.gradle └── src     ├── main     │   ├── java     │   │   └── pl     │   │       └── samouczekprogramisty     │   │           └── Library.java     │   └── resources     └── test         ├── java         │   └── pl         │       └── samouczekprogramisty         │           └── LibraryTest.java         └── resources  13 directories, 8 files   Teraz omówię poszczególne elementy wygenerowane przez gradle init.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        settings.gradle   Plik settings.gradle zawiera konfigurację projektu. Po pominięciu komentarza znajduje się w nim tylko nazwa projektu określona w trakcie działania gradle init:   rootProject.name = 'samouczek'   Plik ten może jednak zawierać dużo więcej elementów. Wszystkie z nich znajdziesz w oficjalnej dokumentacji. Trochę więcej o tym pliku przeczytasz w dalszej części artykułu, kiedy będę opisywał budowanie zagnieżdżonych projektów.   build.gradle   Sercem projektu jest plik build.gradle2. Wygenerowany plik, z pominięciem komentarzy, wygląda następująco:   plugins {     id 'java-library' }  repositories {     jcenter() }  dependencies {     api 'org.apache.commons:commons-math3:3.6.1'     implementation 'com.google.guava:guava:27.0.1-jre'     testImplementation 'junit:junit:4.12' }   Plik ten zawiera trzy bloki wewnątrz których znajduje się konfiguracja.   Pierwszy blok plugins zawiera wtyczkę java-library. W bloku repositories dodawane jest repozytorium jcenter. Ostatni blok dependencies zawiera zestaw przykładowych zależności.   W dużej części projektów to właśnie te trzy bloki będą stanowiły większość konfiguracji. W bardziej zaawansowanych przypadkach odsyłam Cię do dokumentacji.   wrapper   Standardowa struktura projektu pozwala na łatwe zorientowanie się w nowym projekcie informatycznym. Zarządzanie zależnościami pozwala na przygotowanie wszędzie takiej samej paczki programu3. Wszystko to dzięki plikowi wykonywalnemu gradle. Ten plik jest tak naprawdę skryptem, który opakowuje uruchomienie maszyny wirtualnej Javy. Zachęcam Cię do zajrzenia do środka tego pliku. W przypadku systemów z rodziny Linux możesz spodziewać się skryptu bash.   Ten skrypt różni się pomiędzy różnymi wersjami Gradle. Co więcej Gradle także ewoluuje, DSL używany w różnych wersjach może nie być ze sobą kompatybilny. Może to prowadzić do sytuacji, w której wersja Gradle zainstalowana na Twoim komputerze nie będzie w stanie zbudować projektu, który przygotowany był przy pomocy innej wersji Gradle.   Jest jednak proste rozwiązanie tego problemu. Tym rozwiązaniem jest Gradle wrapper. Jest on domyślnie tworzony po wywołaniu gradle init. Można to także utworzyć samodzielnie w już istniejącym projekcie:   $ gradle wrapper --console=verbose &gt; Task :wrapper  BUILD SUCCESSFUL in 0s 1 actionable task: 1 executed   Efektem działania tego zadania jest utworzenie dwóch katalogów i kilku plików4:   $ tree . . ├── gradle │   └── wrapper │       ├── gradle-wrapper.jar │       └── gradle-wrapper.properties ├── gradlew └── gradlew.bat  2 directories, 4 files   Warto zwrócić uwagę na zwartość pliku gradle/wrapper/gradle-wrapper.properties:   $ cat gradle/wrapper/gradle-wrapper.properties distributionBase=GRADLE_USER_HOME distributionPath=wrapper/dists distributionUrl=https\\://services.gradle.org/distributions/gradle-5.3-bin.zip zipStoreBase=GRADLE_USER_HOME zipStorePath=wrapper/dists   Jedno z ustawień – distributionUrl pokazuje wersję, która powinna być uruchomiona. Co jeśli ktoś inny na swoim komputerze nie będzie miał wersji, na którą wskazuje plik konfiguracyjny? gradlew ściągnie odpowiednią wersję i zapisze ją w katalogu domowym użytkownika:   $ ls -lA ~/.gradle/ total 12 drwxr-xr-x 5 marcinek marcinek 4096 mar 22 18:34 5.2.1 drwxr-xr-x 5 marcinek marcinek 4096 mar 22 18:49 5.3 drwxr-xr-x 2 marcinek marcinek 4096 mar 22 18:49 buildOutputCleanup   Od tego momentu zamiast gradle używaj gradlew, który będzie dostępny w Twoim repozytorium.   Proszę zobacz czym różnią się między sobą gradlew i gradle. Dla czytelności zostawiłem najbardziej istotne fragmenty generowane przez program diff:   $ diff -u ./gradlew /usr/local/bin/gradle --- ./gradlew\t2019-03-22 18:34:35.244396273 +0100 +++ /usr/local/bin/gradle\t2019-02-08 20:01:44.000000000 +0100  -CLASSPATH=$APP_HOME/gradle/wrapper/gradle-wrapper.jar +CLASSPATH=$APP_HOME/lib/gradle-launcher-5.2.1.jar  -eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS \"\\\"-Dorg.gradle.appname=$APP_BASE_NAME\\\"\" -classpath \"\\\"$CLASSPATH\\\"\" org.gradle.wrapper.GradleWrapperMain \"$APP_ARGS\" +eval set -- $DEFAULT_JVM_OPTS $JAVA_OPTS $GRADLE_OPTS \"\\\"-Dorg.gradle.appname=$APP_BASE_NAME\\\"\" -classpath \"\\\"$CLASSPATH\\\"\" org.gradle.launcher.GradleMain \"$APP_ARGS\"   Linijki zaczynające się od - są w gradlew, te z + na początku są w standardowym skrypcie gradle. Jak widzisz różnic jest niewiele. Polegają one wyłącznie na tym, że uruchomienie gradlew korzysta z gradlew-wrapper.jar i używa innej klasy z metodą main org.gradle.wrapper.GradleWrapperMain.   Używanie gradlew pozwala na uniezależnienie się od wersji gradle zainstalowanej na komputerze programisty.   Budowanie projektów   Używając gradlew tasks i gradlew help dowiesz się sporo o możliwych zadaniach do wykonania. Chciałbym zwrócić Twoją uwagę na dwa z nich: build i test.   Poniżej widzisz wywołanie zadania build z przełącznikiem --console=verbose, który sprawia, że na konsoli pokazuje się trochę więcej informacji:   $ ./gradlew build --console=verbose &gt; Task :compileJava UP-TO-DATE &gt; Task :processResources NO-SOURCE &gt; Task :classes UP-TO-DATE &gt; Task :jar UP-TO-DATE &gt; Task :assemble UP-TO-DATE &gt; Task :compileTestJava UP-TO-DATE &gt; Task :processTestResources NO-SOURCE &gt; Task :testClasses UP-TO-DATE &gt; Task :test UP-TO-DATE &gt; Task :check UP-TO-DATE &gt; Task :build UP-TO-DATE  BUILD SUCCESSFUL in 0s 4 actionable tasks: 4 up-to-date   Wiesz już, że Gradle uruchamia wszystkie zależne zadania. Ten przykład doskonale to pokazuje. Poprosiłem o wywołanie build a w efekcie została wykonana cała seria zadań, zaczynając od compileJava a na build kończąc. Niektóre z tych zadań generują tak zwane artefakty – efekty procesu budowania.   Na przykład artefaktem zadania compileJava są pliki .class ze skompilowanymi klasami. Artefakty procesu budowania umieszczane są w katalogu build. Poniżej możesz zobaczyć część struktury tego katalogu:   $ tree build build ├── classes │   └── java │       ├── main │       │   └── pl │       │       └── samouczekprogramisty │       │           └── Library.class │       └── test │           └── pl │               └── samouczekprogramisty │                   └── LibraryTest.class ... ├── libs │   └── samouczek.jar ├── reports │   └── tests │       └── test │           ├── classes │           │   └── pl.samouczekprogramisty.LibraryTest.html │           ├── css │           │   ├── base-style.css │           │   └── style.css │           ├── index.html │           ├── js │           │   └── report.js │           └── packages │               └── pl.samouczekprogramisty.html ...  29 directories, 14 files   Drzewko powyżej pokazuje między innymi katalogi build/classes, build/libs i build/reports. Pierwszy z nich zawiera skompilowane klasy. Drugi plik jar (utworzony przez zadanie jar). Zwróć też uwagę na ostatni katalog. Ten katalog powstaje po wykonaniu zadania test. Zawiera on raporty z testów automatycznych uruchomionych w trakcie budowania projektu:             Przykładowy raport testów wygenerowany przez Gradle’a        Wielką zaletą narzędzi typu Gradle jest to, że potrafią automatycznie uruchamiać takie testy w trakcie budowania.   Budowanie złożonych projektów   Gradle świetnie sprawdza się do budowania projektów, które zawierają podprojekty. Jako przykład może tu posłużyć Kurs Java czy Kurs Aplikacji Webowych.   W każdym z tych repozytoriów znajdziesz plik settings.gradle. W przypadku pojedynczego projektu ten plik jest opcjonalny. W przypadku projektów zawierający podprojekty plik settings.gradle jest wymagany. W tym drugim przypadku zawiera on ścieżki wskazujące na zagnieżdżone projekty. Fragment takiego pliku może wyglądać następująco:   rootProject.name = 'KursAplikacjeWebowe'  include '01_serwlety' include '02_serwlety' include '03_filtry' include '04_kontekst'   Konfiguracja podprojektów   Każdy z projektów zagnieżdżonych może zawierać swój własny plik konfiguracyjny build.gradle. Jednak nie zawsze jest to najlepszy pomysł. Często żeby wyeliminować duplikację wspólna konfiguracja wyciągnięta jest do głównego projektu. Służy do tego blok subprojects. Jego przykład możesz znaleźć w pliku build.gradle w Kursie Java:   subprojects {     apply plugin: 'java'     apply plugin: 'idea'      repositories {         mavenCentral()     }      group = 'pl.samouczekprogramisty.kursjava'     version = '1.0-SNAPSHOT'      gradle.projectsEvaluated {         tasks.withType(JavaCompile) {             options.compilerArgs &lt;&lt; \"-Xlint:deprecation\"         }     } }   W tym przykładzie każdy z podprojektów będzie zawierał dwie wtyczki, będzie korzystał z repozytorium mavenCentral. Będzie miał ustawiony atrybuty group i version.   Ostatni blok używa mechanizmu rozszerzeń Gradle. W ten sposób dołączam pewną akcję po wystąpieniu zdarzenia projectsEvaluated. W tym przypadku dodaję do kompilatora javac flagę -Xling:deprecation, która włącza ostrzeżenia dotyczące używania przestarzałego API.   Niektóre podprojekty nie potrzebują dodatkowej konfiguracji. W takim przypadku nie mają własnego pliku build.gradle. W innych przypadkach build.gradle rozszerza konfigurację zawartą w bloku subprojects.   Gradle a repozytorium kodu   Jeśli korzystasz z systemu kontroli wersji część plików związanych z Gradle powinna być w nim zawarta. Jeśli nie korzystasz, to najwyższy czas zacząć ;) – zapraszam Cię do kursu Git’a. Katalog gradle, pliki gradlew,  gradlew.bat wraz z wszystkimi plikami konfiguracyjnymi powinny zostać dodane do systemu kontroli wersji.   Natomiast ukryty katalog .gradle powinien zostać pominięty. Sprawa wygląda podobnie z wszystkimi artefaktami powstałymi w wyniku budowania projektu. Z założenia mogą one być w prosty sposób odtworzone na podstawie plików źródłowych. Innymi słowy zawartość katalogu build nie powinna wylądować w repozytorium kodu.   Dodatkowe materiały do nauki   W artykule wielokrotnie odwoływałem się do dokumentacji Gradle. Nie bez powodu. Moim zdaniem dokumentacja Gradle’a jest na prawdę przydatnym źródłem wiedzy:      dokumentacja Gradle’a,   dodatkowo na stronie Gradle’a znajdziesz serię dobrze przygotowanych poradników.   Ćwiczenie do wykonania   Na koniec mam dla Ciebie drobne ćwiczenie. Spróbuj utworzyć nowy projekt wywołując gradle init z dodatkowymi parametrami opisanymi w dokumentacji. Czy dasz radę napisać polecenie, które utworzy nowy projekt i pominie wszystkie pytania, które Gradle zadaje po wywołaniu gradle init?   Podsumowanie   Po przeczytaniu tego artykułu wiesz jak działa Gradle. Znasz elementy DSL pozwalające na budowanie nieskomplikowanych skryptów budowania. Udało Ci się poznać szereg komend Gradle’a, które pomogą Ci w efektywny sposób pracować z tym narzędziem.   Na koniec mam do Ciebie prośbę, proszę poleć ten artykuł znajomym, którym Twoim zdaniem może się on przydać. Dzięki temu pozwolisz dotrzeć mi do większego grona odbiorców, z góry dziękuję!   Jeśli nie chcesz ominąć kolejnych artykułów na Samouczku dopisz się do samouczkowego newslettera i polub Stronę samouczka na Facebook’u. To tyle na dzisiaj, trzymaj się i do następnego razu!                 W systemie Windows jest to ścieżka %userprofile%/gradle/caches. &#8617;                  Po odpowiedniej konfiguracji albo sposobie uruchomienia gradle nazwa tego pliku może być inna, build.gradle jest wartością domyślną. &#8617;                  Pomijam skrajne sytuacje, w których ktoś może zmodyfikować swoje lokalne środowisko w sposób, który pozwoli zbudować coś innego. Jednak taka sytuacja wymaga świadomego działa :). &#8617;                  To wywołanie tworzy też ukryty katalog .gradle. &#8617;           ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "/pierwszy-projekt-z-gradle/",
        "teaser": "/assets/images/2019/03/22_gradle_artykul.jpeg"
      },{
        "title": "Granice wsparcia w rekrutacji",
        "excerpt":"Dzisiaj będzie bardzo nietypowo. Nie jestem mistrzem pióra, dużo lepiej czuję się w technicznych tematach, jednak jest to dla mnie ważne i ciekaw jestem Twojego zdania. Dlatego zapraszam Cię do lektury i podzielenia się w komentarzu Twoją opinią na temat poruszany w treści artykułu.   Początek   Jakiś czas temu słuchałem jednego z odcinków podkastu „Z pasją o mocnych stronach” – Talenty w czasie rozmowy rekrutacyjnej. Po przesłuchaniu odcinka naszła mnie pewna myśl.   Jak rekruterzy patrzą na pomoc w rozmowach kwalifikacyjnych? Czy taka pomoc nie jest źle odbierana? Sam pełniłem różne role, będąc zarówno rekrutującym jak i rekrutowanym. Byłem ciekawy jak na ten problem patrzą inni. W związku z tym zadałem Ani następujące pytanie:      Ciekawy jestem Twojej opinii na temat przygotowywania rozwiązań do zadań z rozmów kwalifikacyjnych (w moim przypadku z branży IT). Zdarza mi się przygotowywać takie artykuły na blogu. Robię to w dobrej wierze, żeby pomóc kandydatom przygotować się do rozmowy. Zastanawiam się jednak czy nie jest to przekroczenie jakiejś granicy, która według drugiej strony nie powinna być przekroczona? Co o tym sądzisz?    W odpowiedzi dostałem artykuł, do którego przeczytania gorąco Cię zachęcam. Ania pokazując swój punkt widzenia postawiła w nim szereg trafnych pytań. Zanim przejdę do dyskusji opiszę Ci mój punkt widzenia.   Mój sposób uczenia się   Każdy jest inny, ja uczę się przez praktykę. To właśnie z tego powodu rozwiązuję zadania w Advent of Code. Dlatego też czasami zaglądam do wyzwań Codility. Zadania z książek programistycznych przepisuję samodzielnie mimo tego, że autor udostępnia gotowy kod do ściągnięcia – tak uczę się Go.   Teraz na tapecie mam tak zwane wargames. Zamiast pisać artykuły sam dziubię po nocach skrypty, rozwiązujące poszczególne etapy. Nie inaczej było z nauką Python’a, którego też uczyłem się na przykładach rozwiązując Python challange.   Czy patrzę na gotowe rozwiązania? Oczywiście! Niezależnie od tego czy rozwiążę problem samodzielnie czy nie. Jeśli uda mi się rozwiązać dane zadanie samodzielnie wtedy gotowe rozwiązanie pokazane przez autora pozwala na sprawdzenie innego podejścia. Jeśli zadania nie potrafię rozwiązać samodzielnie gotowe rozwiązanie pokazuje mi moje braki. Wtedy jest ono podstawą do dalszej nauki i poszukiwania dodatkowych materiałów.   Rozmowy kwalifikacyjne   Z zadaniami z rozmów kwalifikacyjnych jest dokładnie tak samo. Nie pozjadałem wszystkich rozumów. Nie potrafię rozwiązać każdego problemu. Jeśli mam do rozwiązania zadanie na rozmowie kwalifikacyjnej, z którym się męczę, którego nie potrafię rozwiązać, to po powrocie do domu szukam gotowego rozwiązania w Internecie.   Przygotowując się na rozmowy kwalifikacyjne także przeglądam zadania algorytmiczne. Próbuję rozwiązać je samodzielnie, w przypadku problemów szukam gotowego rozwiązania i patrzę jak autor podszedł do problemu. Gotowe rozwiązanie pozwala wskoczyć na kolejny poziom. Oczywiście nawet gotowe rozwiązania wymaga sporo samodzielnej pracy, jego analiza i zrozumienie algorytmu to proces kiedy poznaję nowe rzeczy.   Świat nie jest idealny   Jeszcze drobna dygresja. Chcę żyć w bańce, w której każdy jest uczciwy. Wierzę, że tak jest po prostu lepiej. Cały czas uważam, że kłamstwo ma krótkie nogi i wcześniej czy później wychodzi na jaw. Nie inaczej jest w IT. Udało Ci się oszukać na rozmowie kwalifikacyjnej. Jogibabu, brawo Jasiu! Chyba nie chcę z Tobą pracować. Tylko, co to znaczy „oszukać na rozmowie kwalifikacyjnej”?   Dyskusja   W ogólności zgadzam się z punktem widzenia Ani, jednak moim zdaniem nie wszystkie argumenty pasują do problemu gotowych rozwiązań dla programistycznych zadań rekrutacyjnych.   Jest problem      Co pomaga realnie i długofalowo? Co daje większą wartość i wspiera faktyczny rozwój? Czy na pewno pokazanie rozwiązania jednego problemu da Twoim odbiorcom więcej niż nauczenie sposobu myślenia o problemach?    Kurka wodna. W punkt. Tylko jest jeden malutki problem. W nauce programowania zdarzają się ślepe zaułki. Można przedstawić wiedzę teoretyczną, pokazać sposób jej zastosowania jednak dalej jest problem z jej praktycznym zastosowaniem. Można „słowno-muzycznie” opisać problem. Można też zrobić to konkretnie, nie pozostawiając żadnego miejsca do interpretacji. Takim konkretnym opisem jest implementacja algorytmu. Podanie podobnego zadania niewiele zmieni. Potencjalny kandydat dalej będzie miał gotowca z algorytmem, który w przypadku obu zadań będzie taki sam.   Pomagam w sposób, który sprawdza się u mnie. Dochodzenie do rozwiązań samemu jest zdecydowanie najlepszym sposobem. Podkreślam to na każdym kroku. W każdym artykule, w którym są zadania z przykładowymi rozwiązaniami. Problem polega na tym, że mając wiedzę teoretyczną często jest bardzo trudno przełożyć ją na praktykę. Owszem jest X% ogona w krzywej Gaussa. To ci wybitni, którzy rozumieją wszystko w lot. Niestety nie należę do tego ogona, podobnie jak ogromna większość (potencjalnych) programistów. W takim przypadku zostaje mi analiza i próba zrozumienia rozwiązania wypracowanego przez inne osoby. Nie ma w tym absolutnie nic złego.   Tutaj drobna dygresja, która przychodzi mi do głowy. Był sobie dr Wieczorek. Prowadził zajęcia z fizyki na Politechnice Wrocławskiej. W zbiorze zadań było zadanie: „Biedronka porusza się po kręcącej się tarczy…”. Na kolokwium pojawiło się zadanie kropka w kropkę to samo różniące się jednym szczegółem. Na kolokwium po tarczy chodził żuczek. Pewna osoba, która miała zestaw ściąg nie rozwiązała zadania – nie zgadzał się początek treści zadania. Kurtyna.   Kłamstwo ma krótkie nogi   Rolą osób weryfikujących jest sprawdzenie, czy kandydat spełnia wymagania/rokuje/ogarnia/wyjada/inne określenie branżowe. Zgadzamy się co do faktu, że jak na dłoni widać osoby korzystające z gotowców. Zatem czy to przypadkiem nie pomaga od razu odsiać osób, z którymi nie chcemy mieć do czynienia? Czy kandydat pływający po wszystkich tematach, który nagle odnajduje się w jednym zdaniu technicznym nie zapala czerwonej lampki? Owszem można odebrać to jako marnowanie czasu. Czym zatem będzie zatrudnienie tej osoby?   Brałem udział w takiej rozmowie. Kandydat nie przeszedł do kolejnego etapu.   Brałem udział także w innej rozmowie. W której kandydat otwarcie przyznał, że zna to zadanie. Zna jego sposób rozwiązania. Czy to nie właśnie takie podejście powinno być premiowane? Czy taka uczciwość od samego początku to nie jest to czego pracodawcy potrzebują?   Zadanie to nie wszystko   Zadanie z rozmowy rekrutacyjnej to nie wszystko. To często wisienka na torcie. Co więcej tych wisienek często jest kilka. Moim zdaniem bycie miłym dla każdej ze stron jest obowiązkiem. W związku z tym rekrutujący, którzy podają zadania często nie zaczynają z grubej rury. Nawet kandydat, który nie spełnia wymagań i znacząco odstaje od oczekiwań nie powinien być przeczołgany przez rozmowę tak żeby nie wiedział jak się nazywa.   Często wszystko zaczyna się od bardzo podstawowego zadania, które następnie jest rozbudowywane do finalnego problemu. Często problemów jest więcej.   Po raz kolejny obowiązkiem rekrutującego jest sprawdzenie czy kandydat spełnia wymagania. Zadanie i sposób jego rozwiązania daje sporo dodatkowej wiedzy.   Nauka na pamięć nie ma sensu. Nawet jeśli ktoś dostanie rozwiązanie na tacy to nic z tego nie wyjdzie. Zawsze powtarzam, że kłamstwo ma krótkie nogi. Nie warto kłamać. A już na pewno nie jest to opłacalne w długim terminie. Mówiąc wprost, twarz każdy ma jedną. Rynek IT jest mały. Opinia o tym jak ktoś podchodzi do pracy i swoich zadań zostaje na rynku…   Na tapczanie siedzi leń      Komu teraz pomagam? A komu CHCĘ pomagać? Kto korzysta z gotowców i jak może ich użyć? Czy nie wspieram leniuchów (by nie powiedzieć „oszustów”) i nie uczę pokonywania trudności przez obejście systemu?    Tutaj mam zdecydowanie odmienne zdanie. Jak pokazałem na początku sam często uczę się w ten sposób. Zdarza mi się utknąć na problemie do rozwiązania. Czytam dokumentację, przeglądam dokładnie opis problemu, szukam powiązanych tematów, doczytuję szukając w wielu źródłach. Zdarza się, że zostaję na noc z problemem. Nic, pustka. Nie mam pojęcia jak rozwiązać dany problem. Ślepy zaułek, o którym pisałem. Rozkładu normalnego nie przeskoczę.   Co robię? Patrzę na gotowe rozwiązanie. Owszem zdarza mi się być leniwym, jednak na pewno nie nazwałbym siebie oszustem. Tym bardziej nie twierdzę, że to jest uczenie pokonywania trudności przez obejście systemu. Raczej uczenie rozwiązywania danej klasy problemów. Przeglądanie gotowego rozwiązania nie sprowadza się do bezmyślnego kopiuj/wklej. To proces, w którym można się na prawdę sporo nauczyć. A jeśli jest to bezmyślne kopiuj/wklej to docieramy do poprzedniego punktu – łatwo to wyłapać.   Innymi słowy sam fakt spojrzenia na gotowe rozwiązanie nie klasyfikuje danej osoby jako oszusta czy oportunistę. To raczej zestaw zachowań poprzedzających czy następujących po poznaniu gotowego rozwiązania coś o danej osobie mówi.      Zakładam, że chcesz pomóc kandydatom w rozwoju, a nie w dostaniu pracy, której wymagań nie spełniają, prawda? ;)    Tutaj także się nie mogę zgodzić. Jeśli dzięki rozwiązaniom na blogu ktokolwiek dostanie pracę, której wymagań nie spełnia to mam wrażenie, że osoba sprawdzająca umiejętności techniczne jest tą, która także nie do końca wywiązała się ze swoich obowiązków.   Gotowce a rozwój   Niestety nie zgadzam się ze stwierdzeniem, że rozwiązując problem za kogoś likwiduję jego szanse rozwojowe. Owszem jeśli dana osoba podejdzie to problemu na zasadzie kopiuj/wklej to ewentualnie można się z takim stwierdzeniem zgodzić. Jednak ponownie dochodzimy do miejsca, w którym takie osoby są odrzucane, bo da się je wychwycić. Chyba, że ktoś ma talent aktorski jak panowie Janusz Gajos, Andrzej Grabowski czy Marian Opania (swoja drogą zastanawiam się czy w takim przypadku mimo braku umiejętności programistycznych nie chciałbym z taką osobą pracować ;)).   Łut szczęścia   Odchodząc trochę od tematu chciałbym poruszyć jeszcze jeden punkt. Powodzenie w rozmowie kwalifikacyjnej to często kwestia tak zwanego szczęścia.   Jak wygląda twój biorytm w dniu rozmowy kwalifikacyjnej? Albo horoskop? Albo cokolwiek innego w co wierzysz? Mam wrażenie, że rozmowa rekrutacyjna to czasami także kwestia szczęścia. Ten sam kandydat może być oceniony różnie w zależności od wielu czynników. Pory dnia, miejsca przeprowadzenia rozmowy, nastroju rekrutującego, kolejności rozwiązywanych zadań, tego czy ktoś na rekrutującego chwilę wcześniej w kuchni nie wylał kawy itp.   Dodatkowo wszyscy jesteśmy ludźmi – nie bez znaczenia są także osobiste uprzedzenia. Na przykład jestem świadomy jednego z moich uprzedzeń – nie przepadam za ludźmi, którzy są strasznie pyszni i pewni siebie. Dużo lepiej odbieram osoby skromne, które są świadome możliwości popełnienia błędu. Czy pewni siebie są w jakikolwiek sposób gorsi? Nie! Po prostu mi ciężej się z takimi osobami pracuje.   Podsumowanie   Podsumowując, mam wrażenie, że mamy z Anią podobny punkt widzenia, jednak nasze opinie różnią się w kilku punktach. Moje zdanie jest takie, że gotowe zadania nie są z gruntu złe. Złe jest nierozważne korzystanie z gotowych rozwiązań. Owszem znajdą się osoby, które użyją gotowych rozwiązań w zły sposób, jednak zgadzamy się, że takie osoby można łatwo wyeliminować. Nie uważam, że przez ten odsetek pozostała grupa powinna być pokrzywdzona.   Zatem, programisto – korzystaj rozważnie z gotowych rozwiązań.   Co o tym sądzisz?   A jakie jest Twoje zdanie? Czy powinienem dalej bujać w obłokach i zakładać dobrą wiarę wszystkich Czytelników? Czy może od dzisiaj kolejne rozwiązania zadań nie powinny pojawić się na blogu? Czy Twoim zdaniem rozwiązania zadań w ogóle pomagają? Ciekaw jestem Twojej opinii, proszę daj znać co o tym wszystkim sądzisz w komentarzach. Na pewno pominąłem sporo ważnych tematów, które przyjdą Ci do głowy. Z góry dziękuję za Twoją opinię!   To tyle, trzymaj się!  ","categories": [],
        "tags": [],
        "url": "/granice-wsparcia-w-rekrutacji/",
        "teaser": "/assets/images/2019/04/09_granice_wsparcia_w_rekrutacji_artykul.jpeg"
      },{
        "title": "Jak pisać kod wysokiej jakości w języku Java",
        "excerpt":"Powtórzę to po raz kolejny. Uważam, że nauka przez praktykę to najlepsze rozwiązanie. Właśnie z tego powodu artykuły na Samouczku bardzo często zawierają zadania z przykładowymi rozwiązaniami. Sporo Czytelników rozwiązuje te zadania prosząc później o spojrzenie na kod krytycznym okiem.   Tego typu praktyka spotykana jest także w codziennej pracy programisty. Przeglądy kodu (ang. code review) to bardzo dobry sposób na poznawanie projektu i naukę. Najlepsze w tym wszystkim jest to, że uczy się zarówno osoba, która sprawdza kod jak i ta której kod jest sprawdzany.   Na przestrzeni kilku lat prowadzenia Samouczka widziałem już różne przypadki. W tym artykule zbieram najczęściej popełniane błędy wraz z propozycją ich rozwiązania.   Część proponowanych tu rozwiązań jest subiektywna. Nie jest poparta żadną specyfikacją czy dokładnym opisem „u źródła”. Masz prawo nie zgadzać się z moją opinią, z chęcią usłyszę Twój punkt widzenia w komentarzach.   Ogólne uwagi dotyczące kodu   Konwencja nazewnicza   Zanim zacznę opisywać jakiekolwiek standardy muszę zaznaczyć jedną bardzo ważną rzecz. Jeśli w projekcie, z którym pracujesz istnieje już jakaś konwencja proponuję nadal ją stosować. Jeśli wejdziesz między wrony, musisz krakać jak i one.   Jeśli Twoim zdaniem ta konwencja jest bez sensu porozmawiaj o tym z innymi członkami zespołu. Każdy przypadek powinien być rozpatrywany indywidualnie, a konsensus może usprawiedliwić zmianę istniejącej konwencji.   W języku Java „obowiązuje” konwencja nazewnicza. Kompilator nie będzie marudził jeśli kod, który napiszesz nie będzie jej przestrzegał. Będzie marudziła kolejna osoba, która z tym kodem będzie pracowała. W praktyce często jest tak, że raz napisany kod czytany jest wielokrotnie. Często przez kogoś innego niż autor. Stosowanie konwencji nazewniczej pozwala na łatwiejsze zorientowanie się w kodzie, z którym się pracuje.   Mimo tego, że pisownia jest ważna to nie jest najważniejsza. Najbardziej istotne jest nadanie poszczególnym elementom dobrej nazwy. Pracuję w IT od 2007 roku, nadal nie potrafię tego robić dobrze. W branży IT panuje obiegowa opinia:      There are only two hard things in Computer Science: cache invalidation and naming things.    Istotne jest aby nazwy elementów (typów, parametrów, atrybutów, metod itd.) oddawały to co dany element zawiera/robi. Złe nazwy mogą wprowadzić w błąd, co może utrudnić zrozumienie kodu.   Typy   Klasy, typy wyliczeniowe, interfejsy powinny być nazwane zgodnie z PascalCase. Oznacza to tyle, że nazwy powinny być jednym ciągiem znaków, w którym każde kolejne słowo zaczyna się od wielkiej litery. Dobrze, jeśli te nazwy są rzeczownikami. Problem jest z akronimami, nawet JDK nie zachowuje tu konwencji – część akronimów pisana jest wielkimi literami (na przykład URL), część używając PascalCase (na przykład Http). W tym przypadku proponuję Ci używanie pierwszego podejścia.   Moim zdaniem przykłady poniżej pokazują nazwy, które można poprawić:   // incorrect class anonymousUser { }  interface Bus_driver { }  enum color { }   Poprawnymi przykładami nazw mogą być:   // correct class User { }  interface PageCollector { }  enum URLSchema { }   Metody, parametry, atrybuty   Metody w języku Java zwykło się nazywać używając camelCase. Oznacza to tyle, że pierwsze słowo pisane jest małą literą. Każdy kolejny wyraz zaczyna się wielką literą. Przykładami poprawnych nazw mogą być:   // correct class CodeExecutor {     String snippet;     int returnCode;      Future&lt;Integer&gt; executeAsynchronously() {         // ...     } }   Stałe   Swego rodzaju wyjątkiem od reguły są stałe – atrybuty przypisane do klasy oznaczone słowem kluczowym final. Te powinny być pisane wyłącznie wielkimi literami używając SCREAMING_SNAKE_CASE. Poszczególne słowa pisane wielkimi literami powinny być oddzielone symbolem _. Na przykład:   // correct class Temperature {     public static final double BOILING_WATER_CELSIUS = 100; }   Pakiety   Mimo tego, że Java pozwala na używanie domyślnego pakietu (brak deklaracji package) nie jest to zalecane. Przyjęło się, że nazwa pakietu składa się z małych liter oddzielonych kropkami. Każdy z członów opisuje bardziej szczegółowo swoją zwartość.   Przyjęło się, że pakiety mają postać „odwróconej domeny”:   // incorrect package pckg.pl;  // correct package pl.samouczekprogramisty.kursjava.loops;       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Formatowanie kodu   Nie chcę rozpoczynać świętej wojny. Niektórzy programiści bronią formatowania, do którego są przyzwyczajeni, jak niepodległości. Mam do tego bardziej pragmatyczne podejście. Używaj formatowania kodu. Niech IDE robi to za Ciebie, nie zastanawiaj się nad tym dopóki nie zacznie Ci ono przeszkadzać. Nie chcę się tu rozpisywać nad wyższością jednego formatowania nad drugim, to nie ma sensu. Istotne jest to, że brak formatowania kodu można traktować jako złą praktykę.   Moim zdaniem dobrym podejściem jest włączenie automatycznego formatowania kodu w IDE1. W zależności od tego jakiego IDE używasz ta akcja może być wykonywana na przykład przed każdym zapisem pliku czy przed każdym commit’em do repozytorium. Dzięki temu możesz w ogóle zapomnieć o formatowaniu i skupić się na innych rzeczach. IDE zrobi to za Ciebie.   Istotne jest to, żeby wszystkie osoby, które pracują w danym projekcie używały spójnego formatowania kodu. Wachlowanie się commit’ami, które polegają tylko na zmianach w formatowaniu kodu nie jest dobrym pomysłem. Formatowanie kodu to konwencja, która musi być ustalona wspólnie przez cały zespół i konsekwentnie stosowana.   Bloki z jedną linią   Język Java pozwala na opuszczanie nawiasów { } jeśli blok ma jedną linię. Tego typu konstrukcja może być na przykład użyta po warunku if czy pętli. Proszę spójrz na przykład poniżej:   // incorrect if (activeUser.isAnAdmin())     allowedActions.add(Action.DELETION);  System.out.println(\"Some log message\");   Moim zdaniem to bardzo zła praktyka. Może prowadzić do trudnych do znalezienia błędów. Co jeśli tylko użytkownik, który jest administratorem powinien móc dokonywać modyfikacji? Ktoś mógłby wprowadzić drobną zmianę:   // incorrect if (activeUser.isAnAdmin())     allowedActions.add(Action.DELETION);     allowedActions.add(Action.MODIFICATION);  System.out.println(\"Some log message\");   Problem polega na tym, że taki fragment kodu powoduje, że każdy użytkownik mógłby wykonać modyfikację. Dlatego nawet przy jednoliniowych blokach należy używać nawiasów:   // correct if (activeUser.isAnAdmin()) {     allowedActions.add(Action.DELETION); }  System.out.println(\"Some log message\");   Flagi   Na początku mojej przygody z programowaniem pracowałem w Eurobanku. Nie zapomnę do końca życia strony w intranecie opisującej „kwiatki w kodzie”. Kwiatki w kodzie czyli radosną twórczość programistów, która po dłuższym zastanowieniu nie ma sensu. Dość dużą część tej strony zajmowały przykłady kodu z wyrażeniami logicznymi.   Proszę spójrz na kilka złych przykładów wraz z propozycjami jak można je poprawić:   // incorrect boolean parameter = // ... if (parameter == true) {     // ... }  // correct boolean parameter = // ... if (parameter) {     // ... }   Podobnie wyglądać może sytuacja z odwróceniem warunku  // incorrect if (parameter == false) {     // ... }  // correct if (!parameter) {     // ... }   Spotkałem się też z uzależnieniem wartości zwracanej od zmiennej typu boolean:   // incorrect if (parameter == true) {     return false; } else {     return true; }  // correct return !parameter;   Warunki logiczne często urastają do sporych potworków. Jeśli zauważysz jeden z nich, który ma zawsze taką samą wartość warto uprościć takie wyrażenie. Dzięki temu kod będzie bardziej czytelny. W przykładzie poniżej zakładam, że variableThatAlwaysIsNull w wyniku różnych operacji zawsze ma wartość null:   // incorrect Object variableThatAlwaysIsNull = methodAlwaysReturningNull(); boolean someMagicFlag = // ...  if (variableThatAlwaysIsNull == null &amp;&amp; someMagicFlag) {     // ... }   // correct boolean someMagicFlag = // ...  if (someMagicFlag) {     // ... }   Spotkałem się też z kodem tego typu:   // incorrect if (someMagicFlag) { } else {     // code to execute }   Blok if nie zawierał żadnej linijki. Kod do wykonania znajdował się wewnątrz bloku else:   // correct if (!someMagicFlag) {     // code to execute }   Przykłady tego typu można mnożyć. Ważne, żeby zwracać uwagę na wyrażenia logiczne – bardzo często można je uprościć. Jeśli nie znasz praw De Morgana, to najwyższy czas je poznać ;).   Duplikacja kodu   Jakiś czas temu pisałem o regule Don’t Repeat Yourself. Można ją zastosować na wielu poziomach. Jednym z nich jest kod źródłowy programu. Duplikacja w kodzie jest zła. Należy ją eliminować (jestem gorącym zwolennikiem usuwania kodu). Poniższy przykład pokazuje duplikację w bardzo wąskim zakresie:   // incorrect class MagicNumber {     private int value;      public boolean isEven() {         return value % 2 == 0;     }      public boolean isOdd() {         return value % 2 == 1;     } }  // correct class MagicNumber {     private int value;      public boolean isEven() {         return value % 2 == 0;     }      public boolean isOdd() {         return !isEven();     } }   Unikanie zbędnych zagnieżdżeń   Moim zdaniem unikanie zbędnych zagnieżdżeń jest dobre. Mam tu na myśli pomijanie bloku else, jeśli kod wewnątrz bloku if na pewno zakończy działanie metody. Może się tak stać na przykład w sytuacji kiedy wewnątrz bloku if znajduje się return:   // „incorrect” if (someFlag) {     // return/throw/break/continue } else {     // something else }   Moim zdaniem pomięcie else poprawia czytelność:   // correct if (someFlag) {     // return/throw/break/continue } // something else   Metody statyczne   Metody statyczne są przypisane do klasy. Moim zdaniem warto o tym pamiętać i wywoływać metody statyczne posługując się klasą a nie jej instancją:   // incorrect SomeClass instance = new SomeClass(); instance.staticMethod();   // correct SomeClass.staticMethod();   import *   Kolejny subiektywny punkt. Nie podchodzą mi klasy/metody statyczne importowane przy pomocy *. Pewnie wynika to trochę z filozofii jaką proponuje Python –  explicit is better than implicit.   // incorrect import static java.lang.Math.*;   // correct import static java.lang.Math.sqrt; import static java.lang.Math.pow;   Projekt   Problemy i złe praktyki na poziomie poszczególnych plików to czubek góry lodowej. Pod spodem kryją się większe problemy. Problemy związane z podejściem do samego projektu.   Brak systemu kontroli wersji   Piszesz kod bez używania systemu kontroli wersji? Robisz błąd. System kontroli wersji jest narzędziem niezbędnym w pracy każdego programisty. Polecam Ci Git’a, który moim zdaniem jest standardem w branży.   Brak testów jednostkowych   Piszesz kod bez testów jednostkowych? Robisz błąd. Moim zdaniem automatyczne testy jednostkowe w wielu przypadkach są niezbędne. Nie będę się tu rozwodził nad tematyką testów. Zachęcam Cię do przeczytania artykułów:      Wprowadzenie do tematyki testów jednostkowych na przykładzie JUnit4 – jeśli nigdy nie udało Ci się pracować z testami zacznij od tego artykułu,   Opis biblioteki JUnit5 – ten artykuł opisuje bibliotekę JUnit5,   Test Driven Development – jak poznasz już bibliotekę do pisania testów czas zabrać się za TDD.   Zła organizacja kodu   Na ten temat powstają mądre książki. Dobrym początkiem będzie zapoznanie się z zasadami SOLID i ich świadome stosowanie w pracy z kodem.   Brak standardowego mechanizmu budowania   W idealnym świecie zbudowanie projektu powinno składać się z dwóch etapów:      Pobrania źródeł projektu, na przykład z repozytorium Git’a,   Uruchomienia narzędzia do budowania, które na podstawie plików konfiguracyjnych zbuduje projekt.   Oba etapy powinny działać niezależnie od środowiska programisty. Drugi punkt rozwiązywany jest przez narzędzia takie jak Maven, Make, Rake, Gradle, Ant, Grunt itp. Jeśli do tej pory nie udało Ci się pracować z narzędziami tego typu zachęcam Cię do zajrzenia do artykułów opisujących Gradle:      Wstęp do Gradle,   Pierwszy projekt z Gradle.   Niestandardowa struktura projektu   Organizacja plików w projekcie jest ważna. Podobnie jak z nazewnictwem czy formatowaniem kodu istnieje pewna konwencja, która pozwala na szybkie zorientowanie się w strukturze projektu. Niejako powiązane z tym tematem jest używanie narzędzie wspomagającego budowanie projektu, które „narzucają” używanie pewnych konwencji. Standardową strukturę projektu opisałem we wstępie do Gradle.   Martwy kod   Historia w repozytorium jest od tego, żeby pamiętać co działo się w projekcie. Fragmenty kodu w komentarzu, które „może kiedyś się przydadzą” moim zdaniem powinny od razu wylecieć w kosmos. Nie są potrzebne, jedynie zaciemniają obraz.   Kilka poniższych podpunktów opisuje różne przypadki, które można podsumować w jednym zdaniu: nie jest sztuką napisać dużo kodu, sztuką jest napisać jak najmniej czytelnego i zrozumiałego kodu, który robi to samo. Jeśli masz możliwość usunięcia czegoś, co nie jest używane zrób to! :) Mniej kodu oznacza mniej potencjalnych błędów. Mniej kodu, to niższy koszt jego utrzymania2.   Często jest tak, że fragmenty martwego kodu narastają z czasem – wynikają z kilku zmian wprowadzonych na przestrzeni życia projektu. Odwaga do usuwania danej linijki kodu jest odwrotnie proporcjonalna do jej wieku ;).   Kod, który nigdy nie będzie wykonany   Ten punkt jest powiązany z flagami, które poruszałem wcześniej. Po uproszczeniu warunków logicznych możesz czasami zauważyć, że dotarcie do pewnych fragmentów kodu jest po prostu niemożliwe. W podstawowych przypadkach IDE potrafi pokazać takie fragmenty kodu jako martwe. Dobrym pomysłem jest usunięcie śmieci tego typu.   Niepotrzebne parametry i atrybuty   Widzisz metodę, która ma nieużywany parametr? Zastanów się czy możesz go usunąć. Jeśli tak, to wiesz co masz zrobić ;). Podobną regułę trzeba stosować przy atrybutach klas.   Zwróć szczególną uwagę na zmianę sygnatury metody. Tego typu zmiany mogą prowadzić do „dziwnych zachowań”. Mam tu na myśli sytuację, w której metoda nadpisywała inną w klasie bazowej. Tu drobne ćwiczenie dla Ciebie – czym może skończyć się takie usunięcie parametru?   Usuwanie atrybutów, to też coś co wymaga pewnej analizy. W zależności od modyfikatora dostępu może, ale nie musi, łamać kompatybilność wsteczną.   Zbędne metody   Nie zrozum mnie źle. Uważam, że nieduże metody są dobre. Jednak także i tutaj trzeba zachować zdrowy rozsądek. Proszę spójrz na przykład poniżej, używa on klasy Math:   // incorrect double someVeryImportantCalculation(double argument0, double argument1) {     return argument0 + sqrt(argument1); }  double sqrt(double argument) {     return Math.sqrt(argument); }   Moim zdaniem w tym przypadku wprowadzenie metody sqrt nic nie wnosi. Równie dobrze w miejscu jej wywołania można byłoby użyć Math.sqrt.   // correct double someVeryImportantCalculation(double argument0, double argument1) {     return argument0 + Math.sqrt(argument1); }   Nieużywana wartość zwracana   Widziałem przypadki, w których metoda wywoływana dla efektów ubocznych3 zwracała wartość. Ta zwrócona wartość nie była w ogóle wykorzystywana. Moim zdaniem warto uprościć taką metodę usuwając wartość zwracaną:   // incorrect class User {     String login() {         try {             callingExternalServiceToLogin();         }         catch (LoginException e) {             // handling exception         }         return \"logged in\";     } }  // correct class User {     void login() {         try {             callingExternalServiceToLogin();         }         catch (LoginException e) {             // handling exception         }     } }   Wydajność   Przedwczesna optymalizacja   Tutaj nie mam przykładu z zadań na blogu, jednak nadal warto wspomnieć o tym błędzie. W świecie programistów panuje przekonanie, że „przedwczesna optymalizacja jest źródłem całego zła”4. Podpisuję się pod tym obiema rękami. Kompilator Java jest na tyle zaawansowany, że potrafi zrobić cuda, tak żeby nasz kod był bardziej wydajny.   Zacznij od pisania zrozumiałego i czytelnego kodu. Dopiero gdy zauważysz, że pojawiają się problemy wydajnościowe wprowadzaj optymalizacje. Istotne jest żeby wprowadzać takie zmiany na podstawie twardych dowodów – przeprowadzonych testów wydajnościowych.   Jest to ważne, bo może zdarzyć się tak, że intuicja nawet doświadczonych programistów nie sprawdza się w praktyce. Przez co wprowadzona optymalizacja ma znikomy (zerowy?) wpływ na wydajność, a sprawia, że kod jest zupełnie niezrozumiały.   Tworzenie nadmiarowych obiektów   Im mniej obiektów, tym mniej zajętej pamięci. Jeśli możesz użyć obiektu wielokrotnie zrób to, nie ma sensu tworzyć nowej instancji dla każdego wywołania. Tutaj sprawa trochę się komplikuje. Wszystko przez wątki i współdzielenie instancji pomiędzy nimi. Jeśli instancja obiektu będzie współdzielona pomiędzy wątkami należy upewnić się, że kod jej klasy napisany jest w wielowątkowo bezpieczny sposób.   Uproszczony przykład tworzenia nadmiarowej instancji:   // incorrect class UserInput {     public String get(String prompt) {         System.out.println(prompt);         Scanner scanner = new Scanner(System.in);         return scanner.next();     } }  // correct class UserInput {     private Scanner scanner = new Scanner(System.in);      public String get(String prompt) {         System.out.println(prompt);         return scanner.next();     } }   Znajomość JDK   Znajomość bibliotek i API przychodzi z czasem. Nie ma sensu uczyć się tego na pamięć. Poniżej zebrałem najczęściej spotykane błędy powiązane z klasami dostarczonym wraz z JDK.   System.in, System.out, System.err   Wspomniany wyżej Scanner jest bardzo często używany do pobierania danych od użytkownika. Jednym ze sposobów utworzenia instancji tej klasy jest przekazanie jej instancji InputStream. Możesz na przykład użyć System.in. Proszę spójrz na przykład poniżej:   // incorrect public static void main(String[] args) {     try(Scanner s = new Scanner(System.in)) {         System.out.println(s.next());     }     try(Scanner s = new Scanner(System.in)) {         System.out.println(s.next());     } }   Ten kod jest zły z dwóch powodów. Pierwszy to wyżej wspomniane tworzenie dwóch instancji klasy Scanner, w tym przypadku spokojne wystarczy jeden obiekt i jego użycie wiele razy. Drugim, poważniejszym błędem jest zamykanie System.in. Dzieje się tak, ponieważ po wyjściu z bloku try with resources na instancji s wywoływana jest metoda close. Powoduje to zamknięcie System.in. W ramach ćwiczenia uruchom powyższy kod i zobacz jaki będzie jego efekt.   Nie jest to dobra praktyka. To wirtualna maszyna Javy otwiera ten strumień i to ona jest odpowiedzialna za jego zamknięcie. Sprawa wygląda podobnie w przypadku strumieni System.out czy System.err.   Jeśli chcesz przeczytać więcej o stdout, stderr i stdin w trochę innym kontekście zapraszam do przeczytania artykułu opisującego początki pracy z linią poleceń.   Poniżej możesz zobaczyć poprawiony fragment kodu:   // correct public static void main(String[] args) {     Scanner s = new Scanner(System.in);     System.out.println(s.next());     System.out.println(s.next()); }   Znak końca linii   Java pozwala tworzyć programy, które mogą być uruchamiane na różnych systemach operacyjnych. Żeby programy te działały w pełni poprawnie trzeba brać pod uwagę różnice, które występują pomiędzy nimi.   Sztandarowym przykładem jest tutaj znak końca linii. W zależności od systemu operacyjnego inny ciąg znaków odpowiedzialny jest za łamanie linii. Poniższy przykład pokazuje błąd i jego rozwiązanie:   // incorrect System.out.println(\"This is a list:\\n- item.\");  // correct System.out.println(\"This is a list:\" + System.lineSeparator() + \"- item.\");   Kompilacja wyrażenia regularnego   Wyrażenia regularne i bardziej zaawansowane wyrażenia regularne były już poruszane na blogu.   Tutaj chciałbym zwrócić na jeden drobny szczegół. Proszę rzuć okiem na kod poniżej:   // incorrect class Postcode {     public static boolean isValid(String postcode) {         Pattern postcodePattern = Pattern.compile(\"^\\\\d{2}-\\\\d{3}$\");         Matcher matcher = postcodePattern.matcher(postcode);         return matcher.find();     } }   Kompilacja wyrażenia regularnego jest procesem długotrwałym. Jeśli jest taka możliwość to warto wykonywać tę czynność tylko raz:   // correct class Postcode {     public static final Pattern PATTERN = Pattern.compile(\"^\\\\d{2}-\\\\d{3}$\");      public static boolean isValid(String postcode) {         Matcher matcher = PATTERN.matcher(postcode);         return matcher.find();     } }   Znajomość wbudowanych wyjątków   Java dostarcza cały szereg gotowych klas wyjątków. Czasami nie ma sensu tworzenie własnego dedykowanego wyjątku – warto użyć jednego z istniejących. Dobrym przykładem jest użycie wyjątku IllegalArgumentException jeśli chcesz zasygnalizować niepoprawny argument.   Dodatkowo ważne jest żeby rzucać wyjątki, które pasują do danej sytuacji. Na przykład rzucenie wyjątku IllegalStateException w sytuacji gdy podano błędny argument nie jest najlepszym rozwiązaniem.   java.util.Date i spółka   Gdzie tylko się da omijaj stare API do zarządzania datami szerokim łukiem. Na przykład instancje java.util.Date nie są wielowątkowo bezpieczne, API jest zagmatwane, obsługa stref czasowych wymaga więcej pracy.   Skup się na poznaniu LocalDateTime i jej podobnych.   Konstrukcje języka   Konstrukcje języka nie są związane z API a składnią jaką język oferuje. Java ewoluuje jak każdy język. W kolejnych wersjach wprowadza nowe elementy. Warto z nich korzystać. Za przykład mogą tu posłużyć wyrażenia lambda, wyrażenia switch, zmienne lokalne przy użyciu var, konstrukcja try with resources i tak dalej ;).   Dodatkowe materiały do nauki   Do tej pory nie nazwałem tego wprost. Wprowadzanie zmian, które nie modyfikują zachowania programu to tak zwana refaktoryzacja. Zacznij od przeczytania czym jest refaktoryzacja w artykule na Wikipedii. Później możesz sięgnąć po książkę Refactoring autorstwa Martin’a Fowler’a. Pierwsza edycja zawiera przykłady w Javie, druga w JavaScript.   Możesz też rzucić okiem na dość stary dokument opisujący konwencja nazewnicza w języku Java. Opisuje on też zalecane formatowanie kodu.   W treści artykułu wspomniałem o prawach De Morgana. To podstawa, jak już je poznasz warto poczytać więcej o algebrze Boole’a i wzorach pozwalających na upraszczanie wyrażeń logicznych.   Podsumowanie   Moją motywacją do napisania tego artykułu było zebranie w jednym miejscu błędów i propozycji ich rozwiązania. Temat bynajmniej nie jest wyczerpany. Większość z tych punktów można rozbudować podając więcej przykładów.   Jednak nawet w obecnej formie artykuł pokazał Ci większość klas „podstawowych błędów”. Po jego lekturze wiesz jak można je poprawić. Stosując się do zaleceń, które tu zebrałem Twój kod będzie na pewno wyższej jakości. Z góry gratuluję ;).   Jeśli znasz kogoś dla kogo ten artykuł byłby pomocny proszę podziel się linkiem. Dzięki temu pomożesz mi dotrzeć do nowych Czytelników, za co od razu bardzo dziękuję!   Jeśli nie chcesz pomiąć kolejnych artykułów polub Samouczka na Facebooku i dopisz się do samouczkowego newslettera. To tyle na dzisiaj, trzymaj się i do następnego razu!                 Potrafię sobie wyobrazić wyjątki od tej reguły. Załóżmy, że pracujesz nad projektem, który nie jest pierwszej młodości. Znajdują się w nim pliki mające kilka lat i kilka tysięcy linii. Musisz poprawić błąd, który sprowadza się do zmiany kilku linijek. Łączenie tej zmiany z formatowaniem całego pliku przeważnie nie jest dobrym pomysłem. &#8617;                  Jak napisałem wcześniej – zakładam, że kod jest napisany w sposób czytelny i zrozumiały. Nie chodzi mi tu o sytuację, w której używasz jednoliterowych nazw metod, żeby „było mniej kodu”. &#8617;                  Abstrahując od tego czy metody posiadające efekty uboczne są w porządku czy nie. &#8617;                  Cytat pochodzi z książki autorstwa Donalda Knuth’a. &#8617;           ","categories": [],
        "tags": [],
        "url": "/jak-pisac-kod-wysokiej-jakosci-w-jezyku-java/",
        "teaser": "/assets/images/2019/04/20_jak_pisac_dobry_kod_w_javie_artykul.jpeg"
      },{
        "title": "Wzorzec projektowy obserwator",
        "excerpt":"Czytasz jeden z artykułów opisujących wzorce projektowe. Jeśli interesuje Cię ten temat zapraszam Cię do lektury pozostałych artykułów, które powstały w ramach tej serii – wzorce projektowe. W zrozumieniu artykułu przyda Ci się wiedza dotycząca podstaw UML’a.   Problem do rozwiązania   Czytasz artykuły na różnych stronach internetowych. Jedną z tych stron jest Samouczek Programisty ;). Są strony na które zaglądasz regularnie. Raz na jakiś czas sprawdzasz czy na stronach, które Cię interesują nie pojawiły się nowe artykuły. Po lekturze nowych artykułów spisujesz swoje notatki. Jeśli stron do śledzenie masz sporo pojawia się problem. Regularne sprawdzanie czy pojawiły się nowe treści jest mało efektywne. Możesz rozwiązać ten problem na kilka sposobów, jednym z nich może być zapisanie się do newslettera. Można powiedzieć, że zapisanie się na newsletter czyni z Ciebie obserwatora strony.   Ten sam problem występuje w projektach informatycznych. Istnieją zdarzenia, które powinny wyzwalać pewne zachowanie. Wystąpienie zdarzenia powoduje to, że obserwator aktualizuje swój stan na podstawie zmiany obserwowanego elementu. Aktywne sprawdzanie czy zdarzenie wystąpiło w większości przypadków nie jest dobrym rozwiązaniem. W projektach informatycznych problem tego typu rozwiązany jest przez wzorzec projektowy obserwator (ang. observer).   Wzorzec obserwator   Diagramy klas   Ten wzorzec projektowy opiera się o dwa interfejsy. Jeden z nich reprezentuje obserwatora. Drugi element, który jest obserwowany:             Wzorzec projektowy obserwator (ang. observer)        Interfejs Observable zawiera trzy metody:      attach(Observer) – powoduje dodanie nowego obserwatora (obserwator jest zainteresowany zmianami),   detach(Observer) – powoduje usunięcie istniejącego obserwatora (obserwator nie jest już zainteresowany zmianami),   notify() – powoduje powiadomienie wszystkich obserwatorów o wystąpieniu zmiany.   Interfejs Observer zawiera wyłącznie jedną metodę:      update() – metoda jest wywołana przez Observable w momencie wystąpienia zmiany.   Interfejsy nie przechowują żadnego stanu, który może się zmienić. Właściwe obiekty implementują te interfejsy i to one przechowują stan.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Przykładowa implementacja obserwatora   Interfejsy przedstawione na diagramie UML mogą wyglądać następująco:   public interface Observable {     void attach(Observer observer);     void detach(Observer observer);     void notifyObservers(); }   public interface Observer {     void update(); }   Posłużę się przykładem, który przytoczyłem na początku artykułu. Wyobraź sobie blog, na którym publikowane są artykuły. Blog pozwala się obserwować – implementuje interfejs Observable. W momencie dodania nowego czytelnika zostaje on dodany do zbioru obserwatorów.   Następnie w momencie publikacji nowego artykułu (metoda publishArticle) zmieniany jest wewnętrzny stan instancji klasy Blog. Po tej zmianie wywołana jest metoda notifyObservers. Wewnątrz tej metody na każdej z instancji implementującej Observer wywołana jest metoda update:   public class Blog implements Observable {      private Set&lt;Observer&gt; observers = new HashSet&lt;&gt;();     private String newestArticle;      @Override     public void attach(Observer observer) {         observers.add(observer);     }      @Override     public void detach(Observer observer) {         observers.remove(observer);     }      @Override     public void notifyObservers() {         observers.forEach(Observer::update);     }      public String getNewestArticle() {         return newestArticle;     }      public void publishArticle(String article) {         newestArticle = article;         notifyObservers();     } }   Obserwatorem jest czytelnik reprezentowany przez klasę Reader. Czytelnik wie jaki zasób obserwuje, przechowuje go w atrybucie blog. W momencie powiadomienia, czyli w trakcie wywołania metody update, sprawdzany jest stan atrybutu blog i Reader może odpowiednio na tę zmianę zareagować. W tym przypadku informuje o najnowszym artykule:   public class Reader implements Observer {     private final Blog blog;     private String newestArticle;      public Reader(Blog blog) {         this.blog = blog;         newestArticle = blog.getNewestArticle();     }      @Override     public void update() {         newestArticle = blog.getNewestArticle();         System.out.println(String.format(\"An article „%s” was published!\",  newestArticle));     } }   Przekładając klasy z tego przykładu na te użyte w diagramie UML:      SomeObservable – Blog,   SomeObserver – Reader.   Dodatkowe rozważania   Obserwator to wzorzec, który jest bardzo generyczny. W swojej podstawowej wersji nie posiada mechanizmu na informowanie o tym co dokładnie zmieniło się w obserwowanym obiekcie. Takie podejście ma swoje wady i zalety.   Zalety   Jedną z zalet stosowania tego wzorca projektowego jest to, że klasa implementująca interfejs Observer nie musi aktywnie sprawdzać czy interesujący ją obiekt się zmienił.   Dzięki zastosowaniu tego wzorca projektowego można w czysty sposób odizolować od siebie obiekty. Nie są one ze sobą sztywno powiązane. Dodatkowo szeroka definicja metody update pozwala na informowanie o zdarzeniach różnego rodzaju.   Niewątpliwą zaletą także jest to, że obiekt obserwowany może poinformować wielu obserwatorów używając tego samego protokołu.   Wady   Obserwator powiadomiony o zmianie sam musi dojść do tego co się zmieniło w obiekcie obserwowanym. Czasami takie sprawdzenie może nie być trywialne. Co więcej nie jest to potrzebne, bo obserwowany obiekt doskonale wie co się zmieniło – sam przecież o tej zmianie informuje swoich obserwatorów.   Można to obejść poprzez rozszerzenie metody attach lub update. Na przykład zmiana deklaracji z attach(Observer observer) na attach(Observer observer, EnumType event) może informować obiekt informowany o tym, że dany obserwator zainteresowany jest jedynie podzbiorem zdarzeń.   Podobną zmianę można wprowadzić w metodzie update zmieniając ją z update() na update(EventDetails eventDetails). Zmiany tego typu sprawiają, że interfejsy Observable czy Observer nie są już tak generyczne.   Przy synchronicznym powiadamianiu obserwatorów może wystąpić sytuacja, w której wywołania metody update zajmują lwią część czasu zmiany stanu obiektu obserwowanego.   Przykłady użycia wzorca obserwator   W standardowej bibliotece języka Java możesz spotkać całą masę różnych implementacji interfejsu EventListener. Jest to interfejs bazowy dla pozostałych interfejsów, które służą do informowania o wystąpieniu pewnego zdarzenia. To nic innego jak Observer, z rozszerzoną metodą update.   Jeśli udało Ci się już przeczytać artykuł o wątkach to wiesz o mechanizmie powiadamiania. Także tam można dopatrzeć się analogii do wzorca projektowego obserwator. Wątek, oczekujący na pewien zasób jest powiadamiany kiedy zasób staje się dostępny.   Można powiedzieć, że MVC (ang. Model View Controller) jest wzorcem architektonicznym. Połączenia pomiędzy poszczególnymi komponentami można uzyskać stosując wzorzec obserwatora. Na przykład widok obserwuje zmiany w modelu, model informuje widok o zmianach, które powinny zostać pokazane użytkownikowi.   Ćwiczenie do wykonania   Ćwiczenie polega na zaimplementowaniu klasy zdarzenia ArticleEvent, która będzie zawierała informacje o nowym artykule opublikowanym na blogu. Wymaga to także zmiany metody update. Niech obserwator użyje informacji przekazywanej w tym zdarzeniu do pokazania najnowszego artykułu. Czy w takim przypadku Reader potrzebuje instancji klasy Blog?   Dodatkowe materiały do nauki   Niezmiennie, we wszystkich artykułach z serii poświęconej wzorcom projektowym polecam książkę Design Patterns – Gamma, Helm, Johnson, Vlissides. Jeśli miałbym polecić wyłącznie jedno źródło to poprzestałbym na tej książce.   Możesz też przeczytać więcej o obserwatorze z innego punktu widzenia. Wartościowym źródłem są także artykuły na polskiej i angielskiej Wikipedii.   Zachęcam Cię też do zajrzenia do kodu źródłowego, który użyłem w tym artykule.   Podsumowanie   Po lekturze tego artykułu wiesz czym jest obserwator. Artykuł pokazał Ci też pewne wariacje tego wzorca projektowego. Po wykonaniu ćwiczenia potrafisz zaimplementować swój własny obserwator. Można powiedzieć, że udało Ci się poznać kolejny wzorzec projektowy. Gratulacje!   Czy udało Ci się użyć tego wzorca w praktyce? W czym pomógł w Twoim projekcie? Podziel się Twoją opinią z innymi Czytelnikami :).   Jeśli znasz kogoś komu obserwator może się przydać proszę podziel się odnośnikiem do tego artykułu. Kto wie, może dzięki Tobie Samouczek zyska kolejnego Czytelnika? Z góry dziękuję!   Jeśli nie chcesz pominąć kolejnych artykułów proszę dopisz się do samouczkowego newslettera i polub profil Samouczka na Facebook’u. To tyle na dzisiaj, trzymaj się i do następnego razu!   ","categories": ["Wzorce projektowe"],
        "tags": [],
        "url": "/wzorzec-projektowy-obserwator/",
        "teaser": "/assets/images/2019/0502-wzorzec-projektowy-obserwator/wzorzec_projektowy_obserwator_artykul.jpg"
      },{
        "title": "Struktury danych – zbiór",
        "excerpt":"     Artykuł ten opisuje przykładową implementację zbioru. Zbiór jest abstrakcyjnym typem danych, który występuje w wielu językach programowania. Zasada pracy ze zbiorami są niezależnie od języka programowania.   Przykładową implementację przygotowałem w Javie. Żeby wynieść jak najwięcej z tego artykułu potrzebna jest wiedza na temat hashCode i equals. Niezbędna jest też znajomość kontraktu pomiędzy metodami equals i hashCode.   Do zrozumienia przykładowej implementacji niezbędna będzie też wiedza o typach generycznych.   Może przydać się też wiedza na temat szacowania złożoności obliczeniowej.     Struktura danych a abstrakcyjny typ danych   W poprzednich artykułach z serii opisujących listę wiązaną czy tablicę asocjacyjną pominąłem kwestie definicji. Używałem określenia struktura danych i abstrakcyjny typ danych zamiennie. Tym razem chciałbym zwrócić Twoją uwagę na drobną różnicę pomiędzy tymi określeniami.   Abstrakcyjny typ danych definiuje zachowanie danego typu. Określa zestaw operacji, które można na tym typie wykonać. Opis abstrakcyjnego typu danych zawiera także cechy charakterystyczne dla danego typu.   Na przykład zbiór jest abstrakcyjnym typem danych (niżej opiszę jego własności), a TreeSet czy HashSet są implementacjami tego abstrakcyjnego typu danych. Te implementacje używają rożnych struktur danych. Innym przykładem może być abstrakcyjny typ danych tablica asocjacyjna, której implementacja może używać tablicy i listy wiązanej.   Czym jest zbiór   Zbiór jest abstrakcyjnym typem danych, który ma następujące własności:      pozwala na przechowywanie wielu elementów,   kolejność elementów w zbiorze nie ma znaczenia1,   pozwala na przechowywanie co najwyżej jednej kopii elementu (duplikaty nie są dozwolone).   Podstawowymi operacjami, które można przeprowadzić na zbiorze jest dodanie elementu, usunięcie elementu i sprawdzenie czy dany element jest częścią zbioru.   Zbiór jest także jednym z podstawowych pojęć matematycznych.   Algebra zbiorów   Tematem tego artykułu nie jest zbiór w kontekście matematycznym. Chciałbym jednak zwrócić Twoją uwagę na podstawowe operacje, które można przeprowadzać na zbiorach. Ta podstawowa wiedza może także przydać się w kontekście programowania.   Poza operacjami przyda się też wiedza o tak zwanym zbiorze pustym. Zbiór pusty jak sama nazwa wskazuje jest pusty, nie ma żadnego elementu.   Iloczyn   Nazywany także przecięciem dwóch zbiorów. Przecięcie to nic innego jak część wspólna dwóch zbiorów. Przecięcie dwóch zbiorów może prowadzić do uzyskania:     mniejszego podzbioru, który jest częścią wspólną obu zbiorów,   zbioru równemu obu zbiorom, jeśli oba zbiory zawierają dokładnie takie same elementy,   pustego zbioru, jeśli oba zbiory nie mają wspólnych elementów.   Iloczyn dowolnego zbioru ze zbiorem pustym zawsze jest zbiorem pustym.   Suma   Suma dwóch zbiorów to zbiór, który zawiera wszystkie elementy z obu sumowanych zbiorów.   Różnica   Różnica zbioru A i zbioru B to zbiór zawierający wszystkie elementy, które są w zbiorze A i nie ma ich w zbiorze B.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Jak działa zbiór?   W ramach tego artykułu skupię się na przykładowej implementacji, która oparta jest o funkcję skrótu (w języku Java jest to hashCode). Przedstawiona tu implementacja będzie uproszczoną wersją klasy HashSet, znajdującej się w bibliotece standardowej.   hashCode i equals   Podobnie jak w przypadku tablicy asocjacyjnej opartej o funkcję skrótu tak i tutaj hashCode i equals pełnią kluczową rolę.   Także tutaj na podstawie wartości funkcji hashCode obliczone zostanie „wiaderko”, do którego wpadnie dany element. Następnie elementy wewnątrz tego samego wiaderka porównywane będą przy pomocy metody equals. Takie podejście pozwala na uzyskanie bardzo dobrej złożoności obliczeniowej.   Podobnie jak w przypadku tablicy asocjacyjnej kluczowe jest zachowanie kontraktu pomiędzy tymi metodami.   Podstawowe operacje   Jak wspomniałem wyżej zbiór oferuje kilka podstawowych operacji. Na potrzeby tego artykułu ograniczę je do takiego interfejsu:   public interface SimpleSet&lt;E&gt; {     int size();     boolean add(E element);     boolean remove(E element);     boolean contains(E element); }      int size() – metoda zwraca liczbę elementów zbioru,   boolean add(E element) – metoda dodaje element to zbioru, zwraca true jeśli element został dodany,   boolean remove(E element) – metoda usuwa element ze zbioru, zwraca true jeśli element został usunięty,   boolean contains(E element) – metoda zwraca flagę informującą czy element istnieje w zbiorze.   Przykładowa implementacja   Podobieństwa pomiędzy HashSet i HashMap   Zacznę od krótkiego przypomnienia czym jest tablica asocjacyjna. Ta struktura pozwala na przechowywanie kluczy i odpowiadających im wartości. Implementacja HashMap zakłada, że tablica asocjacyjna zawiera unikalny zestaw kluczy. Innymi słowy nie może w niej być dwóch takich samych kluczy.   Tablica asocjacyjna, podobnie jak zbiór, nie zwraca uwagi na porządek kluczy2. Zbiór nie zawiera duplikatów, mapa nie przechowuje zduplikowanych kluczy.   Czy widzisz tu pewne podobieństwo pomiędzy zbiorem a tak zdefiniowaną tablicą asocjacyjną? Powiem więcej, bardzo często implementacje zbioru pod spodem używają tablicy asocjacyjnej.   Są też języki programowania, w których w bibliotece standardowej nie ma zbiorów a jedynie tablice asocjacyjne. Jednym z takich języków jest Go.   Kod źródłowy   Jak wspomniałem wcześniej zbiór jest bardzo podobny do tablicy asocjacyjnej. To podobieństwo jest widoczne także w przykładowej implementacji:   public class SimpleHashSet&lt;T&gt; implements SimpleSet&lt;T&gt; {     private static final Object PRESENT = new Object();      private final SimpleMap&lt;T, Object&gt; map = new SimpleHashMap&lt;&gt;();      @Override     public int size() {         return map.size();     }      @Override     public boolean add(T item) {         return map.put(item, PRESENT) == null;     }      @Override     public boolean remove(T item) {         return map.remove(item) == PRESENT;     }      @Override     public boolean contains(T item) {         return map.containsKey(item);     } }   Zauważ, że cały mechanizm związany z funkcją skrótu, kubełkami, dynamicznym rozszerzaniem pojemności zbioru jest ukryty w implementacji tablicy asocjacyjnej. Sam zbiór korzysta jedynie z publicznych metod. Jeśli nie znasz któregokolwiek z tych mechanizmów koniecznie przeczytaj artykuł o tablicy asocjacyjnej.   Interesującym zabiegiem jest tu użycie instancji PRESENT. Dzięki takiemu podejściu minimalizowana jest wielkość zbioru, istnieje tylko jeden obiekt wartości współdzielony pomiędzy wszystkimi kluczami.   Implementacja zbioru opartego o funkcje skrótu jest na tyle prosta, że zestaw testów jednostkowych ma dużo więcej linijek kodu ;).   Złożoność obliczeniowa   Złożoność obliczeniowa poszczególnych operacji odpowiada złożoności obliczeniowej tablicy asocjacyjnej. Wynika to z faktu, że każda operacja wywołuje odpowiednią metodę zaimplementowaną w tablicy asocjacyjnej.   Ma to dokładnie takie same konsekwencje jak w przypadku mapy opartej o funkcję skrótu. Jeśli funkcja skrótu jest „dobra” wówczas złożoność operacji wynosi Ο(1). Jeśli jest zła, złożoność obliczeniowa spada do Ο(n).   Dla przypomnienia możesz rzucić okiem na złożoność obliczeniową mapy.   Najczęściej zadawane pytania   Czy zbiór jest serializowalny/wielowątkowo bezpieczny/posortowany   Jak wspomniałem na początku artykułu zbiór tak na prawdę nie jest strukturą danych. Zbiór to abstrakcyjny typ danych, który może mieć wiele implementacji. Jedną z nich przedstawiłem w tym artykule. Sam zbiór nie może być serializowalny/wielowątkowo bezpieczny/posortowany, ale jego konkretna implementacja już tak. Na przykład implementacja zbioru oparta o drzewo jest posortowana, a ta oparta o funkcję skrótu już nie musi taka być.   Czym zbiór różni się od listy   Zbiór z definicji jest nieuporządkowanym zbiorem elementów, które nie mogą się powtarzać. Lista to elementy, które mogą się powtarzać. Dodatkowo lista ma swój określony porządek.   Czym zbiór różni się od tablicy asocjacyjnej   Tablica asocjacyjna zawiera unikalny zbiór kluczy, Każdy z kluczy ma przyporządkowaną wartość. Zbiór kluczy w mapie nie zawiera duplikatów. Można powiedzieć, że zbiór jest częścią mapy – zbiór nie zawiera mapowania. To podobieństwo widać w przykładowej implementacji.   Dodatkowe materiały do nauki   W artykule tylko musnąłem zagadnienia związane z matematyką. Jeśli chcesz możesz dowiedzieć się czegoś więcej o algebrze zbiorów.   Polecam lekturę dokumentacji klasy HashSet i przejrzenie implementacji HashSet w OpenJDK. Możesz też rzucić okiem na implementację zbioru opartą o drzewa.   Jak zwykle zachęcam Cię też do przejrzenia kodu źródłowego użytego w artykule.   Podsumowanie   Teraz wiesz czym jest zbiór. Znasz złożoność obliczeniową poszczególnych operacji. Znasz podstawowe operacje, które można przeprowadzać na zbiorach. Masz też pod ręką zestaw dodatkowych materiałów, które pozwolą Ci poszerzyć zdobytą wiedzę. Możesz śmiało powiedzieć, że udało Ci się poznać kolejny abstrakcyjny typ danych :).   Jeśli znasz kogoś komu materiał zebrany w tym artykule może się przydać będę wdzięczny za podzielenie się linkiem. Zależy mi na dotarciu do nowych Czytelników, a Ty możesz mi w ten sposób pomóc – z góry dziękuję!   Jeśli nie chcesz pominąć kolejnych artykułów na blogu dopisz się do samouczkowego newslettera. Możesz też polubić profil Samouczka na Facebook’u. To tyle na dzisiaj, trzymaj się i do następnego razu!                 Niektóre implementacje porządkują elementy zbioru. &#8617;                  To zależy od implementacji, na przykład TreeMap sortuje klucze a TreeSet przechowuje posortowane wartości. &#8617;           ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "/struktury-danych-zbior/",
        "teaser": "/assets/images/2019/05/07_struktury_danych_zbior_artykul.jpg"
      },{
        "title": "Podzapytania SQL",
        "excerpt":"     To jest jeden z artykułów w ramach praktycznego kursu SQL. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Każde zapytanie z kursu możesz wykonać samodzielnie. Potrzebujesz do tego środowiska opisanego w pierwszym artykule kursu. Bardzo mocno Cię do tego zachęcam. Moim zdaniem najwięcej nauczysz się samodzielnie eksperymentując z zapytaniami.     Czym jest podzapytanie   Podzapytanie to zapytanie SQL, które umieszczone jest wewnątrz innego zapytania. Podzapytanie zawsze otoczone jest parą nawiasów (). Jak zwykle spróbuję pokazać to na przykładzie. Dla przypomnienia, najprostsze zapytanie SQL może wyglądać tak:   SELECT 1;   Po wykonaniu takiego zapytania otrzymasz pojedynczy wiersz zawierający jedną kolumnę z wartością 1. Teraz trochę skomplikuję to zapytanie:   SELECT *   FROM (SELECT 1);   Efekt działania obu przykładów jest dokładnie taki sam. Drugi przykład używa podzapytania. Główne zapytanie SELECT * FROM zwraca wszystkie wiersze zwrócone przez podzapytanie SELECT 1. Przykład, który tu pokazałem jest trochę naciągany, bardziej prawdopodobny przykład może wyglądać następująco:   SELECT name   FROM artist  WHERE artistid IN (SELECT artistid                       FROM album                   GROUP BY artistid                     HAVING COUNT(*) &gt; 10);   Ponownie rozbiję to zapytanie na czynniki pierwsze. Proszę zwróć uwagę na podzapytanie:      SELECT artistid      FROM album  GROUP BY artistid    HAVING COUNT(*) &gt; 10;   To zapytanie zwraca listę identyfikatorów płodnych artystów ;). Zapytanie zwraca identyfikatory artystów z tabeli album, którzy opublikowali więcej niż dziesięć albumów.   W połączeniu z głównym zapytaniem otrzymuję nazwy artystów, którzy opublikowali więcej niż dziesięć albumów.   Podzapytania skorelowane   Poprzedni przykład pokazywał „zwykłe” podzapytania. Istnieją jeszcze tak zwane podzapytania skorelowane. Czasami nazywa się je także zapytaniami powiązanymi. Od zwykłych różnią się one tym, że są powiązane z nadrzędnym zapytaniem. Spróbuję wyjaśnić to na przykładzie:   SELECT trackid       ,albumid       ,name   FROM track AS outer_track  WHERE milliseconds &gt; (SELECT 10 * MIN(milliseconds)                          FROM track AS inner_track                         WHERE inner_track.albumid = outer_track.albumid);   To zapytanie zwraca identyfikator utworu, identyfikator albumu i tytuł utworu z tabeli track. Zwraca wyłącznie takie utwory, które są dziesięć razy dłuższe niż najkrótszy utwór z tego samego albumu. W tym przypadku podzapytanie używa dokładnie tej samej tabeli. Żeby móc odróżnić tabelę track z zapytania wewnętrznego, od tej samej tabeli w zapytaniu zewnętrznym używam aliasów – słowa kluczowego AS.   SELECT 10 * MIN(milliseconds)   FROM track AS inner_track  WHERE inner_track.albumid = outer_track.albumid;   Do tej pory w kursie posługiwałem się wyłącznie aliasami kolumn, jak widzisz istnieje także możliwość nadania aliasu tabelom.   Zapytania skorelowane nie są możliwe do wykonania bez dostępu do zapytania nadrzędnego. W tym przypadku zapytanie nie może być wykonane samodzielnie dlatego, że nie wie czym jest tabela outer_track.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Po co stosuje się podzapytania   Powtórzę jeszcze raz przykład z poprzedniego punktu:   SELECT name   FROM artist  WHERE artistid IN (SELECT artistid                       FROM album                   GROUP BY artistid                     HAVING COUNT(*) &gt; 10);   Czy można osiągnąć ten sam efekt bez podzapytania1? Oczywiście, że można. Jednym ze sposobów jest użycie stałej listy identyfikatorów artystów. Listę tych identyfikatorów zwróci zapytanie:     SELECT artistid     FROM album GROUP BY artistid   HAVING COUNT(*) &gt; 10;   ArtistId   ---------- 22         58         90      Następnie taką listę można użyć w kolejnym zapytaniu:   SELECT name   FROM artist  WHERE artistid IN [22, 58, 90];   Takie podejście ma jednak swoje wady. Jedną z nich jest to, że trzeba wykonać dwa zapytania. Kolejną jest potrzeba modyfikowania drugiego zapytania na podstawie wyników pierwszego. Co więcej taka modyfikacja nie zawsze jest możliwa – co jeśli lista zwróconych identyfikatorów miałaby kilkadziesiąt tysięcy elementów?   Podzapytania mogą mieć wiele zastosowań. Czasami osiągnięcie oczekiwanego efektu nie jest możliwe bez użycia podzapytania. Stosowanie podzapytań czasami może także prowadzić do uproszczenia finalnego zapytania.   Podzapytania mogą mieć różny wpływ na wydajność zapytania. Jeśli wydajność zapytania jest kluczowa sprawdzaj plan zapytania upewniając się czy usunięcie podzapytań mogłoby przyspieszyć jego wykonanie2.   Gdzie może występować podzapytanie   Podzapytanie może występować praktycznie wszędzie wewnątrz zapytania SQL. To gdzie podzapytanie może być użyte uzależnione jest od tego ile wartości zwraca. Jeśli podzapytanie zwraca pojedynczą wartość może być użyte jako część wyrażenia – na przykład w porównaniach, czy zwracanych kolumnach.   W przypadku gdy podzapytanie zwraca wiele wartości może być użyte na przykład w porównaniach czy jako tabela źródłowa. Poniższe przykłady powinny wyjaśnić poszczególne przypadki.   Podzapytanie wewnątrz listy pobieranych wartości   Wyobraź sobie raport, który musisz przygotować. Raport powinien zawierać wszystkie faktury klientów. Poszczególne kolumny powinny pokazywać identyfikator klienta, wartość faktury i globalną średnią wartość faktur. Tego typu problem możesz rozwiązać używając podzapytania:     SELECT customerid         ,total         ,(SELECT AVG(total)             FROM invoice) AS avg_total     FROM invoice ORDER BY customerid    LIMIT 14;   W tym przypadku podzapytanie zwraca pojedynczą wartość – globalną średnią wartość wszystkich faktur:   SELECT AVG(total)   FROM invoice;   avg(total) ---------------- 5.65194174757282   W połączeniu z zapytaniem głównym zwróci następujące wyniki:   CustomerId  Total       avg_total ----------  ----------  ---------------- 1           3.98        5.65194174757282 1           3.96        5.65194174757282 1           5.94        5.65194174757282 1           0.99        5.65194174757282 1           1.98        5.65194174757282 1           13.86       5.65194174757282 1           8.91        5.65194174757282 2           1.98        5.65194174757282 2           13.86       5.65194174757282 2           8.91        5.65194174757282 2           1.98        5.65194174757282 2           3.96        5.65194174757282 2           5.94        5.65194174757282 2           0.99        5.65194174757282   Okazuje się, że raport nie jest idealny. Lepiej wyglądałoby zestawienie wartości poszczególnych faktur ze średnią faktur dla danego klienta. W tym przypadku podzapytanie musi bazować na kolumnie dostępnej w zapytaniu głównym. Aby móc tego dokonać niezbędne jest używanie aliasów (w tym przypadku aliasów dla tabel):     SELECT customerid         ,total         ,(SELECT AVG(total)             FROM invoice AS subquery_invoice            WHERE subquery_invoice.customerid = query_invoice.customerid) AS avg_total     FROM invoice AS query_invoice ORDER BY customerid LIMIT 14;   W tym przypadku podzapytanie nadal zwraca pojedynczą wartość. Jednak tym razem wartość ta zależna jest od identyfikatora klienta znajdującego się w danym wierszu. Dla przykładu wybrałem jeden z identyfikatorów:   SELECT AVG(total)   FROM invoice AS subquery_invoice  WHERE subquery_invoice.customerid = 1;   avg(total) ---------- 5.66   Zwróć uwagę, że tym razem zapytanie główne zwraca średnią charakterystyczną dla każdego klienta (która jest rożna od średniej dla wszystkich klientów):   CustomerId  Total       avg_total ----------  ----------  ---------- 1           3.98        5.66 1           3.96        5.66 1           5.94        5.66 1           0.99        5.66 1           1.98        5.66 1           13.86       5.66 1           8.91        5.66 2           1.98        5.37428571 2           13.86       5.37428571 2           8.91        5.37428571 2           1.98        5.37428571 2           3.96        5.37428571 2           5.94        5.37428571 2           0.99        5.37428571   Drugi przypadek pokazuje podzapytanie skorelowane. To podzapytanie powiązane jest z zapytaniem głównym. W odróżnieniu od pierwszego przypadku musi zostać wykonane wiele razy. Średnia użyta w pierwszym przypadku może być obliczona dokładnie raz dla uzyskania poprawnego wyniku.   Podzapytanie wewnątrz klauzuli FROM   Wyniki podzapytania użytego wewnątrz klauzuli FROM traktowane są jakby były tabelą. Dlatego w tym przypadku podzapytanie może zwrócić wiele wartości. Kolumny użyte w podzapytaniu stają się kolumnami „tabeli” i mogą być użyte w zapytaniu głównym.   Proszę spójrz na przykład:   SELECT AVG(customer_total)   FROM (SELECT SUM(total) AS customer_total           FROM invoice       GROUP BY customerid);   Ponownie zacznę od analizy podzapytania:     SELECT SUM(total) AS customer_total     FROM invoice GROUP BY customerid;   Podzapytanie sumuje wszystkie poszczególnych klientów. Zwraca dokładnie tyle wierszy ile jest wartości kolumny customerid:   customer_total -------------- 39.62 37.62 39.62 39.62 40.62 …   Następnie taki wynik użyty jest do policzenia średniej z wszystkich sum. Ostatecznym wynikiem zapytania jest liczba pokazująca średnią sumę zamówień wszystkich klientów:   avg(customer_total) ------------------- 39.4677966101694   Podzapytania tego typu mogą być użyte w bardziej skomplikowanych zapytaniach. Proszę spójrz na przykład poniżej:   SELECT invoiceid       ,total       ,invoice.billingstate       ,billingstate_avg.state_avg   FROM (SELECT billingstate               ,AVG(total) AS state_avg           FROM invoice       GROUP BY billingstate) AS billingstate_avg JOIN invoice                                                  ON billingstate_avg.billingstate = invoice.billingstate;   Analizę ponownie zacznę od podzapytania:     SELECT billingstate         ,AVG(total) AS state_avg     FROM invoice GROUP BY billingstate;   Podzapytanie używa klauzuli GROUP BY żeby zwrócić średnią wartość zamówienia dla każdego stanu:   BillingState  state_avg ------------  ---------------               5.6930693069307 AB            5.3742857142857 AZ            5.3742857142857 BC            5.5171428571428 CA            5.5171428571428 …   Następnie takie wyniki, używając klauzuli JOIN, złączone są z tabelą invoice. Kolumną używaną do złączenia jest billingstate. Wynikiem jest zbiór wierszy zawierający faktury, które mają uzupełnioną kolumnę billingstate (efekt złączenia). Każda taka faktura zestawiona jest później ze średnią obowiązującą w danym stanie:   InvoiceId   Total       BillingState  state_avg ----------  ----------  ------------  ---------------- 4           8.91        AB            5.37428571428571 5           13.86       MA            5.37428571428571 10          5.94        Dublin        6.51714285714286 13          0.99        CA            5.51714285714286 14          1.98        WA            5.66 …   Podzapytania wewnątrz klauzuli WHERE   Podzapytanie może być także użyte do filtrowania wyników głównego zapytania. Przykład poniżej pokazuje takie zapytanie:   SELECT trackid       ,name       ,milliseconds   FROM track  WHERE milliseconds &lt; (SELECT 10 * MIN(milliseconds)                          FROM track);   W tym przypadku podzapytanie zwraca dziesięciokrotność długości najkrótszej ścieżki:   SELECT 10 * MIN(milliseconds)   FROM track;   10 * min(milliseconds) ---------------------- 10710   Następnie ten wynik użyty jest do zwrócenia ścieżek, które są krótsze od tej wartości:   TrackId     Name        Milliseconds ----------  ----------  ------------ 168         Now Sports  4884         170         A Statisti  6373         178         Oprah       6635         2461        É Uma Part  1071         3304        Commercial  7941      Możliwe jest także używanie podzapytań zwracających wiele wartości. Proszę spójrz na przykład poniżej:   SELECT trackid       ,name   FROM track  WHERE mediatypeid IN (SELECT mediatypeid                          FROM mediatype                         WHERE name LIKE '%AAC%');   W tym przypadku podzapytanie zwraca listę identyfikatorów typów których nazwa pasuje do wyrażenia '%AAC%'. Następnie te identyfikatory użyte są do odfiltrowania ścieżek, które mają odpowiednią wartość kolumny mediatypeid. Innymi słowy zapytanie zwraca ścieżki, które są w formacie pasującym do '%AAC%'.   Wyżej wspomniałem już o zapytaniach powiązanych. Musisz wiedzieć, że podzapytania powiązane mogą wystąpić także w innych miejscach. Poniżej pokazuję Ci przykład takiego podzapytania występującego w klauzuli WHERE:   SELECT albumid       ,name       ,milliseconds   FROM track AS outer_track   WHERE milliseconds &lt; (SELECT AVG(milliseconds)                          FROM track AS inner_track                         WHERE inner_track.albumid = outer_track.albumid);   W tym przypadku podzapytanie zwraca średnią długość ścieżki dla każdego albumu. Następnie wartość ta użyta jest w głównym zapytaniu. Pozwala ona zwrócić wyłącznie te wiersze, które dotyczą ścieżek o długości krótszej niż średnia z ich albumu.   Operator EXISTS   W artykule dotyczącym klauzuli WHERE pominąłem między innymi możliwość użycia operatora EXISTS. Operator EXISTS powoduje, że zwrócone są wyłącznie te wiersze, dla których podzapytanie zwróci co najmniej jeden wiersz. Proszę spójrz na przykład:   SELECT *   FROM employee AS outer_employee  WHERE EXISTS (SELECT *                  FROM employee AS inner_empolyee                 WHERE inner_employee.reportsto = outer_employee.employeeid);   W tym przypadku skorelowane podzapytanie zwraca wiersze, które połączone są relacją szef-podwładny. Wiersze, które zawierają pracowników nie posiadających podwładnych są pominięte. Dzieje się tak dlatego, że podzapytanie w ich przypadku nie zwróci ani jednego wiersza.   Operatory ALL i ANY   Operatory ALL i ANY nie są obsługiwane przez bazę SQLite.   Operatory ALL i ANY używa się w połączeniu z operatorami porównania z klauzuli WHERE.   Na przykład wyrażenie kolumna &gt; ALL (podzapytanie) oznacza, że kolumna musi mieć większą wartość niż wszystkie wartości zwrócone przez podzapytanie.   Analogicznie kolumna &lt;= ANY (podzapytanie) oznacza, że kolumna musi mieć wartość mniejszą bądź równą którejkolwiek z wartości zwróconych przez podzapytanie.   Chociaż SQLite nie wspiera tych operatorów identyczne zachowanie, w przypadku niektórych zapytań, można uzyskać stosując funkcje MIN albo MAX. Dla przykładu dwa poniższe zapytania dałyby te same wyniki:   SELECT *   FROM track  WHERE milliseconds &lt; ANY (SELECT milliseconds                              FROM track);   SELECT *   FROM track  WHERE milliseconds &lt; (SELECT MAX(milliseconds)                          FROM track);   Podzapytania jako wyrażenie   Podzapytania zwracające pojedynczą wartość mogą traktowane być jako wyrażenie. W związku z tym mogą wystąpić w innych miejscach zapytania SQL. Kilka zapytań tego typu omówiłem dokładnie w poprzednich podpunktach.   Poniżej pokazuję kilka przykładów obrazujących użycie podzapytań w innych miejscach zapytania SQL.   Podzapytania wewnątrz klauzuli ORDER BY   Dziwne, ale poprawne sortowanie:     SELECT *     FROM artist ORDER BY (SELECT MAX(albumid)             FROM album            WHERE artist.artistid = album.artistid);   Podzapytania wewnątrz klauzuli LIMIT   Ponownie dziwne, ale poprawne ograniczanie liczby wierszy:   SELECT * FROM album LIMIT (SELECT COUNT(*)                              FROM artist);   Podzapytania wewnątrz klauzuli HAVING   Tym razem podzapytanie zostało użyte do zwrócenia wierszy, dla których suma jest większa niż suma w jednym ze stanów:     SELECT customerid         ,SUM(total) AS sum_total     FROM invoice GROUP BY customerid   HAVING sum_total &gt; (SELECT SUM(total)                         FROM invoice                        WHERE billingstate = 'WA');   Podzapytania a klauzula JOIN   Często istnieje wiele sposobów na uzyskanie tych samych wyników. W przypadku niektórych podzapytań możliwe jest ich zastąpienie odpowiednimi złączeniami. Poprawne użycie klauzuli JOIN może pomóc w usunięciu niechcianego podzapytania.   Podzapytania w innych rodzajach zapytań   Do tej pory w ramach kursu SQL omawiałem wyłącznie zapytania typu SELECT. W języku SQL istnieją także inne rodzaje zapytań. Musisz wiedzieć, że także w zapytaniach typu UPDATE czy DELETE możesz spodziewać się użycia podzapytań.   Dobre praktyki przy używaniu podzapytań   To, że coś jest możliwe, wcale nie znaczy, że powinno być używane. Zapytania SQL szybko mogą stać się mało czytelne. Przez co będą trudne w zrozumieniu i późniejszym utrzymaniu. Jeśli podzapytanie wprowadza niepotrzebne zamieszanie postaraj się rozwiązać problem inaczej – czasami jest to możliwe na przykład przy użyciu klauzuli JOIN.   Ta sama klauzula może także pomóc w optymalizowaniu zapytania zawierającego podzapytania. Dobrą praktyką jest porównanie planu wykonania obu wersji zapytania. Plan zapytania możesz sprawdzić używając EXPLAIN &lt;zapytanie sql&gt;.  Podzapytanie w podzapytaniu podzapytania   Podzapytania to twory, które mogą być zagnieżdżone. W zależności od silnika bazy danych limit zagnieżdżonych podzapytań może być różny. Mimo tego, że takie konstrukcje są możliwe, w codziennej pracy nie spotkałem się za podzapytaniami zagnieżdżonymi więcej niż dwa poziomy.   Nadmierne zagnieżdżanie podzapytań nie jest dobrą praktyką. Takie łańcuszki nie poprawiają czytelności zapytania. Dodatkowo powoduje problemy z jego utrzymaniem. Jeśli musisz stosować więcej niż jeden, dwa poziomy zagnieżdżenia zastanów się czy nie można rozwiązać tego problemu inaczej.   Zadania do wykonania   Poniżej przygotowałem dla Ciebie zestaw kilku zadań, które pozwolą Ci sprawdzić wiedzę dotyczącą podzapytań w praktyce. Zanim zerkniesz do przykładowego rozwiązania zachęcam się do samodzielnej próby rozwiązania zadań – w ten sposób nauczysz się najwięcej.   Napisz zapytanie używając podzapytań, które zwróci:      sumaryczną wartość (kolumna total) faktur (tabela invoice), których kwota jest powyżej średniej wartości wszystkich faktur,   średnią liczbę albumów (tabela album) dla artystów, którzy opublikowali więcej niż dwa albumy,   wiersze zawierające identyfikator klienta (kolumna customerid) i wartość faktur ponad średnią wartość faktur danego klienta (wartość - średnia). Zapytanie powinno zwrócić wyłącznie wiersze gdzie ta różnica jest większa od 0,   te same wyniki, które zwraca zapytanie poniżej bez użycia klauzuli JOIN:       SELECT name   FROM artist JOIN album              ON artist.artistid = album.artistid GROUP BY name   HAVING COUNT(*) &gt; 10;           te same wyniki, które zwraca zapytanie poniżej bez użycia klauzuli JOIN:     SELECT invoiceid    ,total    ,invoice.billingstate    ,billingstate_avg.state_avg   FROM (SELECT billingstate            ,AVG(total) AS state_avg        FROM invoice    GROUP BY billingstate) AS billingstate_avg JOIN invoice                                               ON billingstate_avg.billingstate = invoice.billingstate;           Przykładowe rozwiązania zadań  1.  SELECT SUM(total)   FROM invoice  WHERE total &gt; (SELECT AVG(total)                   FROM invoice);  2.  SELECT AVG(how_many)   FROM (SELECT COUNT(*) AS how_many           FROM album       GROUP BY artistid         HAVING how_many &gt; 2);  3.  SELECT customerid       ,(total - (SELECT AVG(total)                    FROM invoice AS i2                   WHERE i1.customerid = i2.customerid)) AS above_average   FROM invoice AS i1  WHERE above_average &gt; 0;  4.  SELECT name   FROM artist  WHERE artistid IN (SELECT artistid                       FROM album                   GROUP BY artistid                     HAVING COUNT(*) &gt; 10);  5.  SELECT invoiceid       ,total       ,billingstate       ,(SELECT AVG(total) AS state_avg           FROM invoice          WHERE billingstate = outer.billingstate)   FROM invoice AS outer  WHERE billingstate IS NOT NULL;   Podsumowanie   Po lekturze artykułu wiesz już czym są podzapytania. Wiesz doskonale gdzie można ich używać. Udało Ci się także poznać kilka dobrych praktyk dotyczących używania podzapytań. Po samodzielnym rozwiązaniu zadań możesz śmiało powiedzieć, że potrafisz posługiwać się podzapytaniami.   Artykuł ten zamyka część kursu poświęconą zapytaniom typu SELECT. W kolejnych częściach kursu poznasz pozostałe elementy języka SQL niezbędne do codziennej pracy.   Mam nadzieję, że artykuł przypadł Ci do gustu. Udało Ci się rozwiązać zadania? Podziel się swoimi rozwiązaniami! Spojrzenie na ten sam problem z innego punktu widzenia pozwoli wszystkim na nauczenie się jeszcze więcej.   Zależy mi na dotarciu do nowych Czytelników, jeśli uważasz, że ten artykuł byłby wartościowy dla kogoś z Twoich znajomych bardzo proszę podziel się z nim odnośnikiem do tego artykułu. Z góry dziękuję!   Jeśli nie chcesz ominąć kolejnych artykułów w przyszłości proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebook’u. Trzymaj się i do następnego razu!                 Dla uproszenia pominę tu możliwość użycia klauzuli JOIN. &#8617;                  Możliwe, że silnik bazy danych, której używasz użyje dokładnie takiego samego planu zapytania zarówno przy użyciu podzapytań jak i klauzuli JOIN. &#8617;           ","categories": ["Bazy danych","Kurs SQL"],
        "tags": [],
        "url": "/podzapytania-sql/",
        "teaser": "/assets/images/2019/08/19_podzapytania_sql_artykul.jpg"
      },{
        "title": "Podstawy UML",
        "excerpt":"W artykule opisuję wyłącznie moje doświadczenia. Możliwe, że ktoś ma zupełnie inne. Z chęcią poznam Twój punkt widzenia w komentarzach. Proszę weź też pod uwagę to, że lepiej czuję się w mniejszych firmach niż ustrukturyzowanych korporacjach – ma to wpływ na moje zdanie na temat UML’a.   Jak mówi znane powiedzenie „jeden obraz jest wart tysiąca słów”. Takie przypadki zdarzają się także w programowaniu. Często w trakcie projektowania czy rozmawiania na temat fragmentu oprogramowania programistom dużo łatwiej jest się porozumieć rysując. Takie rysunki mogą opisywać ogólną architekturę projektu, sposób podejścia do rozwiązania, kolejność zdarzeń w ramach procesu itd. Dobrze jest mieć wspólny język. W tym przypadku pomocny może być UML.   Czym jest UML   UML to akronim pochodzący od angielskiego określenia Unified Modeling Language. W polskim tłumaczeniu znany jest jako zunifikowany język modelowania. UML to jasno wyspecyfikowany język składający się z kilkunastu diagramów. Diagramy te pozwalają na formalne opisywanie i modelowanie struktur czy procesów.   Czy warto uczyć się UML’a   Odpowiadając na tak postawione pytanie w jednym zdaniu mogę powiedzieć, że z mojego doświadczenia UML jest ważny i warto znać jego podstawy. Chociażby po to żeby rozszerzyć swój „słownik”, który później możemy użyć w trakcie rozmowy na temat programowania z inną osobą. UML to kolejne narzędzie, które możesz używać w odpowiednich sytuacjach. Rysunek, który usuwa zbędne szczegóły pokazując najbardziej istotne aspekty jest niezastąpiony.   Jednak to tylko część rzeczywistości. UML jest ważny, między innymi z wyżej wspomnianych powodów. Jednak ten sam UML to kobyła. Specyfikacja UML w wersji 2.5.1 zawiera 754 strony! Pracując jako programista od 2007 roku w całej swojej karierze nie spotkałem ani jednej osoby, która fanatycznie przestrzegałaby reguł opisujących UML’a1. Część funkcjonalność UML’a bardzo rzadko albo w ogóle nie jest wykorzystywana w praktyce.   Innymi słowy: tak, warto poznać UML’a, jednak wybiórczo.   Czy UML jest używany w pracy związanej z oprogramowaniem   Na początku muszę powiedzieć Ci trochę o moich doświadczeniach. Po kilku latach pracy zauważyłem, że nie czuję się dobrze w korporacjach. Projekty, które wykorzystują „ciężkie metodologie” do ich prowadzenia też raczej nie są dla mnie. Mimo pracy jako programista od 2007 roku doświadczyłem wyłącznie niedużej części dużego świata firm IT. Bardzo możliwe, że w środowisku, którego nie lubię nacisk na „czystego UML’a” jest większy.   Z mojego doświadczenia UML jest wykorzystywany w nieformalny sposób. To tak jak z językiem obcym – najważniejsza jest komunikacja. Możesz robić mnóstwo błędów, jeśli jednak potrafisz się dogadać z drugą stroną to jesteś w domu. Właśnie komunikacja i umiejętność przekazywania informacji jest tu kluczowa. Innymi słowy jeśli będziesz znać podstawy najbardziej istotnych diagramów, to ta wiedza powinna być wystarczająca.   Taki punkt widzenia potwierdza też badanie przeprowadzone na grupie programistów, testerów, architektów czy kierowników projektów2. Wynik przeprowadzonej ankiety potwierdza, że UML używany jest raczej nieformalnie.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Narzędzia   UML to diagram, rysunek. Do efektywnej pracy przyda Ci się zestaw narzędzi pozwalający tworzyć te diagramy.   Przede wszystkim polecam tablicę i marker (lub kartkę i długopis). To zdecydowanie najczęściej używane narzędzia przy pracy z nieformalnymi diagramami.   W trakcie pracy nad Samouczkiem, szczególnie pracując na artykułami dotyczącymi wzorców projektowych używam programów UMLet i yED. Są to darmowe programy, które pozwalają na tworzenie niektórych rodzajów diagramów UML. Istotne w nich dla mnie jest to, że same programy są proste a tworzone diagramy zapisane są w postaci tekstowej (można je eksportować do formatów graficznych). Format tekstowy świetnie nadaje się do zapisania w repozytorium git’a.   Istnieje całkiem sporo narzędzi, które mają dużo większe możliwości, jednak dla komercyjnych zastosowań są płatne.   Najczęściej używane diagramy UML   Wspominałem to już wcześniej, jednak powtórzę to po raz kolejny. Poniżej prezentuję wyłącznie podzbiór diagramów. Skupiam się wyłącznie na tych, które doczekały się swojego praktycznego zastosowania w mojej dotychczasowej pracy komercyjnej. Pomijam diagramy, które wymagane były tylko w trakcie projektów na uczelni. Dodatkowo nie opisuję tu wszystkich możliwości, a jedynie te najczęściej używane.   Poniżej pokazałem diagram UML, który zawiera wszystkie dostępne diagramy. Na zielono oznaczyłem wyłącznie te, które opisuję w tym artykule:             Diagramy w UML        Diagram klas   Diagram klas (ang. class diagram) to chyba najczęściej używany diagram. Służy do pokazania klas i zależności między nimi. Pozwala na szczegółowy opis klas zwracając uwagę na dostępne atrybuty i operacje. Ta szczegółowość pozwala na generowanie kodu na podstawie kompletnego diagramu. W praktyce nigdy nie spotkałem się z takim zastosowaniem. Diagram klas pozwala na „narysowanie” wycinka większego systemu. Jest on jednym z najbardziej rozbudowanych diagramów w notacji UML.   Klasa   Zacznę od pokazania symbolu klasy:             Klasa w diagramie klas        Klasa reprezentowana jest przez prostokąt podzielony na kilka części. W pierwszej z nich znajduje się nazwa klasy. W przykładzie jest to Customer. Następna sekcja zawiera atrybuty, kolejna metody.   Elementy, które są podkreślone oznaczają elementy statyczne. Na przykład atrybut DEFAULT_PROMO_CODE jest statycznym atrybutem klasy. Elementy pisane kursywą są abstrakcyjne (może dotyczyć także samej klasy), na przykład metoda fetchPromoCode jest abstrakcyjna.   Zarówno atrybuty jak i operacje mogą być poprzedzone symbolem. Dopuszczalne są między innymi:      + – element publiczny,   # – element „chroniony” (może odpowiadać protected w języku Java),   - – element prywatny.   Klasa w przykładzie ma cztery atrybuty. Trzy atrybuty instancji i jeden atrybut klasy (statyczny). Atrybuty zapisywane są w formacie nazwa:typ. Ta sama klasa ma trzy metody. Prywatną metoda modifyOrderStats i dwie metody publiczne. Zwróć uwagę na to, że metody mogą mieć określone typy parametrów i wartości zwracanej.   W podobny sposób oznacza się interfejs. W odróżnieniu od klasy zawiera on tak zwany stereotyp «interface». Na diagramie powyżej NotificationPipe jest interfejsem zawierającym dwie metody. Zauważ, że w tym przypadku pominąłem symbole określające dostępność metod.   Atrybuty klas mogą być także opisane przez relacje pomiędzy klasami.   Relacje   Pomiędzy klasami mogą występować relacje. Przykładem relacji jest dziedziczenie. Relacje reprezentowane są przez różne symbole. Proszę spójrz na rysunek poniżej, na którym zebrałem możliwe relacje:             Przykładowe pomiędzy klasami        Zacznę od lewej kolumny. Pierwsza przerywana strzałka reprezentuje implementację. Jest używana do tego żeby pokazać jaki interfejs jest implementowany przez klasę. Druga oznacza dziedziczenie. W tym przypadku grot wskazuje klasę nadrzędną.   W prawej kolumnie znajdują się strzałki pokazujące relacje pomiędzy klasami inne niż implementacja czy dziedziczenie. Posegregowałem je w rosnąco według tego jak silne są relacje przez nie opisywane.   Relacje ze strzałkami mogą być jednokierunkowe albo dwukierunkowe. W przypadku relacji jednokierunkowej strona bez grota używa strony, na którą pokazuje grot. W przypadku braku grota relacja jest dwukierunkowa. Trochę inaczej sprawa wygląda z rombami. Opiszę to jak poznasz rodzaje relacji.   Najsłabszą relacją pomiędzy klasami jest zależność. Reprezentowana jest przez przerywaną linię. Zależność oznacza, że jedna klasa w pewnym momencie używa innej, na przykład jako parametr, czy wartość zwracana metody. W przypadku zależności klasa, od której zależymy nie jest zapisana jako atrybut. Przykładem zależności w bibliotece standardowej Javy może być zależność Integer od String, widać ją na przykład w metodzie Integer.valueOf(String).   Kolejnym rodzajem relacji jest asocjacja. W tym przypadku jest to zapis, który może zastąpić atrybut klasy – jeśli nie chcesz dodawać atrybut w prostokącie reprezentującym klasę możesz użyć asocjacji. Przykładem asocjacji w bibliotece standardowej Javy może być FileInputStream i String. Klasa FileInputStream posiada atrybut typu String reprezentujący ścieżkę do pliku.   Kolejną relacją jest agregacja. Agregacja wprowadza w relacji stronę, która jest „właścicielem”. Jedna klasa agreguje inną. Relacja tego typu oznaczona jest przez ciągłą linię z pustym rombem po stronie właściciela. W bibliotece standardowej tego typu relacja występuje pomiędzy ArrayList a klasą, której instancje przechowuje3.   Ostatnią relacją jest kompozycja. Kompozycja jest bardzo podobna do agregacji. Jest między nimi jedna znacząca różnica. W przypadku kompozycji „właściciel” jest odpowiedzialny za tworzenie (cykl życia) elementów, które grupuje. Przykładem kompozycji w bibliotece standardowej Javy może być implementacja HashMap, która zarządza elementami w kolekcji opakowując je w instancje HashMap.Node, które tworzy.   Proszę spójrz na diagram poniżej (dla czytelności pominąłem w nim atrybuty i operacje). Pokażę Ci na nim przykładowe relacje pomiędzy klasami:             Możliwe relacje pomiędzy klasami           klasa LargeItem implementuje interfejs Item – implementacja,   klasy VIP i OrdinaryCustomer dziedziczą po klasie abstrakcyjnej Customer – dziedziczenie,   klasa OrderCalculator używa klasy Basket – zależność,   klasa Basket wie o kliencie z którym jest powiązana (klasie Customer), odwrotne stwierdzenie także jest prawdziwe – asocjacja,   klasa Basket może zawierać wiele instancji klasy Item – agregacja,   klasa VIP zawiera wiele instancji klasy BonusCode i zarządza ich cyklem życia – kompozycja.   Wiesz już, że strzałeczka oznacza kierunek relacji. Na przykład asocjacja pomiędzy ItemBundle a Item jest jednokierunkowa. ItemBundle wie o powiązanej klasie Item, Item zaś nie wie nic o ItemBundle. Jeśli strzałeczka nie jest umieszczona oznacza to, że relacja jest dwukierunkowa – można „przejść” z jednej klasy do drugiej w obu kierunkach4.   Trochę inaczej wygląda sprawa w relacjach agregacji i kompozycji. W tym przypadku romby oznaczają stronę, która agreguje drugą stronę relacji. Na powyższym przykładzie klasa VIP zarządza cyklem życia BonusCode. BonusCode nic nie wie o klasie VIP.   Nowością dla Ciebie jest także komentarz do relacji (contains), który może ją opisywać. Nowe są także oznaczenia pokazujące liczność. W powyższym przykładzie jeden koszyk może zawierać wiele elementów (0..*).   Relacje dwukierunkowe   Wiesz już jak oznaczana jest dwukierunkowa relacja zależności. Na przykładzie wyżej pokazałem ją pomiędzy klasami Customer i Basket. W praktyce występują też bardziej zagmatwane przypadki. Wyobraź sobie klasę reprezentująca książkę – Book. Książka ma autora – Author. Jedna książka może być napisana przez wielu autorów, a jeden autor może napisać wiele książek. To klasyczna relacja „wiele do wielu”.   Często tego typu relacje wprowadzają nową klasę, która reprezentuje samą relację. W tym przypadku byłoby to autorstwo – Authorship. Poniższy diagram pokazuje przykładowe sposoby przedstawienia sytuacji tego typu na diagramie UML5.             Przykład relacji dwukierunkowych        W pierwszym przypadku Author przechowuje kolekcję Book i zarządza ich cyklem życia. Book wie o liście swoich autorów.   W drugim przypadku Author przechowuje kolekcję swoich „autorstw”. Podobną kolekcję przechowuje także Book.   Diagram komponentów   Wiesz już, że diagram klas pozwala zobaczyć powiązania pomiędzy klasami w wąskiej części systemu. Diagram komponentów (ang. component diagram) pozwala spojrzeć na projekt z większej odległości. W diagram komponentów kluczową rolę odgrywają komponenty. Proszę spójrz na przykładowy symbol komponentu:             Przykładowy komponent        Jak widzisz komponent to prostokąt ze specyficzną ikonką w prawym górnym rogu. Komponent na rysunku wymaga jeden interfejs i sam dostarcza dwa. Komponent UserManagement wymaga dostępu do interfejsu persistence a sam zapewnia dwa inne register i ban.   Interfejs to kreska z kółkiem (interfejs udostępniany przez komponent) lub kreska z półkolem (interfejs wymagany przez komponent). Relacje pomiędzy komponentami odbywają się poprzez interfejsy. Można powiedzieć, że komponenty łączy relacja zależności – najsłabsza z typów relacji występująca w diagramie klas.   Czym jest komponent   Wiesz już jak wygląda symbol komponentu i interfejsów. Tylko czym ten komponent właściwie jest? Cytując za specyfikacją:      A Component represents a modular part of a system that encapsulates its contents and whose manifestation is replaceable within its environment.    Powyższe zdanie można przetłumaczyć jako: komponent reprezentuje wydzieloną, opakowaną część systemu, której reprezentacja jest wymienna w ramach swojego środowiska.   A teraz raz jeszcze, moimi słowami. Komponent to część systemu, która ma swoje interfejsy. Interfejsy czyli dokładnie określone sposoby komunikacji. Interfejsy służą do komunikacji z pozostałymi komponentami. Każdy z komponentów można zastąpić inną implementacją. Istotne jest to, że każda implementacja musi spełniać wymagania dotyczące jego interfejsów.   Jak widzisz definicja komponentów jest dość luźna. Do tego worka można wsadzić bardzo dużo rzeczy. Zaczynając od rozbudowanej implementacji w jednej klasie, poprzez ich zestaw znajdujący się w jednym pakiecie/module a na sporej części aplikacji kończąc. Ty jako autor diagramu sam decydujesz o tym do jakiego poziomu komponentów chcesz zejść. Istotne jest to, żeby poziom ten był spójny i prezentował wszystkie komponenty na diagramie „z podobnej odległości”.   Przykładowy diagram komponentów   Proszę spójrz na przykładowy diagram komponentów systemu, który może być odpowiedzialny za rezerwację biletów lotniczych:   Możesz na nim zobaczyć kilka komponentów, które są od siebie zależne. Każdy z nich definiuje interfejsy, które pozwalają komunikować się z innymi komponentami. Dla uproszczenia pominąłem opisowe nazwy interfejsów:             Przykładowy diagram komponentów        Diagram wdrożenia   Przedstawiłem Ci już diagram klas i diagram komponentów. Wiesz już, że na system można spojrzeć z różnej odległości zwracając uwagę na coraz mniej szczegółów. Kolejnym stopniem ukrywającym szczegóły może być diagram wdrożenia (ang. deployment diagram).   Każdy działający projekt/aplikacja składa się z dwóch niezbędnych elementów. Oprogramowania (ang. software) i sprzętu (ang. hardware). Zauważ, że żaden z powyżej omówionych diagramów nie poruszał tematyki sprzętu. Tę lukę wypełnia diagram wdrożenia. Diagram wdrożenia służy do odwzorowania zależności pomiędzy oprogramowaniem i/lub sprzętem. To właśnie na diagramie wdrożenia można pokazać sposób w jaki aplikacja/projekt powinien być zainstalowany/wdrożony.   Także tutaj specyfikacja UML pozwala na dużą dowolność jeśli chodzi o szczegóły. Ty jako autor diagramu decydujesz, czy potrzebna jest dokładna specyfikacja poszczególnych elementów sprzętowych, czy zgrubna informacja w zupełności wystarczy.   Na początku swojej przygody z programowaniem ten diagram nie będzie Ci do niczego potrzebny. W późniejszym czasie bardzo pomoże Ci przy rozmowach na temat sposobu wdrożenia projektu.   Elementy diagramu wdrożenia   Przykład poniżej pokazuje elementy, które możesz spotkać na diagramach wdrożenia:             Elementy diagramu wdrożenia        Kolejno od lewej na rysunku możesz zobaczyć:      serwer typu n2-highmem-64,   element o nazwie Nginx, który reprezentuje serwer HTTP,   element Deployment, który wewnątrz zawiera artefakt o nazwie Artifact.   Zauważ, że podobnie jak w przypadku diagramu klas wstępują tu stereotypy, które dodają informacje. Mimo tego, że poszczególne części diagramu reprezentują zupełnie różne rzeczy, UML stosuje jedną graficzną reprezentację. W przypadku tego diagramu zupełnie nie przejmowałbym się sugestiami specyfikacji – w praktyce często spotyka się różnego rodzaju ikonki, które pozwalają lepiej zobrazować poszczególne elementy.   Przykładowy diagram wdrożenia   Proszę spójrz na przykład poniżej, który mógłby być diagramem wdrożenia dla aplikacji pozwalającej na rezerwację biletów:             Przykładowy diagram wdrożenia        Na diagramie wyżej możesz zobaczyć kilka oddzielnych klastrów (zestawów maszyn), przeznaczonych do wdrożenia poszczególnych komponentów. Kreski łączące komponenty obrazują powiązania między nimi.   Diagram sekwencji   Trzy poprzednie diagramy dotyczyły relacji pomiędzy elementami. Diagram sekwencji (ang. sequence diagram) jest jednym z tak zwanych diagramów interakcji. Kładzie on nacisk na komunikację, która odbywa się pomiędzy poszczególnymi klasami/obiektami. Diagram sekwencji pokazuje dokładnie sekwencję wykonania metod w poszczególnych obiektach. Diagram ten przydaje się do pokazania przebiegu skomplikowanej komunikacji.   Elementy diagramu sekwencji   Każdy z obiektów reprezentowany jest jako prostokąt połączony z pionową kreską. Ta linia oznacza „linię życia” – czas życia obiektu. Na diagramie może występować także tak zwany aktor. Aktor to człowiek albo system, który może brać udział w komunikacji. Proszę spójrz na przykład:             Przykładowy diagram sekwencji        Wąskie pionowe prostokąty na liniach życia oznaczają czas, w którym dany aktor/obiekt był aktywny. Aktywność była niezbędna do wypełnienia żądania, które dany obiekt wysłał/otrzymał.   Niektóre obiekty mogą żyć krócej niż pozostałe. Koniec życia obiektu zaznaczany jest przez znak X na ich linii życia.   Diagram, który pokazałem powyżej może służyć jako przykład opisujący mechanizm wysyłania wiadomości e-mail. Na początku aktor inicjalizuje proces, Instance 1 obsługuje akcję sendEmail przekazując ją asynchronicznie do Instance 2. Następnie dwukrotnie sprawdza czy wysłanie wiadomości się powiodło, po czym zwraca informację do aktora.   Rodzaje komunikatów   Wiesz już, że pionowe kreski oznaczają linię życia. Im wyżej na diagramie, tym wcześniej coś się wydarzyło. Poziome kreski oznaczają komunikaty. Jak widzisz istnieje kilka rodzajów komunikatów:             Rodzaje komunikatów        Strzałki w lewej kolumnie oznaczają komunikaty synchroniczne. Strzałka z ciągłą liną oznacza wysłanie komunikatu, strzałka z przerywaną linią otrzymanie odpowiedzi. W prawej kolumnie pokazałem strzałkę reprezentującą asynchroniczne wysłanie komunikatu.   Dodatkowe materiały do nauki   Jak wspomniałem na początku artykułu nie było moim zamiarem wyczerpanie tematu. Celowo skupiłem się wyłącznie na diagramach, które moim zdaniem są najczęściej używane. Ponadto pominąłem sporą część możliwości, których nie używałem w praktyce. Właśnie te diagramy były dla mnie najbardziej przydatne w sesjach przy tablicach z kolegami z pracy. Jeśli jednak temat UML Cię zainteresował zapraszam Cię do zapoznania się z zestawem materiałów dodatkowych. Zacznę od materiałów oficjalnych:      Oficjalna strona UML’a,   Specyfikacja UML 2.5.1 – jest niezastąpiona jeśli potrzebujesz zajrzeć do źródła i chcesz poznać wszystkie szczegóły, w innym przypadku gorąco nie polecam.   Dodatkowo mam dla Ciebie artykuł podsumowujący badanie na temat użycia diagramów w praktyce.   Uczelnie techniczne często mają osobne kursy poświęcone tematyce UML’a. Czasami jest też tak, że UML zajmuje część wykładu dotyczącego na przykład inżynierii oprogramowania. Przygotowałem dla Ciebie zestaw odnośników do materiałów przygotowanych na uczelniach:      Fragment wykładu z UW dotyczący UML’a część I,   Fragment wykładu z UW dotyczący UML’a część II,   Opis diagramu klas w materiałach dla studentów AGH,   Opis diagramu komponentów w materiałach dla studentów AGH,   Opis diagramu wdrożenia w materiałach dla studentów AGH,   Opis diagramu sekwencji w materiałach dla studentów AGH,   Na koniec zestawienie linków do artykułów na Wikipedii:      Artykuł o UML na polskiej Wikipedii,   Artykuł o UML na angielskiej Wikipedii,   Diagram klas na angielskiej Wikipedii,   Diagram klas na polskiej Wikipedii,   Diagram komponentów na angielskiej Wikipedii,   Diagram wdrożenia na angielskiej Wikipedii,   Diagram sekwencji na angielskiej Wikipedii.   Podsumowanie   Znasz już mój punkt widzenia dotyczący UML’a. Wiesz, że moim zdaniem warto znać podstawy tego języka. Mogą Ci się one przydać w codziennej pracy. Jeśli lubisz pracować w bardziej formalnym środowisku może się okazać, że UML będzie niezastąpiony. Znasz kilka rodzajów diagramów, które mogą być przydatne. Znasz także darmowe narzędzia, które pozwalają na tworzenie diagramów UML.   Mam nadzieję, że artykuł przypadł Ci do gustu. Proszę daj znać w komentarzach co sądzisz o UML’u. Czy Twoim zdaniem znajomość tego języka przydaje się w codziennej pracy? A może to już tylko zaszłość, która powoli odchodzi do lamusa? Jestem ciekawy Twoje opinii.   Dodatkowo, jak zwykle, proszę Cię o podzielenie się odnośnikiem do artykułu ze swoimi znajomymi. W ten sposób pomożesz mi dotrzeć do nowych Czytelników, za co z góry Ci dziękuję. Jeśli nie chcesz pomiąć kolejnych artykułów proszę zapisz się do samouczkowego newslettera i polub Samouczka na Facebook’u. To tyle na dzisiaj, trzymaj się i do następnego razu!                 Sam też nie mogę ich fanatycznie przestrzegać – nie znam tej specyfikacji wystarczająco dokładnie. &#8617;                  Swoją drogą badanie było przeprowadzone na dość małej grupie kontrolnej. W związku z tym jest ryzyko, że wyniki nie są w pełni miarodajne. &#8617;                  Tak na prawdę ArrayList zawiera tablicę instancji typu Object, to dzięki typom generycznym na zewnątrz widoczna jest inna klasa. &#8617;                  Można powiedzieć, że to swego rodzaju uproszczenie. Tak naprawdę to można „przejść” z instancji jednej klasy do drugiej i odwrotnie. &#8617;                  Do tego dochodzi jeszcze modelowanie relacji tego typu w relacyjnych bazach danych, jednak to jest już zupełnie inna para kaloszy i temat na osobny artykuł ;). &#8617;           ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "/podstawy-uml/",
        "teaser": "/assets/images/2019/09/21_podstawy_uml_artykul.jpeg"
      },{
        "title": "Wzorzec projektowy dekorator",
        "excerpt":"Czytasz jeden z artykułów opisujących wzorce projektowe. Jeśli interesuje Cię ten temat zapraszam Cię do lektury pozostałych artykułów, które powstały w ramach tej serii – wzorce projektowe. W zrozumieniu artykułu przyda Ci się wiedza dotycząca podstaw UML’a.   Problem do rozwiązania   Wyobraź sobie restaurację, w której możesz zjeść pizzę. Właściciel restauracji daje Ci do wyboru 10 różnych dodatków. Możesz skomponować pizzę samodzielnie używając dostępnych dodatków. Każdy z dodatków ma swoją cenę i może być użyty wyłącznie jeden raz. Właściciel restauracji mógłby wypisać wszystkie kombinacje z tych 10 dodatków. Menu miałoby wtedy 1023 pozycje, 1024 jeśli wliczymy Margharitę… Trochę dużo ;).   Właściciel podszedł do sprawy inaczej. Nadal daje Ci dowolność w wyborze dodatków, jednak wycenia każdy z nich jako osobną pizzę. Na przykład pizza z szynką, pizza z bazylią, pizza z mozzarellą i tak dalej. Następnie pozwala Ci łączyć ze sobą te pizze w dowolny sposób. Na przykład pizza bez żadnych dodatków kosztuje 15zł. Pizza z szynką kosztuje o 7 zł więcej niż pizza bazowa. Pizza z bazylią kosztuje o 2 zł więcej niż pizza bazowa.   Dzięki takiemu podejściu w menu znajduje się 11 pozycji. Cena pizzy bez dodatków i cena każdego dodatku określona jako cena pizzy bazowej + X zł. Można powiedzieć, że właściciel restauracji użył wzorca dekoratora do opracowania cennika1.   Podobne problemy występują w projektach informatycznych. Zdarzają się sytuacje, w których trzeba rozszerzyć działanie pewnego obiektu. Możliwych rozszerzeń jest wiele, jeszcze więcej jest kombinacji tych rozszerzeń. Z pomocą w rozwiązaniu tego problemu przychodzi wzorzec projektowy dekorator (ang. decorator2).   Wzorzec dekorator   Diagramy klas   Istnieje wiele możliwości implementacji tego wzorca projektowego. Diagram klas poniżej pokazuje najprostszą z nich:             Wzorzec projektowy dekorator (ang. decorator)        DecoratorA i DecoratorB dekorują klasę Component. Dekoratory zawierają instancję klasy Component.   Często ten wzorzec projektowy przedstawiany jest w bardziej skomplikowany sposób:             Wzorzec projektowy dekorator (ang. decorator)        W tym przypadku dekoratory mają wspólnego przodka, abstrakcyjną klasę Decorator. Sam komponent, który jest dekorowany także jest klasą abstrakcyjną, która posiada swoje konkretne implementacje. Na diagramie wyżej jest to ConcreteComponent.   Nie są to jedyne możliwe wersje implementacji tego wzorca. Przykładem innej implementacji może być użycie interfejsów w miejscu klasy komponentu. Inną modyfikacją może być użycie kompozycji w miejscu agregacji. Obie zmiany nie wpływają znacząco na implementację tego wzorca projektowego.   Wzorzec projektowy dekorator pozwala na wielokrotne rozszerzenie funkcjonalności obiektu poprzez „nakładanie” na siebie dekoratorów.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Przykładowa implementacja dekoratora   Zacznę od pizzy bazowej:   public class Pizza {     private static final BigDecimal BASE_PRICE = new BigDecimal(12);      public BigDecimal getPrice() {         return BASE_PRICE;     }      @Override     public String toString() {         return \"Pizza\";     } }   Ot, zwykła klasa, która reprezentuje podstawową pizzę. Posiada metodę getPrice, która zwraca jej cenę.   Poniżej możesz zobaczyć jeden z dekoratorów. W tym przypadku jest to pizza z mozzarellą:   public class PizzaWithMozzarella extends Pizza {     private static final BigDecimal MOZZARELLA_PRICE = new BigDecimal(5);     private final Pizza basePizza;      public PizzaWithMozzarella(Pizza basePizza) {         this.basePizza = basePizza;     }      @Override     public BigDecimal getPrice() {         return basePizza.getPrice().add(MOZZARELLA_PRICE);     } }   PizzaWithMozzarella w konstruktorze przyjmuje jako parametr instancję klasy Pizza, którą opakowuje. Następnie używa jej do obliczenia ceny pizzy z mozzarellą dodając do ceny pizzy bazowej cenę sera.   W tym przypadku klasa Pizza odpowiada klasie Component z diagramu UML, a klasa PizzaWithMozzarella reprezentuje DecoratorA.   Poniżej możesz zobaczyć użycie dekoratorów w praktyce. Opakowując kolejne pizze w dekoratory otrzymuję coraz bardziej skomplikowane pozycje. Dzięki takiemu podejściu mogę łączyć dodatki w dowolny sposób:   public class Restaurant {     public static void main(String[] args) {         Pizza margherita = new Pizza();         Pizza withMozzarella = new PizzaWithMozzarella(margherita);         Pizza withMozzarellaAndHam = new PizzaWithHam(withMozzarella);         Pizza withMozzarellaHamAndBasil = new PizzaWithBasil(withMozzarellaAndHam);          DecimalFormat df = new DecimalFormat(\"#,00 zł\");         for (Pizza pizza : List.of(margherita, withMozzarella, withMozzarellaAndHam, withMozzarellaHamAndBasil)) {             System.out.println(String.format(\"%s costs %s.\", pizza, df.format(pizza.getPrice())));         }     } }   Dodatkowe rozważania   Zalety   Jedną z często polecanych praktyk w programowaniu obiektowym jest preferowanie kompozycji przed dziedziczeniem. Wzorzec projektowy dekorator jest flagowym przykładem użycia tej reguły. Takie podejście pozwala na dynamiczne rozszerzanie funkcjonalności obiektu bez potrzeby kompilacji kodu.   Niewątpliwą zaletą dekoratora jest możliwość dowolnego łączenia istniejących dekoratorów. Każdy z nich będzie opakowywał kolejny obiekt nie mając świadomości, że jest kolejnym dekoratorem w kolejce. Jest to istotne w przypadku gdy istnieje kilka dodatkowych funkcjonalności, które powinna zawierać rozszerzana klasa.   Wady   Interfejs dekoratora musi być dokładnie taki sam jak klasy dekorowanej. W niektórych językach programowania (na przykład w Javie) może prowadzić to do klas, które mają sporo metod, których implementacja polega na przekazaniu wywołania do dekorowanego obiektu (jeśli dekorator implementuje interfejs). Tę wadę można rozwiązać stosując dziedziczenie3.   Dekorator często jest „płaską klasą”. Rozszerza on dekorowaną klasę o jedną, podstawową funkcjonalność. Prowadzić to może do sytuacji, w której system zawiera wiele niewielkich klas. W sytuacji gdy zazwyczaj używa się stałego zbioru dekoratorów użycie standardowego dziedziczenia może ograniczyć tę liczbę.   Przykłady użycia wzorca dekorator   W przypadku języka Java wzorzec projektowy dekorator jest dość często używany w bibliotece standardowej. Za przykład mogą tu posłużyć strumienie wykorzystywane przy operacjach na plikach. InputStream jest klasą abstrakcyjną, która posiada wiele dekoratorów, na przykład FileInputStream czy BufferedInputStream.   Innym przykładem, również z języka Java, mogą być dekoratory kolekcji. Dekoratory te na przykład pozwalają na utworzenie kolekcji, która jest synchronizowana czy niemodyfikowalna. Collections zawiera szereg metod zaczynających się od synchronized albo unmodifiable, które tworzą instancje dekoratorów.   W języku Python istnieje składnia, która pozwala na łatwe użycie dekoratorów. Można powiedzieć, że ten wzorzec projektowy został wbudowany w język. Notacja @dekorator pozwala dekorować zarówno klasy jak i funkcje. Przykładami dekoratorów dostępnych w bibliotece standardowej mogą być @property, @contextlib.contextmanager czy @functools.wraps.   Zadanie do wykonania   Chociaż klasy reprezentujące pizze z dodatkami spełniają swoje zadanie mogą być ulepszone. Zwróć uwagę, że klasy te są do siebie bardzo podobne. Duplikacja kodu jest zła, zrefaktoryzuj kod w taki sposób aby usunąć tę duplikację. Spróbuj rozwiązać ten problem używając bardziej skomplikowanej wersji dekoratorów z drugiego diagramu UML.   Jak zwykle zachęcam Cię do samodzielnego rozwiązania zadania, w ten sposób nauczysz się najwięcej. Możesz też porównać swoje rozwiązanie z przykładowym.   Dodatkowe materiały do nauki   Niezmiennie, we wszystkich artykułach z serii poświęconej wzorcom projektowym polecam książkę Design Patterns – Gamma, Helm, Johnson, Vlissides. Jeśli miałbym polecić wyłącznie jedno źródło to poprzestałbym na tej książce.   Warto także rzucić okiem do polskiej i angielskiej Wikipedii gdzie znajdziesz artykuły dotyczące tego wzorca projektowego.   Zachęcam Cię też do zajrzenia do kodu źródłowego, którego użyłem w tym artykule.   Podsumowanie   Po lekturze tego artykułu wiesz czym jest wzorzec dekorator. Znasz przykładowy sposób jego implementacji. Masz też zestaw materiałów dodatkowych, które pozwolą Ci spojrzeć na temat z innej strony. Po rozwiązaniu zadania wiesz jak zaimplementować ten wzorzec samodzielnie. Innymi słowy udało Ci się właśnie poznać kolejny wzorzec projektowy. Gratulacje! ;)   Jeśli artykuł przypadł Ci do gustu proszę podziel się nim ze znajomymi. Dzięki temu pozwolisz mi dotrzeć do nowych Czytelników, za co z góry dziękuję. Jeśli nie chcesz pomiąć kolejnych artykułów dopisz się do samouczkowego newslettera i polub Samouczka Programisty na Facebooku.   Do następnego razu!                 Ten przykład jest trochę naciągany. Sam dodatek nie jest pizzą, ale pizza z dodatkiem już tak. Jest to coś najbliższego światu rzeczywistemu co jest „dekoratorem” i powinno być łatwe do zrozumienia. &#8617;                  Inną nazwą tego wzorca projektowego, z którą możesz się spotkać jest wrapper. &#8617;                  Takie podejście może wydłużać hierarchię dziedziczenia, sam preferuję użycie interfejsów jeśli hierarchia dziedziczenia jest dość długa. &#8617;           ","categories": ["Wzorce projektowe"],
        "tags": [],
        "url": "/wzorzec-projektowy-dekorator/",
        "teaser": "/assets/images/2019/11/21_wzorzec_projektowy_dekorator_artykul.jpg"
      },{
        "title": "Wprowadzenie do bash'a",
        "excerpt":"       Jeśli do tej pory nie pracowałeś z konsolą koniecznie przeczytaj artykuł opisujący początki pracy z linią poleceń. Mając podstawy opisane w tamtym artykule będzie Ci dużo łatwiej. Artykuł o początkach pracy z linią poleceń między innymi opisuje programy:      cd   ls   pwd   mkdir   rmdir   touch   echo   cat   clear     Specyficzne dla bash‘a   Na tym etapie wiesz już czym jest ścieżka. Sporo programów akceptuje ścieżki jako parametry. W niektórych przypadkach niezbędne jest przekazanie wielu ścieżek. W takiej sytuacji z pomocą mogą przyjść wyrażenia glob.   Glob   bash nie wspiera wyrażeń regularnych. Mam na myśli to, że sama powłoka nie pozwala na przykład na określenia ścieżki do pliku używając wyrażeń regularnych1. bash używa wyrażeń „glob”, które są do nich podobne.   Historycznie glob był osobnym programem, który został wchłonięty przez bash’a. Wyrażenia glob pozwalają na odwoływanie się do plików/katalogów używając ?, * i []. Znak ? zastępuje jeden znak, * zastępuje dowolną liczbę znaków. Na przykład wyrażenie glob *.txt pasuje do wszystkich plików z rozszerzeniem .txt w aktualnym katalogu. Wyrażenie glob ?.txt pasuje do wszystkich plików których nazwa (przed rozszerzeniem) ma jeden znak.   [] zawiera w sobie grupę dozwolonych znaków. Na przykład wyrażenie [ab].txt pasuje do nazw plików a.txt i b.txt ale nie pasuje do nazwy ab.txt. Grupy umieszczone wewnątrz [] mogą być zakresami znaków. Zakres znaków oddzielony jest -, na przykład [a-d].txt pasuje do nazw plików a.txt, b.txt, c.txt i d.txt. Jeśli chcesz dopasować - dosłownie umieść go na początku, albo na końcu grupy, na przykład [-a] albo [a-].   Podsumowując, w wyrażeniach glob możesz używać następujących wzorców:      ? oznacza dowolny pojedynczy znak (poza / i . na początku)   * oznacza dowolną liczbę znaków (poza / i . na początku)   […] oznacza grupę znaków zgodnie z zawartością   Istotne jest to, że wyrażenia glob są interpretowane przez konsolę zanim zostanie uruchomiony właściwy program. Proszę rzuć okiem na przykład poniżej:   $ ls a.txt b.txt c.csv  $ ls *.txt a.txt b.txt   W pierwszym przypadku zostanie uruchomiony program ls bez żadnego parametru. Domyślnie zatem zostanie użyty aktualny katalog (.). Program wypisze zawartość aktualnego katalogu, w moim przypadku są to trzy pliki: a.txt, b.txt i c.csv. W drugim przypadku pojawia się wyrażenie glob *.txt, które zostaje rozwinięte przez konsolę do a.txt b.txt i przekazane jako argument do programu ls. Zatem w przykładzie powyżej ls *.txt jest tak na prawdę wywołaniem ls a.txt b.txt.   Wyrażenia glob nie biorą pod uwagę plików/katalogów, których nazwa zaczyna się od kropki (.). Jeśli wyrażenie glob nie może być rozwinięte (nie pasuje do żadnego pliku/katalogu) zostanie przekazane jako parametr bez zmian:   $ ls exists.txt  $ echo *.txt exists.txt  $ echo *.pdf *.pdf       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Rozwijanie ~   W bash‘u znak tyldy (~) ma specjalne znaczenie. ~ oznacza katalog domowy użytkownika. Podobnie jak wyrażenia glob, tylda rozwijana jest do właściwej ścieżki przed przekazaniem jej jako parametr do programu. Proszę spójrz na przykład poniżej, w którym użyłem programu echo:   $ echo ~ /home/mapi  $ echo ~/some/path /home/mapi/some/path   Używając tyldy możesz także odwołać się do katalogu domowego dowolnego użytkownika. Na przykład ~root oznacza katalog domowy użytkownika root:   $ echo ~root /root   Możesz użyć także rozwijania ~ do poznania aktualnego katalogu używając +2:   $ cd /run/usr/1000  $ echo ~+ /run/user/1000   W podobny sposób - pokazuje poprzedni katalog:   $ cd /tmp  $ cd   $ echo ~- /tmp   Podobnie jak wyrażenia glob, także znak ~ jest rozwijany przez powłokę przed przekazaniem tego znaku jako parametr do uruchamianego programu.   Rozwijanie { }   Bash wspiera także mechanizm rozwijania { }. Proszę spójrz na przykład poniżej:   $ echo some-{magic,long,complicated}-text some-magic-text some-long-text some-complicated-text   Wywołanie programu echo wyświetla przekazane argumenty używając standardowego wyjścia. Bash, w trakcie procesu rozwijania { } zamienił pojedynczy parametr na trzy osobne parametry.   Wewnątrz nawiasów może znajdować się dowolna liczba elementów oddzielona znakiem ,. Każdy z tych elementów będzie skutkował nowym „słowem” podstawionym przez bash’a.   Rozwijanie { } może także służyć do generowania sekwencji numerów. Proszę spójrz na przykład, w którym generuję liczby od 7 do 10:   $ echo sequence-{7..10} sequence-7 sequence-8 sequence-9 sequence-10   Użycie wiodącego 0 powoduje generowanie numerów o stałej szerokości:   $ echo sequence-{07..10} sequence-07 sequence-08 sequence-09 sequence-10   Opcjonalnym, trzecim parametrem może być skok, który informuje o ile powinny różnić się kolejno generowane liczby:   $ echo sequence-{0..10..2} sequence-0 sequence-2 sequence-4 sequence-6 sequence-8 sequence-10   Ten sam mechanizm można także użyć do generowania sekwencji liter:   $ echo sequence-{a..d} sequence-a sequence-b sequence-c sequence-d   Najczęściej używam tej składni jeśli chcę skopiować albo przenieść plik czy folder:   $ ls  some_file.txt  $ mv some_file.txt{,.bak}  $ ls  some_file.txt.bak   Parametry specjalne   bash posiada zestaw parametrów, które mają specjalne znaczenie. Możesz odwołać się do tych parametrów używając składni $&lt;znak parametru&gt;, na przykład $?. Są one traktowane jako specjalne, ponieważ służą wyłącznie do odczytu. Część z nich znajdziesz poniżej:      $# - zawiera liczbę parametrów przekazanych do skryptu bash’a   $? - zawiera kod wyjścia poprzednio uruchomionego programu   $$ - zawiera identyfikator procesu bash’a   $_ - zawiera ostatni argument poprzedniej komendy   Proszę spróbuj trochę poeksperymentować z użyciem tych parametrów, wtedy zrozumienie ich działania będzie dużo łatwiejsze.   Historia   Bash posiada bardzo przydatną funkcję, pozwala ona na zapisywanie historii wykonywanych poleceń. Przy odpowiedniej konfiguracji (domyślnej na przykład w Ubuntu) w pliku ~/.bash_history zapisywana jest historia poleceń. Historia ta jest aktualizowana w momencie zamykania okna terminala.   Historia jest przydatna, bo często możesz używać poleceń, których używałeś poprzednio. Pomocny może być skrót klawiaturowy Ctrl+R, który pozwala na przeszukiwanie historii. Po użyciu tego skrótu klawiaturowego zmieni się standardowy znak zachęty. Możesz wtedy wpisywać fragmenty poleceń z historii. Jak zwykle, zachęcam Cię do eksperymentów:   (reverse-i-search)`':    To dzięki historii możesz też używać strzałek (góra/dół) do poruszania się po historii wykonywanych poleceń. Chociaż sam używam częściej programu history albo wspomnianego skrótu Ctrl+R.   history   Program history wypisuje historię wykonywanych poleceń. Często zdarza mi się używać tego programu w połączeniu z grep i potokami:   $ history | grep docker | tail -n 3  4500  docker run --rm -it alpine  4501  docker run --rm -it --entrypoint /bin/sh alpine/helm  4545  history | grep docker | tail -n 3   Przydatny może być też program fc, który pozwala na edycję wprowadzonych do tej pory komend przed ich wywołaniem. W przykładzie poniżej fc 1170 uruchomi edytor tekstu z poleceniem git rebase -i master. To polecenie znajduje się na 1170 miejscu w historii bash’a:   $ history | grep git | tail -n 4  1170  git rebase -i master  1174  git status  1176  git log -5  1178  git push  $ fc 1170   Modyfikowanie historii   Chociaż historia to dobra rzecz i nie raz może uratować skórę, zdarzają się przypadki, w których nie chcesz zostawiać po sobie śladu. Na przykład kiedy w linii poleceń wpisujesz hasło czy klucz do API.         To bardzo zła praktyka. Do przekazywania danych wrażliwych jak hasła czy tokeny dostępu używaj plików (przekazując ścieżkę do pliku z danymi wrażliwymi) albo zmiennych środowiskowych (zawierających dane wrażliwe albo ścieżkę do pliku z danymi wrażliwymi).   To rozwiązanie też nie jest idealne. Zmienne środowiskowe, podobnie jak pliki mogą być dostępne dla innych użytkowników systemu. Jednak takie rozwiązanie jest o niebo lepsze niż używanie danych wrażliwych bezpośrednio w konsoli.     W przypadku kiedy nie chcesz aby dana komenda została zapisana w historii poprzedź ją ` ` (spacją)3.   A co jeśli mleko już się rozlało i komenda została już zapisana w historii? Wówczas z pomocą przychodzi program history z parametrem -d:   $ history | tail -n 1  1190 curl https://admin:password1@ministry.gov  $ history -d 1190  $ history -w   Polecenie history -d 1190 usuwa z historii komendę z numerem 1190. hisory -w zapisuje aktualną historię (z usuniętą komendą) w pliku historii.   Jeśli nie chcesz używać programu history zawsze możesz edytować plik historii samodzielnie. Zmienna środowiskowa HISTFILE przechowuje ścieżkę do pliku, w którym przechowywana jest historia poleceń:   $ vim $HISTFILE   Rozwijanie historii   Proszę spójrz na przykład poniżej, w którym użyłem podstawowego mechanizmu rozwijania historii:   $ history | grep git | tail -n 3  1174  git status  1176  git log -5  1178  git push  $ !1176  $ history | grep git | tail -n 3  1176  git log -5  1178  git push  1201  git log -5   Wywołanie !1176 spowodowało ponowne uruchomienie programu zapisanego w historii pod numerem 1176. Mechanizm ten jest dość rozbudowany. Jeśli chcesz poznać więcej jego możliwości odsyłam Cię do sekcji „History expansion” w dokumentacji bash‘a.   Polecenia wbudowane   Do tej pory używałem głównie określenia „program”, jednak nie we wszystkich przypadkach było to do końca poprawne. Dzieje się tak za sprawą poleceń wbudowanych.   W dochodzeniu do prawdy pomocny będzie program which :). Ten program zwraca ścieżki programów, które byłyby uruchomione dla każdego z przekazanych parametrów. Robi to oparciu o listę katalogów przechowywanych w zmiennej środowiskowej PATH. Proszę spójrz na przykład:   $ which ls /bin/ls   W tym przykładzie which zwraca absolutną ścieżkę programu, który zostanie uruchomiony po wywołaniu ls. W tym przypadku jest to /bin/ls.   W ten sam sposób możesz sprawdzić inne programy:   $ which which mount cron /usr/bin/which /bin/mount /usr/sbin/cron   A teraz spróbuj zrobić to samo dla innych „programów”, których używasz cd czy history:   $ which cd history   Hmm ;), which nie pokazało nic. Dzieje się tak z tego powodu, że zarówno cd jak i history to polecenia wbudowane w bash‘a. Takich poleceń jest więcej. Jednym z wbudowanych poleceń jest type, które rzuca więcej światła na tę sprawę:   $ type -a history history is a shell builtin   Użyłem tu przełącznika -a, który zwraca wszystkie możliwe opcje, a jest ich kilka :). Proszę spójrz na kolejny przykład:   $ type -a kill pwd kill is a shell builtin kill is /bin/kill pwd is a shell builtin pwd is /bin/pwd   Jak widzisz istnieją także „programy”, które są zarówno poleceniami wbudowanymi jak i zwyczajnymi programami. W dalszej części artykuł nadal będę używał określenia „program” odnosząc się zarówno do programów jak i poleceń wbudowanych.   Wywoływanie programów w tle   Może się zdarzyć, że chcesz wywołać program, który działa bardzo długo a nie chcesz zajmować aktualnego okna konsoli. Z pomocą przychodzi operator &amp;:   $ ping www.samouczekprogramisty.pl &gt; ~/ping_output.txt &amp; [1] 11410   W przykładzie powyżej wywołałem program ping i przekierowałem standardowe wyjście do pliku ~/ping_output.txt. Kolejna linia [1] 11410 informuje o tym, że zadanie [1] działające w tle zostało uruchomione. Zadanie to działa jako proces 11410.   W każdym momencie możesz sprawdzić listę zadań używając programu jobs:   $ jobs [1]+  Running                 ping www.samouczekprogramisty.pl &gt; ~/ping_output.txt &amp;   W tym przypadku uruchomione jest jedno zadanie w tle, które ma status Running. Możesz „przywołać” to zadanie używając programu fg (od ang. foreground):   $ fg %1 ping www.samouczekprogramisty.pl &gt; ~/ping_output.txt   W zarządzaniu zadaniami pomocny jest też skrót klawiaturowy &lt;Ctrl+Z&gt;, który usypia aktualny program4:   $ fg %1 ping www.samouczekprogramisty.pl &gt; ~/ping_output.txt ^Z # tu użyłem Ctrl+Z [1]+  Stopped                 ping www.samouczekprogramisty.pl &gt; ~/ping_output.txt   Jak widzisz w tym przypadku zadanie [1] ma status Stopped. Jeśli chcesz wznowić zatrzymany program w tle użyj programu bg (od ang. background):   $ jobs [1]+  Stopped                 ping www.samouczekprogramisty.pl &gt; ~/ping_output.txt  $ bg %1 [1]+ ping www.samouczekprogramisty.pl &gt; ~/ping_output.txt  $ jobs [1]+  Running                 ping www.samouczekprogramisty.pl &gt; ~/ping_output.txt &amp;   Zmienne środowiskowe   Uruchomienie programu wiąże się z uruchomieniem procesu. Proces nadzorowany jest przez system operacyjny. Każdy proces posiada, między innymi, swój zestaw zmiennych środowiskowych.   Można powiedzieć, że zmienne środowiskowe są podobne do zmiennych w językach programowania. Zmienne środowiskowe zawierają dane, które dostępne są dla procesu (programu). Zazwyczaj nazwy zmiennych środowiskowych używają wielkich liter, choć nie jest to wymagane. Kilka przykładowych zmiennych środowiskowych:      PATH – zawiera listę katalogów, w których poszukiwane są programy do uruchomienia. To dzięki tej zmiennej możesz napisać ls bez podawania pełnej ścieżki programu (/bin/ls),   HOME – zawiera ścieżkę do katalogu domowego użytkownika,   EDITOR – zawiera ścieżkę do preferowanego edytora tekstu,   PPID – zawiera identyfikator procesu nadrzędnego (tego, który uruchomił aktualny proces).   Możesz sprawdzić aktualną listę zmiennych środowiskowych wywołując program set bez żadnych parametrów5:   $ set | head -n 1 BASH=/bin/bash   Przykład poniżej pokazuje użycie zmiennych środowiskowych:   $ echo $HOME /home/mapi  $ echo $HOMEsweetHOME  $ echo ${HOME}sweetHOME /home/mapisweetHOME   Pierwsza komenda wyświetla zawartość zmiennej HOME. Druga zawartość zmiennej HOMEsweetHOME. Zauważ, że w tym przypadku bash nie wie gdzie kończy się nazwa zmiennej środowiskowej. Dlatego właśnie wyświetla pustą linię – zmienna HOMEsweetHOME nie jest zdefiniowana. W trzecim przypadku użyłem składni ${}6 otaczając nawiasami klamrowymi nazwę zmiennej.   Możesz też definiować swoje zmienne środowiskowe używając składni NAZWA_ZMIENNEJ=wartosc zmiennej:   $ echo $NEW_VARIABLE  $ NEW_VARIABLE=\"some value\"  $ echo $NEW_VARIABLE some value   Zmienne środowiskowe w procesach potomnych   Wiesz już, że zmienne środowiskowe przypisane są do procesu. Każdy proces ma swoją kopię zmiennych środowiskowych. Uruchamiając nowy proces eksportowane zmienne środowiskowe kopiowane są do procesu potomnego. Oznacza to tyle, że proces potomny ma dostęp wyłącznie do podzbioru zmiennych aktualnie zdefiniowanych.   Zmienną środowiskową możesz eksportować używając programu export. Proszę spójrz na przykład:   $ VARIABLE_1=value1  $ export VARIABLE_2=value2  $ echo $VARIABLE_1 $VARIABLE_2 $PPID value1 value2 2855  $ bash  # uruchamia nowy proces  $ echo $VARIABLE_1 $VARIABLE_2 $PPID value2 10189   W przykładzie możesz zobaczyć dwie zmienne: VARIABLE_1 i VARIABLE_2. Druga z nich została wyeksportowana. Dzięki temu jest dostępne w procesie potomnym.   Dodatkowe materiały do nauki   Podobnie jak w poprzednim artkule z serii jako pierwsze źródło polecę Ci dokumentację. Znów odsyłam cię do programu man lub wbudowanej dokumentacji, którą możesz przeczytać uruchamiając &lt;program&gt; --help.   W przypadku tego artykułu nieocenionym źródłem wiedzy będzie dokumentacja programu bash, którą możesz przeczytać po uruchomieniu man bash lub online.   Możesz też rzucić okiem na stronę https://explainshell.com, która pozwoli Ci lepiej zrozumieć bardziej skomplikowane komendy.   Niezmiennie zachęcam Cię do samodzielnych eksperymentów. Najwięcej nauczysz się samodzielnie bawiąc się linią poleceń.   Podsumowanie   Po lekturze tego artykułu możesz spokojnie używać linii poleceń w codziennej pracy. Udało Ci się poznać zestaw przydatnych cech bash‘a. Potrafisz swobodnie poruszać się po historii poleceń i ją modyfikować w razie potrzeby. Wiesz więcej o zmiennych środowiskowych i rozumiesz jaka jest zależność pomiędzy procesem a zmienną środowiskową. Gratulacje! :)   To tyle na dzisiaj, dziękuję za lekturę, trzymaj się i do następnego razu! A… zapomniałbym, jeśli uważasz, że materiał może się przydać komuś z Twoich znajomych proszę podziel się z nim odnośnikiem do artykułu. W ten sposób pomożesz mi dotrzeć do nowych czytelników, z góry dziękuję! Jeśli nie chcesz pomiąć kolejnych artykułów dopisz się do samouczkowego newslettera i polub Samouczka Programisty na Facebooku.   Do następnego razu!                 Zupełnie inną sprawą są programy, które pozwalają na używanie wyrażeń regularnych w przekazanych parametrach. &#8617;                  Chociaż szczerze mówiąc częściej używam zmiennej środowiskowej PWD lub wywołuję program pwd ;) &#8617;                  Ten mechanizm zależy od wartości zmiennej środowiskowej HISTCONTROL. &#8617;                  Tak na prawdę to wysyła sygnał do procesu. To w jaki sposób ten sygnał jest obsłużony do inna sprawa. Domyślnie program jest „usypiany”. &#8617;                  Program ten wyświetla też listę dostępnych funkcji. &#8617;                  To mechanizm rozwijania parametrów, podobny do rozwijania ~ czy rozwijania {}. &#8617;           ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "/wprowadzenie-do-basha/",
        "teaser": "/assets/images/2020/0921-wprowadzenie-do-basha/wprowadzenie_do_basha_artykul.jpg"
      },{
        "title": "Wzorzec projektowy metoda wytwórcza",
        "excerpt":"Czytasz jeden z artykułów opisujących wzorce projektowe. Jeśli interesuje Cię ten temat zapraszam Cię do lektury pozostałych artykułów, które powstały w ramach tej serii – wzorce projektowe. W zrozumieniu artykułu przyda Ci się wiedza dotycząca podstaw UML’a.   Problem do rozwiązania   Wyobraź sobie sytuację, w której prowadzisz sklep internetowy ze znaczkami pocztowymi. Obsługa zamówień odbywa się przez program, który zarządza całym procesem. Program nadzoruje wszystko od złożenia zamówienia do obsługi ewentualnych reklamacji. Jednym z etapów obsługi zamówienia jest wysyłka towaru do klienta.   Do tej pory program  pozwalał wyłącznie na wysyłkę znaczków używając standardowej poczty. Z biegiem czasu klienci zaczęli oczekiwać dostępności innych sposobów dostawy. Problem polega na tym, że program używa wyłącznie jednego rodzaju wysyłki. Z pomocą w usprawnieniu takiego programu może przyjść metoda wytwórcza (ang. factory method).   W tym przypadku metoda wytwórcza może być odpowiedzialna za tworzenie klas odpowiedzialnych za różne rodzaje wysyłek.   Wzorzec projektowy metoda wytwórcza   Diagram klas   Ten wzorzec projektowy w jednej ze swoich form opiera się o 4 elementy. Proszę spójrz na diagram klas poniżej:             Wzorzec projektowy metoda wytwórcza (ang. factory method)           Product – klasa bazowa dla obiektów tworzonych przez metodę wytwórczą,   Creator– klasa zawierająca metodę wytwórczą factoryMethod,   SublassedProduct – przykładowa podklasa Product,   SubclassedCreator – podklasa, nadpisująca metodę wytwórczą zwracając instancję SubclassedProduct.   Chociaż na diagramie klas pokazałem Product jako klasę, w rzeczywistości wcale nie musi tak być. Podobnie metoda factoryMethod nie musi być abstrakcyjna.   Product może być zdefiniowany jako interfejs. W takim przypadku podklasy Creator tworzą instancje różnych klas implementujących interfejs Product. Metoda factoryMethod wcale nie musi być abstrakcyjna. Klasa Creator może mieć domyślną implementację tej metody, która może być napisana przez podklasy.   Inną modyfikacją może być wprowadzenie parametrów do metody wytwórczej. W takim przypadku parametry mogą mieć wpływ na obiekt, który jest przez nią zwracany.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Przykładowa implementacja metody wytwórczej   Java   W przykładzie odpowiednikiem Product będzie następujący interfejs:   public interface DeliveryService {     void deliver(Parcel parcel); }   Interfejs ten jest implementowany przez kilka klas. Jedną z nich możesz zobaczyć poniżej:   public class Pigeon implements DeliveryService {     @Override     public void deliver(Parcel parcel) {         System.out.println(String.format(\"Parcel %s was delivered by Pigeon\", parcel));     } }   Odpowiednikiem klasy Creator jest klasa OrderLifecycle, która obsługuje cykl życia zamówienia. Jak widzisz poniżej metoda wytwórcza zwraca instancję PostOffice:   public class OrderLifecycle {     public void processOrder(String orderId) {         Parcel parcel = prepareParcel(orderId);         DeliveryService deliveryService = deliveryService();         deliveryService.deliver(parcel);     }      protected DeliveryService deliveryService() {         return new PostOffice();     }      private Parcel prepareParcel(String orderId) {         Parcel parcel = new Parcel(orderId);         System.out.println(String.format(\"Parcel %s was prepared\", parcel));         return parcel;     } }   Dodatkowe podklasy nadpisują implementację metody wytwórczej zwracając inną implementację interfejsu DeliveryService:   public class PigeonOrderLifecycle extends OrderLifecycle {     @Override     protected DeliveryService deliveryService() {         return new Pigeon();     } }   Przykładowa metoda main pokazuje sposób wywołania poszczególnych klas, które używają metody wytwórczej:   public static void main(String[] args) {     CourierOrderLifecycle courierOrder = new CourierOrderLifecycle();     PigeonOrderLifecycle pigeonOrder = new PigeonOrderLifecycle();     OrderLifecycle postOfficeOrder = new OrderLifecycle();      postOfficeOrder.processOrder(\"order_1\");     courierOrder.processOrder(\"order_2\");     pigeonOrder.processOrder(\"order_3\"); }   Po uruchomieniu tego programu na konsoli pokaże się:   Parcel [sampro:order_1] was prepared Parcel [sampro:order_1] was delivered by PostOffice Parcel [sampro:order_2] was prepared Parcel [sampro:order_2] was delivered by Courier Parcel [sampro:order_3] was prepared Parcel [sampro:order_3] was delivered by Pigeon   Python   Implementacja w języku Python wygląda trochę prościej1:   class PostOffice:     def deliver(self, parcel):         print(f\"Parcel {parcel} was delivered by PostOffice\")   class Courier:     def deliver(self, parcel):         print(f\"Parcel {parcel} was delivered by Courier\")   class Pigeon:     def deliver(self, parcel):         print(f\"Parcel {parcel} was delivered by Pigeon\")   class OrderLifecycle:     def process_order(self, order_id):         parcel = self.prepare_parcel(order_id)         delivery_service = self.delivery_service()         delivery_service.deliver(parcel)      def prepare_parcel(self, order_id):         parcel = f\"[sampro:{order_id}]\"         print(f\"Parcel {parcel} was prepared\")         return parcel      def delivery_service(self):         return PostOffice()   class PigeonOrderLifecycle(OrderLifecycle):     def delivery_service(self):         return Pigeon()   class CourierOrderLifecycle(OrderLifecycle):     def delivery_service(self):         return Courier()   if __name__ == \"__main__\":     courier_order = CourierOrderLifecycle()     pigeon_order = PigeonOrderLifecycle()     post_office_order = OrderLifecycle()      post_office_order.process_order(\"order_1\")     courier_order.process_order(\"order_2\")     pigeon_order.process_order(\"order_3\")   Efekt działania tego programu będzie dokładnie taki sam jak w przypadku implementacji w języku Java.   Dodatkowe rozważania   Metoda wytwórcza to specyficzny przypadek innego wzorca projektowego – metody szablonowej. Wzorzec metody szablonowej opiszę w jednym z kolejnych artykułów w serii.   Metoda wytwórcza może być częścią innego wzorca projektowego jakim jest fabryka abstrakcyjna, także ten wzorzec omówię w jednym z kolejnych artykułów w serii.   Zalety   Stosowanie metody wytwórczej sprawia, że kod staje się łatwiejszy do testowania. Dzieje się tak ponieważ w łatwy sposób można nadpisać metodę wytwórczą używając mock’ów, albo naiwnej implementacji na potrzeby testów.   To, że kod jest łatwiejszy do testowania jest konsekwencją stosowania reguł opisanych przez akronim SOLID:      kod jest możliwy do rozszerzania – tworząc podklasy w bardzo łatwy sposób możesz zmienić zachowanie klas używających metody wytwórczej,   możesz używać obiektów podklas zwracanych przez metody wytwórcze – to zachowanie to „serce” metody wytwórczej.   Wady   Moim zdaniem główną wadą tego wzorca projektowego jest hierarchia dziedziczenia. Prowadzi ona do powstawania wielu (nadmiarowych?) bytów. Przeciążenie metody wytwórczej wymaga dziedziczenia po klasie, która ma już implementację tej metody. Pewną alternatywą dla takiego podejścia może być stosowanie kompozycji zamiast dziedziczenia. Proszę spójrz na przykład:   class OrderLifecycle:     def __init__(self, delivery_service_factory=PostOffice):         self.delivery_service_factory = delivery_service_factory      def process_order(self, order_id):         parcel = self.prepare_parcel(order_id)         delivery_service = self.delivery_service_factory()         delivery_service.deliver(parcel)      def prepare_parcel(self, order_id):         parcel = f\"[sampro:{order_id}]\"         print(f\"Parcel {parcel} was prepared\")         return parcel  if __name__ == \"__main__\":     courier_order = OrderLifecycle(Courier)     pigeon_order = OrderLifecycle(Pigeon)     post_office_order = OrderLifecycle()      post_office_order.process_order(\"order_1\")     courier_order.process_order(\"order_2\")     pigeon_order.process_order(\"order_3\")   To rozwiązanie nie jest już „czystą” metodą wytwórczą. To coś pomiędzy budowniczym (tak, kolejny wzorzec, który opiszę w innym artykule) a metodą wytwórczą. Na byt tego typu czasami mówi się po prostu fabryka.   Przykłady użycia wzorca metody wytwórczej   Ten wzorzec projektowy jest często używany w ramach fabryki abstrakcyjnej. Za przykład może to posłużyć metoda LogFactory.getLog z biblioteki commons-logging.   Innymi przykładami mogą być metody w fabrykach związanych z obsługą formatu JSON, na przykład JsonReaderFactory czy   JsonBuilderFactory.   Zadanie do wykonania   W sekcji opisującej wady metody wytwórczej pokazałem sposób modyfikacji tego wzorca projektowego. Zaimplementuj analogiczne rozwiązanie w języku Java. Spróbuj użyć wyrażeń lambda. Przydatny może też być interfejs Supplier.   Dodatkowe materiały do nauki   Niezmiennie, we wszystkich artykułach z serii poświęconej wzorcom projektowym polecam książkę Design Patterns – Gamma, Helm, Johnson, Vlissides. Jeśli miałbym polecić wyłącznie jedno źródło to poprzestałbym na tej książce.   Warto także rzucić okiem do polskiej i angielskiej Wikipedii, gdzie znajdziesz artykuły opisujące metodę wytwórczą:      artykuł na polskiej Wikipedii o metodzie wytwórczej,   artykuł na angielskiej Wikipedii o metodzie wytwórczej.   Kod źródłowy przykładów użytych w artykule także może być pomocny:     kod źródłowy w języku Java.   kod źródłowy w języku Python.   Podsumowanie   Wiesz już czym jest metoda wytwórcza i jak można ją zbudować. Znasz przykłady jej zastosowania zarówno z przykładu w artykule jak i innych bibliotek. Poznałeś zalety i wady tego wzorca projektowego. Wiesz jak można poradzić sobie z jego wadami. Jeśli udało Ci się samodzielnie rozwiązać zadanie do wykonania możesz śmiało powiedzieć, że znasz ten wzorzec projektowy. Gratulacje! :)   Jeśli artykuł przypadł Ci do gustu proszę podziel się nim ze znajomymi. Dzięki temu pozwolisz mi dotrzeć do nowych Czytelników, za co z góry dziękuję. Jeśli nie chcesz pomiąć kolejnych artykułów dopisz się do samouczkowego newslettera i polub Samouczka Programisty na Facebooku.   Do następnego razu!                 Jeśli coś chodzi jak kaczka i kwacze jak kaczka to jest kaczką ;). W odróżnieniu od Javy nie stosowałem tu dziedziczenia w przypadku odpowiedników klasy Product. Tę implementację można ją jeszcze uprościć, jak pokazałem paragrafie opisującym wady. &#8617;           ","categories": ["Wzorce projektowe"],
        "tags": [],
        "url": "/wzorzec-projektowy-metoda-wytworcza/",
        "teaser": "/assets/images/2020/0929-wzorzec-projektowy-metoda-wytworcza/wzorzec_projektowy_metoda_wytworcza_artykul.jpg"
      },{
        "title": "Funkcje analityczne w SQL",
        "excerpt":"     To jest jeden z artykułów w ramach praktycznego kursu SQL. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu.   Każde zapytanie z kursu możesz wykonać samodzielnie. Potrzebujesz do tego środowiska opisanego w pierwszym artykule kursu. Bardzo mocno Cię do tego zachęcam. Moim zdaniem najwięcej nauczysz się samodzielnie eksperymentując z zapytaniami.     W tym artykule używam funkcji SQLite, które zostały dodane w wersji 3.28.0. Jeśli używasz SQLite do eksperymentowania upewnij się, że korzystasz z wersji 3.28.0 bądź nowszej. Możesz to zrobić używając polecenia sqlite3 --version.   Czym są funkcje analityczne w SQL   W jednym zdaniu można powiedzieć, że funkcje analityczne (ang. analytic functions) zwracają wartość na podstawie grupy wierszy powiązanych z aktualnym wierszem. Tę grupę nazywa się partycją. Sam opis może być skomplikowany, więc proszę spójrz na przykład poniżej:     SELECT customerid         ,invoiceid         ,total         ,SUM(total) OVER (PARTITION BY customerid) AS customer_total_sum     FROM invoice ORDER BY customerid    LIMIT 10;   Poza funkcją analityczną użyłem tu aliasu kolumny, sortowania i ograniczenia liczby zwracanych wierszy. W wyniku tego zapytania otrzymasz dziesięć wierszy:   CustomerId  InvoiceId  Total  customer_total_sum ----------  ---------  -----  ------------------ 1           98         3.98   39.62 1           121        3.96   39.62 1           143        5.94   39.62 1           195        0.99   39.62 1           316        1.98   39.62 1           327        13.86  39.62 1           382        8.91   39.62 2           1          1.98   37.62 2           12         13.86  37.62 2           67         8.91   37.62   To zapytanie zwraca cztery różne kolumny. Ostatnia z nich jest wynikiem działania funkcji analitycznej. Spróbuję rozłożyć ją na części pierwsze:   SUM(total) OVER (PARTITION BY customerid)   W pierwszej linijce widzisz funkcję SUM. Możesz ją pamiętać z artykułu o funkcjach w SQL. W poprzednim przypadku była ona użyta jako funkcja agregująca. Użycie słowa kluczowego OVER sprawia, że jej zachowanie nieznacznie się zmienia. W tym przypadku SUM nadal zwraca sumę, jednak w przypadku funkcji analitycznej pod uwagę brana jest partycja a nie cała tabela1.   W ostatniej linijce znajduje się definicja partycji, która zostanie użyta do obliczenia wartości funkcji. W tym przypadku do partycji należą wiersze zawierające taką samą wartość kolumny customerid.   Zatem ta funkcja:     oblicza sumę kolumny total (SUM(total)),   sumując wiersze, które mają taką samą wartość kolumny customerid (PARTITION BY customerid).   Proszę spójrz na pierwszych siedem wierszy, które mają taką samą wartość kolumny customerid. Kolumna total sumowana jest w ramach partycji: 3.98 + 3.96 + 5.94 + 0.99 + 1.98 + 13.86 + 8.91 = 39.62. Wartość ta, będąca wynikiem działania funkcji, jest przypisywana do każdego wiersza z partycji.   Można powiedzieć, że funkcje analityczne są podobne do standardowego grupowania przy użyciu klauzuli GROUP BY. Funkcje agregujące zwracają jeden wiersz dla grupy, funkcje analityczne zwracają wiele wierszy.   Pozostałe funkcje agregujące   Poniżej znajdziesz listę funkcji agregujących, których możesz użyć przed słowem kluczowym OVER:      AVG – zwraca średnią wartość,   COUNT – zwraca liczbę wierszy,   MAX – zwraca maksymalną wartość,   MIN – zwraca minimalną wartość,   SUM – zwraca sumę wartości.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Klauzula PARTITION BY   W przykładzie wyżej wszystkie wiersze w tabeli invoice zostały podzielone na osobne partycje. Do podziału na partycje użyłem wyłącznie jednej kolumny. W klauzuli PARTITION BY możesz użyć wielu wyrażeń:   SUM(total) OVER OVER (PARTITION BY customerid, billingcountry)   W tym przypadku tabela zostanie podzielona na więcej partycji. Do jednej partycji trafią wszystkie wiersze, które mają taką samą wartość kolumn customerid i billingcountry.   Istnieje też możliwość pominięcia klauzuli PARTITION BY:   SUM(total) OVER ()   W takim przypadku partycja równoznaczna jest z całą tabelą2. Dla każdego wynikowego wiersza SUM(total) OVER () zwróci sumę kolumny total we wszystkich wierszach.   Kiedy obliczana jest wartość funkcji analitycznej   Funkcje analityczne mogą być użyte wyłącznie w klauzuli SELECT i ORDER BY. Wynika to z faktu, że funkcje analityczne operują na „wirtualnej tabeli” (w modelu relacyjnym można mówić o relacji), która powstanie po filtrowaniu i grupowaniu wierszy.   Można powiedzieć, że zapytanie wykonywane jest w następującej kolejności:      Wykonanie klauzuli WHERE,   Wykonanie klauzuli GROUP BY,   Wykonanie klauzuli HAVING,   Wykonanie funkcji analitycznych,   Wykonanie klauzuli ORDER BY,   Wykonanie klauzuli LIMIT.   Czym jest okno   Tak naprawdę, to funkcja do obliczenia wartości bierze pod uwagę tak zwane okno. Każdy wiersz w partycji ma swoje własne okno, które jest podzbiorem partycji. Jeśli okno nie jest zdefiniowane wówczas przyjmuje ono wartość całej partycji. Istnieje wiele możliwości na ograniczenie okna dla funkcji analitycznej. Najprostszym z nich jest użycie klauzuli ORDER BY.   Ćwiczenia do samodzielnego wykonania   Teraz czas na Twoje eksperymenty. Spróbuj samodzielnie uruchomić przykładowe zapytanie. Możesz je także zmodyfikować:      zmień limit zwracanych wierszy,   zwróć wyłącznie wiersze z parzystą wartością kolumny customerid.   Sortowanie w funkcjach analitycznych   Nieznacznie zmodyfikuję definicję partycji z pierwszego zapytania. Przykład poniżej używa dwóch funkcji. Druga z nich używa ORDER BY invoiceid po definicji partycji:     SELECT customerid         ,invoiceid         ,total         ,SUM(total) OVER (PARTITION BY customerid) AS customer_total_sum         ,SUM(total) OVER (PARTITION BY customerid                               ORDER BY invoiceid) AS customer_total_increasing_sum     FROM invoice ORDER BY customerid, invoiceid    LIMIT 10;   Proszę spójrz na wynik zapytania. Zwróć uwagę na wartości kolumn customer_total_sum i customer_total_increasing_sum:   CustomerId  InvoiceId  Total  customer_total_sum  customer_total_increasing_sum ----------  ---------  -----  ------------------  ----------------------------- 1           98         3.98   39.62               3.98 1           121        3.96   39.62               7.94 1           143        5.94   39.62               13.88 1           195        0.99   39.62               14.87 1           316        1.98   39.62               16.85 1           327        13.86  39.62               30.71 1           382        8.91   39.62               39.62 2           1          1.98   37.62               1.98 2           12         13.86  37.62               15.84 2           67         8.91   37.62               24.75   Użycie ORDER BY w definicji funkcji analitycznej powoduje zmianę okna dla każdego z wierszy. ORDER BY tworzy „narastające okna” dla każdego kolejnego wiersza:      okno dla pierwszego wiersza to wyłącznie pierwszy wiersz (3.98 = 3.98),   okno dla drugiego wiersza to dwa pierwsze wiersze (3.98 + 3.96 = 7.94),   okno dla trzeciego wiersza to trzy pierwsze wiersze (3.98 + 3.96 + 5.94 = 13.88),   itd.   Zauważ, że w tym przykładzie użyłem dwóch klauzul ORDER BY. Pierwsza z nich służy do określenia okna dla funkcji analitycznej, druga służy do sortowania wyników całego zapytania.   Partycje a sortowanie   Zapytanie używające partycji zwraca dane posortowane zgodnie z definicją partycji. Na przykład wyniki poniższego zapytania będą posortowane używając kolumny customerid:   SELECT customerid       ,SUM(total) OVER (PARTITION BY customerid) AS customer_total_sum   FROM invoice   Chociaż dane będą zwrócone w ten sposób nie polegałbym na tym zachowaniu. Jeśli zależy Ci na uzyskaniu posortowanych danych określ to jasno używając klauzuli ORDER BY. W ten sposób jasno określasz swoje intencje:     SELECT customerid         ,SUM(total) OVER (PARTITION BY customerid) AS customer_total_sum     FROM invoice ORDER BY customerid;   We wszystkich przykładach w artykule dodałem klauzulę ORDER BY.   Ćwiczenia do samodzielnego wykonania   Teraz czas na Twoje eksperymenty. Spróbuj samodzielnie uruchomić przykładowe zapytanie zawierające dwie funkcje analityczne. Możesz je także zmodyfikować:      sprawdź jak na wynik zapytania wpływają różne kolumny użyte do sortowania,   użyj kilku kolumn do sortowania wyników/wierszy w partycji,   użyj DESC/ASC do z zmiany wyniku sortowania.   Unikanie duplikacji – nazwane partycje   Wyobraź sobie sytuację, w której chcesz zwrócić wynik różnych funkcji analitycznych, jednak używając tej samej definicji partycji. Spójrz na przykład poniżej:     SELECT customerid         ,invoiceid         ,total         ,SUM(total) OVER (PARTITION BY customerid) AS customer_total_sum         ,AVG(total) OVER (PARTITION BY customerid) AS customer_total_avg     FROM invoice ORDER BY customerid    LIMIT 10;   W tym przykładzie definicja partycji jest prosta. Możesz jednak trafić na przypadek, w którym będzie ona dużo bardziej skomplikowana. Takie zapytanie zawiera duplikację definicji partycji. Duplikacja w większości przypadków jest zła. Nie inaczej jest w przypadku zapytań SQL. W takiej sytuacji z pomocą przychodzi klauzula WINDOW. Proszę spójrz na przykład poniżej, jest on równoznaczny z poprzednim zapytaniem:     SELECT customerid         ,invoiceid         ,total         ,SUM(total) OVER customer_window AS customer_total_sum         ,AVG(total) OVER customer_window AS customer_total_avg     FROM invoice   WINDOW customer_window AS (PARTITION BY customerid) ORDER BY customer id    LIMIT 10;   Oba zapytania zwrócą ten sam wynik:   CustomerId  InvoiceId  Total  customer_total_sum  customer_total_avg ----------  ---------  -----  ------------------  ------------------ 1           98         3.98   39.62               5.66 1           121        3.96   39.62               5.66 1           143        5.94   39.62               5.66 1           195        0.99   39.62               5.66 1           316        1.98   39.62               5.66 1           327        13.86  39.62               5.66 1           382        8.91   39.62               5.66 2           1          1.98   37.62               5.37428571428571 2           12         13.86  37.62               5.37428571428571 2           67         8.91   37.62               5.37428571428571   Co więcej partycje zdefiniowane w ten sposób możesz dodatkowo rozszerzać:     SELECT customerid         ,invoiceid         ,total         ,SUM(total) OVER (customer_window ORDER BY invoiceid) AS customer_ordered_total_sum         ,AVG(total) OVER customer_window AS customer_total_avg     FROM invoice   WINDOW customer_window AS (PARTITION BY customerid) ORDER BY customerid    LIMIT 10;   W tym przykładzie suma kolumny total jest narastająca:   CustomerId  InvoiceId  Total  customer_ordered_total_sum  customer_total_avg ----------  ---------  -----  --------------------------  ------------------ 1           98         3.98   3.98                        5.66 1           121        3.96   7.94                        5.66 1           143        5.94   13.88                       5.66 1           195        0.99   14.87                       5.66 1           316        1.98   16.85                       5.66 1           327        13.86  30.71                       5.66 1           382        8.91   39.62                       5.66 2           1          1.98   1.98                        5.37428571428571 2           12         13.86  15.84                       5.37428571428571 2           67         8.91   24.75                       5.37428571428571   Funkcje okna   Jak już wiesz funkcje analityczne działają w oparciu o partycje. Dodatkowo funkcje te pozwalają Ci na zdefiniowanie tak zwanego okna. Domyślnie okno zawiera:      wszystkie wiersze partycji jeśli nie użyjesz klauzuli ORDER BY,   wiersze „do aktualnego wiersza” jeśli użyjesz klauzuli ORDER BY.   Domyślną zawartość okna możesz zmienić. Okno pozwala na dalsze ograniczenie wierszy branych pod uwagę przez funkcję. Składnię można rozszerzyć do:   &lt;funkcja&gt; OVER [ PARTITION BY … ] [ ORDER BY … ] &lt;definicja okna&gt;   Okno może być jednego z trzech rodzajów:      ROWS – granice okna określone są przez liczbę wierszy przed i po aktualnym wierszu,   GROUPS – granice okna określone są przez liczbę „grup” przed i po aktualnej „grupie”. Do grupy zalicza się te wartości, które są „równe” w trakcie sortowania przy użyciu ORDER BY,   RANGE – granice okna określone są przez różnicę wartości względem aktualnego wiersza.   Dla uproszczenia w definicji okna będę używał wyłącznie BETWEEN x PRECEDING AND y FOLLOWING. Oznacza to, że okno będzie obejmowało zakres x przed aktualnym wierszem i y po aktualnym wierszu. Składania pozwala na dużo bardziej zaawansowane modyfikacje, jednak ich znajomość nie jest niezbędna do zrozumienia działania samego mechanizmu. Jeśli jesteś zainteresowany tymi szczegółami odsyłam Cię do dokumentacji silnika bazy danych, którego używasz.   Mam świadomość, że to wszystko brzmi jak łacina bez konkretnego przykładu. Postaram się to poprawić ;)   Okno typu ROWS   Proszę spójrz na pierwszy z nich:     SELECT customerid         ,invoiceid         ,total         ,SUM(total) OVER (PARTITION BY customerid                               ORDER BY invoiceid                                   ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS rolling_sum     FROM invoice ORDER BY customerid         ,invoiceid    LIMIT 10;   W wyniku tego zapytania otrzymasz 10 wierszy:   CustomerId  InvoiceId  Total  rolling_sum ----------  ---------  -----  ----------- 1           98         3.98   7.94 1           121        3.96   13.88 1           143        5.94   10.89 1           195        0.99   8.91 1           316        1.98   16.83 1           327        13.86  24.75 1           382        8.91   22.77 2           1          1.98   15.84 2           12         13.86  24.75 2           67         8.91   24.75   W tym przypadku SUM(total) sumuje jedynie wiersze należące do okna, a nie całej partycji.      dla pierwszego wiersza oknem są wiersze pierwszy i drugi: 3.98 + 3.96 = 7.94 (brak poprzedniego wiersza w partycji),   dla drugiego wiersza oknem są wiersze pierwszy, drugi i trzeci: 3.98 + 3.96 + 5.94 = 13.88 ,   dla siódmego wiersza oknem są wiersze szósty i siódmy: 13.86 + 8.91 = 22.77 (brak następnego wiersza w partycji).   Okno typu GROUPS   Tym razem do utworzenia partycji posłużę się kolumną billingcountry:     SELECT billingcountry         ,invoiceid         ,total         ,SUM(total) OVER (PARTITION BY billingcountry                               ORDER BY total                                 GROUPS BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS rolling_sum     FROM invoice    WHERE billingcountry = 'India' ORDER BY total;   W wyniku tego zapytania otrzymasz 13 wierszy:   BillingCountry  InvoiceId  Total  rolling_sum --------------  ---------  -----  ----------- India           120        1.98   9.92 India           218        1.98   9.92 India           315        1.98   9.92 India           97         1.99   17.84 India           412        1.99   17.84 India           23         3.96   23.78 India           338        3.96   23.78 India           45         5.94   37.62 India           360        5.94   37.62 India           186        8.91   57.42 India           284        8.91   57.42 India           131        13.86  45.54 India           229        13.86  45.54   Także tym przypadku SUM(total) sumuje jedynie wiersze należące do okna, a nie całej partycji:      dla pierwszego wiersza oknem jest pierwszych pięć wierszy. Grupa do której należy pierwszy wiersz i następna grupa: 3 * 1.98 + 2 * 1.99 = 9.92 (brak poprzedniej grupy w partycji),   dla piątego wiersza oknem jest pierwszych siedem wierszy. Grupa poprzedzająca, grupa do której należy piąty wiersz i następna grupa: 3 * 1.98 + 2 * 1.99 + 2 * 3.96 = 17.84 ,   dla przedostatniego wiersza oknem są wiersze 10., 11., 12. i 13.: 2 * 8.91 + 2 * 13.86 (brak następnej grupy w partycji).   Okno typu RANGE   W tym przypadku okno definiowane jest jako „odległość” 2 przed i po wartości kolumny total:     SELECT customerid         ,invoiceid         ,total         ,SUM(total) OVER (PARTITION BY customerid                               ORDER BY total                                  RANGE BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS rolling_sum     FROM invoice ORDER BY customerid         ,total    LIMIT 10;   W wyniku tego zapytania otrzymasz dziesięć wierszy:   CustomerId  InvoiceId  Total  rolling_sum ----------  ---------  -----  ----------- 1           195        0.99   2.97 1           316        1.98   10.91 1           121        3.96   15.86 1           98         3.98   15.86 1           143        5.94   13.88 1           382        8.91   8.91 1           327        13.86  13.86 2           293        0.99   4.95 2           1          1.98   8.91 2           196        1.98   8.91   Także tutaj SUM(total) sumuje jedynie wiersze należące do okna, a nie całej partycji.      dla pierwszego wiersza oknem są pierwsze dwa wiersze. Dzieje się tak ponieważ wartość kolumny total dla tych wierszy jest w zakresie  &lt;0.99 - 2, 0.99 + 2&gt;,   dla drugiego wiersza oknem są pierwsze cztery wiersze. Dzieje się tak ponieważ wartość kolumny total dla tych wierszy jest w zakresie  &lt;1.98 - 2, 1.98 + 2&gt;,   dla trzeciego wiersza oknem są wiersze drugi, trzeci, czwarty i piąty. Dzieje się tak ponieważ wartość kolumny total dla tych wierszy jest w zakresie  &lt;3.96 - 2, 3.96 + 2&gt;.   Filtrowanie okna   Jakby tego było mało do tego wszystkiego dochodzi możliwość filtrowania :). Oznacza to tyle, że możesz użyć filtrowania jak w klauzuli WHERE, żeby dodatkowo ograniczyć wiersze „pasujące” do definicji okna. Proszę spójrz na przykład poniżej:     SELECT customerid         ,invoiceid         ,total         ,SUM(total) OVER rows_window AS rolling_sum         ,SUM(total) FILTER (WHERE invoiceid != 121)                       OVER rows_window AS filtered_rolling_sum     FROM invoice   WINDOW rows_window AS (PARTITION BY customerid) ORDER BY customerid    LIMIT 10;   Zwróć uwagę na wartości kolumn rolling_sum i filtered_rolling_sum:   CustomerId  InvoiceId  Total  rolling_sum  filtered_rolling_sum ----------  ---------  -----  -----------  -------------------- 1           98         3.98   39.62        35.66 1           121        3.96   39.62        35.66 1           143        5.94   39.62        35.66 1           195        0.99   39.62        35.66 1           316        1.98   39.62        35.66 1           327        13.86  39.62        35.66 1           382        8.91   39.62        35.66 2           1          1.98   37.62        37.62 2           12         13.86  37.62        37.62 2           67         8.91   37.62        37.62   filtered_rolling_sum ma wartość 39.62 - 3.96 = 35.66. Zatem funkcja analityczna w przypadku partycji gdzie customerid = 1 nie wzięła pod uwagę filtrowanego wiersza. Wiersz, w którym invoiceid = 121 nie został wzięty pod uwagę podczas sumowania. Dla przypomnienia odsyłam cię do artykułu opisującego klauzulę WHERE.   Lista funkcji   Bazy danych posiadają szereg funkcji dedykowanych do użycia z klauzulą OVER. Poniżej znajdziesz listę zawierającą część z nich. Podobnie jak w innych przypadkach odsyłam Cię do dokumentacji Twojej bazy danych, jeśli chcesz znać ich komplet:      ROW_NUMBER() – Numeruje wiersze w partycji zaczynając od 1. Bierze pod uwagę klauzulę ORDER BY,   RANK(), DENSE_RANK() – Funkcje numerujące unikalne wartości w partycji. RANK zostawia „dziury” w numeracji. Pokażę to na przykładzie poniżej. Bez klauzuli ORDER BY każdy z wierszy ma numer 1,   NTILE(N) – Dzieli partycję na N „możliwie równych” i przydziela wiersze do grup o wartości od 1 do N.   Pierwszy przykład pokazuje działanie funkcji ROW_NUMBER:   SELECT customerid       ,total       ,ROW_NUMBER() OVER (PARTITION BY customerid) AS row_number   FROM invoice  LIMIT 10;   CustomerId  Total  row_number ----------  -----  ---------- 1           0.99   1 1           1.98   2 1           3.96   3 1           3.98   4 1           5.94   5 1           8.91   6 1           13.86  7 2           0.99   1 2           1.98   2 2           1.98   3   Drugi przykład porównuje funkcje RANK i DENSE_RANK. Proszę zwróć uwagę na wyniki tych funkcji dla 10. i 11. wiersza:   SELECT customerid       ,total       ,RANK() OVER customer_window AS rank_unsorted       ,DENSE_RANK() OVER customer_window AS dense_rank_unsorted       ,RANK() OVER (customer_window ORDER BY total) AS rank_sorted       ,DENSE_RANK() OVER (customer_window ORDER BY total) AS dense_rank_sorted   FROM invoice WINDOW customer_window AS (PARTITION BY customerid)  LIMIT 13;   CustomerId  Total  rank_unsorted  dense_rank_unsorted  rank_sorted  dense_rank_sorted ----------  -----  -------------  -------------------  -----------  ----------------- 1           0.99   1              1                    1            1 1           1.98   1              1                    2            2 1           3.96   1              1                    3            3 1           3.98   1              1                    4            4 1           5.94   1              1                    5            5 1           8.91   1              1                    6            6 1           13.86  1              1                    7            7 2           0.99   1              1                    1            1 2           1.98   1              1                    2            2 2           1.98   1              1                    2            2 2           3.96   1              1                    4            3 2           5.94   1              1                    5            4 2           8.91   1              1                    6            5   Ostatni przykład pokazuje sposób podziału partycji przez funkcję NTILE z użyciem różnych argumentów:   SELECT customerid       ,total       ,NTILE(2) OVER customer_window AS ntile_2       ,NTILE(4) OVER customer_window AS ntile_4   FROM invoice WINDOW customer_window AS (PARTITION BY customerid)  LIMIT 10;   CustomerId  Total  ntile_2  ntile_4 ----------  -----  -------  ------- 1           3.98   1        1 1           3.96   1        1 1           5.94   1        2 1           0.99   1        2 1           1.98   2        3 1           13.86  2        3 1           8.91   2        4 2           1.98   1        1 2           13.86  1        1 2           8.91   1        2   Funkcje analityczne a klauzula WHERE   Jak już wiesz funkcje analityczne mogą być użyte wyłącznie w klauzuli SELECT i ORDER BY. Co jeśli musisz użyć wyniku funkcji analitycznej do filtrowania? Z pomocą przychodzą podzapytania. Na przykład poniższe zapytanie zwróci wyłącznie te faktury wystawione dla klienta, których suma będzie mniejsza niż 10:     SELECT customerid         ,invoiceid         ,total     FROM invoice JOIN (SELECT invoiceid                              ,SUM(total) OVER (PARTITION BY customerid                                                    ORDER BY invoiceid) AS invoice_sum                          FROM invoice)                  USING (invoiceid)    WHERE invoice_sum &lt; 10 ORDER BY customerid    LIMIT 10;   CustomerId  InvoiceId  Total ----------  ---------  ----- 1           98         3.98 1           121        3.96 2           1          1.98 3           99         3.98 4           2          3.96 4           24         5.94 5           77         1.98 5           100        3.96 6           46         8.91 7           78         1.98   Nie przejmuj się, jeśli to zapytanie będzie dla Ciebie zbyt skomplikowane. To nic dziwnego, używa ono wielu elementów składki SQL. Postaraj się przeanalizować je jeszcze raz. Spróbuj też samodzielnie eksperymentować. Zacznij od wywołania podzapytania i przeanalizowania jego wyników.   Dodatkowe materiały do nauki   Artykuł nie wyczerpuje tematu funkcji analitycznych. Zachęcam Cię do rzucenia okiem na dodatkowe materiały do nauki. Pamiętaj, że dokumentacja Twojego silnika baz danych jest niezastąpiona ;) i zawiera dużo bardziej szczegółowe informacje.      Tutorial dotyczący funkcji analitycznych dla PostgreSQL,   Składnia funkcji analitycznych w PostgreSQL,   Funkcje okna w PostgreSQL,   Składnia funkcji analitycznych w SQLite,   Materiały wykładowe z Politechniki Poznańskiej.   Podsumowanie   Po przeczytaniu tego artykułu wiesz już czym są funkcje analityczne. Wiesz czym takie funkcje różnią się od zwykłego grupowania. Wiesz czym są funkcje okna i jak ich używać. Po przerobieniu ćwiczeń możesz śmiało powiedzieć, że udało Ci się sprawdzić wiedzę w praktyce. Gratulacje ;), funkcje analityczne to jedne z bardziej zaawansowanych elementów składki SQL.   Mam nadzieję, że artykuł był dla Ciebie pomocny. Proszę podziel się nim ze swoimi znajomymi. Dzięki temu pozwolisz mi dotrzeć do nowych Czytelników, za co z góry dziękuję. Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do samouczkowego newslettera i polub Samouczka Programisty na Facebooku.   Do następnego razu!                 W wyjątkowych przypadkach partycją może być także cała tabela. Przeczytasz o tym w dalszej części artykułu. &#8617;                  Właściwie to nie z całą tabelą, a relacją powstałą po filtrowaniu i grupowaniu. Także to zagadnienie opiszę dokładniej w dalszej części artykułu. &#8617;           ","categories": ["Bazy danych","Kurs SQL"],
        "tags": [],
        "url": "/funkcje-analityczne-w-sql/",
        "teaser": "/assets/images/2021/0504-funkcje-analityczne-w-sql/funkcje_analityczne_w_sql_artykul.jpg"
      },{
        "title": "Pogodynka w chmurze",
        "excerpt":"       Ten artykuł pokazuje kolejną odsłonę projektu Pogodynka. Jeśli jesteś zainteresowany starszą wersją odsyłam Cię do serii poprzednich artykułów:      Projekt Pogodynka – wprowadzenie   Projekt Pogodynka – naiwny termometr   Projekt Pogodynka – działający termometr   Projekt Pogodynka – szkielet aplikacji webowej   Projekt Pogodynka – JSON i walidacja   Projekt Pogodynka – JPA i Spring Data   Projekt Pogodynka – konfiguracja serwera   Projekt Pogodynka – konfiguracja bazy danych   Projekt Pogodynka – szkic interfejsu użytkownika   Projekt Pogodynka – integracja   Projekt Pogodynka – podsumowanie     Nowe podejście   Hardware   Starsza wersja pogodynki zawierała więcej komponentów, nad którymi pracowałem samodzielnie. Wówczas postawiłem na serwer współdzielony, na którym zainstalowałem niezbędne elementy takie jak silnik bazy danych czy serwer HTTP. Stary diagram wygląda tak:             Diagram aplikacji Pogodynka 1.0        Takie podejście ma swoje wady i zalety. Niestety w skali tak małego projektu doświadczałem głównie wad:      byłem odpowiedzialny za utrzymanie wszystkich komponentów,   koszt serwera był relatywnie wysoki,   zdarzały się przerwy w dostępności Pogodynki.   Biorąc te elementy pod uwagę postanowiłem zmienić podejście. Tym razem jedynym sprzętem za który jestem odpowiedzialny jest Rasberry Pi z zestawem czujników. Reszta to płatne usługi. Mimo tego, że usługi te są płatne, finalnie koszt będzie dużo niższy. Dokładny opis szacowania kosztów znajdziesz w jednym z punktów poniżej.       Pobierz opracowania zadań z rozmów kwalifikacyjnych   Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 6147 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.        Software   Kolejnym elementem, który zmieniłem jest stos technologiczny. Stara wersja Pogodynki używała głównie języka Java. Do tego przygotowałem prosty interfejs użytkownika przy pomocy HTML, CSS i JavaScript. Do zarządzania infrastrukturą użyłem Puppet’a.   Nowe podejście jest mocno uproszczone. Użyłem języka Python. Do zarządzania zasobami w chmurze posłużyłem się Terraform’em.   Nowa pogodynka   Czujnik pyłu zawieszonego SDS011   Przebudowując Pogodynkę rozszerzyłem ją o dodatkowy czujnik. Teraz Pogodynka może także mierzyć ilość pyłu zawieszonego o średnicy 2.5μm i 10μm. Podstawowa wersja kodu, którą napisałem sprawia, że czujnik działa bez przerwy. Pogodynka 2.1 mogłaby włączać czujnik na żądanie wydłużając żywotność lasera.   Python vs Java   Co tu dużo mówić, większą frajdę sprawia mi pisanie kodu w Python’ie. Między innymi z tego powodu zdecydowałem, że Pogodynka 2.0 używa tego języka programowania. Proszę spójrz na przykład poniżej:   class SDS011:      DATA_PACKET_SIZE = 10     HEADER = 0xAA     TAIL = 0xAB      def __init__(self, port):         self.port = port      def poke_25(self):         data = self.read_bytes()         return int.from_bytes(data[2:4], byteorder=\"little\") / 10      def poke_10(self):         data = self.read_bytes()         return int.from_bytes(data[4:6], byteorder=\"little\") / 10      def read_bytes(self):         data = self.port.read(self.DATA_PACKET_SIZE)          assert data[0] == self.HEADER         assert data[9] == self.TAIL          return data   Te 24 linijek kodu to wszystko, co jest potrzebne do obsługi czujnika SDS011 (dla czytelności pominąłem dokumentację i komentarze). Aż boję się pomyśleć ile musiałbym się nadziubać, żeby zaimplementować to w Javie :). Testy jednostkowe dla kodu są równie zwięzłe:   @pytest.fixture def port_mock():     port_mock = mock.MagicMock()     port_mock.read.return_value = b\"\\xaa\\xc0\\x1c\\x001\\x00\\x0b\\x141\\xab\"      return port_mock   def test_pm25(port_mock):     pm_sensor = sds011.SDS011(port_mock)      assert pm_sensor.poke_25() == pytest.approx(2.8)   def test_pm10(port_mock):     pm_sensor = sds011.SDS011(port_mock)      assert pm_sensor.poke_10() == pytest.approx(4.9)   Google Cloud Platform   Przeniosłem Pogodynkę do chmury :). Postawiłem na Google BigQuery jako bazę danych, w której przechowuję wyniki pomiarów. Przesiadka na BigQuery pozwoliła mi zwiększyć częstotliwość pomiarów bez przejmowania się potencjalnymi problemami z wydajnością bazy danych. Pogodynka 2.0 wysyła wskazania czujników co minutę.   Za strumieniowe przesyłanie danych do chmury odpowiedzialny jest poniższy fragment kodu:   def stream_to_gbq(client, scoped_table, measurements):     rows_to_insert = []     for measurement in measurements:         row = {             \"time\": measurement.time.strftime(GBQ_TIMESTAMP_FORMAT),             \"pm25\": measurement.pm25,             \"pm10\": measurement.pm10,             \"temperature\": measurement.temperature,         }         rows_to_insert.append(row)      try:         errors = client.insert_rows_json(scoped_table, rows_to_insert)     except exceptions.BadRequest as e:         raise StoreError(e)      if errors != []:         raise StoreError(errors)   Zrezygnowałem też z własnego narzędzia do wizualizacji na rzecz Google DataStudio. Przykładowy raport wygenerowany na podstawie danych zebranych przez Pogodynkę 2.0 możesz zobaczyć poniżej:             Pogodynka 2.0 w DataStudio        Starałem się maksymalnie ograniczyć liczbę komponentów żeby niepotrzebnie nie komplikować rozwiązania.   Terraform   W związku z przesiadką na chmurę odstawiłem w kąt Puppet’a. Tym razem użyłem Terraform’a do zarządzania wszystkimi zasobami w chmurze. Przechowywanie definicji infrastruktury jako kod ma wiele zalet. Jedną z nich jest możliwość wglądu w historię zmian. Konfiguracja w przypadku Pogodynki 2.0 nie jest skomplikowana. Możesz ją przejrzeć w publicznym repozytorium.   Funkcja cache   Przy Pogodynce 1.0 zauważyłem, że elementem, który był najbardziej zawodny był dostęp do internetu w miejscu gdzie działała Pogodynka. Skutkowało to utratą wyników pomiarów wykonanych w czasie, kiedy nie było dostępu do internetu.   Tym razem postanowiłem to zmienić wprowadzając lokalny cache. W przypadku braku dostępu do internetu  Pogodynka 2.0 zapisuje wyniki pomiarów lokalnie. Raz jeszcze dzięki Python’owi cały kod jest niesłychanie zwięzły:   class Cache:     def __init__(self, cache_path):         self.cache_path = cache_path      def load(self):         if not path.isfile(self.cache_path):             return []          with open(self.cache_path, \"rb\") as cache_file:             return pickle.load(cache_file)      def dump(self, measurements):         with open(self.cache_path, \"wb\") as cache_file:             pickle.dump(measurements, cache_file)      def clear(self):         self.dump([])   Połączenie klas wspomnianych wyżej możesz zobaczyć poniżej:   pm_port = serial.Serial(args.pm_sensor_device) pm_sensor = sds011.SDS011(pm_port) temperature_sensor = ds18b20.DS18B20(args.temperature_sensor_path)  cache = store.Cache(args.cache_path)  measurements = cache.load() measurements.append(     sensor.Measurement(         time=datetime.datetime.utcnow(),         pm25=pm_sensor.poke_25(),         pm10=pm_sensor.poke_10(),         temperature=temperature_sensor.poke(),     ), )  gbq_client = bigquery.Client()  try:     store.stream_to_gbq(gbq_client, args.destination_table, measurements)     cache.clear() except store.StoreError:     cache.dump(measurements)     raise   Na początku tworzę instancje klas obsługujących czujniki. Kolejna linijka to utworzenie instancji klasy obsługującej lokalny cache. Następne linijki to utworzenie listy pomiarów do wysłania.   W końcu wysyłam pomiary do tabeli w Google BigQuery.   Przygotowanie karty SD   System, które używałem w przypadku Pogodynki 1.0 ma już swoje lata. Zdecydowałem się zaktualizować go do najnowszej wersji. Ze strony Rasberry Pi pobrałem najnowszą wersję systemu Raspberry Pi OS Lite. Obraz skopiowałem na kartę microSD zgodnie z instrukcją ze strony Raspberry Pi.   Po uruchomieniu malinki zaktualizowałem zainstalowane oprogramowanie i dodałem kilka dodatkowych narzędzi:   apt-get update  apt-get upgrade  apt-get install python3-pip python3-venv git vim tree   Kod odpowiedzialny za Pogodynkę uruchamiany jest w kontekście dedykowanego użytkownika:   useradd pogodynka usermod --append --groups dialout pogodynka   Ostatnia komenda dodaje użytkownika pogodynka do grupy dialout. Jest to potrzebne, aby mieć  bezpośredni dostęp do odczytu danych z portu USB.   Wszystkie te operacje wykonałem podłączając klawiaturę bezpośrednio do malinki. Dla wygody włączyłem demona ssh, dzięki czemu pozostałe operacje mogę wykonać zdalnie:   touch /boot/ssh   Moduły jądra Linux’a   Żeby termometr działał poprawnie wymagana jest drobna modyfikacja konfiguracji malinki:   echo dtoverlay=w1-gpio &gt;&gt; /boot/config.txt  reboot  modprobe w1-gpio modprobe w1-therm   Stara architektura a chmura   Porównanie kosztów   Pogodynka 1.0 używała serwera współdzielonego. Korzystałem z usług jednej z polskich firm hostingowych. Koszt utrzymania serwera wynosił około 10zł miesięcznie. Pogodynka 2.0 to zupełnie inna para kaloszy. Szacowanie kosztów usług chmurowych jest dużo bardziej złożone. W przypadku usług, z których korzystam składniki ceny są następujące:      przechowywanie danych w bazie danych – kosztuje $0,02 za 1GB przechowywanych danych1,   strumieniowe ładowanie danych do bazy – kosztuje $0,01 za 200MB, ładowany wiersz to minimum 1KB,   pobieranie danych z bazy danych – kosztuje $5 za każdy odczytany 1TB.   Koszt przechowywania danych   Spróbuję oszacować wielkość bazy danych po roku:   60 (odczytów na godzinę) * 24 (godziny) * 365 (dni) = 525'600 (odczytów rocznie)   Każdy odczyt to jeden wiersz. Tabela przechowująca pomiary składa się z czterech kolumn:      daty typu DATETIME   odczytu temperatury typu FLOAT   odczytu PM2.5 typu FLOAT   odczytu PM10 typu FLOAT   Każda z tych kolumn to 8B, więc jeden wiersz to 8B * 4 = 32B. Zatem 525’600 odczytów rocznie to w sumie 17MB (16’819’200B). Zatem przechowywanie całego roku danych kosztuje aż $0,00034. A… zapomniałem dodać, że pierwsze 10GB jest darmowe. Innymi słowy przy takiej skali danych nie muszę się przejmować opłatami za przechowywanie danych.   Koszt ładowania danych   Zdecydowałem się na ładowanie strumieniowe żeby mieć natychmiastowy dostęp do danych. Strumieniowe ładowanie danych jest płatne. W ciągu miesiąca Pogodynka 2.0 doda do bazy następującą liczbę wierszy:   60 (odczytów na godzinę) * 24 (godziny) * 30 (dni) = 43'200 (odczytów miesięcznie)   Żądanie dodania danych do bazy ma minimum 1KB (w przypadku Pogodynki 2.0 jest dużo mniejsze, jednak takie jest ograniczenie narzucone przez Google BigQuery). Zatem w ciągu miesiąca strumieniowo zostanie przesłanych 43,2MB danych. Podsumowując, miesięczny koszt strumieniowego ładowania danych to $0,0002. Myślę, że mogę żyć z takim zobowiązaniem ;).   Koszt pobierania danych z bazy   Nie planuję odczytywać danych samodzielnie. Dane będą odczytywane przez raport, który utworzyłem w DataStudio. Dla uproszczenia pomijam tu kwestię przechowania wyników w cache’u, która obniży finalny koszt.   Załóżmy, że pogodynka będzie działała przez 1000 lat ;). W trakcie tak długiego czasu w bazie uzbiera się 17GB. Jednorazowy odczyt tysiącletniej historii pomiarów czujników Pogodynki 2.0 kosztowałby $0,09. A… znów zapomniałem o tym, że pierwszy 1TB w miesiącu jest darmowy. Po raz kolejny przy takiej skali danych nie muszę się przejmować opłatami za odczyt danych z bazy.   Finalne porównanie   W tym konkretnym przypadku chmura jest praktycznie darmowa. Pamiętaj jednak, że podobną analizę kosztów warto zrobić dla konkretnego przypadku – koszty rozwiązań chmurowych potrafią zaskoczyć, jeśli projektowane rozwiązania nie są efektywne.   Dla przykładu, w pierwotnej wersji Pogodynki 2.0 każdy czujnik zapisywał pomiar w osobnym wierszu. Sprowadzał się do do trzy razy większej liczby wierszy – trzy razy wyższym koszcie za strumieniowe przesyłanie danych. W skali Pogodynki $0,0002 czy $0,0006 nie robi większej różnicy, jednak w produkcyjnych systemach operujących na dużych zbiorach danych takie szczegóły mogą być bardzo istotne.   Infrastruktura jako kod   Pracując z projektami opartymi o chmurę miałem do czynienia z różnym podejściem do zarządzania zasobami w chmurze. W części z projektów zasoby były tworzone ręcznie. Całość konfiguracji odbywała się ręcznie przez interfejs dostarczony przez dostawcę chmury.   Na dłuższą metę takie podejście jest uciążliwe. Używanie narzędzi pokroju Terraform znacząco ułatwia pracę w projekcie opartym o chmurę.   Podsumowanie   Pogodynka 2.0 już działa. Zachęcam Cię do samodzielnego wykonania takiego projektu. Koszt jaki będziesz musiał ponieść jest znikomy w porównaniu do wiedzy, którą możesz zdobyć. Jedynym znaczącym kosztem jest cena samej malinki (aktualnie około 180zł) i czujnika SDS011 (aktualnie około 70zł).   Kod źródłowy Pogodynki 2.0 dostępny jest na Samouczkowym Githubie.   Mam nadzieję, że artykuł był dla Ciebie pomocny. Proszę podziel się nim ze swoimi znajomymi. Dzięki temu pozwolisz mi dotrzeć do nowych Czytelników, za co z góry dziękuję. Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do samouczkowego newslettera i polub Samouczka Programisty na Facebooku.   Do następnego razu!                 Dla uproszczenia obliczeń pomijam tutaj tak zwane „long-term storage”, dane starsze niż 90 dni kosztują $0,01 za 1GB &#8617;           ","categories": ["Projekty","Pogodynka"],
        "tags": [],
        "url": "/pogodynka-w-chmurze/",
        "teaser": "/assets/images/2021/0523-pogodynka-w-chmurze/pogodynka_w_chmurze_artykul.jpg"
      },{
        "title": "Strefa zadaniowa",
        "excerpt":"Gorąco wierzę w to, że nauka powinna odbywać się przez praktykę. Uważam, że samodzielne rozwiązywanie problemów i późniejsze porównywanie rozwiązań to najlepszy sposób na naukę. Właśnie z tego powodu staram się, żeby każdy z artykułów kończył się praktycznym zadaniem do wykonania.   Dodatkowo przygotowałem dla Ciebie osobny zestaw artykułów, w którym znajdziesz szereg zadań o różnym poziomie trudności. Część z zadań jest czysto algorytmiczna, część skupia się na umiejętnym wykorzystaniu biblioteki standardowej. Każde zadanie, bez wyjątku, posiada przykładowe rozwiązanie, które możesz porównać ze swoim.   Zadania z rozmów kwalifikacyjnych   Czasami od czytelników dostaję zadania z ich rozmów kwalifikacyjnych. Poniżej znajdziesz listę artykułów, w których rozkładam takie zadania na czynniki pierwsze. W tym przypadku przyda Ci się wiedza dotycząca złożoności obliczeniowej.      Czy liczba jest cykliczna   Znajdź brakujący element   Zagnieżdżona struktura   Kalkulator   Łańcuchy białkowe   Zadania różne      Zestaw ćwiczeń dla początkujących programistów   Choinka   Game of Life   Maszyna losująca   Advent of Code   Advent of Code to inicjatywa, w której codzienne w trakcie adwentu publikowane są zadania do rozwiązania. W jednym z początkowych lat istnienia bloga wziąłem na tapet zadania prezentowane w tym cyklu.      Advent of Code 2016 dzień 1   Advent of Code 2016 dzień 2   Advent of Code 2016 dzień 3   Advent of Code 2016 dzień 4   Advent of Code 2016 dzień 5   Advent of Code 2016 dzień 6   Advent of Code 2016 dzień 7   Advent of Code 2016 dzień 8   Advent of Code 2016 dzień 9   Advent of Code 2016 dzień 10   Advent of Code 2016 dzień 11   Advent of Code 2016 dzień 12   Advent of Code 2016 dzień 13   Advent of Code 2016 dzień 14   Advent of Code 2016 dzień 15   Advent of Code 2016 dzień 16   Advent of Code 2016 dzień 17   Advent of Code 2016 dzień 18   Advent of Code 2016 dzień 19   Advent of Code 2016 dzień 20   Advent of Code 2016 dzień 21   Advent of Code 2016 dzień 22   Advent of Code 2016 dzień 23   Advent of Code 2016 dzień 24   Advent of Code 2016 dzień 25   Nie zapominaj o testach   Manualne testowanie swoich rozwiązań na dłuższą metę nie jest dobre. Nie zapominaj o testach jednostkowych. Listę artykułów poświęconych testowaniu zebrałem w dziale opisującym narzędzia i dobre praktyki.   Co dalej?   Udało Ci się przerobić zadania, które zebrałem na tej stronie i chcesz więcej? Bardzo dobrze! :). Rzuć okiem na odpowiedź na to pytanie na portalu StackExchange. Znajdziesz tam całą masę innych stron, które zbierają programistyczne zadania do rozwiązania.   Możesz też zabrać się za większe zadania. Na blogu opisałem kilka projektów zrealizowany od początku do końca.   A może masz zadanie z rozmowy kwalifikacyjnej, które sprawiło Ci problem? Jeśli tylko dam radę je rozwiązać z chęcią napiszę o nim kolejny artykuł :). Możesz mi je podesłać na mój adres e-mail marcin małpka samouczekprogramisty.pl.     Często firmy zastrzegają sobie to, żeby nie rozpowszechniać zadań, które były na rozmowie kwalifikacyjnej. Jeśli tak było w Twoim przypadku proszę uszanuj wolę danej firmy i nie przesyłaj mi takiego zadania.   Dostając zadanie od Ciebie zakładam, że mogę je opublikować na blogu.     ","categories": [],
        "tags": [],
        "url": "/strefa-zadaniowa/",
        "teaser": "/assets/images/splash/dzial_strefa_zadaniowa.jpg"
      },{
        "title": "Strefa projektowa",
        "excerpt":"Na blogu staram się pokazywać, że nauka powinna odbywać się poprzez praktykę. Właśnie z tego powodu realizuję projekty “od początku do końca”. Na tej stronie znajdziesz zestaw artykułów, które związane są z większymi projektami programistycznymi.   Projekty   Pogodynka   Pogodynka to projekt, który polegał na udostępnieniu odczytów temperatury na żywo. Termometr cały czas działa i pokazuje temperaturę: http://pogodynka.pietraszek.pl. Projekt ten realizowałem w trakcie konkursu Daj się poznać 2017.      Projekt Pogodynka – wprowadzenie   Projekt Pogodynka – naiwny termometr   Projekt Pogodynka – działający termometr   Projekt Pogodynka – szkielet aplikacji webowej   Projekt Pogodynka – JSON i walidacja   Projekt Pogodynka – JPA i Spring Data   Projekt Pogodynka – konfiguracja serwera   Projekt Pogodynka – konfiguracja bazy danych   Projekt Pogodynka – szkic interfejsu użytkownika   Projekt Pogodynka – integracja   Projekt Pogodynka – podsumowanie   Informator   Zadaniem tego projektu było udostępnienie API pozwalającego na odczyt informacji o konferencji infoShare. Projekt ten realizowałem w ramach współpracy z organizatorem konferencji infoShare 2018.      Projekt Informator – wprowadzenie   Projekt Informator – wdrożenie w chmurze   Projekt Informator – zasilenie bazy, Spring i błędy jako JSON   Co dalej?   Zabierz się za swój projekt ;). Znajdź temat, który interesuje Cię najbardziej. Niech Twój projekt rozwiązuje problem związany z tym interesującym tematem. Może to być rejestr podlewania kwiatków, zbiór wyników ligi piłki ręcznej czy zestawienie z datami premier interesujących Cię seriali. Niech to będzie cokolwiek, co zachęci Cię do programowania. Masz problem ze znalezieniem tematu? Zapytaj najbliższych znajomych. Osoby, które znają Cię najlepiej na pewno wskażą coś, co będzie dla Ciebie interesujące.   Jeśli masz już kilka projektów za sobą to może warto rozejrześ się za pierwszą pracą w IT.   A może masz pomysł na projekt, który powinienem zrealizować na blogu? Może Twoim zdaniem trzeba poprawić coś w istniejących projektach? A może znalazłeś błąd? Nie wahaj się naskrobać do mnie parę zdań, będę wdzięczny za każdą opinię. Mój adres e-mail to marcin małpka samouczekprogramisty.pl.  ","categories": [],
        "tags": [],
        "url": "/strefa-projektowa/",
        "teaser": "/assets/images/splash/dzial_strefa_projektowa.jpg"
      },{
        "title": "Praca i rozmowa kwalifikacyjna",
        "excerpt":"Prezentowanie swojej wiedzy to też umiejętność. Umiejętności tej także uczy się przez praktykę. Częściowo można ją zdobyć także w domu. Na tej stronie starałem się pogrupować materiały, które pomogą Ci w zdobyciu pracy jako programista.   Pierwsza praca   Pierwsza praca i rozmowa kwalifikacyjna to spory stres dla początkujących programistów. Sam wysłałem ponad czterdzieści CV zanim dostałem swoją pierwszą pracę. Było to w 2007 roku kiedy firm na rynku było dużo mniej niż dzisiaj. Jeśli dobrze pamiętam to odpowiedzi dostałem raptem z trzech firm.   Nie wiem czy dzisiaj jest łatwiej, czy trudniej zdobyć pracę niż w 2007 roku. Na pewno wiem, że to nie jest proste. Właśnie dlatego napisałem kilka artykułów, które mogą pomóc Ci przejść ten etap.      Jak zostać programistą   Jak dostać pierwszą pracę jako programista   Zmiana branży na IT – wywiady z tymi, którym się udało   Zadania z rozmów o pracę   Czasami dostaję od czytelników zadania, które otrzymali do rozwiązania w trakcie rozmowy kwalifikacyjnej. Każde z tych zadań rozbieram na części pierwsze i pokazuję w jaki sposób można je rozwiązać. Artykuły często zawierają klika przykładowych sposobów rozwiązania danego problemu.   Zależy mi na tym, żeby materiały te traktować jako coś co pomoże Ci w poprawieniu swoich umiejętności. Właśnie dlatego zawsze zachęcam do samodzielnego rozwiązania zadań i porównania rozwiązań. W ten sposób nauczysz się najwięcej.      Zadanie z rozmowy – znajdź brakujący element   Zadanie z rozmowy – czy liczba jest cykliczna   Zadanie z rozmowy – zagnieżdżona struktura   Zadanie z rozmowy – kalkulator   Zadanie z rozmowy – łańcuchy białkowe   Jakiś czas temu zastanawiałem się, czy bardziej nie zaszkodzę niż pomogę publikując gotowe rozwiązania. Moje przemyślenia na ten temat zebrałem w artykule opisującym granice wsparcia w rekrutacji.   Co dalej?   Może zadanie z Twojej rozmowy sprawiło Ci trochę problemów? Proszę daj mi o nim znać, jeśli tylko będę potrafił je rozwiązać z chęcią umieszczę je na blogu. Możesz mi je wysłać na mój adres e-mail marcin małpka samouczekprogramisty.pl.     Często firmy zastrzegają sobie to, żeby nie rozpowszechniać zadań, które były na rozmowie kwalifikacyjnej. Jeśli tak było w Twoim przypadku proszę uszanuj wolę danej firmy i nie przesyłaj mi takiego zadania.   Dostając zadanie od Ciebie zakładam, że mogę je opublikować na blogu.     Jeśli chcesz lepiej przygotować się do rozmowy kwalifikacyjnej zapraszam Cię do strony gdzie pogrupowałem zadania dla programistów z rozwiązaniami i przykładowe projekty programistyczne, które realizowałem na blogu.   Zachęcam Cię także do poszerzenie swojej wiedzy związanej z teorią informatyki. Niektóre zagadnienia tam poruszane dość często zdarzają się na rozmowach kwalifikacyjnych.  ","categories": [],
        "tags": [],
        "url": "/praca-i-rozmowa-kwalifikacyjna/",
        "teaser": "/assets/images/splash/dzial_praca_i_rozmowa_kwalifikacyjna.jpg"
      },{
        "title": "Wprowadzenie do informatyki",
        "excerpt":"Studiowałem Informatykę na Politechnice Wrocławskiej. Nie jestem wykładowcą akademickim, więc nie oczekuj ode mnie akademickiej teorii ;). W artykułach teorię staram się pokazać w przyjazny i zrozumiały sposób, poparty przykładami.   Tematy, które opisałem w artykułach znajdujących się na tej stronie to materiał, który moim zdaniem powinien znać każdy programista. Jeśli masz inne zdanie z chęcią poznam Twój punkt widzenia.   Arytmetyka komputerów   Można powiedzieć, że komputer posługuje się ciągiem 0 i 1. Jak te ciągi przekładają się na liczby? Artykuły z tej listy pomogą Ci to zrozumieć.      System binarny   Liczby zmiennoprzecinkowe w standardzie IEEE754   Struktury danych   Struktury danych to chleb powszedni pracy programisty. Bez ich pomocy nie powstanie żaden większy program. Moim zdaniem dobrze jest rozumieć jak te struktury działają. Artykuły z tej listy przybliżą Ci te najczęściej używane. Zawsze pokazuję też przykładową implementację:      Struktura danych – lista wiązana   Struktura danych – hashmap   Struktura danych – zbiór   Różne   Na koniec mam dla Ciebie listę różnych zagadnień, które także są warte Twojej uwagi, a nie pasowały do kategorii wymienionych wyżej.      Podstawy złożoności obliczeniowej   Protokół HTTP   Wstęp do relacyjnych baz danych   Podstawy UML   Co dalej?   Teorię trzeba łączyć z praktyką, zapraszam Cię do rozwiązania kilku zadań dla programistów. Kolejnym etapem praktyki może być przejrzenie projektów programistycznych.   Zachęcam Cię też do przeczytania artykułu, w którym znajdziesz zestawienie zawierające książki dla programistów.  ","categories": [],
        "tags": [],
        "url": "/wprowadzenie-do-informatyki/",
        "teaser": "/assets/images/splash/dzial_wprowadzenie_do_informatyki.jpeg"
      },{
        "title": "Narzędzia i dobre praktyki",
        "excerpt":"Znajomość składni języka programowania to dopiero początek. Programista w swojej codziennej pracy wykorzystuje szereg narzędzi, które pomagają mu w pracy. Na tej stronie zebrałem artykuły, które związane są z narzędziami i dobrymi praktykami, które warto stosować na co dzień.   Narzędzia      Wstęp do Gradle   Pierwszy projekt w Gradle   Walidacja obiektów w języku Java   Format JSON w języku Java   Początki pracy z wierszem poleceń   Wprowadzenie do bash’a   Dodatkowo koniecznie musisz znać system kontroli wersji. Proponuję Ci zacząć od Git’a, który jest standardem w branży. Kurs Gita dostępny na Samouczku powinien Ci pomóc go poznać.   Dobre praktyki   Bez tego się nie obejdzie. Jeśli chcesz tworzyć kod, który będzie łatwy w utrzymaniu, możliwy do rozszerzenia i testowania stosuj dobre praktyki opracowane przez bardziej doświadczonych programistów. Ta lista zawiera artykuły, które opisują takie praktyki.      Zasady SOLID   Reguły DRY, KISS i YAGNI   Porównanie DIP, IOC i DI   W niektórych sytuacjach rysunki pokazujące system/rozwiązanie problemu. Właśnie wtedy może Ci się przydać znajomość podstaw UML.   Testowanie kodu   Testowanie kodu to temat rzeka. Na początek polecam Ci artykuły, które opisują tematykę testów jednostkowych i bibliotekę JUnit:      Testy jednostkowe z JUnit   Testy jednostkowe z JUnit 5   Testy jednostkowe z Mockito   Jak poznasz już bibliotekę pomagającą w pisaniu testów jednostkowych koniecznie musisz poznać podejście Test Driven Development. W artykule tym na przykładzie pokazuję jak TDD wygląda w praktyce. Część zadań z rozmów kwalifikacyjnych, które dostałem od Czytelników także rozwiązałem używając TDD:      Zagnieżdżona struktura   Kalkulator   Wzorce projektowe   Nie bez znaczenia są także wzorce projektowe. Na blogu opisałem kilka z nich. Do zrozumienia diagramów użytych w artykułach dotyczących wzorców musisz poznać podstawy notacji UML. Artykuły poniżej zawierają dokładny opis, przykłady zastosowania i implementację poszczególnych wzorców projektowych:      Wzorzec projektowy adapter   Wzorzec projektowy obserwator   Wzorzec projektowy dekorator   Wzorzec projektowy metoda wytwórcza   Co dalej?   Skoro udało Ci się już poznać kilka użytecznych narzędzi i dobrych praktyk warto je wykorzystać. Proponuję Ci rozpoczęcie swojego projektu lub przećwiczenie ich w trakcie rozwiązywania zadań. Oba te tematy poruszam na blogu. Znajdziesz tu projekty realizowane od początku do końca jak i zadania dla programistów z przykładowymi rozwiązaniami.   Kolejnym krokiem może być także poszerzenie swojej wiedzy związaną z teorią informatyki.  ","categories": [],
        "tags": [],
        "url": "/narzedzia-i-dobre-praktyki/",
        "teaser": "/assets/images/splash/dzial_narzedzia_i_dobre_praktyki.jpg"
      }]
