var store = [{
        "title": "Czym właściwie jest programowanie",
        "excerpt":"Kto może zostać programistą Programowanie to zajęcie, które wymaga znajomości wielu zagadnień. To wiedza, którą zdobywa się przez kilka ładnych lat. Nie znam żadnego programisty, który nauczył się wszystkiego w jeden wieczór. To jest po prostu niemożliwe. Tak i na tym blogu będziemy razem przechodzili przez serię artykułów, które pomogą Ci zgłębić podstawowe zagadnienia. Pokażę Ci dalszą drogę, która pomoże Ci zostać programistą. Programowanie jako zajęcie wymaga pewnych umiejętności. Umiejętności te są pomocne przy zgłębianiu niezbędnej wiedzy. Poza umiejętnościami bardzo istotne jest także zaangażowanie i wytrwałość. Oczywiście “talent” pomaga, jednak ciężka, systematyczna praca to podstawa. Bez talentu można programować, jednak bez ciężkiej pracy włożonej w naukę już nie (jestem tego bardzo dobrym przykładem). Nie bez powodu piszę blog po polsku. Zależy mi na tym, żeby ludzie, którzy nie czują się swobodnie czytając angielskie teksty również znaleźli coś dla siebie. Jednak muszę to powiedzieć z pełną stanowczością. Język angielski to podstawa. Jest to uniwersalny język komunikacji, który każdy programista po prostu musi znać. Jeśli go nie znasz zachęcam do przyłożenia się do zajęć z języka angielskiego. Jeśli nie masz dostępu do takich zajęć w internecie można znaleźć bardzo dużo darmowych materiałów pomagających w nauce. Mówi się, że programista powinien charakteryzować się analitycznym myśleniem, rozumieć zagadnienia matematyczne. Oczywiście ścisły umysł to predyspozycja, która bardzo pomaga – sam znam architektów (tych od budownictwa) czy chemików, którzy samodzielnie nauczyli się programowania. Jednak mam wrażenie, że przy odpowiedniej ilości ciężkiej pracy i humanista też w programowaniu znajdzie coś dla siebie. Spróbuj, to na pewno nie zaszkodzi! :) Podsumowując:   ucz się języka angielskiego, na pewno przyda się nie tylko do programowania,  nie bój się przedmiotów ścisłych,  wkładaj dużo pracy w naukę programowania.Rozmowa z komputerem Do porozumiewania się ze swoimi przyjaciółmi, znajomymi używamy dobrze znanych słów i zwrotów. Rozumiemy się nawzajem, jesteśmy w stanie przekazać sobie pewne informacje. Jeśli posługujemy się językami obcymi porozumiemy się swobodnie z większą grupą ludzi. Podobnie jest z komputerem. Jeśli chcesz się z nim porozumieć musisz mówić jego językiem. Nie chcę Cię tu zanudzać wpisem o zerach i jedynkach fruwających w pamięci komputera jednak pewne podstawy są tu potrzebne. Język programowania to nic innego jak język, który rozumieją programiści. Są w stanie się nim swobodnie posługiwać, który następnie tłumaczony jest do języka komputera. Słowa przetłumaczone są na ciąg zer i jedynek zrozumiały przez komputer. Ten etap tłumaczenia możemy nazwać kompilacją (ang. compile). Języki programowania możemy podzielić na języki niskopoziomowe i wysokopoziomowe. Te pierwsze są bardzo trudne do samodzielnego używania. Programy napisane przy ich pomocy mogą być uruchamiane tylko na konkretnych rodzajach komputerów. Na przykład program napisany w języku niskiego poziomu na Twój komputer nie może być uruchomiony na komputerze Twojego kolegi1. Tego typu ograniczenia sprawiają, że języków niskiego poziomu nie używa się powszechnie, a jedynie do bardzo specyficznych zastosowań, które są bardzo odległe od podstaw i nauki programowania :) Dzięki tym samym ograniczeniom języki wysokiego poziomu zyskują na popularności.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Polski? Angielski? Niemiecki? Rosyjski? Francuski? F? Erlang? JavaScript? Java? Perl? Ruby? Podobnie jak istnieje wiele języków, którymi mówią ludzie istnieje także wiele języków programowania. Każdy z tych języków charakteryzuje się specyficzną składnią (ang. syntax). Każdy z nich ma również specyficzny zakres zastosowań. Po prostu jego właściwości sprawiają, że lepiej nadaje się np. do pisania gier komputerowych niż tworzenia interaktywnych stron internetowych. W ramach pierwszego kursu dostępnego na blogu skupimy się na języku Java. Wybór padł na ten język ponieważ Google nadal raportuje spore zainteresowanie tym językiem, jak i jest on w miarę uniwersalny i bardzo powszechny. W następnym artykule skupimy się na omówieniu podstaw tego języka jednak zanim do tego dojdzie chciałbym Wam przybliżyć następujące pojęcia:   język obiektowy (ang. objective language)  maszyna wirtualna (ang. virtual machine)Czym jest język obiektowy? Weźmy za przykład stół i jego projekt. Fabryka produkuje setki stołów, wszystkie według tego samego projektu. Podobne projekty istnieją w języku programowania. Stół możemy uznać za tak zwaną instancję (ang. instance) lub obiekt (ang. object) klasy stół. Innymi słowy projekt służy nam do tworzenia obiektów/instancji. Odpowiednikiem projektu w języku programowania jest klasa (ang. class). Język obiektowy jest językiem, który pozwala na tworzenie swoich własnych klas. Mając definicję klasy jesteśmy w stanie stworzyć jej instancję. Czym jest maszyna wirtualna? Maszyna wirtualna to program napisany w języku niższego poziomu. Program ten pozwala na pewną abstrakcję, upraszcza niektóre aspekty rozmowy z komputerem. Jako przykład podam tu maszynę wirtualną języka Java. Maszyna ta do pewnego stopnia zwalnia programistę z odpowiedzialności zarządzania pamięcią. Instancje klas, które tworzymy zajmują pamięć. Komputer musi dokładnie wiedzieć ile pamięci ma zarezerwować na daną instancję. Jeśli język korzysta z maszyny wirtualnej wspomagającej zarządzenie pamięcią programista nie musi się tym przejmować (oczywiście jest to pewne uproszczenie, ale na tym etapie zaawansowania w zupełności wystarczy). Na dzisiaj wystarczy. Dzisiaj było bardzo mocno teoretycznie, następnym razem zaczniemy bawić się programowaniem. Czy którykolwiek z elementów wydał się dla Ciebie niezbyt jasny? Proszę daj mi znać o tym w komentarzu. Jeśli uznasz wpis za ciekawy proszę podziel się nim ze swoimi znajomymi. Do następnego razu! :)             Jest to duże uproszczenie, chodzi tu o tak zwaną architekturę procesora. Każda architektura ma swój specyficzny zestaw komend tzw. assembler, która czasami nie może być uruchamiana na różnych procesorach. &#8617;       ","categories": ["Programowanie"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/czym-wlasciwie-jest-programowanie/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2015/10/07_czym_jest_programowanie.jpg"},{
        "title": "Przygotowanie środowiska programisty",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. W poprzednim artykule pobieżnie opisałem czym właściwie jest programowanie. Do rozpoczęcia nauki niezbędne będzie zainstalowanie paru dodatkowych narzędzi niezbędnych dla programisty. Zanim do tego przejdziemy postaram się wytłumaczyć czym właściwie jest wersjonowanie oprogramowania. Wersjonowanie oprogramowania Czy widziałeś czasami dziwne numerki dołączone do nazwy programu, którego aktualnie używasz? Np. 1.0.7, 0.7, 1.2-rc1, 3.14? To nic innego jak wersja oprogramowania, którego używasz. Nowsze wersje oprogramowania przeważnie zawierają zestaw nowych funkcjonalności niedostępnych w poprzednich wersjach. Poprawiają błędy znalezione przez użytkowników. Rozwiązują problemy związane z bezpieczeństwem. Jeśli program jest w stanie współpracować z innym programem mówimy wówczas, że jest on kompatybilny (ang. compatible). Czasami zdarza się, że nowsza wersja nie jest kompatybilna wstecz ze starą wersja oprogramowania. Oznacza to, że programy używające innego programu w wersji 1 nie będą mogły używać go w wersji 2. Poniżej przedstawię Ci przykładowy opis jednego z możliwych standardów wersjonowania programów. Nie jest to standard jedyny, jednak jest dość popularny. Wersjonowanie oprogramowania X.Y.Z Standardowo na wersję oprogramowania składają się trzy osobne liczby. Mówiąc o wersji oprogramowania możemy mieć na myśli np. wersję 2.7.0. Wersja ta składa się z 3 członów:   2 – (ang. major) każdy nowy numer oznacza nową wersję, która nie jest kompatybilna wstecz,  7 – (ang. minor) każda nowa wersja oznacza wprowadzenie nowych funkcjonalności kompatybilnych wstecz,  0 – (and. patch) kolejny numer wersji w tym członie symbolizuje zbiór łatek.Jako łatkę (ang. patch) możemy traktować fragment kodu poprawiający błędy (ang. bugs) znalezione w starszej wersji oprogramowania. Zbiór łatek przeważnie grupowany jest w osobne wersje. Np. wersja 2.7.1 zawierająca kila łatek poprawia błędy znalezione w wersji 2.7.0. A teraz kilka przykładów:   Wersja 2.0.0 wprowadza zmiany, które nie są kompatybilne z wersją 1.8.0,  Wersja 1.8.0 wprowadza nową funkcjonalność kompatybilną z 1.7.5,  Wersja 1.7.5 wprowadza poprawki funkcjonalności względem wersji 1.7.4.  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Instalacja niezbędnych narzędzi Naszą naukę zaczniemy od języka Java. Jest to język obiektowy, wymagający wirtualnej maszyny (oba pojęcia wyjaśniłem poprzednio - zachęcam do powtórki w razie wątpliwości). Istnieje wiele implementacji wirtualnej maszyny Javy. Mówiąc o wielu implementacjach mam tu na myśli różne firmy dostarczające JVM (ang. Java Virtual Machine). Najbardziej popularną z nich jest maszyna wirtualna firmy Oracle. Zanim jednak przejdziemy przez proces instalacji chciałbym wyjaśnić Ci jedną ważną kwestię.. Czym różni się JDK od JRE? W przypadku języka Java często będziesz miał styczność z terminami JRE oraz JDK. Bardzo istotne jest zrozumienie różnicy pomiędzy nimi. JRE (ang. Java Runtime Environment) – jest to maszyna wirtualna nie zawierająca dodatkowych narzędzi niezbędnych dla programisty. W uproszczeniu można powiedzieć że zawiera wyłącznie implementację wirtualnej maszyny – program java. Do uruchamiania programów napisanych w języku Java wystarczy JRE. JDK (ang. Java SE Development Kit) – jest to zestaw narzędzi dla programisty. Zestaw ten jest niezbędny do pisania programów w języku Java. Poza programem java zawiera wiele innych. Jednym z dodatkowych programów zawartych w zestawie jest javac – kompilator1 języka Java. Instalacja JDK Proces instalacji jest różny na różnych systemach operacyjnych. Sam używam jednejz dystrybucji systemu Linux jednak na potrzeby tego wpisu pożyczyłem komputerz systemem Windows 7. Cały proces zaczynamy od ściągnięcia odpowiedniej wersji maszyny wirtualnej. Ważne jest żeby była to wersja 1.8 bądź nowsza (poniżej zobaczysz proces instalacji dla wersji 1.8u60). Krok pierwszy polega na ściągnięciu odpowiedniej wersji JDK ze strony Oracle. Proszę pamiętaj o tym, żeby ściągnąć wersję odpowiednią dla Twojego systemu. Jeśli masz system 32-bitowy ściągnij plik jdk-8u60-windows-i586.exe. W przypadku systemu 64-bitowego ściągnij plik jdk-8u60-windows-x64.exe. Instrukcja opisująca to jak dowiedzieć się jaki masz system dostępna jest na stronie pomocy systemu Windows. Aby móc ściągnąć jeden z plików musisz przeczytać i zaakceptować warunki licencji.         Pobierz JDK.  Po ściągnięciu pliku uruchom go i postępuj zgodnie z instrukcją instalacji. Poniżej prezentuję kolejne ekrany widoczne podczas instalacji JDK.         Instalacja JDK krok I          Instalacja JDK krok II          Instalacja JDK krok III          Instalacja JDK krok IV  Czego używają programiści do pisania kodu W najprostszym przypadku wystarczy zwykły edytor tekstu. W systemie operacyjnym Windows tę funkcję spełnia Notatnik. Większość języków programowania nie wymaga innego narzędzia do pisania kodu. Chociaż takie narzędzie w zupełności wystarczy do efektywnej pracy przydają się bardziej zaawansowane narzędzia. Jednym z nich jest „zintegrowane środowisko programistyczne” – IDE (ang. Integrated Development Environment). IDE poza bardziej zaawansowanym edytorem zawiera zestaw dodatkowych narzędzi przydatnych programiście. Np. „profiler”, „debuger”, zestaw narzędzi do refaktoryzacji itp. Jeśli jesteś zainteresowany, którymkolwiek z tych zagadnień daj znać, na pewno napiszę artykuł na jego temat ;) Nie ma jednego, słusznego IDE, którego programista powinien używać. Sam swoją przygodę zaczynałem z Eclipse i NetBeans. Jednak po pierwszych doświadczeniach z InteliJ Idea i opinii wśród innych programistów wydaję mi się, że powinieneś zacząć właśnie od tego IDE. Postaram się przeprowadzić Cię przez cały proces instalacji. Instalacja InteliJ Idea Podobnie jak w przypadku instalacji JDK używałem maszyny z systemem Windows 7. Aby ściągnąć InteliJ Idea musisz na stronie https://www.jetbrains.com/idea/download nacisnąć przycisk z napisem „Download Community”.         Pobierz InteliJ Idea.  Instalacja InteliJ nie zawiera tak wiele ekranów jak instalacja JDK :) Jednak to nie wszystko. Teraz, gdy mamy już działające IDE należy je skonfigurować. Na pierwszym ekranie masz możliwość wyboru zestawu kolorów. Ja wybrałem ciemny, oczywiście możesz to później zmienić.         Instalacja krok I  Tworzenie pierwszego projektu w InteliJ Idea Świeżo po instalacji InteliJ Idea niestety nie wie, którego JDK ma użyć (tak, możesz mieć kilka zainstalowanych JDK na jednym komputerze). Dlatego przy tworzeniu pierwszego projektu należy wskazać odpowiednią ścieżkę gdzie poprzednio zainstalowaliśmy JDK.         Instalacja krok II          Tworzenie projektu krok I  Następnie wybieramy ścieżkę gdzie zainstalowaliśmy JDK.         Tworzenie projektu krok II  Po dodaniu JDK możemy je wybrać w menu rozwijanym. Na kolejnym ekranie nie wybieramy żadnego szablonu. Ostatni ekran to wybór nazwy projektu – ja wybrałem test.         Tworzenie projektu krok III          Tworzenie projektu krok IV          Tworzenie projektu krok V  I tak utworzyliśmy swój pierwszy projekt w InteliJ! :) Co prawda nie ma w nim jeszcze ani linijki kodu ale tym szczegółem zajmiemy się następnym razem.         Tworzenie projektu krok VI  Podsumowanie I tak dobrnęliśmy do końca przygotowania podstawowego środowiska dla programisty. Jeśli masz pytania dotyczące któregokolwiek z tematów proszę zadaj je w komentarzach. Proszę także podziel się tym artykułem ze swoimi znajomymi jeśli uznasz go za interesujący.             Kompilator to narzędzie tłumaczące język wysokiego poziomu na instrukcje zrozumiałe przez komputer. W naszym przypadku javac jest kompilatorem tłumaczącym język Java na tak zwany bajtkod (ang. bytecode). Ten drugi jest interpretowany i wykonywany przez maszynę wirtualną. &#8617;       ","categories": ["Kurs programowania Java","Programowanie"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/przygotowanie-srodowiska-programisty/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2015/10/18_przygotowanie_srodowiska_programisty.jpg"},{
        "title": "Metody w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Metoda boolean isBig(int someNumber) {    return someNumber &gt; 100;}Więc jesteś już po przeczytaniu swojego pierwszego fragmentu kodu! Brawo! Programowanie to nie tylko pisanie, ale także czytanie kodu. Ale do rzeczy… Metoda to nic innego jak worek grupujący zestaw instrukcji. Kod grupujemy w ten sposób z kilku powodów. Wymienię dwa, które moim zdaniem są najważniejsze:   jeśli jakiś fragment kodu ma być wykonany w wielu miejscach zdecydowanie lepiej jest utworzyć metodę i ją uruchomić (wywołać), niż kopiować ten sam fragment kodu wielokrotnie. Jest to istotne ponieważ w przypadku błędu trzeba go poprawić w jednym miejscu a nie w kilku1,  programy są duże, bez odpowiedniego podziału opanowanie całego projektu/programu jest bardzo czasochłonne. Sensowny podział na mniejsze części pozwala szybciej zrozumieć kod.Typy danych Zadnim przejdę do omówienia metod musisz dowiedzieć się czym są typy danych. Metoda wyżej przyjmuje argument someNumber. Argument ten ma swój typ int. Typ w języku programowania opisuje rodzaj danych. Na przykład w kodzie powyżej widoczne są dwa typy:   boolean – typ przechowujący wartości prawda/fałsz. Prawda reprezentowana jest przez wartość true. Fałsz to false. Typ ten może nam pomóc przechowywać informację o tym czy ktoś jest wysoki, czy jest pełnoletni, czy ma niebieski kolor oczu itp.boolean isTall = true;boolean hasBlueEyes = false;  int – typ przechowujący liczby całkowite. Liczby te możesz zapisać na wiele sposobów, skupię się na najprostszym – ciąg cyfr (opcjonalnie poprzedzony znakiem). Ten typ może nam posłużyć do przechowywania informacji o aktualnej temperaturze, wzroście, odległości z miasta A do B itp.Tutaj muszę też powiedzieć o pewnych ograniczeniach. int podobnie jak każda inna wartość reprezentowana jest w pamięci komputera. Każda z wartości zajmuje określony rozmiar pamięci. Przez to ograniczenie nie jesteśmy w stanie przechowywać wszystkich liczb w zmiennej. W przypadku Javy w zmiennej typu int możemy przechowywać liczby od -2 147 483 648 do 2 147 483 647. Jak widzisz są do dość duże liczby jednak do pewnych zastosowań potrzebujemy innych typów danych. int temperature = -12;int height = 186;int distance = 2589;int numberOfErrors = 0;Innym popularnym typem danych jest String. Służy on do przechowywania łańcuchów znaków: String name = \"Marcin\";String weekday = \"Monday\";String someSentence = \"Samouczek Programisty jest git ;)\";Omówienie składni definiowania metody Powtórzę ten sam fragment kodu jeszcze raz: boolean isBig(int someNumber) {    return someNumber &gt; 100;}Powyższe trzy linijki to definicja metody. W ten sposób tworzy się metodę. Metoda to zestaw instrukcji, który opcjonalnie może zwracać jakąś wartość. Szablon metody wygląda następująco: &lt;typ zwracany&gt; &lt;nazwa metody&gt;(&lt;opcjonalna lista argumentów&gt;) {    &lt;ciało metody&gt;}Argumenty metody Metody mogą przyjmować dowolnie dużo argumentów albo mogą nie przyjmować ich wcale. To, że jest to możliwe nie oznacza, że tak powinno się robić. W większości przypadków metody zawierające dużą liczbę argumentów są oznaką złych praktyk (ang. code smell). Duża liczba argumentów w metodzie pogarsza czytelność kodu. Argumenty zawsze mają postać &lt;typ argumentu&gt; &lt;nazwa argumentu&gt;. Jeśli występuje więcej argumentów oddzielone są one przecinkiem. Na przykład metoda niżej pobiera trzy argumenty i zwraca ich sumę: int addNumbers(int number1, int number2, int number3) {    return number1 + number2 + number3;}  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Wartość zwracana Metoda może zwracać jakąś wartość. Do zwrócenia wartości z metody służy słowo kluczowe return. Na przykład metoda niżej nie pobiera żadnych argumentów i zwraca łańcuch znaków: String getName() {    return \"Marcin\";}Metoda może także nie zwracać żadnej wartości, wówczas używa się słowa kluczowego void do określenia typu zwracanej wartości. Na przykład metoda poniżej nie przyjmuje żadnych argumentów i nie zwraca żadnej wartości: void printSomething() {    System.out.println(\"Something\");}Jeśli metoda nie zwraca żadnej wartości również możesz użyć w jej ciele słowa kluczowego return. W takim przypadku return służy do wcześniejszego zakończenia działania metody (nie przejmuj się konstrukcją if, omówię ją niżej): void printSomethingIfNumberIsBig(int number) {    if (number &lt; 10) {        return;    }    System.out.println(\"Something\");}Wiesz już, że metody mogą przyjmować wiele argumentów. W języku Java nie jest możliwe zwracanie wielu wartości. Metoda może nie zwrócić nic (void) lub pojedynczą wartość. Ciało metody Ciało metody to kod zawarty pomiędzy nawiasami klamrowymi {}. Przeanalizuję teraz ciała trzech metod pokazanych powyżej. Metoda printSomething nie zwraca żadnej wartości. W środku zawiera wyłącznie fragment kodu. W tym przypadku zawiera wywołanie metody System.out.println. Ta metoda wyświetla przekazany argument na konsoli: System.out.println(\"Something\");Metoda addNumbers dodaje trzy zmienne number1, number2 i number3. Wynik dodawania zwracany jest jako wynik metody. Słowo kluczowe return wskazuje wynik metody: return number1 + number2 + number3;Podobnie w przypadku metody isBig słowo kluczowe return wskazuje wynik: return someNumber &gt; 100;Ciało tej metody zawiera operator porównania &gt;. someNumber &gt; 100 może zwrócić wartość logiczną. W zależności od wartości zmiennej someNumber wartość ta będzie różna:   jeśli someNumber równa się 10 wówczas someNumber &gt; 100 oznacza fałsz - false,  jeśli someNumber równa się 100 wówczas someNumber &gt; 100 oznacza fałsz - false,  jeśli someNumber równa się 101 wówczas someNumber &gt; 100 oznacza prawdę - true.Pamiętaj o tym, że słowo kluczowe return może występować w metodach, które nie zwracają żadnej wartości. Definicja metody a jej wywołanie Musisz nauczyć się rozróżniać dwa różne zapisy. Definicję metody: boolean isBig(int someNumber) {    return someNumber &gt; 100;}Wywołanie metody: boolean someVariable = isBig(10);printSomething();Pierwszy z nich to definicja metody. W ten sposób tworzy się metodę. Samo utworzenie metody nie powoduje jej wywołania. Drugi fragment kodu to wywołanie metody isBig i przypisanie wyniku do zmiennej someVariable. W trzecim fragmencie wywołana jest metoda printSomething. Teraz celowo trochę zamieszam Ci w głowie. Spójrz na kod poniżej: boolean isBig = isBig(10);Ta linijka to wywołanie metody isBig, która zwraca wartość i przypisuje ją do zmiennej o nazwie isBig. W tym przypadku isBig może oznaczać dwie różne rzeczy:   nazwę metody,  zmienną przechowującą typ boolean - w tym przypadku wynik działania metody isBig.Wywołanie metody Wiesz już, że samo utworzenie metody nic nie daje. Metodę trzeba wywołać, aby została wykonana. Zwróć uwagę na ten fragment kodu: int someNumber = 123;boolean result = isBig(someNumber);Ten fragment kodu zawiera kolejno:   Pierwsza linijka to utworzenie zmiennej i przypisanie do niej wartości:          int określający typ zmiennej,      someNumber nazwa zmiennej,      znak =, który oznacza przypisanie do zmiennej,      wartość 123, tak zwany literał.        Druga linijka to wywołanie metody i przypisanie wyniku do zmiennej:          boolean określający typ zmiennej,      result nazwę zmiennej,      znak przypisania,      wywołanie metody isBig, jako argument do jej wywołania przekazałem wartość zmiennej someNumber.      Zauważ, że linijki z kodem kończą się znakiem ;. Wywołąnie metody zawsze zawiera nazwę nawiasy () i nie zawiera {}. Nazewnictwo Każdy język programowania ma swego rodzaju standardy określające sposób w jaki powinno się nazywać metody, zmienne, funkcje, klasy itp. W języku Java używa się tzw. Camel Case. W uproszczeniu sprowadza się on do tego, że kolejne słowa łączy się w jeden ciąg znaków. Każde kolejne słowo pisze się wielką literą:   someSampleName,  example,  SampleClassName.Swego rodzaju wyjątkiem są tu nazwy klas, które także zaczynają się od wielkiej litery. Nie każdy ciąg znaków może być użyty jako nazwy klasy/zmiennej/metody. Niektórych znaków nie można używać. Podobnie jest z niektórymi słowami. Java ma zestaw słów, które są zastrzeżone i nie mogą być użyte jako nazwa zmiennej. Kilka przykładów:   boolean - jest to typ danych, nie można tak nazwać zmiennej,  class - jest to słowo kluczowe użyte przy definicji klasy,  return - słowo kluczowe użyte w metodzie oznacza wartość zwracaną przez daną metodę,  void - słowo kluczowe pokazujące brak zwracanej wartości,  #2someName! - nie wszystkie znaki są dopuszczalne. Dla uproszczenia można przyjąć, że można używać wyłącznie małych i wielkich liter od a do z bez polskich znaków2.Konstrukcja if Tę konstrukcję wprowadzam teraz tylko abyś mógł użyć jej w rozwiązaniu ćwiczenia. Szerzej opisałem ją w osobnym artykule. Zacznę od fragmentu kodu: boolean result = isBig(123);if (result) {    System.out.println(\"Liczba jest duza.\");}else {    System.out.println(\"Liczba nie jest duza.\");}Pierwszą linijkę już znasz. To wywołanie metody isBig i przypisanie wyniku do zmiennej o nazwie result. Kolejna linijka to konstrukcja if. Konstrukcja ta sprawdza czy result ma wartość true. Jeśli tak, to zostanie wywołany kod, który jest w bloku otoczonym {}. Jeśli result ma wartość false wówczas zostanie wywołany kod znajdujący się w bloku po else. Więc jeśli result ma wartość true wówczas zostanie wywołany kod: System.out.println(\"Liczba jest duza.\");Jeśli result ma wartość false to wywołany zostanie kod: System.out.println(\"Liczba nie jest duza.\");Ćwiczenie Na koniec mam dla Ciebie małe ćwiczenie. Napisz metodę, która sprawdzi czy temperatura przekazana jako argument jest dodatnia. Po rozwiązaniu zadania możesz rzucić okiem na przykładowe rozwiązanie. Jeszcze nie wiesz jak uruchomić tę metodę w działającym programie. Dowiesz się jak to zrobić w kolejnych etapach kursu. Podsumowanie I jak czujesz się po pierwszej lekcji? Udało Ci się wykonać ćwiczenie? Daj znać jak Ci poszło w komentarzach. W następnym artykule przeczytasz o klasach. Jeśli chcesz być na bieżąco proszę polub stronę Samouczka na Facebook’u. Naukę dobrze jest rozpocząć w gronie znajomych motywując się nawzajem, proszę poleć im tę stronę - razem zaczniecie uczyć się programowania.             DRY (ang. Don’t Repeat Yourself) zasada kładąca nacisk na redukcję powtarzającego się kodu. &#8617;               Reguły są oczywiście dużo bardziej rozbudowane, jednak dla naszych potrzeb takie uproszczenie w zupełności wystarczy. &#8617;       ","categories": ["Kurs programowania Java","Programowanie"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/metody-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2015/10/22_metody_w_jezyku_java.png"},{
        "title": "Obiekty w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Pakiet Programy komputerowe składają się z wielu plików. Przy dużym projekcie składającym się z kilkuset, kilku tysięcy plików kluczowe staje się odpowiednie zarządzanie plikami z kodem źródłowym programu. Bez takiego zarządzania wydajność programisty mocno spada. Więc czym jest pakiet? Pakiet wraz z nazwą klasy tworzy swego rodzaju “unikalny adres”. Podobnie jak ludzie mają swoje adresy tak klasy mają swoje pakiety, które pomagają zlokalizować klasy w trakcie działania programu. package pl.samouczekprogramisty.kursjava;Rozbijmy tę linię kodu na części pierwsze:   package - to słowo kluczowe podobnie jak class czy if, informuje kompilator o tym w jakim pakiecie znajduje się plik,  pl.samouczekprogramisty.kursjava - właściwa nazwa pakietu. Podobnie jak w przypadku omówionego w poprzednim artykule nazewnictwa metod tutaj obowiązują podobne zasady. Dla uproszczenia możemy powiedzieć, że dozwolone są małe litery oraz znak kropki.Istnieje kilka zarezerwowanych nazw pakietów. Służą one do odróżnienia klas dostarczonych wraz z wirtualną maszyną Javy od klas tworzonych przez programistów. Innymi słowy pakiety tworzone przez Ciebie nie mogą zaczynać się od java. ani od javax.. Pakiety służą do grupowania klas, interfejsów, typów wyliczeniowych czy adnotacji (Jeśli czytasz artykuły chronologicznie te terminy prawdopodobnie są dla Ciebie nowe. Nie przejmuj się, opiszę je dokładnie w jednym z kolejnych artykułów.). Jak zauważyłeś nazwa pakietów jest specyficzna. Przyjęło się, że za pakiet używa się odwróconej nazwy domeny. Takie podejście pozwala na łatwiejsze uniknięcie konfliktów. W przypadku naszego kursu użyłem pl.samouczekprogramisty.kursjava. Istotne jest tutaj odwzorowanie struktury katalogów. Każdy człon pakietu odpowiada katalogowi na dysku.         Pakiety w języku Java  W pliku źródłowym może znajdować się wyłącznie jedna linia z pakietem. Musi znajdować się na początku pliku. Co prawda nie jest to linia obowiązkowa, jednak używanie domyślnego pakietu nie jest dobrą praktyką1. Nazwy pakietów powinny odwzorowywać ich zawartość. Np pakiet pl.samouczekprogramisty.animals mógłby zawierać klasę Dog, ale już klasa Owner powinna znaleźć się prawdopodobnie w innym miejscu.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Klasa Klasy służą do grupowania atrybutów i metod, pakietów używamy do grupowania klas. Zanim pokażę Wam przykład kodu przejdziemy przez parę funkcji IDE, które na pewno przydadzą się w przyszłości. Skróty klawiaturowe IDE czy zwykły edytor tekstu są narzędziami pracy programisty. Znajomość narzędzi pracy znacząco zwiększa wydajność pracy. Innymi słowy bardzo przydatne jest używanie skrótów klawiaturowych. Postaram się przybliżyć Wam kilka z nich. Po lewej stronie widzicie okno do przeglądania struktury projektu. To okienko możecie włączać/wyłączać używając skrótu &lt;Alt + 1&gt;2. Po kliknięciu w obszar tego okienka przyda się skrót &lt;Alt + Ins&gt;. W tym kontekście przyda się on do stworzenia nowego pakietu oraz pliku z naszą pierwszą klasą. Po naciśnięciu tego skrótu pokaże się Wam takie okienko.         Tworzenie pakietu  Gdy mamy już nasz pakiet używając tego samego skrótu możemy stworzyć klasę. W naszym przykładzie stworzyłem pakiet pl.samouczekprogramisty.kursjava.engine a w nim klasę Cogwheel.         Tworzenie klasy          Tworzenie pakietu, dialog  package pl.samouczekprogramisty.kursjava.engine;/** * Created by &lt;uzytkownik&gt; on &lt;data&gt;. */public class Cogwheel {}Podobnie jak poprzednio teraz linijka po linijce przeanalizujemy przykładowy kod klasy w języku Java. Pierwsza linijka nie jest już dla Was niczym nowym, ot zwykła deklaracja pakietu. Ciekawsze są kolejne linie. Komentarze w kodzie Kolejne 3 linie to komentarz w kodzie. Komentarz w kodzie to dodatkowa wiadomość dla programisty. Czasami dodanie komentarza nad fragmentem bardziej skomplikowanego kodu pomaga w jego zrozumieniu. Komentarz jest pomijany w trakcie wykonywania programu. W języku Java występują 2 typy komentarzy:   komentarze w kilku liniach - przykład widzicie powyżej, wszystko co znajduję się pomiędzy /** a */ traktowane jest jako komentarz.  komentarz jednoliniowy - wszystko co znajduje się za // do końca linii traktowane jest jako komentarz. Parę przykładów poniżejint count = 3; // number of already read books// flag indicating if book was readboolean wasRead = false;Kolejne 2 linijki to już właściwa definicja klasy. Opiszmy każdy z elementów osobno:   public - modyfikator dostępu. Temat modyfikatorów dostępu opiszę dokładniej w osobnym artykule. Na tym etapie możemy założyć, że przed klasą stawiamy słowo kluczowe public i oznacza ono, że jest ona widoczna dla innych klas,  class - słowo kluczowe informujące kompilator o tym, że mamy do czynienia z definicją klasy,  Cogwheel - nazwa klasy. Przyjęło się, że nazwę klasy zaczynamy wielką literą. Podobnie jak w przypadku pakietów nie możemy używać wszystkich znaków. Dla uproszczenia możemy założyć, że nazwa klasy musi zaczynać się wielką literą, później możemy używać wielkich/mały liter bądź cyfr,  {} - para nawiasów określająca tak zwany blok, podobnie ja w metodzie grupuje on kilka instrukcji. Wszystkie linie kodu znajdujące się między nawiasami klamrowymi składają się na pełną definicję klasy.Poniżej ta sama klasa ale już trochę bardziej rozbudowana public class Cogwheel {    private int size;    private int numberOfCogs;    public Cogwheel() {    }    public Cogwheel(int size, int noCogs) {        this.size = size;        numberOfCogs = noCogs;    }}Pierwszy nowy element to tak zwany atrybut klasy: private int size;  private - modyfikator dostępu. Tym razem jest to słowo kluczowe private. Oznacza tyle, że dany element (w tym przypadku atrybut) dostępny jest wyłącznie z wnętrza danej klasy,  int - znany już typ,  size - nazwa atrybutu. Konwencja nazewnicza zakłada, że nazwy atrybutów piszemy małą literą. Podobnie jak poprzednio w nazwach możemy używać małych liter, wielkich liter i cyfr.Kolejne dwie metody to tak zwane konstruktory. Zauważ, że ich definicje są specjalne - nie mają typu zwracanego. Konstruktor służy, jak sama nazwa wskazuje, do tworzenia nowych instancji klasy. Każda klasa musi mieć konstruktor. Konstruktory to specjalne metody, które inicjalizują instancje klas. Konstruktory wywołujemy dokładnie tak samo jak inne metody, dodatkowo używamy słowa kluczowego new: cogwheel = new Cogwheel();cogwheel = new Cogwheel(1, 2);Pierwszy konstruktor to konstruktor bezparametrowy. Kolejny przyjmuje argument size i noCogs ale to dla Ciebie nic nowego, o argumentach wiesz wszystko z artykułu o metodach w języku Java. Nowością tutaj jest ciało konstruktora. this.size = size;numberOfCogs = noCogs;Obie linie przypisują wartość do atrybutu klasy. Pierwsza zawiera dodatkowe słowo kluczowe this aby odróżnić parametr size od atrybutu size. W następnej linii widzisz, że this nie jest wymagane jeśli jednoznacznie jesteśmy w stanie zidentyfikować atrybut. Generowanie konstruktorów IDE może nam pomóc przy pisaniu konstruktorów. Po naciśnięciu znanego już skrótu &lt;Alt + Insert&gt; w edytorze klasy pokaże się takie okienko.         Tworzenie konstruktora  W kolejnym można wybrać atrybuty klasy, które mają być przekazywane jako parametry.         Wybieranie parametrów konstruktora  Zauważ, że w poprzednim przykładzie klasy Cogwheel nie umieściłem definicji żadnego konstruktora. Kilka akapitów wcześniej napisałem, że każda klasa musi mieć konstruktor. Więc jak to właściwie jest z tym konstruktorem? Otóż kompilator tworzy domyślny konstruktor automatycznie jeśli nie zdefiniujemy żadnego innego konstruktora. Jeśli utworzysz jakikolwiek inny konstruktor przyjmujący parametry kompilator nie doda domyślnego, bezparametrowego konstruktora. Kolejny przykład klasy Poniżej już troszkę bardziej skomplikowany przykład. Proszę przeczytaj poniższy fragment kodu. package pl.samouczekprogramisty.kursjava; import pl.samouczekprogramisty.kursjava.engine.Cogwheel; public class Engine {    private boolean started;    private Cogwheel cogwheel;     public Engine() {        cogwheel = new Cogwheel(4, 450);        started = true;    }    public Engine(Cogwheel cogwheel) {        this.cogwheel = cogwheel;    }     public void start() {        started = initiateStartingSequence();    }    private boolean initiateStartingSequence() {        return true;    }    public void stop() {        started = false;    }    public boolean isStarted() {        return started;    }    public void setStarted(boolean started) {        this.started = started;    }}Poza używaniem typów, które już znasz, możesz używać już istniejących klas. Właśnie w ten sposób klasa Engine ma atrybut typu Cogwheel. Zwróć uwagę, że klasa Engine znajduje się w innym pakiecie niż klasa Cogwheel. Kompilator musi wiedzieć gdzie szukać tej klasy, właśnie z tego powodu dodajemy linijkę importującą tę klasę: import pl.samouczekprogramisty.kursjava.engine.Cogwheel;  Deklaracja importu to coś zupełnie innego niż deklaracja pakietu, importów w klasie może być wiele (możemy korzystać z wielu innych klas), natomiast nasza klasa może być wyłącznie w jednym pakiecie.   Jeśli importujemy wiele klas z jednego pakietu zamiast wypisywać je wszystkie możemy użyć * np import pl.samouczekprogramisty.kursjava.engine.*;Tutaj przychodzi z pomocą IDE. Okazuje się, że programista używający IDE nie musi pisać tych linii, IDE dodaje te linijki automatycznie. IDE także pomaga przy pisaniu samego kodu. W trakcie pisania zobaczysz menu kontekstowe podpowiadające programiście fragmenty kodu. Skrótami klawiaturowymi, które jeszcze mogą przy tym pomóc są &lt;Ctrl + Space&gt; i &lt;Ctrl + Shift + Space&gt;. Oba z nich pomagają programiście, drugi jest bardziej „inteligenty” podpowiadając wyłącznie kod, który jest poprawny w danym kontekście.         Pomoc IDE  Metody nie zwracające żadnej wartości Zwróćmy jeszcze uwagę na metodę public void start() {    started = initiateStartingSequence();}Nowe dla Ciebie jest słowo kluczowe void w miejscu typu zwracanego. To słowo kluczowe informuje, że dana metoda nie zwraca żadnej wartości. W ciele tej metody do atrybutu started przypisujemy wartość zwróconą przez metodę initiateStartingSequence. Słowo kluczowe this Proszę zwróć uwagę na dwa poniższe fragmenty kodu: public class Engine {    private Cogwheel cogwheel;    public Engine(Cogwheel cogwheel) {        this.cogwheel = cogwheel;    }}public class Engine {    private Cogwheel cogwheel;    public Engine(Cogwheel otherCogwheel) {        cogwheel = otherCogwheel;    }}W pierwszym przypadku w konstruktorze zostało użyte słowo kluczowe this. Było ono potrzebne aby kompilator był w stanie odróżnić parametr cogwheel od atrybutu klasy cogwheel. W drugim przypadku słowo to nie było konieczne ponieważ w tym kontekście od razu wiadomo czym jest cogwheel - jest atrybutem klasy. Oba konstruktory robią dokładnie to samo, przypisują wartość parametru to atrybutu nowej instancji. Gettery i settery Znasz już 2 modyfikatory dostępu, private i public. Wiesz też, że atrybuty, metody które poprzedzone są modyfikatorem private są dostępne wyłącznie w danej klasie. Jak więc z zewnątrz można dowiedzieć się jaka jest wartość atrybutu started w instancji klasy Engine? Z pomocą przychodzą tak zwane “gettery” i “settery”. Jest to nic innego jak specyficzne metody, których jedynym zadaniem jest odpowiednio pobranie bądź ustawienie wartości atrybutu. Poniżej przykłady: engine = new Engine(); // tworzymy instancje klasyengine.isStarted(); // zwraca wartość atrybutuengine.setStarted(true); // ustawia wartość atrybutu started w instancji engineGettery i settery to metody, których nazwy są określone przez specyfikację Java Beans. W skrócie:   metody pobierające wartość atrybutu mają nazwę get typ zwracany odpowiada typowi atrybutu. Metoda nie przyjmuje żadnego parametru. Specyfikacja dopuszcza pewien wyjątek w nazwie jeśli atrybut jest typu boolean. W takim przypadku możemy użyć nazwy is, reszta pozostaje bez zmian.public boolean isStarted() // zwraca wartość atrybutu startedpublic boolean getStarted() // zwraca wartość atrybutu startedpublic Cogwheel getCogwheel() // zwraca wartość atrybutu cogwheel  metoda ustawiająca wartość atrybutu. Nową wartością jest parametr przekazany do tej metody. Nazwa metody musi pasować do wzorca set. Metoda musi przyjmować jeden parametr odpowiadający typowi atrybutu i nie może zwracać żadnej wartości.public void setStarted(boolean started) // ustawia wartość atrybutu startedpublic void setCogwheel(Cogwheel cogwheel) // ustawia wartość atrybutu cogwheelGenerowanie getterów setterów Podobnie jak w przypadku generowania konstruktorów IDE pomaga w generowaniu getterów/setterów. W edytorze pomaga przy tym skrót `` naciśnięty gdy kursor znajduje się na nazwie atrybutu.         Wybieranie parametrów konstruktora  Metody te można także wygenerować przy pomocy skrótu &lt;Alt + Insert&gt; naciśniętego w edytorze i wybraniu opcji “Getter and Setter”.         Tworzenie getterów i setterów  Ćwiczenie Najwyższy czas na Twoje ćwiczenie. W ramach ćwiczenia utwórz nowy projekt, w nim utwórz 2 różne pakiety. W pakietach utwórz klasy odpowiadające kilku rodzajom zwierząt wraz z kilkoma atrybutami. Postaraj się używać przy tym poznanych dzisiaj skrótów. Jeśli chcesz, możesz spojrzeć na przykładowe rozwiązanie, które umieściłem na githubie. Podsumowanie Bardzo się cieszę, że doczytałeś do tego miejsca! Jak poszło Ci z ćwiczeniem? Proszę daj znać w komentarzach. Jeśli podobają Ci się artykuły na blogu byłbym bardzo wdzięczny gdybyś polecił blog swoim znajomym. Jak już powtarzałem - w grupie łatwiej się uczy :) Polub stronę na Facebooku, a nie przegapisz żadnego nowego artykułu. Do zobaczenia!             Jeśli nie umieścisz żadnej deklaracji pakietu dany typ (klasa, interfejs etc.) zostanie umieszczony w domyślnym, pustym pakiecie. &#8617;               Taka notacja oznacza jednoczesne naciśnięcie dwóch klawiszy, w tym przypadku jest to Alt i 1. &#8617;       ","categories": ["Kurs programowania Java","Programowanie"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/obiekty-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2015/11/01_obiekty_w_jezyku_java.jpg"},{
        "title": "Pierwszy program w Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Zaczynamy! Zaczynamy z grubej rury, bez patyczkowania się:   otwórz IDE,  utwórz nowy projekt,  utwórz nowy pakiet (Alt + Insert),  utwórz nową klasę (Alt + Insert).To już znasz, teraz czas na nowe rzeczy. Wszystkie elementy zostały opisane w poprzednich artykułach z cyklu:   Kurs programowania Java - przygotowanie środowiska  Kurs programowania Java - metody  Kurs programowania Java - obiekty i pakietyLive templates W ciele klasy, która została stworzona w poprzednim punkcie naciśnij Ctrl + J. Pokaże się okienko z podpowiedziami. To jest bardzo przydatna funkcja IDE pozwalająca bardzo szybki sposób pisać kod programiście. Z okienka, które się pokazało wybierz psvm. Bum! Cała metoda już “się napisała” :) Teraz w edytorze wpisz sout i naciśnij Enter. Bum! Znów cała linijka jest gotowa. Napisaliśmy tylko kilka znaków, a całe ciało metody zostało stworzone za nas. Poprzednie dwa akapity to nic innego jak funkcja Live templates IDE (dosłownie przetłumaczyć można to na żywe szablony). W trakcie kursu będziemy poznawali kolejne szablony pomagające w pisaniu kodu.         Dialog po naciśnięciu skrótu  Tworzenie zmiennych lokalnych Następnie wewnątrz () wpisz message, bądź cokolwiek innego co nadaje się na nazwę zmiennej. Jak widzisz IDE zaznacza tę nazwę na czerwono pokazując nam błąd. Oczywiście zmienna nie została jeszcze utworzona. Po naciśnięciu Alt + Enter pokaże nam okienko z możliwymi sposobami rozwiązania problemu. Z okienka wybierz “Create local variable…“. IDE utworzy nam zmienną, musimy wybrać jej typ. Z dostępnej listy wybierz String i przypisz do niego jakiekolwiek zdanie otoczone \"\", jak w przykładzie: String message = \"To jest mój pierwszy łańcuch znaków! Potocznie \\\"string\\\".\";  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Uruchomienie programu Może nie uwierzysz, ale przy pomocy tych kilku skrótów klawiaturowych napisałeś swój pierwszy program, który możemy uruchomić! Jak to zrobić? Naciśnij skrót Alt + Shift + F10. Z okienka, które się pokazało wybierz nazwę klasy i „Run”. To spowoduje uruchomienie programu, który napisałeś. W dolnej część IDE pokaże się okno wyświetlające nasz program. Proste prawda? Nagrałem też filmik, pokazujący jak doszedłem do gotowej klasy. Możesz go obejrzeć na kanale youtube         Dialog uruchomienia programu  Istnieje również skrót Shift + F10, który pozwala na uruchomienie aktualnie edytowanej klasy (jeśli taka możliwość istnieje). Omówienie kodu programu Najwyższy czas na analizę kodu, który napisaliśmy. package pl.samouczekprogramisty.kursjava; public class Main {    public static void main(String[] args) {        String message = \"To jest mój pierwszy łańcuch znaków! Potocznie \\\"string\\\".\";        System.out.println(message);    }}Linijka z pakietem to dla Ciebie nic nowego, więcej na temat pakietu przeczytasz w artykule . Później definiujemy klasę, również nic nowego. W tym samym artykule przeczytasz więcej o klasach. Następna linijka to już dwie nowe rzeczy. public static void main(String[] args)Metody statyczne Ten fragment kodu to nic innego jak definiowanie metody. Więcej o metodach przeczytasz w artykule o metodach w języku Java. Nowe jest jednak słowo kluczowe static. Przy pomocy tego słowa kluczowego definiujemy metody statyczne. Jak pamiętasz do wywołania metody potrzebujemy instancji klasy: Engine engine = new Engine();engine.start();Metody statyczne różnią się od zwykłych metod tym, że do ich wywołania nie potrzebujemy instancji klasy. Taką metodę możemy wywołać na klasie. Biorąc nasza przykładową klasę Main z metodą main wywołanie wyglądałoby następująco. Main.main();Typ tablicowy Kolejna nowa rzecz to typ przekazywanego argumentu. String[] oznacza tablicę obiektów typu String. O tablicach więcej przeczytasz w jednym z kolejnych artykułów. Klasę String omówimy jednak trochę dokładnej, kilka akapitów poniżej. System.out.println(message);Ta konstrukcja jest trochę bardziej skomplikowana. Odwołujemy się tutaj do atrybutu out klasy System. System.out także jest obiektem, jest to obiekt klasy java.io.PrintStream. Klasa ta definiuje wiele metod, jedną z nich jest println, która wypisuje to co przekażemy jej jako parametr w osobnej linii1. Klasa String W każdym języku programowania, który znam istnieje sposób na zapisanie łańcucha znaków w sposób zrozumiały dla komputera. W języku Java do tego celu używamy klasy String. String someRandomWord = \"słowo\";Jak widzisz w linijce tworzymy zmienną someRandomWord typu String i przypisujemy jej wartość \"słowo\". Wszystko co jest otoczone \" oznacza String. Jest to konstrukcja wbudowana w język Java. Do utworzenia instancji obiektu String nie potrzebujemy konstruktora, wystarczy otoczyć łańcuch znaków \"\" jak w przykładzie wyżej. Jeśli wewnątrz łańcucha znaków chcesz umieścić \" musisz go poprzedzić ukośnikiem \\ jak w przykładzie poniżej. String escapedCharacter = \"This is an \\\" escaped charecter\";Łańcuchy znaków możemy ze sobą łączyć przy pomocy symbolu +. String productName = \"Coca\" + \"Cola\";Kilka metod klasy String Podobnie jak inne klasy String ma zestaw metod, których możemy użyć. Poniżej kilka z nich:   length - zwraca długość łańcucha znakówint length = productName.length(); // w naszym przypadku zwraca 8  contains - sprawdza czy w łańcuchu znaków znajduje się ten przekazany jako parametrproductName.contains(„ocaCol”); // w naszym przypadku zwraca trueproductName.contains(„Pepsi”); // w naszym przypadku zwraca false  endsWith - spradza czy łańcuch kończy się przekazanym argumentemproductName.endsWith(„ola”); // w naszym przypadku zwraca trueproductName.endsWith(„oca”); // w naszym przypadku zwraca falseMetod jest sporo. Ponownie z pomocą przychodzi IDE. Wystarczy, że napiszesz . (kropkę) po instancji i od razu dostaniesz podpowiedzi z metodami, które możesz wywołać.         Dialog z metodami klasy String  JavaDoc Przypadkiem nie próbuj ich zapamiętać! Owszem parę podstawowych wejdzie Ci w krew po pewnym czasie ale zakuwanie ich z kartką w ręku nie ma najmniejszego sensu. Z pomocą przychodzi dokumentacja. Każda klasa z biblioteki standardowej ma dokładną dokumentację opisującą wszystkie metody, ich argumenty i typy zwracane. Na przykład dokumentację dla klasy String możesz znaleźć pod tym adresem http://docs.oracle.com/javase/8/docs/api/java/lang/String.html Pewnie pamiętasz jak na początku w artykule opisującym czym jest programowanie przekonywałem, że angielski to podstawa? :) Biblioteka standardowa String i dużo innych klas są częścią tak zwanej biblioteki standardowej. Jest to nic innego jak zestaw klas dostarczony wraz z językiem dostępny dla programisty. Znajdują się w w niej różne klasy używane na co dzień przez programistów np. java.io.PrintStream, java.lang.String czy java.lang.System, które poznałeś w tym artykule. Zadanie Napisz program, który wyświetli trzy różne zdania opisujące aktualną pogodę. W czwartej linii wypisz sumaryczną długość trzech poprzednich zdań. Podsumowanie Prawda, że nie było tak strasznie? Jeśli podobał Ci się dzisiejszy artykuł proszę polub stronę na facebooku. Zależy mi na tym, żeby dotrzeć do jak największej liczby osób, które chcą się nauczyć programować, jeśli mógłbyś przekazać im informację o stronie byłbym ogromnie wdzięczny. Do następnego razu!             To jest spore uproszczenie, tutaj musielibyśmy mówić o strumieniach, plikach, IO itd. dzisiaj to pominiemy, skupimy się na tym w przyszłości. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pierwszy-program-w-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2015/11/08_pierwszy_program_w_java.png"},{
        "title": "Tablice w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Czym jest tablica Tydzień ma siedem dni. Załóżmy, że pierwszy dzień tygodnia to poniedziałek. Wtorek jest drugi, środa jest następna itd. Dni możemy ułożyć w swego rodzaju ponumerowany szereg. Tablica jednowymiarowa to nic innego jak właśnie taki ponumerowany szereg. W Javie elementy w tablicy numerujemy od 0. Więc w naszym przypadku poniedziałek ma numer 0, wtorek 1 itd. Numer identyfikujący każdy element tablicy to indeks. Tablice grupują obiekty tego samego typu1. Mogą to być łańcuchy znaków, liczby, wartości logiczne, instancje klas stworzonych przez Ciebie, itd. Tworzenie tablicy Przekładając nasz przykład z dniami tygodnia na Javę dojdziemy do takiego fragmentu kodu String[] daysOfWeek = new String[7];daysOfWeek[0] = \"poniedziałek\";daysOfWeek[1] = \"wtorek\";daysOfWeek[2] = \"środa\";daysOfWeek[3] = \"czwartek\";daysOfWeek[4] = \"piątek\";daysOfWeek[5] = \"sobota\";daysOfWeek[6] = \"niedziela\";W pierwszej linijce tworzymy nową tablicę obiektów typu String. Tablica może pomieścić 7 elementów. Poniedziałek ma indeks 0, niedziela ma indeks 6. Raz przypisany obiekt w tablicy możemy nadpisać. daysOfWeek[0] = \"Monday\";Teraz pod indeksem 0 znajduje się Monday, pod 1 bez zmian nadal jest wtorek. Jeśli spróbujesz odwołać się do nieistniejącego elementu w tablicy zostanie rzucony wyjątek java.lang.ArrayIndexOutOfBoundsException. O wyjątkach przeczytasz w jednym z kolejnych artykułów. Aktualnie wystarczy Ci informacja, że wyjątki sygnalizują sytuacje wyjątkowe :) i mogą przerwać działanie programu. Poniższa linijka zakończy program wyjątkiem, odwołujemy się tam do ósmego, nieistniejącego elementu tablicy. System.out.println(daysOfWeek[7]);Tablicę można też od razu zainicjalizować wartościami. Oba sposoby inicjalizacji tworzą obiekt tablicy. Zauważ, że w drugim przypadku nie musimy podawać jej długości. Jest ona znana na podstawie przekazanych wartości. String[] wintersMonths = new String[] {\"grudzień\", \"styczeń\", \"luty\"};  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Atrybut length Tablica to obiekt. Podobnie jak inne obiekty posiada swoje atrybuty i metody. Jedynym publicznie dostępnym atrybutem metody jest length. Atrybut ten przechowuje rozmiar tablicy System.out.println(wintersMonths.length); // w naszym przypadku wyświetli 3Tablice wielowymiarowe Wyżej napisałem, ze w tablicy możesz trzymać dowolny obiekt. Tablica też jest obiektem :) Więc nic nie stoi na przeszkodzie, żeby w tablicach umieścić inne tablice. Tablica dwuwymiarowa to nic innego jak tabela zawierająca wiersze i kolumny w której możesz przechowywać dane. Nic nie stoi na przeszkodzie do tworzenia tablic, które mają więcej niż 2 wymiary, jednak w praktyce raczej ich się nie spotyka. Jeśli potrzebna jest tak skomplikowana tablica programiści zazwyczaj przechowują dane w inny sposób używając zbiorów, map czy list2. W naszym przykładzie tablicy dwuwymiarowej użyjemy do przechowywania stanu gry kółko krzyżyk int[][] ticTacToeBoard = new int[3][];ticTacToeBoard[0] = new int[3];ticTacToeBoard[1] = new int[3];ticTacToeBoard[2] = new int[3];W pierwszy wierszu inicjalizujemy wyłącznie jeden z wymiarów. Musimy tam podać tylko liczbę wierszy, które będzie przechowywała nasza tablica dwuwymiarowa. Kolejne 3 linie kodu to inicjalizacja wierszy tablicy. Jeśli każdy z wierszy tablicy wielowymiarowej ma dokładnie taki sam rozmiar możemy zainicjalizować ją w jednej linijce. Poniższy przykład ma ten sam efekt jak poprzedni: int[][] ticTacToeBoard = new int[3][3];ticTacToeBoard[0] odwołuje się do pierwszego wiersza w tablicy. ticTacToeBoard[0][0] odwołuje się do pierwszej komórki w pierwszym wierszu. W ten sposób każde pole na naszej planszy ma unikalny indeks składający się z dwóch liczb:             00      01      02              10      11      12              20      21      22      Podobnie jak w przypadku tablicy jednowymiarowej i tu możemy przypisywać wartości. Poniżej przykładowy przebieg gry. int nought = 1; // kółkoint cross = 2; // krzyżykticTacToeBoard[1][1] = nought;ticTacToeBoard[2][2] = cross;ticTacToeBoard[0][0] = nought;ticTacToeBoard[1][2] = cross;ticTacToeBoard[0][2] = nought;ticTacToeBoard[0][1] = cross;Spróbuj narysować sobie na kartce powyższy przebieg gry. Kto ma szanse na wygraną? :) Magiczne liczby Przykład z planszą do gry świetnie nadaje się do wytłumaczenia czym właściwie są magiczne liczby (ang. magic numbers). W kodzie programu bardzo często występują liczby. Liczby te w rzeczywistości mają jakieś znaczenie. W naszym przykładzie 1 to nie zwykła jedynka, a wartość oznaczająca kółko. Dobrą praktyką jest przypisanie takich „magicznych wartości” do zmiennych/stałych3 i używanie ich w kodzie. Na dłuższą metę kod używający nazwanych zmiennych w miejscu „magic numbers” jest bardziej czytelny i łatwiejszy w utrzymaniu. ticTacToeBoard[1][1] = nought;ticTacToeBoard[2][2] = cross;ticTacToeBoard[1][1] = 1;ticTacToeBoard[2][2] = 2;Poza czytelnością zyskujemy kolejną rzecz. Nie łamiemy zasady DRY (ang. Don’t Repeat Yourself)4. Metody o zmiennej liczbie argumentów (ang. varargs) Znasz już metodę main, domyślnie przyjmuje ona tablicę łańcuchów znaków. Równie dobrze tę metodę możemy zapisać jako: public static void main(String ... args);Inny przykład metody z wieloma argumentami to metoda sumująca wszystkie przekazane liczby: int sum(int ... numbers);Magiczny wielokropek to coś w rodzaju wzbogacenia składni (ang. syntactic sugar). Nasza metoda z przykładu może przyjąć dowolną liczbę argumentów typu int (ang. varargs). W szczególności może też nie przyjąć żadnego. sum();sum(1, 2, 3);Metody mogą przyjmować wiele argumentów. Jednak argument z wielokropkiem może być tylko jeden i musi występować jako ostatni. Jak wspomniałem wielokropek to wzbogacenie składni. W rzeczywistości metody są tożsame: int sum(int ... numbers);int sum(int[] numbers);Materiały dodatkowe Jeśli chcesz przeczytać o tablicach w innym miejscu zachęcam do rzucenia okiem na linki poniżej:   Fragment wykładu na jednym z uniwersytetów w Stanach Zjednoczonych dotyczący tablic.Zadania   Napisz metodę pobierającą dwuelementową tablicę liczb i zwracający ich sumę.  Napisz program pobierający trójelementową tablicę liczb i zwracający największą liczbę.  Jak przechowałbyś stan sudoku? Napisz program, który stworzy instancje tablicy służących do przechowywania sudoku i uzupełnij ją przykładową planszą.  Jak przechowałbyś stan gry w szachy? Napisz program, który stworzy instancje tablic służące do przechowywania stanu gry w szachy. Potrafiłbyś zachować w nim ostatni stan partii Kasparowa z Deep Blue?Zachęcam Cię, do samodzielnego rozwiązania zadań, jeśli jednak miałbyś jakikolwiek problem możesz rzucić okiem na przykładowe rozwiązania. Pamiętaj, że rozwiązując zadania samodzielnie nauczysz się najwięcej. Podsumowanie Bardzo się cieszę, że przeczytałeś artykuł aż do końca. Jeśli masz jakiekolwiek uwagi proszę podziel się nimi w komentarzach. Byłbym także bardzo wdzięczny gdybyś przekazał swoim znajomym informację o blogu – jak zawsze zależy mi na dotarciu do jak największej grupy ludzi, którzy chcą uczyć się programować. Jak zwykle informacje o artykule prezentuję na stronie na Facebooku. Polub ją, a będziesz otrzymywał informacje o nowych artykułach.             Znów uproszczenie, jak poznamy dziedziczenie dowiesz się trochę więcej na ten temat. &#8617;               Są to 3 podstawowe typy kolekcji w języku Java. Przeczytasz o nich w jednym z kolejnych artykułów. &#8617;               O stałych przeczytasz w innym artykule. &#8617;               W uproszczeniu zasada mówi o nie powtarzaniu tego samego kodu wielokrotnie, przeczytasz o tym w jednym z kolejnych artykułów. Poprę to lepszym przykładem niż ten w tym artykule. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/tablice-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2015/11/11_tablice_w_jezyku_java.png"},{
        "title": "Pętle i instrukcje warunkowe w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Operatory logiczne Zanim przejdę do opisania instrukcji warunkowych przeczytasz coś więcej na temat operatorów logicznych. &lt; jest operatorem logicznym, który znasz z poprzednich artykułów. W Javie istnieje kilka operatorów logicznych:   == równe,  &lt; mniejsze,  &lt;= mniejsze bądź równe,  &gt; większe,  &gt;= większe bądź równeIch działanie możesz zobaczyć na kilku przykładach poniżej: int x = 1;int y = 1;int z = 2; x == y; // truex == z; // falsex &lt; y; // falsex &lt; z; // truex &lt;= y; // true// itd.Proste operacje logiczne możesz ze sobą łączyć przy pomocy dodatkowych operatorów:   &amp;&amp; logiczne i,  || logiczne lub.Pomocna przy tym może być następująca tabelka. Pokazuje ona podstawowe operacje logiczne1.             Operacja      Wynik                  prawda i prawda      prawda              prawda i fałsz      fałsz              fałsz i prawda      fałsz              fałsz i fałsz      fałsz              prawda lub prawda      prawda              prawda lub fałsz      prawda              fałsz lub prawda      prawda              fałsz lub fałsz      fałsz      Przekładając kilka powyższych linii na przykłady ze zmiennymi w Java wygląda to następująco: int x = 1;int y = 1;int z = 2;x == y &amp;&amp; z &gt; y; // true &amp;&amp; true =&gt; truex &lt;= y &amp;&amp; z &lt;= x; // true &amp;&amp; false =&gt; falsex == y || z &gt; y; // true || true =&gt; truex &lt;= y || z &lt;= x; // true || false =&gt; trueOperatory w języku Java mają swój priorytet. Dzięki temu mnożenie jest wykonywane przed dodawaniem. Podobnie jest tutaj, operatory &lt;, ==, &lt; itp. mają wyższy priorytet niż &amp;&amp; czy ||.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Instrukcje warunkowe Instrukcja if, else if, else Do tej pory każda linijka kodu, którą napisałeś w działającym programie została wykonana. W większych programach często musimy decydować co powinno być wykonane. Np. jeśli jest temperatura jest większa niż 37°C2 oznacza to, że możesz być chory. Jeśli jest mniejsza niż 36°C możesz być osłabiony. To jest najprostsza instrukcja warunkowa. Blok kodu zostanie wykonany jeśli wartość w nawiasie () będzie prawdą. W przykładzie sprawdzamy, czy temperatura jest mniejsza niż 36 stopni. if (temperature &lt; 36) {    System.out.println(\"Jesteś osłabiony?\");}else, podobnie jak if, jest słowem kluczowym. Jeśli warunek przy instrukcji if nie zostanie spełniony wywołany zostanie zestaw instrukcji w bloku else. if (temperature &lt; 36) {    System.out.println(\"Jesteś osłabiony?\");}else {    System.out.println(\"Masz 36 lub więcej stopni.\");}W języku Java możesz także połączyć else z if jak w przykładzie poniżej: int temperature = 38;if (temperature &lt; 36) {    System.out.println(\"Jesteś osłabiony?\");}else if (temperature &lt; 37) {    System.out.println(\"Wszystko w normie!\");}else if (temperature &lt; 38) {    System.out.println(\"Jesteś przeziębiony?\");}else {    System.out.println(\"Masz co najmniej 38 stopni! Biegiem do lekarza!\");}Kod ten na początku sprawdza czy temperatura jest mniejsza niż 36°C. Jeśli ten warunek nie jest spełniony sprawdzamy czy temperatura jest mniejsza niż 37°C. Podobnie działa kolejny warunek. Jeśli żaden z nich nie jest spełniony zostaje wykonany kod w bloku po else. Instrukcja switch Jeśli mamy kilka warunków if następujących po sobie możemy zamienić je na inną konstrukcję - switch. Przejdźmy od razu do przykładu: int temperature = 37;switch (temperature) {    case 35:        System.out.println(\"Jesteś osłabiony?\");        break;    case 36:        System.out.println(\"Wszystko w normie!\");        break;    case 37:        System.out.println(\"Jesteś przeziębiony?\");        break;    case 38:        System.out.println(\"Chyba jesteś chory.\");        break;    default:        System.out.println(\"Nie wiem jak się czujesz :(\");        break;}switch w przykładzie powyżej sprawdza wartość zmiennej temperature i w zależności od jej wartości wykonuje odpowiedni kod zdefiniowany w case poniżej. W naszym przypadku na ekranie zostanie wypisane Jesteś przeziębiony?. Proszę zwróć uwagę na nowe słowo kluczowe break. switch dopasowuje case do wartość zmiennej, i wykonuje kod od pierwszego pasującego warunku do słowa kluczowego break. int temperature = 35;switch (temperature) {    case 35:        System.out.println(\"Jesteś osłabiony?\");    case 36:        System.out.println(\"Wszystko w normie!\");    case 37:        System.out.println(\"Jesteś przeziębiony?\");        break;    case 38:        System.out.println(\"Chyba jesteś chory.\");        break;}W przykładzie powyżej break zostało pominięte przy case 35 oraz case 36. Wartość zmiennej pasuje do case 35. Przez pominięcie słowa kluczowego break na ekranie zostaną wypisane 3 linijki. Dzieje się tak dlatego, że słowo kluczowe break zostało wypisane dopiero przy case 37. Jesteś osłabiony?Wszystko w normie!Jesteś przeziębiony?Warunek default zostaje wykonany jeśli żadna gałąź case nie pasuje do wartości zmiennej. Zachęcam Cię do eksperymentowania :). Instrukcja switch jest trochę ograniczona. Sprawdzana zmienna może być zmienną kilku typów np. int czy String. Pętle w języku Java Pętla for Pętla pozwala na wykonanie fragmentu kodu wielokrotnie. Na przykład jeśli chcemy wypisać wszystkie liczby od 0 do 10 możemy to zrobić przy pomocy pętli for (int number = 0; number &lt;= 10; number++) {    System.out.println(number);}Pierwsza linijka to nic innego jak właśnie definicja pętli for. Kod wewnątrz nawiasu () możemy podzielić na trzy części:   inicjalizacja zmiennych,  sprawdzenie warunku,  zmiana wartości zmiennych.W części inicjalizującej zmienne robimy coś co już znasz, tworzymy zmienną number i przypisujemy jej wartość 0. Kolejna część to sprawdzenie czy wartość zmiennej jest mniejsza bądź równa 10. Nowa dla Ciebie jest trzecia część a właściwie operator ++. Proszę spójrz na przykład poniżej: int counter = 0;counter = counter + 1;counter += 1;counter++;Każda z trzech ostatnich linii zwiększa o jeden wartość zmiennej counter. Ostatnia wersja jest najkrótsza dlatego jest najczęściej spotykana w tego typu pętlach. Kolejnym przykładem użycia pętli może być wyświetlenie każdego elementu tablicy int[] primeNumbers = new int[] {2, 3, 5, 7};for (int index = 0; index &lt; primeNumbers.length; index++) {    System.out.println(primeNumbers[index]);}W pierwszej linijce definiujemy tablicę z kilkoma liczbami pierwszymi (jeśli nie wiesz czym są liczby pierwsze możesz przeczytać o nich w artykule na wikipedii). Następnie w pętli wyświetlamy każdy element tej tablicy. Istnieje też uproszczona wersja pętli for. Jeśli nie musisz mieć dostępu do zmiennej reprezentującej np. indeks tablicy możesz użyć poniżej wersji pętli. for (int primeNumber : primeNumbers) {    System.out.println(primeNumber);}Tutaj w pierwszej linijce do zmiennej primeNumber przypisujemy kolejne elementy tablicy primenNumbers, które następnie wyświetlamy na ekranie. Live templates Obie wersje pętli for możesz utworzyć dużo łatwiej. Z jednego z poprzednich artykułów wiesz już o istnieniu live templates. Okazuje się, że IDE pomaga nam także w tworzeniu pętli. Wystarczy, że wpiszesz fori i naciśniesz Enter, IDE wstawi szablon pętli za Ciebie. Jeśli w ten sam sposób chcesz wstawić szablon uproszczonej pętli for możesz wpisać I i nacisnąć Enter. Pętla while W języku Java istnieją także inne konstrukcje pętli. Kolejnym przykładem jest pętla while. Tym razem przejdziemy od razu do przykładu int number = 0;while (number &lt; 10) {    System.out.println(number);    number++;}Pętla while wykonuje swoje ciało (kod wewnątrz {}) tak długo jak spełniony jest warunek zapisany pomiędzy () (lub pętla nie zostanie przez nas przerwana). Podobnie jak w poprzenich przykładach pętla wyświetla zestaw liczb, tym razem liczby od 0 do 9. Poniżej kolejny przykład pętli while. Tym razem warunek zakończenia pętli sprawdzany jest w jej ciele. Użyliśmy do tego celu instrukcji warunkowej if. Słowo kluczowe break napotkane wewnątrz pętli natychmiast przerywa jej wykonanie (dotyczy to także pętli for). int number = 0;while (true) {    System.out.println(number);    number++;    if (number == 10) {        break;    }}Nieskończona pętla Pętle mają to do siebie, że przy źle zdefiniowanych warunkach mogą wykonywać kod wewnątrz swojego ciała w nieskończoność. Jest to dość częsty błąd, szczególnie spotykany na początku przygody z programowaniem. Dlatego należy uważnie sprawdzać warunki zakończenia pętli, żeby uniknąć tego błędu. Poniżej przykład pętli wyświetlającej 1 w nieskończoność. while(true) {    System.out.println(1);}Zadania   Poza poznanym dzisiaj operatorem ++ istnieje też jego odpowiednik zmniejszający wartość zmiennej o 1. Jest nim --. Napisz program, który wypisze na ekranie malejąco wszystkie liczby od 20 do 10.  Napisz pętlę while, która wypisze na ekranie wszystkie liczby od 10 do 20 włącznie.  Napisz pętlę for, która wypisze na ekranie wszystkie liczby nieparzyste od -10 do 40.  Przerób pętlę z zadania trzeciego na pętlę while.  Napisz metodę, która jako jedyny argument przyjmie zmienną typu int[] i zwróci sumę wszystkich elementów tablicy.  Przerób funkcję z zadania piątego tak, żeby metoda przymowała tablicę dwuwymiarową typu int[][].Przygotowałem też zestaw przykładowych rozwiązań powyższych zadań. Zachęcam jednak do ich samodzielnego rozwiązania, wtedy nauczysz się najwięcej. Podsumowanie Dzisiaj znów nauczyłeś się paru nowych rzeczy dotyczących Javy. Mam nadzieję, że artykuł Ci się spodobał. Jeśli tak będę wdzięczny jeśli podzielisz się nim ze swoimi znajomymi. Proszę polub stronę na facebooku jeśli nie chcesz pominąć żadnego nowego artykułu. Na dzisiaj już starczy wiedzy :) Miłego dnia i do następnego razu!             Tzw. algebrę Boole’a &#8617;               Tutaj lepszym pomysłem byłyby liczby “z przecinkiem”, napisałem osobny artykuł na temat liczb zmiennoprzecinkowych. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/petle-i-instrukcje-warunkowe-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2015/11/08_pierwszy_program_w_java.png"},{
        "title": "Typy proste w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Typ prosty Znasz już typy proste z poprzednich artykułów. int czy boolean są tu dobrymi przykładami. Typy proste nie są instancjami obiektów więc nie mają żadnych metod. Poniżej przykład zmiennych typów, które już znasz: int age = 18;boolean isAdult = true;Jednak poza powyższymi przykładami istnieją też inne typy proste:   byte typ, który może przechowywać liczby całkowite z zakresu od -128 do 127,  short typ, który może przechowywać liczby całkowite z zakresu od -32’768 do 32’767,  int ten już znasz, nowy dla Ciebie będzie zakres możliwych liczb do przechowania -2’147’483’648 do 2’147’483’647,  long podobnie jak poprzednie typy służy do przechowywania liczb całkowitych, jednak tutaj zakres jest znacznie większy: od -9’223’372’036’854’775’808 do 9’223’372’036’854’775’807.byte daysInMonth = 31;short daysInYear = 365;long veryLargeNumber = 72036854775807L;Proszę zwróć uwagę na zmienną veryLargeNumber. Zauważyłeś L na końcu? Dołączenie L na końcu sprawia, że używamy literału innego typu.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Czym jest literał? Zaraz, zaraz! Czym jest literał!? To nic skomplikowanego, jest to po prostu fragment kodu programu, który może być przypisany do zmiennej i nie jest wywołaniem konstruktora ani złożoną instrukcją. Przykładowe literały, które przechowują liczby: 180b11100-0xFF000777+78_123_89845L45l  18 - nic nowego, zwykła liczba, którą już znasz,  0b11100 - też liczba, tylko zapisana binarnie, o tym typie zapisywania liczb przeczytasz w jednym z kolejnych artykułów,  -0xFF00 - tym razem liczba zapisana w systemie szesnastkowym,  0777 - tak wygląda liczba zapisana w systemie ósemkowym,  +78_123_898 - to nic innego jak 78123898, tylko zapisane w troszkę inny sposób. Znak + na początku jest zbędny (domyślnie literały przechowują liczby dodatnie). Znaki _ podobnie nie są obowiązkowe, służą jedynie do zwiększenia czytelności liczby.  45L – domyślnie wszystkie literały liczb całkowitych mają typ int. Żeby dać znać kompilatorowi o tym, ze ten literał może przechowywać większe wartości musimy dodać L na końcu  45l – podobnie jak powyżej literał typu long, jednak tutaj na końcu widzimy małą literę l. Mimo tego, że taka konstrukcja jest dopuszczalna nie jest dobrą praktyką. l często może być pomylone z 1, szczególnie jeśli używana jest czcionka o stałej szerokości.Domyślna konwersja Możesz zadać sobie teraz pytanie. Dlaczego musimy dodawać L na końcu liczby typu long, a nie musimy nic dodawać dla liczby typu short czy int? Okazuje się, że kompilator wykonuje za nas automatycznej konwersji typu. short daysInYear = (short) 365;Wartość w nawiasie mówi o tym na jaki typ chcemy rzutować 365 będące typu int. W tym przypadku rzutowanie nie jest potrzebne bo kompilator wykona tę konwersję za nas. Jeśli jednak będziesz chciał przypisać wartość typu int do wartości typu short musisz takiej konwersji dokonać. int someSmallNumber = 356;short daysInYear = (short) someSmallNumber;W przykładzie powyżej kompilator już takiej konwersji nie wykona automatycznie, programista musi sam o nią zadbać. Zupełnie inną sprawą jest czy powinniśmy tak robić :) Jakim cudem int, który może przechowywać dużo większe liczby może się “zmieścić” w typie short? Otóż nie może :) short overflow = (short) 1_111_111;System.out.println(overflow);Jak myślisz co zostanie wyświetlone na konsoli? Nie, nie będzie to 1’111’111. Komputer wyświetli -3001 :) Dzieje się tak dlatego, że liczba 1’111’111 jest większa od maksymalnej wartości jaką może przechowywać short. To co musisz zapamiętać z tego podrozdziału to fakt, że część konwersji wykonywana jest automatycznie, a część spada na programistę. Te drugie są bardziej niebezpieczne bo mogą prowadzić do niespodziewanych rezultatów. Znak Znasz już klasę String. Instancja klasy String przechowuje łańcuch znaków. Pojedynczy znak natomiast może być przechowywany w zmiennej typu char jak w przykładzie poniżej. char firstAlphabetLetter = 'a';'a' też jest literałem, jest to literał typu char. Jeśli jesteśmy przy znakach to możemy zahaczyć też o łańcuchy znaków. Znany Ci już \"xyz\" to literał typu String. Liczby zmiennoprzecinkowe Do tej pory używaliśmy wyłącznie liczb całkowitych. W Javie istnieją też oczywiście typy proste, które mogą przechowywać liczby zmiennoprzecinkowe. Istnieją dwa takie typy:   float,  double.Podobnie jak w przypadku int i long, float i double różnią się wielkością liczb, które mogą przechowywać. double może przechowywać dużo większe liczby niż float. Na końcu literałów typu float musimy dodawać f bądź F jak w przykładzie poniżej. float pi = 3.14F;double g = 9.80665;Chociaż typy te doskonale nadają się do przechowywania np. temperatury w programie, który napiszesz w ramach ćwiczenia to już do “poważnych” obliczeń te typy się nie nadają. W dużym uproszczeniu można powiedzieć, że komputer ma problem z przechowywaniem pewnych ułamków. W poważniejszych obliczeniach wymagających liczb zmiennoprzecinkowych używamy innych typów takich jak java.math.BigDecimal. 123 jest literałem, podobnie jest z 3.14F, ten drugi to literał przechowujący liczbę zmiennoprzecinkową. W Javie zawsze do oddzielenia liczby całkowitej (3) od dziesiętnej (14) używamy znaku . (kropki). Typy proste a obiekty Każdy z typów prostych ma odpowiadający mu obiekt: byte b1 = 10;Byte b2 = new Byte((byte) 10); short s1 = 10;Short s2 = new Short((short) 10); int i1 = 10;Integer i2 = new Integer(10); long l1 = 10L;Long l2 = new Long(10L); boolean bo1 = true;Boolean bo2 = new Boolean(true) char c1 = 'c';Character c2 = new Character('c'); float f1 = 1.2F;Float f2 = new Float(1.2F); double d1 = 1.2;Double d2 = new Double(1.2);Jak widzisz tworzenie obiektów jest trochę “trudniejsze” niż tworzenie zmiennych typów prostych. Jednak nie jest to wymagane. W Javie istnieje tak zwany autoboxing/autounboxing: Byte b3 = 10;Short s3 = 10;Integer i3 = 10;Long l3 = 10L;Boolean bo3 = true;Character c3 = 'c';Float f3 = 1.2F;Double d3 = 1.2W przykładach powyżej kompilator Javy automatycznie opakował typy proste do obiektów (autoboxing). Operacja odwrotna (autounboxing) także jest możliwa: int i4 = new Integer(12);Pobieranie danych od użytkownika Teraz jak znasz już wszystkie typy proste w języku Java nadszedł moment na napisane pierwszego interaktywnego programu. W programie zapytamy użytkownika o siedem kolejnych temperatur i policzymy średnią temperaturę. Do napisania takiego programu użyjemy znanych już pętli. Zanim jednak do tego przejdziemy musisz poznać klasę java.util.Scanner. Jest to klasa dostępna w standardowej bibliotece Javy, która może nam pomóc w pobieraniu danych od użytkownika. Standardowe wejście i standardowe wyjście W przypadku komputerów możemy mówić o tak zwanym standardowym wejściu i standardowym wyjściu. Możemy to uprościć do tego, że standardowe wyjście to znaki, które wypisujemy na konsoli. Standardowe wyjście jest reprezentowane przez obiekt System.out. Już to znasz: System.out.println(\"standardowe wyjście\"). To nic innego jak użycie metody println na obiekcie System.out. Klasa Scanner używa obiektu standardowego wejścia upraszczając programiście pobieranie danych od użytkownika: Scanner inputScanner = new Scanner(System.in);Klasa Scanner ma kilka ciekawych metod, których możemy użyć, m.in.:   inputScanner.nextInt(),  inputScanner.nextDouble().Metody te odpowiednio pobierają liczbę całkowitą i liczbę zmiennoprzecinkową. Poniżej przykładowy program pobierający siedem temperatur dla kolejnych dni. public class AverageTemperature {    public static void main(String... args) {        double[] temperature = new double[7];        Scanner inputScanner = new Scanner(System.in);         for(int i = 0; i &lt; temperature.length; i++) {            System.out.println(\"Wprowadź liczbę \" + i);            temperature[i] = inputScanner.nextDouble();        }         double summarizedTemp = 0;        for (double temp : temperature) {            summarizedTemp += temp;        }         System.out.println(\"Średnia temperatura wynosi \" + (summarizedTemp / temperature.length));    }}Jeśli masz jakiekolwiek pytania dotyczącke kodu powyżej proszę zadaj je w komentarzach. Ćwiczenie Teraz ćwiczenie dla Ciebie. Napisz program, który policzy średnią z kilku przedmiotów. Możemy założyć, że uczeń w szkole ma 3 przedmioty i z każdego z nich dostał po 4 oceny. Do wykonania tego zadania możesz potrzebować tablic wielowymiarowych i zagnieżdżonych pętli. Dla przypomnienia możesz zajrzeć do artykułu o tablicach wielowymiarowych i pętlach w języku Java. Zagnieżdżona pętla to nic innego jak pętla umieszczona w ciele innej pętli. Dla przykładu pętle, które mogą pomóc Ci wykonać zadanie mogą wyglądać tak: int numberOfClasses = 3;int numberOfNotes = 4;for (int classIndex = 0; classIndex &lt; numberOfClasses; classIndex++) {    for (int noteIndex = 0; noteIndex &lt; numberOfNotes; noteIndex++) {        // zadanie ;)    }}Jeśli masz jakiekolwiek pytania podziel się nimi w komentarzach. Pochwal się też jeśli udało Ci się wykonać to zadanie :) Jeśli będziesz miał problemy z jego wykonaniem możesz rzucić okiem do przykładowego rozwiązania. Materiały dodatkowe Temat bynajmniej nie jest wyczerpany. Jeśli chcesz bardziej pogłębić swoją wiedzę przygotowałem dla Ciebie zestaw linków z dodatkowymi materiałami do nauki. Część z nich jest w języku angielskim.   Dokumentacja do klasy Scanner  System szesnastkowy zapisu liczb,  System ósemkowy zapisu liczb,  Rozdział w Java Language Specification dotyczący typów prostych,  Rozdzial w Java Language Specification dotyczący literałów,  Kod źródłowy przykładów użytych w artykule.Podsumowanie Dzisiaj poznałeś całkiem sporo nowych rzeczy. Znasz już wszystkie typy proste w Javie i typy je opakowujące. Wiesz już czym jest literał i jakie są ich rodzaje. Umiesz pobierać dane od użytkownika. Innymi słowy masz już wszystkie klocki potrzebne do budowania interaktywnych programów :). Mam nadzieję, że artykuł Ci się spodobał. Jeśli tak to proszę podziel się nim ze swoimi znajomymi. Jeśli chcesz wiedzieć o nowych wpisach proszę polub naszą stronę na facebooku. Trzymaj się! Do następnego razu! ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/typy-proste-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2015/11/29_typy_proste_w_jezyku_java.jpg"},{
        "title": "Interfejsy w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Interfejs Wyobraź sobie kuchenkę mikrofalową. Kuchenka ma zestaw przycisków, parę pokręteł możliwe, że dodatkowy wyświetlacz. Ten zestaw to nic innego jak właśnie interfejs (ang. interface). Interfejs to zestaw „mechanizmów” służących do interakcji, w tym przypadku z kuchenką mikrofalową. Pojęcie interfejsu można także przenieść do świata programowania. Mówimy wówczas o tak zwanym API (ang. Application Programming Interface). Interfejs w kontekście programowania w języku Java to zestaw metod bez ich implementacji (bez kodu definiującego zachowanie metody)1. Właściwa implementacja metod danego interfejsu znajduje się w klasie implementującej dany interfejs. W języku Java do definiowani interfejsów używamy słowa kluczowego interface. Interfejsy, podobnie jak klasy, definiujemy w osobnych plikach. Nazwa pliku musi odpowiadać nazwie interfejsu. public interface Clock {    long secondsElapsedSince(Date date);}Powyżej mamy przykład interfejsu o nazwie Clock, który ma jedną metodę secondsElapsedSince, która przyjmuje argument typu Date2 i zwraca wynik typu long mówiący o liczbie sekund, która minęła od czasu przekazanego w argumencie. Wszystkie metody zawarte w interfejsie zawsze są publiczne więc w tym przypadku można ominąć słowo kluczowe public, nie jest potrzebne. Poza zwykłymi metodami w interfejsie mogą się znajdować   metody domyślne,  metody statyczne,  stałe.Więcej o metodach statycznych możesz przeczytać w artykule opisującym pierwszy program w języku Java. Nie jest to dla Ciebie nic nowego. Metody domyślne i stałe wymagają dodatkowego wyjaśnienia.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Metody domyślne Istnieje możliwość zdefiniowania tak zwanych metod domyślnych. Metody te mogą mieć właściwą implementacje w ciele interfejsu. Metody takie poprzedzone są słowem kluczowym default jak w przykładzie poniżej public interface MicrowaveOven {    void start();    void setDuration(int durationInSeconds);    boolean isFinished();    void setPower(int power);    default String getName() {        return \"MicrovaweOwen\";    }}Klasy, które implementują interfejs mogą nadpisać metodę domyślną. Wartości niezmienne i stałe int counter = 123;counter to zmienna. Do zmiennej counter możemy przypisać nową wartość: counter = counter + 1;Wartości niezmienne w odróżnieniu od zmiennych poprzedzamy słowem kluczowym final. Poniżej możesz zobaczyć przykład klasy z atrybutem, którego wartości nie możemy przypisać na nowo. Atrybuty tego typu możemy inicjalizować jak w przykładzie poniżej: bezpośrednio bądź w ciele konstruktora. public class Calculator {    public final double PI = 3.14;    public final double SQRT_2;    public Calculator() {        SQRT_2 = Math.sqrt(2);    }}Wartości niezmienne, podobnie jak metody, mogą być przypisane do instancji bądź klasy. Jeśli taka wartość przypisana jest do klasy mówimy wówczas o stałej. Jeśli chcemy aby stała była przypisana do klasy poprzedzamy ją słowem kluczowym static. Do stałych wartość możemy przypisać wyłącznie raz - podczas inicjalizacji klasy. Zgodnie z konwencją nazewniczą stałe piszemy wielkimi literami. public interface Cat {    int NUMBER_OF_PAWS = 4;}W interfejsie powyżej mamy stałą, która pokazuje ile łap ma kot. Domyślnie wszystkie atrybuty interfejsu są stałymi publicznymi przypisanymi do interfejsu więc słowa kluczowe public static final mogą zostać pominięte. Implementacja interfejsu Sam interfejs nie jest zbyt wiele warty bez jego implementacji. Poniżej możesz zobaczyć przykładową, prostą implementację. public interface Clock {    long secondsElapsedSince(Date date);}public class BrokenClock implements Clock {    public long secondsElapsedSince(Date date) {        return 300;    }}Klasa BrokenClock implementuje interfejs Clock. Zwróć uwagę na słowo kluczowe implements. Używamy go żeby pokazać że klasa BrokenClock implementuje interfejs Clock. W języku Java jedna klasa może implementować wiele interfejsów. W takim przypadku klasa implementująca musi definiować metody wszystkich interfejsów, które implementuje3. Dziedziczenie interfejsów Dziedziczenie to temat na osobny, obszerny artykuł. Jednak już teraz wspomnę, że interfejsy mogą dziedziczyć po innych interfejsach. Dziedziczenie oznaczane jest słowem kluczowym extends. Interfejs, który dziedziczy po innych interfejsach zawiera wszystkie metody z tych interfejsów. public interface Cat {    int NUMBER_OF_PAWS = 4;    String getName();}public interface LasagnaEater {    String getLasagnaRecipe();}public interface FatCat extends Cat, LasagnaEater {    double getWeight();}W przykładzie powyżej klasa implementująca interfejs FatCat, musi zaimplementować 3 metody:   String getName(),  String getLasagnaRecipe(),  duble getWeight().Interfejs znacznikowy A czy możliwa jest sytuacja kiedy interfejs nie ma żadnej metody? Oczywiście, że tak. Mówimy wówczas o interfejsie znacznikowym. Jak sama nazwa wskazuje służy on do oznaczenia, danej klasy. Dzięki temu możesz przekazać zestaw dodatkowych informacji. Przykładem takiego interfejsu jest java.io.Serializable, którego używamy aby dać znać kompilatorowi, że dana klasa jest serializowalna (o serializacji przeczytasz w innym artykule). Interfejs a typ obiektu Każdy obiekt w języku Java może być przypisany do zmiennej określonego typu. W najprostszym przypadku jest to jego klasa. Interfejsy pozwalają na przypisane obiektu do zmiennej typu interfejsu. Wydaje się to trochę skomplikowane jednak mam nadzieję, że przykład poniżej pomoże w zrozumieniu tego tematu. public class Garfield implements FatCat {    // implementacja metod}        Przykład hierarchii dziedziczenia  Garfield garfield = new Garfield();FatCat fatCat = new Garfield();Cat cat = new Garfield();LasagnaEater lasagnaEater = new Garfield();Instancję klasy Garfield możemy przypisać zarówno do zmiennej klasy Garfield jak i każdego z interfejsów, który ta klasa implementuje (bezpośrednio lub pośrednio). Chociaż w trakcie wykonania programu każdy z obiektów jest tego samego typu (instancja klasy Garfield), to w trakcie kompilacji sprawa wygląda trochę inaczej:   na obiekcie garfield możemy wykonać wszystkie metody udostępnione w klasie Garfield i interfejsach, które ta klasa implementuje:          getWeight(),      getName(),      getLasagnaReceipe().        na obiekcie fatCat możemy wykonać wszystkie metody udostępnione w interfejsie FatCat i interfejsach po których dziedziczy:          getWeight(),      getName(),      getLasagnaReceipe().        na obiekcie cat możemy wykonać wyłącznie metody z interfejsu Cat:          getName().        na obiekcie lasagnaEater możemy wykonać wyłącznie metody z interfejsu LasagnaEater:          getLasagnaReceipe().      Zastosowania interfejsów Do czego właściwie potrzebne są nam interfejsy? Czy nie jest to po prostu zestaw dodatkowych linijek kodu, które trzeba napisać i nic one nie wnoszą? Otóż nie. Interfejsy w bardzo prosty sposób ułatwiają różnego rodzaju integrację różnych fragmentów kodu. Wyobraź sobie sytuację, w której Piotrek pisze program obliczający średnią temperaturę w każdym z województw. Współpracuje on z Kasią, która pisze program udostępniający aktualną temperaturę w danej miejscowości. Aby Piotrek mógł napisać swój program musi skorzystać z programu Kasi. Musi się z nim zintegrować. Taką integrację ułatwiają właśnie interfejsy. Piotrek z Kasią uzgadniają, że będą używali następującego interfejsu public interface Thermometer {    double getCurrentTemperatureFor(String city);}Dzięki niemu Piotrek może pisać swój program równolegle z Kasią. Co więcej może się okazać, że implementacja Kasi nie jest zbyt dokładna. Ania implementuje ten sam interfejs ale temperatury przez nią zwracane są dokładniejsze. Wówczas Piotrek w ogóle nie musi zmieniać swojego programu. Wystarczy, ze użyje innej implementacji interfejsu Thermometer dostarczonej przez Anię. To właśnie jest kolejna zaleta interfejsów. Dzięki nim możemy pisać programy, które możemy w łatwiejszy sposób modyfikować. Interfejsy jasno oddzielają komponenty programu. Dzięki takiemu podejściu komponenty można z łatwością wymieniać. Interfejs czyli widok na obiekt Postaram się pokazać Ci kolejny przykład. Ważne jest żebyś zrozumiał koncept interfejsów. Są one bardzo ważne i często używane w codziennym programowaniu. Wyobraź sobie piekarnik. Piekarnik to obiekt. W piekarniku możesz upiec chleb, zrobić dobrą pieczeń czy upiec ciasteczka. Każde z tych dań wymaga innych ustawień piekarnika. Inna temperatura, inny czas pieczenia, inny tryb. W programowaniu często chcemy ukryć takie szczegóły przez innymi klasami. Na zewnątrz w formie interfejsu wystawiamy jedynie dobrze zdefiniowane metody. Każda z tych metod może być umieszczona w osobnym interfejsie, który będzie implementowany przez obiekt piekarnika: public interface BakingOven {    void bakeCookies();    void bakeBread();}public interface RoastingOven {    void roastChicken();}public class Oven implements BakingOven, RoastingOven {    private int time;    private int temperature;    @Override    public void bakeBread() {        temperature = 200;        time = 120;        turnOn();    }    @Override    public void bakeCookies() {        temperature = 180;        time = 90;        turnOn();    }    @Override    public void roastChicken() {        temperature = 130;        time = 240;        turnOn();    }    private void turnOn() {        System.out.println(String.format(\"Start. Heat up to %s and work for %d minutes.\", temperature, time));    }    public static void main(String[] args) {        Oven oven = new Oven();        BakingOven bakingOven = oven;        RoastingOven roastingOven = oven;        bakingOven.bakeBread();        bakingOven.bakeCookies();        roastingOven.roastChicken();    }}Po uruchomieniu tego fragmentu kodu na konsoli pokaże się: Start. Heat up to 200 and work for 120 minutesStart. Heat up to 180 and work for 90 minutes.Start. Heat up to 130 and work for 240 minutes.Użyłem tutaj mechanizmu formatowania łańcuchów znaków. Jeśli chcesz przeczytać o tym więcej zachęcam do przeczytania osobnego artykułu na temat formatowania łańcuchów znaków w języku Java. Interfejsy opisują spójny zakres funkcjonalności udostępniony przez dany obiekt. Metody, które są w nim zawarte powinny być ze sobą powiązane. Możesz porównać interfejsy do “widoku” na obiekt/klasę. Widzą obiekt przez pryzmat interfejsu możesz widzieć tylko podzbiór jego możliwości. Zadanie Napisz dwie klasy implementujące interfejs Computation. Niech jedna z implementacji przeprowadza operację dodawania, druga mnożenia. public interface Computation {    double compute(double argument1, double argument2);}Użyj obu implementacji do uzupełnienia programu poniżej: public class Main {    public static void main(String[] args) {        Main main = new Main();        Computation computation;        if (main.shouldMultiply()) {            computation = new Multiplication(); // zaimplementuj brakującą klasę        }        else {            computation = new Addition(); // zaimplementuj brakującą klasę        }        double argument1 = main.getArgument();        double argument2 = main.getArgument();        double result = computation.compute(argument1, argument2);        System.out.println(\"Wynik: \" + result);    }    private boolean shouldMultiply() {        return false; // tutaj zapytaj użytkownika co chce zrobić (mnożenie czy dodawanie)    }    private double getArgument() {        return 0; // tutaj pobierz liczbę od użytkownika    }}Program po uruchomieniu powinien zapytać użytkownika jaką operację chce wykonać, następnie pobrać dwa argumenty niezbędne do wykonania tej operacji. Ostatnią linijką powinien być wynik dodawania/mnożenia wyświetlony użytkownikowi. Przygotowałem też dla Ciebie przykładowe rozwiązanie zadania, pamiętaj jednak, że rozwiązując je samodzielnie nauczysz się najwięcej. Materiały dodatkowe Oczywiście nie wyczerpaliśmy tematu mimo sporej objętości artykułu. Zachęcam do samodzielnego pogłębiania wiedzy korzystając z materiałów dodatkowych. Specyfikacja Języka Java jest w języku angielskim.   Opis interfejsu na Wikipedii  Rozdział w Java Language Specification dotyczący interfejsów  Kod źródłowy przykładów użytych w artykulePodsumowanie Dzisiaj poruszyliśmy bardzo wiele zagadnień. Dowiedziałeś się o interfejsach, przeczytałeś o ich przeznaczeniu. Poznałeś też kilka nowych słów kluczowych w języku Java. Wystarczająca dawka wiedzy jak na jeden dzień :) Mam nadzieję, że artykuł był dla Ciebie ciekawy, jeśli cokolwiek nie było zrozumiałe bądź wymaga dokładniejszego wyjaśnienia daj znać, na pewno pomogę. Jak zwykle na koniec mam do Ciebie prośbę. Proszę podziel się artykułem ze swoimi znajomymi, zależy mi na dotarciu do jak największej liczby osób, które chcą nauczyć się programowania :) Zapraszam także na SamouczekProgramisty na Facebooku. Możesz też zapisać się do mojego newslettera. Do następnego razu!             Wyjątkiem tutaj są tak zwane metody domyślne, o których przeczytasz niżej. &#8617;               java.util.Date jest jednym z typów z biblioteki standardowej służącym do przedstawiania daty/czasu. &#8617;               Oczywiście jest od tego wyjątek, o klasach abstrakcyjnych przeczytasz w innym artykule. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/interfejsy-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2015/12/16_interfejsy_w_jezyku_java_artykul.jpg"},{
        "title": "Choinka",
        "excerpt":"Na początku z okazji Bożego Narodzenia życzę Ci dużo wytrwałości w dążeniu do wyznaczonego celu. Nie jesteś w stanie nauczyć się programować bez swojej ciężkiej i systematycznej pracy więc życzę Ci także zapału, nie tego słomianego :) Mam nadzieję, że jednym z Twoich założeń jest nauczenie się programowania. Trzymam kciuki za jego realizację, będę się starał aby Ci w tym pomóc na blogu. Mam także nadzieję, że w trakcie Świąt chwila spędzona przed komputerem będzie przyjemnym przerywnikiem od świętowania przy stole. Zadanie Bez zbędnego owijania w bawełnę przechodzimy do zadania dla Ciebie. Zadanie nie jest skomplikowane, pamiętam, że mi podczas nauki programowania zadał je jeden z moich prowadzących na uczelni. Był nim dr Paweł Rogaliński lub dr inż. Marek Piasecki, niestety nie pamiętam dokładnie. Zadanie polega na wydrukowaniu choinki na ekranie :) Twoim zadaniem jest przyjęcie argumentu od użytkownika którym będzie wysokość choinki. Program powinien wypisać na konsoli choinkę tej wysokości. Załóżmy, że użytkownik poprosi o choinkę wysokości 5 wówczas na ekranie powinno pokazać się drzewko (ważne jest drukować je czcionką o stałej szerokości co jest domyślnym ustawieniem na konsoli):     *   ***  ***** ****************Do wykonania zadania użyj pętli. Dokładnie opisane są w tym artykule. Pobieranie danych od użytkownika opisałem w artykule o typach prostych w języku Java.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dodatkowe wskazówki StringBuilder Łańcuchy znaków można ze sobą łączyć znakiem +: String example = \"some\" + \" \" + \"example\";Może to jednak nie być wydajne. W niektórych przypadkach Java przy każdym połączeniu tworzy nowy obiekt String. Łączenie łańcuchów znaków można ulepszyć używając do tego klasy StringBuilder jak w przykładzie poniżej. char treeSymbol = '*';StringBuilder treeRepresentation = new StringBuilder();treeRepresentation.append(\" \");treeRepresentation.append(treeSymbol);treeRepresentation.append(System.lineSeparator());treeRepresentation.append(treeSymbol);treeRepresentation.append(treeSymbol);String christmasTree = treeRepresentation.toString();Metoda append służy do dołączania poszczególnych części łańcucha znaków. Na końcu wywołanie metody toString zwraca właściwy obiekt String. Nowa dla Ciebie może taże być metoda System.lineSeparator(). Bez wchodzenia w zbędne szczegóły, metoda po prostu zwraca znak nowej linii. Zmienna christmasTree z przykładu powyżej wygląda następująco.  ***Podsumowanie Mam nadzieję, że zadanie Ci się podoba :) Jeśli myślisz, że komukolwiek z Twoich znajomych jego rozwiązanie mogłoby także przynieść trochę satysfakcji proszę przekaż mu link do tego wpisu. Gdy będziesz miał problem z rozwiązaniem zadania możesz rzucić okiem na przykładowe rozwiązanie, które umieściłem na githubie. Jeśli nie chcesz przegapić żadnego nowego wpisu możesz polubić stronę na facebooku :) Jeszcze raz Wesołych Świąt! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/choinka/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2015/12/25_choinka.jpg"},{
        "title": "Dziedziczenie w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Dziedziczenie Na początku postaram się wyjaśnić czym właściwie jest dziedziczenie. Nie jest to nic skomplikowanego. Niektóre obiekty mogą mieć między sobą dużo wspólnego. Na przykład zarówno samochód osobowy jak i samochód ciężarowy mają silnik, kierownicę, drzwi, światła itd. Co prawda każdy z tych elementów może być różny, jednak bez wątpienia oba te pojazdy mają wiele wspólnego. Przede wszystkim oba są pojazdami. Możemy powiedzieć, że samochód ciężarowy rozszerza (ang. extends) funkcjonalność pojazdu. W naszym przykładzie pojazd możemy uznać, za tak zwaną klasę bazową (lub nadklasę). Natomiast samochód osobowy i samochód ciężarowy rozszerzają funkcjonalność pojazdu. Możemy też powiedzieć, że każda z nich jest klasą pochodną (lub „podklasą”). Proszę spójrz na przykład: public class Vehicle {}public class Car extends Vehicle {}public class Truck extends Vehicle {}Dziedziczenie jest jedną z podstaw programowania obiektowego (nie tylko w języku Java). Dzięki dziedziczeniu możemy ograniczyć ilość powielonego kodu poprzez definiowanie atrybutów, konstruktorów, metod w klasach bazowych. Dziedziczenie może być wielopoziomowe, jednak w języku Java zawsze bezpośrednio możemy dziedziczyć od jednej klasy. public class Vehicle {}public class Car extends Vehicle {}public class SUV extends Car {}W przykładzie powyżej SUV dziedziczy po klasie Car. Klasa Car jest podklasą klasy Vehicle. Zatem pośrednio SUV także dziedziczy po klasie Vehicle.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Modyfikatory dostępu Dzięki dziedziczeniu możemy mieć dostęp do metod, atrybutów, konstruktorów klas po których dziedziczymy. Do określenia czy dany element może być dostępny w ramach podklasy służą modyfikatory dostępu. Do tej pory poznałeś modyfikatory dostępu takie jak:   public - element oznaczony tym modyfikatorem dostępny jest “z zewnątrz” obiektu, stanowi jego interfejs,  private - element oznaczony tym modyfikatorem jest dostępna wyłącznie wewnątrz obiektu, także klasy pochodne nie mają do niego dostępu.W przypadku dziedziczenia znaczenie ma także modyfikator protected. Element poprzedzony tym atrybutem może być dostępny wewnątrz klasy bądź przez każdą inną klasę która po niej dziedziczy. Przygotowałem osobny artykuł poświęcony modyfikatorom dostępu. Jeśli chcesz dowiedzieć się więcej o modyfikatorach powinieneś go przeczytać. Przesłonięcie i przeciążenie metody Pytanie o to, czym różni się przesłonięcie od przeciążenia metody często trafia się na rozmowach o pracę. Pamiętam je jako jedno z obowiązkowych pytań na stanowiska początkujących programistów. Warto znać tę różnicę. Sygnatura metody Zanim wytłumaczę Ci te pojęcia musisz wiedzieć czym jest sygnatura metody. Specyfikacja języka Java określa sygnaturę metody jako jej nazwę wraz z listą argumentów. W szczególności w skład sygnatury metody nie wchodzi typ zwracany przez daną metodę. W poniższym przykładzie sygnaturą metody jest main(String[]) (nazwy parametrów nie są istotne): public static void main(String[] args) throws Exception {    System.out.println(\"something important\");}  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Przesłonięcie metody Łatwo sobie wyobrazić sytuację, w której metoda o tej samej sygnaturze występuje zarówno w klasie bazowej jak i klasie pochodnej. W tej sytuacji mówimy o tym, że klasa pochodna przesłania metodę z klasy bazowej (ang. override). Proszę spójrz na przykład poniżej. public class Vehicle {    public void startEngine() {        System.out.println(\"Engine starts. Brum brum brum.\");    }} public class Car extends Vehicle {    public void startEngine() {        System.out.println(\"Force driver to fasten seat belts.\");    }}W naszym przykładzie wywołanie metody startEngine na obiekcie typu Car zmusi kierowcę do zapięcia pasów (wyświetli się komunikat Force driver to fasten seat belts). Jeśli tę samą metodę wywołamy na instancji obiektu klasy Vehicle wówczas pojawi się komunikat Engine starts. Brum brum brum.. Co jeśli chcielibyśmy nieznacznie zmodyfikować oryginalną metodę? Jest na to sposób. Słowo kluczowe super pozwala na wywołanie nadpisanej metody z klasy bazowej. Rozszerzając przykład powyżej moglibyśmy napisać taki fragment kodu: public class Car extends Vehicle {    public void startEngine() {        super.startEngine();        System.out.println(\"Force driver to fasten seat belts.\");    }}W takim przypadku wywołanie metody startEngine na instancji obiektu Car na początku wywoła tę metodę z klasy bazowej (wyświetli się komunikat Engine starts...) następnie pokazany zostanie komunikat Force driver... (zachęcam do eksperymentowania z IDE). Adnotacja @Override informuje kompilator o tym, że dana metoda powinna przesłaniać inną metodę w klasie bazowej. Jeśli warunek ten nie będzie spełniony możesz spodziewać się błędu kompilacji. Przeciążenie metody Przeciążenie (ang. overload) metody nie jest związane z dziedziczeniem. Mówimy o tym, że metoda jest przeciążona jeśli w ramach jednej klasy występuje wiele metod o tej samej nazwie. W tym przypadku każda z tych metod, mimo tej samej nazwy, ma różną sygnaturę. Metody te różnią się między sobą listą argumentów. Spójrz na przykład poniżej: public abstract class Vehicle {    protected final int tankCapacity = 60;    protected int fuelLevel = tankCapacity;    public void fillTank() {        int toFill = tankCapacity - fuelLevel;        fillTank(toFill);    }    public void fillTank(int toFill) {        if (toFill + fuelLevel &gt; tankCapacity) {            System.out.println(\"I can't fill tank with \" + toFill + \" litres.\");        }        else {            fuelLevel += toFill;            System.out.println(\"I've filled the tank with \" + toFill + \" litres.\");        }    }}W przykładzie tym metoda fillTank jest przeciążona. Pierwsza jej wersja nie pobiera żadnych argumentów. Druga liczbę typu int. Obie służą do napełnienia zbiornika paliwem. Częstą praktyką jest używanie wewnątrz przeciążonej metody wywołania jej innego odpowiednika. Zazwyczaj metody z mniejszą liczbą argumentów wywołują te z większą. W takim przypadku możesz nadać domyślne wartości parametrów dla metod z większą ich liczbą. W przykładzie powyżej bezargumentowa metoda fillTank wylicza ile paliwa brakuje do pełnego zbiornika. Następnie wywołuje przeciążoną metodę przekazując jej liczbę brakujących litrów Przeciążać można także metody statyczne. Jako przykład może tu posłużyć metoda z biblioteki standardowej LocalDateTime.of. Metoda ta jest przeciążona aż siedem razy. Konstruktory nie są wyjątkiem, także można je przeciążać. Dzięki temu pozwalasz na tworzenie danego obiektu na wiele różnych sposobów: public class Car extends Vehicle {    public Car() {        this(new DiselEngine());    }    public Car(Engine engine) {        super(engine, NUMBER_OF_WHEELS);    }}Podobnie jak w zwykłym przeciążeniu także i tutaj często odwołuje się do innego konstruktora. Służy do tego słowo kluczowe this. W przykładzie powyżej bezparametrowy konstruktor wywołuje konstruktor przyjmujący instancję klasy implementującą interfejs Engine. W tym przypadku nowa instancja DieselEngine tworzona jest wewnątrz konstruktora bezparametrowego. Konstruktory a dziedziczenie Konstruktory w przypadku dziedziczenia zachowują się tak samo jak metody. Także możemy wywołać konstruktor z klasy bazowej wewnątrz klasy dziedziczącej używając słowa kluczowego super (jeśli pozwala na to modyfikator dostępu). Klasa pochodna musi mieć możliwość wywołania konstruktora klasy bazowej. Jeśli tego nie robi domyślnie wywoływany jest konstruktor bezparametrowy public class Animal {    public Animal() {    }} public class Dog extends Animal {    public Dog() {        super();    }}W powyższym przykładzie wewnątrz konstruktora klasy Dog wywołujemy konstruktor klasy Animal wywołując super(). Jak napisałem wyżej możemy pominąć to wywołanie, wówczas kompilator zrobi to za nas. Ma to pewne konsekwencje. Jeśli w klasie bazowej zdefiniujemy konstruktor z parametrami wówczas konstruktor bezparametrowy nie zostanie utworzony automatycznie. W takich przypadkach w konstruktorach klas pochodnych musimy wywołać konstruktor klasy bazowej. Pokazałem to w przykładzie poniżej: public class Vehicle {    private int numberOfWheels;    private Engine engine;     public Vehicle(Engine engine, int numberOfWheels) {        this.engine = engine;        this.numberOfWheels = numberOfWheels;    }} public class Car extends Vehicle {    private static final int NUMBER_OF_WHEELS = 4;     public Car(Engine engine) {        super(engine, NUMBER_OF_WHEELS);    }}Jak widzisz w przykładzie powyżej klasa Car nie musi definiować konstruktora z taką samą liczbą parametrów jak klasa bazowa, ale musi wywołać konstruktor klasy Vehicle i przekazać dwa parametry. Dzieje się tak, ponieważ w klasie Vehicle jest tylko konstruktor z dwoma parametrami. Klasy abstrakcyjne Czasami może wystąpić sytuacja, w której klasa bazowa jest swego rodzaju uogólnieniem, abstrakcją, która nie ma sensu bez konkretnych implementacji. Wówczas możemy mówić o klasie abstrakcyjnej. Nie ma możliwości stworzenie instancji klasy abstrakcyjnej. W naszym przykładzie klasa Vehicle mogłaby być klasą abstrakcyjną. Klasy abstrakcyjne poprzedzamy słowem kluczowym abstract. Proszę spójrz na przykład poniżej. public abstract class Vehicle {    private int numberOfWheels;    private Engine engine;     public Vehicle(Engine engine, int numberOfWheels) {        this.engine = engine;        this.numberOfWheels = numberOfWheels;    }} public class Car extends Vehicle {    private static final int NUMBER_OF_WHEELS = 4;     public Car(Engine engine) {        super(engine, NUMBER_OF_WHEELS);    }}Jak widzisz klasa abstrakcyjna może mieć konstruktor, jednak służy on tylko do tego, żeby uniknąć duplikacji kodu w klasach pochodnych. Klasa Car używa konstruktora zdefiniowanego w abstrakcyjnej klasie Vehicle. Klasy i metody finalne Możliwość dziedziczenia i nadpisywania metod daje bardzo duże możliwości. Wyobraź sobie następujący kod: public interface BankAccount {    void deposit(BigDecimal amount);    void withdraw(BigDecimal amount);} public class Transfer {    public void transferMoney(BankAccount source, BankAccount destination, BigDecimal amount) {        source.withdraw(amount);        destination.deposit(amount);    }}Co stanie się jeśli programista utworzy nową klasę jak w przykładzie poniżej? public class FraudTransfer extends Transfer{    public void transferMoney(BankAccount source, BankAccount destination, BigDecimal amount) {        destination.deposit(amount);    }}Przy takiej implementacji konto docelowe zostałoby zasilone dodatkową kwotą jednak ta kwota nie byłaby pobrana z konta źródłowego. Niedobrze. W takich przypadkach możemy użyć słowa kluczowego final. Słowo to umieszczone przed klasą oznacza, że nie możemy po danej klasie dziedziczyć. W przypadku metody oznacza, że metoda nie może zostać nadpisana. Dla przykładu klasy w pakiecie java.lang są finalne. Nie można nadpisać ich implementacji. Klasa java.lang.Object Teraz już wiesz czym jest dziedziczenie. A wiesz, że używałeś go od pierwszej lekcji nauki języka Java? :) Z jednego z poprzednich artykułów wiesz o tym, że kompilator dodaje automatycznie konstruktor bezparametrowy jeśli nie zdefiniujesz żadnego w swojej klasie. Podobnie jest z dziedziczeniem, każda klasa domyślnie dziedziczy po klasie java.lang.Object (chyba, że zdefiniujesz inną klasę po której dziedziczysz). Dzięki tej klasie masz dostęp do zestawu metod, które zdefiniowane są w ciele klasy Object. Na przykład metoda String toString() ma swoją podstawową implementację w klasie Object1. Dobre praktyki Dziedziczenie to bardzo pomocny mechanizm. Jak napisałem wcześniej pozwala nam na uniknięcie duplikowania kodu. Jednak ma też swoje wady. Hierarchie dziedziczenia, które mają dużo poziomów mogą stać się mało czytelne. Tak zagmatwany kod może stać się trudny w utrzymaniu. Powinniśmy unikać takiej sytuacji. Nie ma tu jasnej reguły, jednak w przypadku gdy w programie występuje wielopoziomowe dziedziczenie starałbym się uprościć taki kod. Bardzo często mówi się o preferowaniu kompozycji nad dziedziczeniem. Kompozycja to nic innego jak zawarcie innego obiektu jako atrybut naszej klasy. Kompozycja w wielu przypadkach potrafi uprościć skomplikowane hierarchie dziedziczenia. Zadanie Na koniec mam dla Ciebie zadanie do wykonania, przećwiczysz w nim zagadnienia omówione w tym artykule. Napisz program, w którym zasymulujesz hierarchię dziedziczenia zwierząt. Stwórz abstrakcyjną klasę Animal, po której będą dziedziczyły klasy Fish i Mammal. Wszystkie te klasy powinny być abstrakcyjne. Następnie stwórz konkretne klasy które dziedziczą po Fish i Mammal. Będą to odpowiednio Goldfish i Human. Nadpisz metodę toString w każdej z tych klas. Stwórz instancje obu tych klas i wyświetl je na konsoli. Jeśli miałbyś problemy z zadaniem możesz spojrzeć na przykładowe rozwiązanie. Dodatkowe materiały Poniżej przygotowałem dla Ciebie zestaw linków z dodatkowymi materiałami, część z nich jest w języku angielskim.   https://pl.wikipedia.org/wiki/Dziedziczenie_%28programowanie%29  https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8  https://docs.oracle.com/javase/tutorial/java/IandI/subclasses.html  https://docs.oracle.com/javase/tutorial/java/concepts/inheritance.html  kod źródłowy przykładów z tego artykułuPodsumowanie Bardzo się cieszę, że przeczytałeś artykuł do końca. Dzisiaj dowiedziałeś się czegoś więcej o dziedziczeniu. Poznałeś słowa kluczowe abstract i final. Wiesz już czym jest nadpisywanie metod czy klasa bazowa. Innymi słowy poznałeś kolejny zestaw narzędzi niezbędnych dla każdego programisty. Tak trzymaj! :) Na koniec bardzo proszę Cię o podzielenie się artykułem ze swoimi znajomymi, którzy są zainteresowani taką tematyką. Jak zwykle zależy mi na tym, żeby z blogiem i jego zawartością dotrzeć do jak największej liczby czytelników takich jak Ty :) Jeśli jeszcze tego nie zrobiłeś prosiłbym o polubienie strony na Facebooku. Do następnego razu!             Domyślna implementacja pokazuje nazwę klasy wraz z pakietem oraz jej adres w pamięci np. pl.samouczekprogramisty.kursjava.cars.X@14ae5a5. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/dziedziczenie-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/01/24_dziedziczenie_w_jezyku_java_artykul.jpeg"},{
        "title": "Wyjątki w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Czym jest wyjątek? Wyjątek (ang. exception) jest specjalną klasą. Jest ona specyficzna ponieważ w swoim łańcuchu dziedziczenia ma klasę java.lang.Throwable. Instancje, które w swojej hierarchii dziedziczenia mają tę klasę mogą zostać „rzucone” (ang. throw) przerywając standardowe wykonanie programu. Przykładem może być tutaj walidacja argumentów metody. Załóżmy, że nasza metoda jako argument przyjmuje liczbę godzin i zwraca liczbę sekund, odpowiadających przekazanemu argumentowi. Możemy założyć, że akceptujemy wyłącznie argumenty dodatnie lub 0. Innymi słowy jeśli metoda zostanie wywołana z argumentem mniejszym od 0 możemy uznać to za nieprawidłowe wywołanie i zasygnalizować taką sytuację rzucając wyjątek. public int getNumberOfSeconds(int hour) {    if (hour &lt; 0) {        throw new IllegalArgumentException(\"Hour must be &gt;= 0: \" + hour);    }    return hour * 60 * 60;}W przykładzie powyżej użyliśmy wyjątku występującego w standardowej bibliotece języka Java: java.lang.IllegalArgumentException. Do rzucania wyjątku używamy słowa kluczowego throw.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Co się dzieje po rzuceniu wyjątku? Wyobraź sobie kilka metod, które wywołują siebie nawzajem. Te kilka wywołań nazywamy stosem wywołań. Proszę zwróć uwagę na przykład poniżej: package pl.samouczekprogramisty.kursjava.exception;public class StackTraceExample {    public static void main(String[] args) {        StackTraceExample example = new StackTraceExample();        example.method1();    }    public void method1() {        method2();    }    public void method2() {        method3();    }    public void method3() {        throw new RuntimeException(\"BUM! BUM! BUM!\");    }}W naszym przykładzie w metodzie main tworzymy instancję klasy StackTraceExample i na instancji wywołujemy metodę method1, metoda ta wywołuje z kolei metodę method2. method2 wywołuje method3, która rzuca wyjątek java.lang.RuntimeException (kolejny wyjątek z biblioteki standardowej). Tą listę metod wywołujących siebie nawzajem nazywamy stosem wywołań. W naszym przypadku stos wygląda następująco:   main  method1  method2  method3A co stanie się po uruchomieniu tego programu? Oczywiście zostanie rzucony wyjątek, a programista zobaczy stos wywołań metod (ang. stacktrace), jak w przykładzie poniżej: Exception in thread \"main\" java.lang.RuntimeException: BUM! BUM! BUM!    at pl.samouczekprogramisty.kursjava.exception.StackTraceExample.method3(StackTraceExample.java:18)    at pl.samouczekprogramisty.kursjava.exception.StackTraceExample.method2(StackTraceExample.java:14)    at pl.samouczekprogramisty.kursjava.exception.StackTraceExample.method1(StackTraceExample.java:10)    at pl.samouczekprogramisty.kursjava.exception.StackTraceExample.main(StackTraceExample.java:6)    at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)    at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)    at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)    at java.lang.reflect.Method.invoke(Method.java:498)    at com.intellij.rt.execution.application.AppMain.main(AppMain.java:140)W pracy programisty umiejętność czytania tego typu komunikatów jest bardzo istotna. Dzisiaj stacktrace widzisz pierwszy raz, zapewniam Cię, że zobaczysz go jeszcze dużo razy ;) Zrozumieć stacktrace Proszę zwróć uwagę na stos wywołań metod, który wspomniałem wyżej i porównaj go ze stacktrace’em. Widzisz pewną zależność? Dokładnie – stacktrace to nic innego jak odwrócony stos wywołań metod od rozpoczęcia programu do miejsca w którym został rzucony wyjątek. Pierwsza linijka mówi o tym jaki wyjątek został rzucony, kolejne linijki to metody, które były wywoływane. Każda linia składa się z nazwy klasy wraz z pakietem, w nawiasach znajduje się nazwa pliku oddzielona dwukropkiem od numeru linii w tym pliku. W naszym przypadku wyjątek RuntimeException został rzucony po wywołaniu metody pl.samouczekprogramisty.kursjava.exception.StackTraceExample.method3, która znajduje się w 18 linijce pliku StackTraceExample.java. Ostatnie linijki także pokazują na kod programu, jednak ten nie jest już napisany prze mnie. Program powyżej uruchamiałem z IDE i to właśnie przez InteliJ stacktrace zawiera te 5 dodatkowych linijek. Obsługa wyjątków Już wiesz jak można rzucić wyjątek. Najwyższy czas zacząć je obsługiwać :) Mówimy, że wyjątek jest obsługiwany, jeśli reagujemy na jego wystąpienie i próbujemy “naprawić” program w trakcie jego działania. Możemy też powiedzieć, że łapiemy wyjątek. Do obsługi wyjątków służy blok try/catch. Proszę spójrz na przykład poniżej: int hours = -3;int numberOfSeconds = 0;try {    numberOfSeconds = instance.getNumberOfSeconds(hours);}catch (IllegalArgumentException exception) {    numberOfSeconds = instance.getNumberOfSeconds(hours * -1);}System.out.println(numberOfSeconds);Znasz już metodę getNumberOfSeconds. Wiesz, że rzuca wyjątek IllegalArgumentException jeśli argument jest mniejszy od 0. W przykładzie powyżej otaczamy wywołanie metody blokiem try {…} catch. Jeśli kod wewnątrz nawiasów { } rzuci wyjątek i blok catch będzie obsługiwał ten typ wyjątku wówczas zostanie wywołany kod w bloku catch i wyjątek nie przerwie działania programu. W przykładzie powyżej pierwsze wywołanie metody rzuci wyjątek ponieważ przekazaliśmy -3 jako argument. Rzucony wyjątek jest obsługiwany przez klauzulę catch (klasa wyjątku “pasuje”) więc zostaje wywołany kod wewnątrz bloku. Pod blokiem try może znajdować się wiele bloków catch. Pierwszy pasujący zostanie wykonany. Rzucony wyjątek może być obsłużony przez dany blok catch jeśli klasa wyjątku w () znajduje się w hierarchii dziedziczenia rzuconego wyjątku. Nie jest to skomplikowane, zdecydowanie łatwiej wygląda to na przykładzie try {    throw new IllegalArgumentException();}catch (ArithmeticException exception) {    // 1}catch (RuntimeException exception) {    // 2}catch (Exception exception) {    // 3}Blok catch 1 nie zostanie wykonany bo ArithmeticException nie znajduje się w hierarchii dziedziczenia wyjątku IllegalArgumentException. Blok catch 2 zostanie wykonany bo IllegalArgumentException dziedziczy po RuntimeException. Następny blok nie zostanie wykonany ponieważ w przypadku obsługi wyjątku pierwszy pasujący blok catch jest wykonywany jako jedyny. Obsługa kilku rodzajów wyjątków w jednym bloku catch Może zdarzyć się sytuacja, w której chciałbyś obsłużyć kilka wyjątków a nie mają one wspólnej klasy bazowej. Wówczas w nawiasach po catch możesz oddzielić klasy wyjątków symbolem | jak w przykładzie poniżej. try {    someMagicMethod();}catch (ArithmeticException | IllegalArgumentException exception) {     // handle exception}Rodzaje wyjątków checked oraz unchecked Każdy wyjątek w języku Java dziedziczy po klasie Throwable. Wyróżniamy dwa rodzaje wyjątków, tak zwane “checked exceptions” oraz “unchecked exceptions”. Różnica między nimi sprowadza się do tego, że te pierwsze muszą być obsłużone przez programistę, wymaga tego kompilator. Przykładowym wyjątkiem typu unchecked jest IllegalArgumentException, natomiast IOException jest wyjątkiem typu checked.         Hierarchia dziedziczenia wyjątków  Reguła podziału wyjątków na te dwa rodzaje jest prosta. Jeśli wyjątek w swojej hierarchii dziedziczenia ma Exception i nie ma RuntimeException jest wyjątkiem typu checked. W każdym innym przypadku jest to wyjątek typu unchecked. Kiedy zatem stosować wyjątki typu checked? Zalecenie jest proste, za każdym razem kiedy program ma możliwość “naprawienia” zaistniałej sytuacji wyjątkowej powinniśmy rzucić wyjątek typu checked. Reguła ta jednak jest bardzo często łamana ponieważ obsługa tego typu wyjątków wymaga trochę więcej kodu ;) Klauzula throws Wyjątek można obsłużyć na dwa sposoby. Jeden już znasz, to otoczenie fragmentu kodu blokami try/catch. Drugi sprowadza się do “zepchnięcia” odpowiedzialności obsłużenia wyjątku o poziom niżej, do metody wywołującej. Służy do tego klauzula throws, którą dodajemy do deklaracji metody. Spójrz na przykład poniżej: public class CheckedExceptions {    public static void main(String[] args) {        CheckedExceptions instance = new CheckedExceptions();        try {            instance.methodWithCheckedException();        }         catch (IOException e) {            e.printStackTrace();        }    }     private void methodWithCheckedException() throws IOException {        throw new IOException();    }}Metoda methodWithCheckedException rzuca wyjątek IOException, który jest typu checked. Nie obsługuje go jednak wewnątrz ale informuje o tym, że może rzucić taki wyjątek dzięki throws. W metodzie main mamy standardowy blok catch, gdzie wyjątek jest obsłużony. Klauzula finally Blok finally możemy umieścić po try. Kod wewnątrz tego bloku zawsze zostanie wykonany1. W rzeczywistości blok try nie musi mieć żadnej klauzuli catch jeśli ma blok finally. try {    throw new RuntimeException();}finally {    System.out.println(\"Surprise!\");}Może być także sytuacja w której mamy zarówno try, catch jak i finally. Jeśli wewnątrz try zostanie rzucony wyjątek, który jest obsługiwany przez blok catch to dodatkowo, jako ostatni, uruchomi się blok finally. Dobre praktyki przy używaniu wyjątków Poniżej zebrałem dla Ciebie zestaw kilku dobrych praktyk przy pracy z wyjątkami:   Pierwsza i najważniejsza zasada, blok try powinien być jak najmniejszy. Takie podejście bardzo ułatwia znajdowanie błędów w bardziej skomplikowanych programach. Dzięki małemu blokowi try także możemy napisać lepszy kod do obsługi wyjątku – wiemy dokładnie z którego miejsca wyjątek może zostać rzucony więc wiemy także jak najlepiej na niego zareagować.  Blok finally bardzo często jest niezbędny. Szczególnie jeśli operujemy na instancjach, które wymagają “zamknięcia”.  Używaj klas wyjątków, które idealnie pasują do danej sytuacji. Jeśli nie ma takiego wyjątku w bibliotece standardowej utwórz własną klasę wyjątku.  Tworząc instancję wyjątków podawaj możliwie najdokładniejszy opis w treści wyjątku. Pozwala to na dużo łatwiejsze znajdowanie błędów w programie jeśli komunikat wyjątku jest szczegółowy.  Nie zapominaj o używaniu wyjątków typu checked. Chociaż wymagają trochę więcej kodu i generują często irytujące błędy kompilacji ich używanie jest czasami wskazane.Zadanie Napisz program, który pobierze od użytkownika liczbę i wyświetli jej pierwiastek. Do obliczenia pierwiastka możesz użyć istniejącej metody java.lang.Math.sqrt(). Jeśli użytkownik poda liczbę ujemną rzuć wyjątek java.lang.IllegalArgumentException. Obsłuż sytuację, w której użytkownik poda ciąg znaków, który nie jest liczbą. Zachęcam do samodzielnego rozwiązania zadania, jeśli rozwiązujesz zadanie samodzielnie uczysz się najwięcej. Jeśli jednak chciałbyś zobaczyć przykładowe rozwiązanie, to umieściłem je na githubie. Dodatkowe materiały do nauki   http://docs.oracle.com/javase/tutorial/essential/exceptions/index.html  https://docs.oracle.com/javase/specs/jls/se8/html/jls-11.html  https://www.youtube.com/watch?v=Nl16BzP6Fao  kod źródłowy przykładów użytych w artykulePodsumowanie Bardzo się cieszę, że dobrnąłeś tak daleko. Mam nadzieję, że artykuł przypadł Ci do gustu. Na koniec mam do Ciebie prośbę, podziel się artykułem ze swoimi znajomymi, którzy mogą być zainteresowani tym tematem. Niezmiennie zależy mi na tym, żeby dotrzeć do jak największej grupy czytelników :) Jeśli nie chcesz ominąć kolejnych artykułów polub nasz profil na facebooku i dopisz się do newslettera. Do następnego razu i życzę Ci udanego dnia :)             Są pewne sytuacje kiedy to nie jest prawdą, np. jeśli wirtualna maszyna Javy zostanie wyłączona. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/wyjatki-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/01/31_wyjatki_w_jezyku_java_artykul.jpeg"},{
        "title": "Referencja, sterta i garbage collector - obiektów w Javie ciąg dalszy",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Sterta i stos w wirtualnej maszynie Java Z poprzednich artykułów wiesz, że maszyna wirtualna Javy zarządza za Ciebie pamięcią. Oznacza to tyle, że miejsce na obiekty, które tworzysz jest rezerwowane (i zwalniane jeśli obiekt nie jest już wykorzystywany) w tej pamięci. Pamięć ta nazywana jest stertą (ang. heap space). Maszyna wirtualna Javy startuje zapewniając sobie miejsce na stertę w pamięci RAM (ang. Random Access Memory). Mówimy, ze alokuje tę pamięć. Na przykład jeśli Twój komputer ma 4GB pamięci RAM maszyna wirtualna podczas startu może przydzielić sobie 512MB. Obszar ten potencjalnie może się powiększyć w zależności od ustawień maszyny wirtualnej i dostępnej pamięci.   Tutaj drobna dygresja na temat dysku i pamięci operacyjnej. W czasach dysków HDD (ang. Hard Disk Drive) czas dostępu do pamięci RAM był znacząco krótszy. Obecnie przy dyskach SSD (ang. Solid State Drive) różnica nadal istnieje jednak nie jest tak duża.   Dzięki temu krótkiemu czasowi dostępu do pamięci RAM programy mogły być bardziej wydajne – działać “szybciej”. Załóżmy że przeczytanie 1MB z pamięci ram zajmuje 1 sekundę (w rzeczywistości jest to około 250 nanosekundy więc cztery miliony razy krócej!), w takiej skali przeczytanie 1MB z dysku HDD zajmuje 1 minutę i 20 sekund, a przesłanie pakietu (paczki danych mniejszej niż 1MB) przez internet z Kalifornii do Holandii i z powrotem aż 10 minut!   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Czym różni się obiekt od referencji i zmiennej? Każdy obiekt w Javie zajmuje jakiś obszar na wspomnianej stercie. Zmienne, które wskazują na obiekty na stercie zawierają referencje. Referencje możemy przedstawić jako „sznurki” łączące zmienną z właściwym obiektem na stercie (obszarem pamięci na stercie gdzie znajduje się obiekt). Referencji (sznurków) do obiektu może być wiele. Proszę spójrz na przykład: public class ObjectVersusReference {    public static void main(String[] args) {        Object referenceToObjectX = new Object();        Object anotherReferenceToObjectX = referenceToObjectX;        Object refferenceToObjectY = new Object();        System.out.println(referenceToObjectX.toString());        System.out.println(anotherReferenceToObjectX.toString());        System.out.println(refferenceToObjectY.toString());    }}W pierszej linijce metody main tworzona jest nowa zmienna typu Object o nazwie referenceToObjectX. W kolejnej linijce tworzona jest kolejna zmienna, która jest kopią isteniejącej już zmiennej. Trzecia linijka to wywołanie konstruktora, czyli utworzenie nowego obiektu i przypisanie go do zmiennej referenceToObjectY. Innymi słowy zmienne referenceToObjectX oraz anotherReferenceToObjectX zawierają tę samą referencję do tego samego obiektu na stercie. Poniżej pokazałem to co zostanie wypisane na konsoli po uruchomieniu powyższego przykładu java.lang.Object@7f31245ajava.lang.Object@7f31245ajava.lang.Object@6d6f6e28java.lang.Object@7f31245a to nic innego jak wynik domyślnej implementacji metody toString znajdującej się w klasie Object. Metoda ta zwraca nazwę klasy wraz z pakietem oraz adres obiektu na stercie. 7f31245a to adres obiektu (oczywiście w Twoim przypadku te numery mogą być różne – Java może przydzielić tym obiektom inny adres przy każdym uruchomieniu)1. Zauważyłeś, że dwie pierwsze linijki są takie same? To nic innego jak konsekwencja tego, że referencje są “sznurkami” wskazującymi na obiekty. Mamy dwie różne zmienne, które wskazują na ten sam adres na stercie. Jaka jest tego konsekwencja? Jeśli zmienimy zawartość obiektu pod tym adresem obie referencje będą pokazywały, nową, zmienioną wersję obiektu. Rzuć okiem na przykład. public class ObjectFieldsChanging {    private int attribute;     public ObjectFieldsChanging(int attribute) {        this.attribute = attribute;    }     public int getAttribute() {        return attribute;    }     public void setAttribute(int attribute) {        this.attribute = attribute;    }     public static void main(String[] args) {        ObjectFieldsChanging reference1 = new ObjectFieldsChanging(123);        ObjectFieldsChanging reference2 = reference1;         System.out.println(reference1.getAttribute());        System.out.println(reference2.getAttribute());         reference1.setAttribute(1);         System.out.println(reference1.getAttribute());        System.out.println(reference2.getAttribute());    }}Zmieniliśmy obiekt tylko pod jedną ze zmiennych, ale w związku z tym, że obie pokazują na ten sam adres na stercie zmiana dotyczyła obu. Przypisanie nowej instancji obiektu do istniejącej zmiennej oczywiście “przepina sznurek” do innego miejsca na stercie (zmienna jest referencją do nowego obiektu, innego miejsca w pamięci). ObjectFieldsChanging reference1 = new ObjectFieldsChanging(123);ObjectFieldsChanging reference2 = reference1;reference2 = new ObjectFieldsChanging(3);  Kolejna dygresja, jeśli po powyższych wyjaśnieniach masz mętlik w głowie pomiń ten akapit przy pierwszym czytaniu. Obiekty trzymane są na stercie, zmienne trzymane są na stosie (ang. stack) :). “Niestety” nie wszystkie zmienne wskazują na obiekty na stosie. Jeśli utworzysz zmienną lokalną (nie będącą atrybutem klasy) typu prostego (np. int czy double) wylądują one bezpośrednio na stosie. Referencja to nic innego jak numer, adres w pamięci. W przypadku zmiennych przechowywanych na stosie ten adres zostaje zastąpiony właściwą wartością zmiennej (np. liczbą 123). Różnica między \"string\" a new String(\"string\") Wiesz już, że obiekty zajmują obszar na stercie. Java stara się być trochę mądrzejsza i ograniczać ilość zajętego miejsca. Jedną z takich optymalizacji jest zachowanie w przypadku literałów reprezentujących typ String. String x1 = new String(\"x\");String x2 = new String(\"x\");String x3 = \"x\";String x4 = \"x\";Dwie pierwsze linijki to dwie zmienne, dwie referencje i dwa różne obiekty (które mają w taką samą zawartość). Dwie ostatnie linijki to dwie zmienne, dwie referencje i jeden obiekt. Obie referencje pokazują na obiekt utworzony w 3 linijce. Innymi słowy konstruktor tworzy kopię przekazanego literału. Literał może czasami ograniczyć ilość zużytego miejsca na stercie. Garbage Collector w wirtualenej maszynie Javy Zbieracz śmieci :) Gargage collector, inaczej GC, jest komponentem wirtualnej maszyny Javy odpowiedzialnym za czyszczenie sterty2. Jeśli na stercie znajdą się obiekty, które już nie są używane zostają one usunięte aby zwolnić miejsce dla nowych obiektów. Gdyby nie było tego mechanizmu pamięć nie byłaby zwalniana i po pewnym czasie program nie mógłby działać, nie miałby miejsca na alokację pamięci dla nowo tworzonych obiektów. GC używa różnych zaawansowanych algorytmów, które pozwalają zdecydować czy dany obiekt jest aktualnie wykorzystywany przez działający program. GC działa w tle, w większości przypadków nawet nie będziesz wiedział kiedy. Wirtualna maszyna sama decyduje kiedy powinna go uruchomić. Istnieją sposoby aby zasugerować uruchomienie GC ale w rzeczywistości nie masz na to wpływu. GC jest dość skomplikowanym mechanizmem, którego na tym etapie nie musisz w 100% rozumieć. Powinieneś wiedzieć o tym, że jest i odwala za Ciebie mnóstwo pracy :) GC nie jest rozwiązaniem wszystkich problemów. Dalej możesz napisać program, który zajmie całą dostępną stertę i maszyna wirtualna nie będzie miała możliwości tworzenia nowych obiektów. W takiej sytuacji Twój program zostanie zamknięty, rzucony zostanie wyjątek java.lang.OutOfMemoryError. null i NullPointerException Oj, ten wyjątek zobaczysz wiele razy w trakcie swojej kariery :) Zanim jednak przejdziemy do wyjątku przeczytaj o magicznym null. Będzie to trochę abstrakcyjne ale właśnie tak jest zdefiniowane w specyfikacji języka Java. Null jest typem, który nie ma nazwy. W związku z tym, że nie ma nazwy nie ma możliwości utworzyć zmiennej typu null. Wyrażenie null zwraca referencję do null. Object object = new Object(); // oknull something = new null(); // compilation errorW praktyce jednak można zapomnieć o typie null i uznać to jako specjalny literał, który możemy przypisać do zmiennej każdego innego typu (który nie jest typem prostym). Możemy też założyć, że to jest “pusta” wartość zmiennej przechowującej referencję do obiektu. A co się stanie jeśli wywołamy metodę na referencji wskazującej na null? Zostanie rzucony wyjątek java.lang.NullPointerException. Innymi słowy za każdym razem kiedy zobaczysz NullPointerException (a zobaczysz go nie raz) oznacza to, że zmienna ma wartość null. Dodatkowe materiały do nauki   https://gist.github.com/jboner/2841832 - zestawienie czasów na podstawie których przygotowałem jeden z akapitów  http://edu.pjwstk.edu.pl/wyklady/ppj/scb/ObRef/ObRef.html  http://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.1 null  kod źródłowy przykładów użytych w artykule  https://pl.wikipedia.org/wiki/Referencja_%28informatyka%29Zadanie Zadanie będzie nietypowe :) Spróbuj napisać program, który spowoduje przepełnienie sterty i skończy się wyjątkiem java.lang.OutOfMemoryError. Od razu powiem, że dla początkującego programisty nie jest to zadanie proste więc należy Ci się podpowiedź. Jak myślisz jak duża tablica z liczbami typu Long zmieści się w pamięci? Czy jeden wymiar tablicy zapełni pamięć? :) Podsumowanie Bardzo się cieszę, że dotrwałeś do końca :) Mam nadzieję, że artykuł przypadł Ci do gustu. Na koniec mam do Ciebie prośbę - polub nasz profil na facebooku i podziel się artykułem ze znajomymi. Dzięki temu dotrę do większej grupy czytelników a właśnie na tym mi zależy. Jeśli masz jakiekolwiek pytania proszę zadaj je w komentarzach, postaram się pomóc :) Miłego dnia i do następnego razu!             Właściwie to zależy od implementacji maszyny wirtualnej Javy, nie mamy gwarancji, że ten numerek będzie adresem. &#8617;               Nie tylko sterty, wirtualna maszyna Javy alokuje też pamięć w innych celach, na przykład tak zwany “metaspace”, który też jest czyszczony przez GC. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/referencja-sterta-garbage-collector/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/02/04_referencja_sterta_garbage_collector_artykul.jpeg"},{
        "title": "System dwójkowy",
        "excerpt":"Czym różni się cyfra od liczby? Cyfra i liczba to dwie różne rzeczy. Cyfra to reprezentacja graficzna liczby np. znak 9. Cyfra to znak graficzny podobnie jak litera. Liczba to wartość, która może składać się z wielu cyfr. Wyjaśniłem tę różnicę na początku ponieważ przyda się ona do zrozumienia pozostałej części artykułu. Suma i iloczyn Każdy z nas miał to na matematyce, jednak dla przypomnienia wyjaśnię jeszcze i te pojęcia. 1 + 2 = 3. To jest operacja dodawania. Wynikiem operacji dodawania jest suma.2 * 3 = 6. To jest operacja mnożenia. Wynikiem operacji mnożenia jest iloczyn. Pojęcia te można ze sobą łączyć opisując dłuższe równania.1 * 2 + 3 * 4 = 14 można opisać jako sumę iloczynów(1 + 2) * (3 + 4) = 21 można opisać jako iloczyn sum. System dziesiętny 1234, ot zwykła liczba. Liczba zapisana przy pomocy czterech cyfr. Takiej notacji uczyliśmy się od początku naszego życia. W ten sposób liczymy pieniądze, upływające lata czy mierzymy nasz wzrost. A co myślisz o liczbie 10011010010 ;) ? Okazuje się że 10011010010 zapisane binarnie to ta sama liczba co 1234 zapisana w systemie dziesiętnym. Zanim przejdziemy do systemu binarnego omówmy trochę dokładniej system dziesiętny. Będzie tu trochę matematyki, jednak to nic trudnego i zupełnie nie ma się czego bać :).   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Potęgi   100 = 1 (10 do potęgi 0 równa się 1) właściwie to każda liczba większa od zera podniesiona do „zerowej potęgi” równa się 1.  101 = 10  102 = 100  103 = 1000i tak dalej…Teraz zapiszmy trochę inaczej naszą liczbę z przykładu: 1 * 1000 + 2 * 100 + 3 * 10 + 4 * 1 =1 * 103 + 2 * 102 + 3 * 101 + 4 * 100 = 1234Innymi słowy każdą liczbę w systemie dziesiętnym możemy zapisać przy pomocy sumy iloczynów potęg liczby 10. Może się to wydawać trochę skomplikowane jednak to nic trudnego, po prostu słownie opisałem 1 * 103 + 2 * 102 + 3 * 101 + 4 * 100. Jeśli 10 nazwiemy bazą systemu dziesiętnego to cyfry, które służą do zapisywania liczb w tym systemie są z zakresu 0 do 9. Zapamiętaj, że tę własność można uogólnić. Innymi słowy jeśli bazę systemu zapisu liczb zastąpimy X wówczas możemy powiedzieć, że liczbę w tym systemie można zapisać przy pomocy cyfr od 0 do X-11. A co stałoby się gdybyśmy potęgi 10 zamienili potęgami 2? Powstałby system binarny zapisywania liczb :). System binarny, system dwójkowy System binarny jest bardzo podobny do systemu dziesiętnego:   podobnie jak podstawą w systemie dziesiętnym system binarny ma swoją podstawę. W systemie dziesiętnym jest to 10. W systemie binarnym podstawą jest 2,  podobnie jak w systemie dziesiętnym cyframi, które można używać do zapisu liczb są cyfry z zakresu 0 do (podstawa – 1). Więc w systemie dziesiętnym mamy zakres od 0 do 9. W systemie binarnym są to tylko dwie cyfry 0 lub 1,  podobnie jak w systemie dziesiętnym każdą liczbę można wyrazić za pomocą dodawania kolejnych potęg pomnożonych przez liczbę (103 * 1 + 102 * 2 + …), podobnie jest w systemie dwójkowym.Potęgi 2   20 = 1  21 = 2  22 = 4  23 = 8  24 = 16  25 = 32  26 = 64  27 = 128  28 = 256  29 = 512  210 = 1024Więc spróbujmy teraz zapisać naszą przykładową liczbę 1234 w systemie binarnym 1024 + 128 + 64 + 16 + 2 =1 * 210 + 1 * 27 + 1 * 26 + 1 * 24 + 1 * 21 =1 * 210 + 0 * 29 + 0 * 28 + 1 * 27 + 1 * 26 + 0 * 25 +1 * 24 + 0 * 23 + 0 * 22 + 1 * 21 + 0 * 20Mając już zapis liczby jako sumę iloczynów kolejnych potęg możemy spisać kolejne mnożne: 1, 0, 0, 1, 1, 0, 1, 0, 0, 1 i 0. Łącząc je w całość powstaje nam 10011010010 czyli nic innego jak 1234 zapisane w systemie binarnym. Przekształcanie liczby do postaci binarnej Wiesz już czym jest postać binarna. Nadszedł czas na algorytm, który pozwoli Ci przekształcić liczbę dziesiętną w binarną. Zanim do niego przejdziemy musisz wiedzieć czym jest dzielenie całkowitoliczbowe. Wynikiem całkowitoliczbowego dzielenia 5 / 2  jest 2, resztą z tego dzielenia jest 1. Wynikiem całkowitoliczbowego dzielenia 4 / 2 jest 2, reszta z tego dzielenia wynosi 0. Algorytm przekształcenia liczby w postaci dziesiętnej na binarną:   Podzieli liczbę całkowitoliczbowo przez 2. Zapisz resztę z dzielenia jako pierwszą cyfrę w postaci binarnej. Przypisz do liczby wynik z dzielenia,  Jeśli wynik dzielenia jest większy od zera przejdź do pierwszego kroku.Poniżej przekształcenie liczby 21 na postać binarną:   Liczba to 21. 21 / 2 = 10 reszty 1, aktualna postać binarna 1,  10 &gt; 0, idziemy dalej,  Liczba to 10. 10 / 2 = 5 reszty 0, aktualna postać binarna 01,  5 &gt; 0, idziemy dalej,  Liczba to 5. 5 / 2 = 2 reszty 1, aktualna postać binarna 101,  2 &gt; 0, idziemy dalej,  Liczba to 2. 2 / 2 = 1 reszty 0, aktualna postać binarna 0101,  1 &gt; 0, idziemy dalej,  Liczba to 1. 1 / 2 = 0 reszty 1, aktualna postać binarna 10101,  0 &gt; 0 nie jest spełnione. Koniec algorytmu. Postać binarna liczby 21 to 10101Spróbuj napisać program, który realizuje ten algorytm. Możesz sprawdzić poprawność wyniku używając metody Integer.toBinaryString. Polecam napisanie kilku testów jednostkowych, które sprawdzą poprawność Twojego rozwiązania. Dodatkowe materiały do nauki   W komentarzu InfW4 wspomniał o ciekawych źródłach, dzięki za wskazówkę ;) Podobnie jak komentujący miałem przyjemność uczęszczać na kursy prof. Janusza Biernata na Politechnice Wrocławskiej, chociaż artykuł nie powstał w oparciu o materiały z Jego książek jeśli interesuje Cię ta tematyka i chciałbyś spojrzeć na temat z bardziej teoretycznej strony możesz zajrzeć do książki, którą pamiętam ze studiów (ostrzegam, jest mocno teoretyczna): Metody i układy arytmetyki komputerowej - Janusz Biernat. Podsumowanie Teraz, wiedząc już jak działa system binarny wiesz już skąd wzięła się ta ogromna liczba polubień. 10000000 w systemie binarnym to 27 * 1 czyli 128 :) Jak zwykle mam dla Ciebie ćwiczenia na koniec. Spróbuj zapisać liczby 321 i 2048 w systemie binarnym. Jeśli chcesz wyższego poziomu trudności zapisz liczby 1024 i 321 w systemie ósemkowym (w systemie, którego podstawą jest 8). I jak? Trudne? Jeśli masz pytania zadaj je w komentarzach, postaram się pomóc. Bardzo dziękuję Ci za przeczytanie artykułu, jeśli chcesz wiedzieć o najnowszych wpisach polub stronę na Facebooku. Na koniec mam do Ciebie jeszcze jedną prośbę. Zależy mi na tym, żeby dotrzeć do jak największej liczby czytelników więc jeśli mógłbyś polecić blog swoim znajomym byłbym wdzięczny. Z góry dziękuję i do następnego razu! PS. Autorem zdjęcia z tytułem artykułu jest mój kolega Wojtek, inne zdjęcia jego autorstwa możecie zobaczyć na https://www.flickr.com/photos/koniu_87/.             Oczywiście to jest umowne, równie dobrze można używać innych symboli. Np w systemie szesnastkowym stosujemy cyfry 0-9 oraz litery a-f. &#8617;       ","categories": ["Programowanie","Wiedza ogólna"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/system-dwojkowy/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/02/11_system_dwojkowy_artykul.png"},{
        "title": "Konwersja i rzutowanie w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Rzutowanie Zaczniemy od rzutowania (ang. cast). Jak już wiesz kompilator Javy ma pewną wiedzę na temat tego jaki rodzaj obiektu kryje się pod daną referencją w trakcie kompilacji. Wie to z typu zmiennej do której przypisany jest dany obiekt. Jednak możliwa jest sytuacja kiedy pod referencją typu X przypisany jest obiekt typu Y jak w przykładzie poniżej: public void differentTypes() {    Object objectInstance = new Object();    Object stringInstance = \"string\";}Obie referencje są typu Object jednak druga z nich przechowuje zmienną typu String. Jest to w 100% poprawny kod. Jednak jeśli na zmiennej stringInstance chciałbyś wywołać metodę, którą implementuje klasa String a nie ma jej w klasie Object skończy się to błędem kompilacji: Error:(15, 23) java: cannot find symbol  symbol: method length()  location: variable stringInstance of type java.lang.ObjectJak zatem wywołać taką metodę? Przecież jesteśmy pewni, że pod zmienną stringInstance kryje się obiekt typu String. Tutaj z pomocą przychodzi rzutowanie. Java pozwala rzutować typ A na typ B używając wyrażenia rzutowania, możesz je zobaczyć w przykładzie poniżej: public void differentTypes() {    Object objectInstance = new Object();    Object stringInstance = \"string\";    String realString = (String) stringInstance;    realString.length();}Oczywiście nie każde rzutowanie jest poprawne. W przykładzie poniżej możesz zobaczyć błędne rzutowanie z typu Object na typ String. Tego typu operacje kończą się wyjątkiem w trakcie wykonania programu: public class RuntimeType {    public static void main(String[] args) {        Object[] someMysteriousObjects = new Object[] {\"1234\", new Object()};        String castedString = (String) someMysteriousObjects[0];        String classCastException = (String) someMysteriousObjects[1];    }}Exception in thread \"main\" java.lang.ClassCastException: java.lang.Object cannot be cast to java.lang.String  at pl.samouczekprogramisty.kursjava.RuntimeType.main(RuntimeType.java:8)Wyjątek mówi tyle, że obiektu typu java.lang.Object nie możemy rzutować do typu java.lang.String. Jakie rzutowanie jest w takim razie dozwolone? Możemy rzutować wyłącznie na typ, który znajduje się hierarchii dziedziczenia danego obiektu. Z tego właśnie powodu rzutowanie String na Object jest dopuszczalne ale odwrotna operacja kończy się błędem. W jednym z kolejnych artykułów przeczytasz o typach generycznych, które pomagają rozwiązać część sytuacji, kiedy rzutowanie jest potrzebne. W codziennym programowaniu radziłbym unikać tego typu operacji. Z pewnością istnieje inny sposób napisania programu, który pozwoli na uniknięcie rzutowania.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Konwersja Rzutowanie to specyficzny przypadek konwersji, jest to konwersja jawna, wymuszona przez programistę. W trakcie niektórych operacji może dochodzić do automatycznej konwersji, konwersji niejawnej. Konwersja niejawna może wystąpić np. podczas wywołania metod czy operacji arytmetycznych. Poniżej przykład konwersji automatycznej, która zachodzi w trakcie wywołania metody: public class WideningConversion {    public static void main(String[] args) {        WideningConversion conversion = new WideningConversion();        int intVariable = Integer.MAX_VALUE;        long longVariable = Long.MAX_VALUE;        conversion.methodLongArgument(longVariable);        conversion.methodLongArgument(intVariable); // extending conversion    }    public void methodLongArgument(long argument) {        System.out.println(argument);    }}Dochodzi do konwersji ponieważ metoda methodLongArgument przyjmuje parametr typu long, a jedno z wywołań przyjmuje zmienną typu int. Jest to tak zwana konwersja rozszerzająca. Może być wykonana niejawnie ponieważ podczas takiej konwersji nie zachodzi ryzyko utracenia informacji (o tym dalej). Kompilator robi to automatycznie za programistę. W przykładzie powyżej zmienna intVariable zostałą automatycznie rozszerzone do typu long. Nie utraciliśmy żadnych informacji ponieważ typ long zawsze może pomieścić liczby które przechowuje int. W przykładzie używam zmiennych statycznych MAX_VALUE, które są typu int lub long i trzymają największą liczbę możliwą do przechowywania przez dany typ. Konwersja w odwrotną stronę wymaga już jawnego rzutowania. Taka konwersja może prowadzić do utraty informacji. Proszę spójrz na przykład: public class NarrowingConversion {    public static void main(String[] args) {        NarrowingConversion conversion = new NarrowingConversion();        int intVariable = Integer.MAX_VALUE;        long longVariable = Long.MAX_VALUE;        long longVariableWithoutLoosingInformation = Integer.MAX_VALUE; // automatic conversion from int to long        conversion.methodIntArgument(intVariable);        conversion.methodIntArgument((int) longVariable);        conversion.methodIntArgument((int) longVariableWithoutLoosingInformation);    }    public void methodIntArgument(int argument) {        System.out.println(argument);    }}Jak myślisz co zostanie wypisane na konsoli po uruchomieniu tego programu? 2147483647-12147483647Dziwne prawda? :) Środkowa linijka to nic innego jak właśnie “utrata informacji”, która może zajść w trakcie jawnej konwersji1. Ostatnia linijka pokazuje, że nie każda konwersja z long do int prowadzi do utraty informacji. Konwersja typów zmiennoprzecinkowych do całkowitoliczbowych Innym przykładem konwersji w której dochodzi do utraty informacji jest konwersja z typów zmiennoprzecinkowych do typów całkowitoliczbowych: int intValue = (int) 123.123F;long longValue = (long) 456.456;W obu przypadkach tracimy informację o ułamku, zostaje wyłącznie część całkowitoliczbowa. Automatyczna konwersja podczas przypisania Podobnie rzecz się ma w przypadku przypisania wartości zmiennej, tutaj także dochodzi do automatycznej konwersji. Poniższy przykład pokazuje kilka możliwych przypadków: public class AssignmentConversion {    public static void main(String[] args) {        long longValue = 123;        int intValue = (short) 123;        float floatValue = 12.12F;        double doubleValue = floatValue;        System.out.println(longValue);        System.out.println(intValue);        System.out.println(floatValue);        System.out.println(doubleValue);    }}Pierwsza linijka metody main to niejawna konwersja z typu int na long (literały całkowitoliczbowe domyślnie są typu int), kolejna zawiera jawne rzutowanie 123 na typ short, które następnie konwertowane jest niejawnie z powrotem na typ int. Ostatni przykład to konwersja z typu float do double. Automatyczna konwersja podczas operacji arytmetycznych Podczas operacji arytmetycznych także może dochodzić do niejawnej konwersji. Zgodnie ze specyfikacją języka Java (https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html#jls-5.6.2) możliwa jest konwersja (zachodzi pierwszy pasujący warunek):   rozszerzająca do typu double jeśli którykolwiek z elementów operacji arytmetycznej jest typu double,  rozszerzająca do typu float jeśli którykolwiek z elementów operacji jest typu float,  rozszerzająca to typu long jeśli którykolwiek z elementów operacji jest typu long,  rozszerzająca do typu int.Wszystkie cztery przypadki pokazane są w przykładzie poniżej: public class ArithmeticConversion {    public static void main(String[] args) {        short shortValue = 1;        int intValue = 1;        long longValue = 2;        float floatValue = 3.1F;        double doubleValue = 4.1;        System.out.println(intValue + doubleValue);        System.out.println(intValue + floatValue);        System.out.println(intValue + longValue);        System.out.println(shortValue + shortValue);    }}Tutaj drobna dygresja, operator dzielenia (/) wykonuje w języku Java dzielenie całkowitoliczbowe jeśli dzielna i dzielnik są całkowitoliczbowe. Jeśli chcemy otrzymać typ zmiennoprzecinkowy co najmniej jeden z elementów musi być typu zmiennoprzecinkowego: 5 / 2 = 25.0 / 2 = 2.55 / 2.0 = 2.56 / 2 = 36.0 / 2 = 3.0Boxing i unboxing Jak wiesz w języku Java występują zarówno typy proste jak i obiekty reprezentujące liczby np. int i Integer. Kompilator Java jest w stanie dokonać konwersji pomiędzy odpowiadającymi sobie typami prostymi i obiektami automatycznie. Proszę spójrz na przykład poniżej int primitiveInt = new Integer(123);long primitiveLong = new Long(123L);float primitiveFloat = new Float(123.123F);double primitiveDouble = new Double(123.123);boolean primitiveBoolean = new Boolean(true);Mamy tu do czynienia z tak zwanym “unboxing‘iem”, czyli automatycznym odpakowywaniem obiektu do odpowiadającego mu typu prostego. Integer objectInteger = 123;Long objectLong = 123L;Float objectFloat = 123.123F;Double objectDouble = 123.123;Boolean objectBoolean = true;Przykłady powyżej pokazują z kolei “boxing”, czyli automatyczne tworzenie instancji obiektów na podstawie typów prostych. Podczas boxingu/unboxingu może dość do rzucenia różnych wyjątków, na przykład gdy obiekt przypisywany do typu prostego jest nullem lub gdy do typu prostego próbujemy przypisać inny obiekt (np. Long do int). Konwersja do typu String Konwersja do typu String jest specyficznym rodzajem konwersji automatycznej. Jest ona specyficzna ponieważ bazuje na metodzie toString, która może być przedefiniowana przez programistę. Konwersja do typu String zachodzi przy operatorze dodawania + jeśli któryś z dodawanych elementów jest typu String. Typy proste także są automatycznie konwertowane do typu String, odbywa się to dwuetapowo, na początku zachodzi boxing następne obiekt konwertowany jest do typu String (wywoływana jest metoda toString). String x = \"123\" + new Object();String y = new Object() + \"123\";String z = 1 + \"123\";Zadania   Napisz program przyjmujący od użytkownika liczbę całkowitą i wyświetl wynik mnożenia tej liczby oraz stałej pi (Math.PI). Wyświetl wynik w postaci liczby całkowitej i liczby zmiennoprzecinkowej.  Napisz program pobierający od użytkownika dwie liczby całkowite. Wyświetl wynik ich dzielenia wraz z częścią ułamkową.  Napisz program, który skończy się wyjątkiem spowodowanym błędem podczas boxingu/unboxingu.  Jak myślisz co otrzymasz przypisując zmienną typu char do zmiennej typu int? Znajdziesz ten numer w tabeli ASCII?Przygotowałem też dla Ciebie zestaw przykładowych rozwiązań zadań, analizując je także możesz się czegoś nauczyć. Dodatkowe materiały do nauki   https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.16 – “cast expression”,  https://docs.oracle.com/javase/specs/jls/se7/html/jls-5.html – rzutowanie i konwersje,  https://github.com/SamouczekProgramisty/KursJava/tree/master/11_konwersja_rzutowanie – kod źródłowy przykładów użytych w artykule.Podsumowanie Właśnie dowiedziałeś się o kilku kolejnych zakamarkach języka Java. Mam nadzieję, że Ci się podobało. Jak zwykle na koniec mam do Ciebie prośbę, podziel się artykułem ze swoimi znajomymi, zleży mi na dotarciu do jak największego grona czytelników. Jeśli nie chcesz pominąć żadnego postu polub Samouczka na facebooku. Do następnego razu! :)             Wartość -1 wynika ze sposobu zapisywania liczb w Javie. Wiesz już o binarnym zapisie, tutaj wykorzystywana jest jego specyficzna odmiana – uzupełnienia do dwóch, jeżeli jesteś zainteresowany szczegółami daj znać w komentarzu, skrobnę o tym artykuł :). &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/konwersja-i-rzutowanie-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/02/17_konwersja_i_rzutowanie_artykul.jpeg"},{
        "title": "Zestaw ćwiczeń dla początkujących programistów",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Do rozwiązania zadań niezbędna będzie wiedza, którą możesz zdobyć czytając dotychczasowe artykuły. Jednak znajdą się też zadania, które będą wymagały dodatkowej lektury dokumentacji standardowej biblioteki Javy czy stron na Wikipedii. Aby wykonać te zadania musisz mieć wiedzę opisaną w artykułach w serii kurs programowania java do artukułu o interfejsach włącznie. Całość podzielona jest na części. Odpowiadają one artykułom, które do tej pory miałeś okazję przeczytać. Polecam robienie ich w kolejności – na przykład ciężko będzie Ci zrobić zadania związane z pętlami bez znajomości tablic. Zadania starałem się zorganizować w ten sposób aby kolejne bazowały na stworzonych już metodach/obiektach. W codziennym programowaniu właśnie tak to wygląda, budujemy małe klocki, z których można złożyć większą całość. To też będziesz mógł przećwiczyć rozwiązując poniższe zadania. Operator % Do tej pory nie opisałem jeszcze jednego dość przydatnego operatora w języku Java. Mianowicie %. Operator % zwraca resztę z dzielenia liczb. Najłatwiej będzie to zrozumieć na przykładzie 4 % 3 == 1; // bo 3 mieści się raz w 4 i zostaje 1 reszty8 % 3 == 2; // bo 3 mieści się dwa razy w 8 i zostaje 2 reszty3 % 4 == 3; // bo 4 nie mieści się w 3 i zostaje 3 reszty15 % 5 == 0; // bo 5 mieści się trzy razy w 15 i zostaje 0 resztyJeśli chcielibyśmy zapisać działanie tego operatora przy pomocy równania matematycznego moglibyśmy użyć następującego wzoru: (a / b) * b + (a % b) == aOperator ten może się przydać na przykład do sprawdzenia czy liczba jest parzysta. Liczbę uważamy za parzystą jeśli jest podzielna przez 2 bez reszty boolean isEven = someNumber % 2 == 0;  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Zadania Metody w języku Java   Napisz metodę, która zwróci Twój aktualny wiek.  Napisz metodę, która zwróci Twoje imię,  Napisz metodę, która jako argument przyjmuje 2 liczby i wypisuje ich sumę, różnicę i iloczyn,  Napisz metodę, która jako argument przyjmuje liczbę i zwraca true jeśli liczba jest parzysta,  Napisz metodę, która jako argument przyjmuje liczbę i zwraca true jeśli metoda jest podzielna przez 3 i przez 5,  Napisz metodę, która jako argument przyjmuje liczbę i zwraca go podniesionego do 3 potęgi,  Napisz metodę, która jako argument przyjmuje liczbę i zwraca jej pierwiastek kwadratowy (poczytaj javadoc do klasy Math, znajdziesz tam metodę, która na pewno Ci pomoże),  Napisz metodę, która jako argument przyjmie trzy liczby. Metoda powinna zwrócić true jeśli z odcinków o długości przekazanych w argumentach można zbudować trójkąt prostokątny.Obiekty i pakiety   Utwórz klasę Human reprezentującą człowieka, musi posiadać atrybuty takie jak wiek, waga, wzrost, imię i płeć. Klasa powinna także zawierać metody getAge, getWeight, getHeight, getName, isMale.  Utwórz klasę reprezentującą prostokąt, musi posiadać atrybuty długość i szerokość. Klasa powinna posiadać metody obliczające pole, obwód i długość przekątnej.  Utwórz klasę o nazwie MyNumber, której jedyny konstruktor przyjmuje liczbę. Klasa powinna mieć następujące metody  MyNumber isOdd() - true jeśli atrybut jest nieparzysty,  MyNumber isEven() - true jeśli atrybut jest parzysty,  MyNumber sqrt() - pierwiastek z atrybutu,  MyNumber pow(MyNumber x) - atrybut podniesiony do potęgi x (przydatnej metody poszukaj w javadoc do klasy Math),  MyNumber add(MyNumber x) - zwraca sumę atrybutu i x opakowaną w klasę MyNumber,  MyNumber subtract(MyNumber x) - zwraca różnicę atrybutu i x opakowaną w klasę MyNumber.A teraz ciekawostka, jeśli rozwiązałeś zadanie 3. to muszę Ci zdradzić, że podobna klasa istnieje w standardowej bibliotece języka Java. Jest to klasa BigInteger/BigDecimal. Oczywiście jej możliwości są dużo bardziej rozbudowane, jednak zasada działania jest podobna. Tablice   Napisz metodę, która zwróci tablicę String[] zawierającą pierwsze 5 liter alfabetu,  Napisz metodę pobierającą trójelementową tablicę liczb, która zwróci tablicę zawierającą te same elementy w odwróconej kolejnościDużo zadań dotyczących tablic wymaga znajmości pętli, dlatego w następnym akapicie znajdziesz więcej interesujących zadań związanych z tablicami. Pętle i instrukcje warunkowe   Utwórz metodę pobierającą dodatnią liczbę całkowitą X, która wyświetli na ekranie liczby od zera do X,  Jeśli w zadaniu 1. użyłeś pętli for przerób tę metodę na while (lub odwrotnie),  Napisz klasę ArrayFactory, która w konstruktorze pobierze liczbę całkowitą X większą od zera. Klasa powinna mieć 2 metody:  int[] oneDimension - zwróci instancję tablicy jednowymiarowej o długości X,      int[][] twoDimension - zwróci instację tablicy dwuwymiarowej gdzie liczba wierszy i liczba kolumn równa się X,     Utwórz metodę, która pobierze liczbę i wypisze każdy znak w osobnej linii zaczynając od ostatniej cyfry (np. dla liczby 123 będą to trzy linie z 3, 2 i 1),  Utwórz metodę, która jako argument pobierze obiekt klasy String i zwróci “odwrócony” argument. Na przykład “pies” przekształci w “seip”,  Utwórz metodę, która pobierze liczbę oraz zwróci ją w formie binarnej (2 =&gt; “10”, 4 =&gt; “100”, 5 =&gt; “101”, itd.). System binarny opisałem w osobnym artykule,  Utwórz metodę, pobierającą łańcuch znaków, która sprawdzi czy jest on palindromem. Np. “kajak” jest palindromem (to samo czytane “od przodu i od tyłu”) jednak “kotek” już nie. Może przydać Ci się metoda String#toCharArray  Do klasy ArrayFactory dodaj metodę zwracającą macierz jednostkową (jedynki “na przekątnej”),  Napisz metodę, która pobierze tablicę liczb całkowitych i wyświetli ją w postaci “[liczba, liczba, liczba]”,  Napisz metodę, która pobierze tablicę liczb całkowitych i posortuje ją w kolejności od najmniejszej do największej liczby. Jednym z podstawowych algorytmów sortowania jest sortowanie bąbelkowe.Chociaż zadania wymagają wiedzy z zakresu podstaw języka Java nie są bardzo łatwe. Na pewno ciekawostką dla Ciebie będzie to, że na przykład zadanie z palindromem czasami trafia się na rozmowach rekrutacyjnych :) Typy proste W tej sekcji znajdują się głównie zadania, które wymagają znajomości klasy Scanner opisanej w artykule dotyczącym typów prostych.   Jeśli w klasie Human użyłeś typów prostych zamień je na odpowiadające im klasy (int =&gt; Integer),  Napisz program, który pobierze od użytkownika liczbę całkowitą, a następnie wyświetli jej binarną reprezentację na ekranie,  Napisz program, który pobierze od użytkownika liczbę całkowitą N reprezentującą długość tablicy, a następnie poprosi o N kolejnych liczb uzupełniając nimi wcześniej stworzoną tablicę. Wyświetl na konsoli tablicę posortowaną w kolejności od najmniejszej do największej liczby,  Napisz program, który pobierze od użytkownika łańcuch znaków i wyświetli na konsoli jego długość, informację czy jest to palindrom czy nie oraz jego odwróconą wartość.Interfejsy   Stwórz interfejs Figure. Interfejs powinien zawierać metody getPerimeter (zwracającą obwód) oraz getArea (zwracającą powierzchnię). Następnie utwórz klasy Circle, Triangle i Rectangle, niech każda z klas implementuje interfejs Figure. Napisz program, który pobierze od użytkownika:  długość promienia koła,  2 długości boków trójkąta prostokątnego (boki przy kącie prostym),  długość boków prostokąta.Utworzy instancje tych obiektów i umieści je w tablicy Figure[]. Następnie iterując po obiektach wyświetl pole oraz obwód aktualnego obiektu. Rozwiązania zadań Starałem się nie korzystać z bibliotek/API, którego jeszcze nie poznaliśmy w ramach kursu. Używając bardziej zaawansowanych metod niektóre z przedstawionych tu zadań można rozwiązać lepiej, jednak na początek takie proste podejście w zupełności wystarczy. Prosiłbym Cię żebyś jednak spróbował rozwiązać zadania samodzielnie, dopiero jeśli nie będzie już innego wyjścia rzuć okiem na przykładowe rozwiązania. Rozwiązania, które dostarczyłem nie są jedynymi możliwymi rozwiązaniami, Ty mogłeś rozwiązać dany problem zupełnie inaczej. Podsumowanie Mam nadzieję, że zestaw zadań Ci się spodobał. Raz jeszcze prosiłbym Cię, żebyś rozwiązał je samodzielnie, wtedy nauczysz się najwięcej. Jeśli chciałbyś abym napisał kolejny artykuł tego typu daj znać ;) Jeśli będziesz miał problem z którymkolwiek z nich możesz rzucić okiem do gotowych rozwiązań. Jeśli nie chcesz pominąć żadnego z kolejnych artykułów proszę polub naszą stronę na facebooku. Proszę Cię też abyś udostępnił ten artykuł innym Twoim znajomym, którzy mogą być zainteresowani – niezmiennie zależy mi na dotarciu do jak największej liczby czytelników. Do następnego razu! :) ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/zestaw-cwiczen-dla-poczatkujacych-programistow/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/03/13_dodatkowe_zadania_artykul.jpg"},{
        "title": "Typy generyczne w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Czym są typy generyczne W uproszczeniu można powiedzieć, że typy generyczne są “szablonami”. Dzięki typom generycznym możemy uniknąć niepotrzebnego rzutowania. Ponadto przy ich pomocy kompilator jest w stanie sprawdzić poprawność typów na etapie kompilacji, oznacza to więcej błędów wykrytych w jej trakcie1. Poza tym dzięki typom generycznym możemy konstruować bardziej złożone klasy, które możemy używać w wielu kontekstach, łatwiej będzie Ci to zrozumieć na przykładzie. Porównanie typów generycznych i standardowych Znasz już zwykłe klasy i interfejsy, zostały one omówione we wcześniejszych artykułach. Klasy mają swoje atrybuty, których typy znasz pisząc program. public class Apple {}public class AppleBox {    private Apple apple;    public AppleBox(Apple apple) {        this.apple = apple;    }    public Apple getApple() {        return apple;    }}W przykładzie powyżej klasa AppleBox “wie” jakiego typu obiekt może przechowywać, jest to obiekt typu Apple. A co jeśli chcielibyśmy zrobić analogiczną klasę dla owoców innego rodzaju? Oczywiście możemy stworzyć podobne pudełko jak w przykładzie poniżej: public class Orange {}public class OrangeBox {    private Orange orange;    public OrangeBox(Orange orange) {        this.orange = orange;    }    public Orange getOrange() {        return orange;    }}Oba przykłady są jak najbardziej poprawne jednak występuje w nich duplikacja. Te same elementy, konstrukcje powielane są wielokrotnie. Duplikacja w kodzie generalnie jest złą praktyką, należy jej unikać. Możemy zatem stworzyć kolejną klasę: public class FruitBox {    private Object fruit;    public FruitBox(Object fruit) {        this.fruit = fruit;    }    public Object getFruit() {        return fruit;    }}public class Main {    public static void main(String[] args) {        FruitBox fruitBox = new FruitBox(new Orange());        Orange fruit1 = (Orange) fruitBox.getFruit();    }}Z racji tego, że atrybut fruit jest typu Object możemy do niego przypisać zarówno instancję klasy Orange jak i Apple. Pojawia się jednak pewien problem. Mianowicie jeśli chcemy pobrać atrybut fruit i przypisać go do zmiennej odpowiedniego typu musimy rzutować. Tego typu konstrukcja może powodować błędy podczas wykonania programu i warto jej unikać. Z pomocą przychodzą typy generyczne. Proszę spójrz na przykład poniżej. public class BoxOnSteroids&lt;T&gt; {    public T fruit;    public BoxOnSteroids(T fruit) {        this.fruit = fruit;    }    public T getFruit() {        return fruit;    }}public class Main {    public static void main(String[] args) {        BoxOnSteroids&lt;Apple&gt; appleBox = new BoxOnSteroids&lt;Apple&gt;(new Apple());        BoxOnSteroids&lt;Orange&gt; orangeBox = new BoxOnSteroids&lt;Orange&gt;(new Orange());        Orange fruit = orangeBox.getFruit();    }}public class BoxOnSteroids&lt;T&gt; to nic innego jak pierwsza linijka definicji klasy. Nowa tutaj jest konstrukcja z nawiasami. Oznacza ona właśnie typ generyczny, który możemy parametryzować innym typem. Typ ten dostaje tymczasową nazwę, w tym przypadku T, której używamy dalej w ciele klasy. W trakcie tworzenia instancji obiektu BoxOnSteroids podajemy informację o typie, który chcielibyśmy wstawić w miejsce T. W naszym przykładzie są to klasy Apple lub Orange. Dzięki takiej konstrukcji kompilator dokładnie wie jakiego typu obiekt zostanie zwrócony przez metodę getFruit w związku z tym rzutowanie nie jest konieczne2.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Klasy generyczne i parametryzowanie Wspomniałem wcześniej, że klasy generyczne są szablonami dla nowych klas. W uproszczeniu można powiedzieć, że parametry klasy generycznej są elementami uzupełnianymi w szablonie. Spróbuję opisać to bardziej obrazowo. Szablon to foremka do wycinania ciastek. Tej foremki możemy użyć do wycięcia wielu ciastek. Każde z nich możemy ozdobić w inny sposób. To w jaki sposób ciastko jest ozdobione jest parametrem tego szablonu: public class CookieCutter&lt;T&gt; {    private T glaze;}Definicja klasy generycznej Klasę generyczną definiujemy w następujący sposób class Name&lt;T1, T2, ..., Tn&gt; {    /* body */}Zauważ, że w nawiasach &lt;&gt; możemy umieścić więcej niż jeden parametr. Chociaż zgodnie ze specyfikacją języka Java możesz użyć dowolnej nazwy która nadaje się na nazwę zmiennej istnieje konwencja nazewnicza sugerująca nazwy parametrów. Zwyczajowo do tego celu używa się wielkich liter T, K, U, V, E. W miejsce parametrów możemy wstawić dowolny obiekt, nie może to jednak być typ prosty. Innymi słowy Integer jest w porządku, int powoduje błąd. Instancja klasy generycznej Skoro już wiemy jak zdefiniować klasę generyczną przydałoby się stworzyć jej instancję, żeby w końcu jej użyć :). Linijka poniżej tworzy instancję klasy generycznej BoxOnSteroids, która parametryzowana jest typem Orange. BoxOnSteroids&lt;Orange&gt; orangeBox = new BoxOnSteroids&lt;Orange&gt;(new Orange());Zauważ, że i tutaj występuje pewna duplikacja. Zarówno przy określaniu typu zmiennej jak i przy wywołaniu konstruktora powtarzamy klasę Orange. Nie jest to konieczne. Jeśli kompilator jest w stanie “wywnioskować” jaki typ powinien być użyty możemy go pominąć przy konstruktorze. BoxOnSteroids&lt;Orange&gt; orangeBox = new BoxOnSteroids&lt;&gt;(new Orange());Zagnieżdżone typy generyczne Możesz też tworzyć instancje typów generycznych, które są bardziej skomplikowane. Przykład poniżej pokazuje klasę Pair, która parametryzowana jest dwoma innymi typami. public class Pair&lt;T, S&gt; {    private T first;    private S second;    public Pair(T first, S second) {        this.first = first;        this.second = second;    }    public T getFirst() {        return first;    }    public S getSecond() {        return second;    }}Java pozwala na to aby tworząc instancję typu generycznego parametryzować go innym typem generycznym. Brzmi to skomplikowanie, mam nadzieję, że przykład pomoże Ci to zrozumieć: Pair&lt;BoxOnSteroids&lt;Orange&gt;, BoxOnSteroids&lt;Apple&gt;&gt; pairOfBoxes =        new Pair&lt;&gt;(                new BoxOnSteroids&lt;&gt;(new Orange()),                new BoxOnSteroids&lt;&gt;(new Apple())        );W przykładzie tym tworzony jest obiekt klasy Pair, który parametryzowany jest klasami BoxOnSteroids&lt;Orange&gt; i BoxOnSteroids&lt;Apple&gt;. Typy generyczne nie rozwiązują wszystkich problemów Typy generyczne zostały wprowadzone w wersji Javy 1.5. Nie były dostępne od początku jej istnienia. Zatem istnieją sytuacje, w których nawet ich stosowanie może prowadzić do wystąpienia błędów w trakcie wykonywania programu. Proszę spójrz na przykład poniżej: BoxOnSteroids boxWithoutType = new BoxOnSteroids(new Apple());BoxOnSteroids&lt;Apple&gt; boxWithApple = boxWithoutType;BoxOnSteroids&lt;Orange&gt; boxWithOrange = boxWithoutType;Apple apple = boxWithApple.getFruit();Orange orange = boxWithOrange.getFruit(); // ClassCastExceptionW przykładzie tym tworzona jest instancja klasy generycznej BoxOnSteroids bez wyspecyfikowania klasy, która znajduje się “w środku”. Następnie tę instancję przypisujemy do zmiennych typu BoxOnSteroids&lt;Apple&gt; i BoxOnSteroids&lt;Orange&gt;. O ile w pierwszym przypadku typ owocu trzymanego w środku się zgadza to ostatnia linia nie jest poprawna – generuje błąd typu ClassCastException. Obiekt typu Apple jest rzutowany przez kompilator do typu Orange3. Słowo kluczowe extends To słowo kluczowe ma zastosowanie także w przypadku typów generycznych. Dzięki niemu możemy ograniczyć zestaw klas którymi możemy parametryzować nasz typ generyczny. Omówmy to na przykładzie: public interface Figure {    String getName();}public class Circle implements Figure {    public String getName() {        return \"circle\";    }}public class BoxForFigures&lt;T extends Figure&gt; {    private T element;    public BoxForFigures(T element) {        this.element = element;    }    public T getElement() {        return element;    }    public String getElementName() {        return element.getName();    }}BoxForFigures&lt;Circle&gt; circleBox = new BoxForFigures&lt;&gt;(new Circle());BoxForFigures&lt;Apple&gt; appleBox; // complilation errorJak widzisz przykład definiuje prosty interfejs Figure i klasę Circle, która go implementuje. Następnie definiujemy klasę BoxForFigures, która jest generyczna i może być parametryzowana przez typy dziedziczące/implementujące Figure. Dzięki takiemu zapisowi kompilator pozwoli nam stworzyć instancję BoxForFigures&lt;Circle&gt; circleBox jednak zacznie się buntować przy BoxForFigures&lt;Apple&gt; appleBox (Apple nie implementuje interfejsu Figure). Kolejną zaletą używania tego słowa kluczowego jest możliwość wywoływania metod na obiekcie typu parametryzowanego. W przykładzie powyżej wiemy że T jest czymś co implementuje Figure więc musi mieć metody dostępne w tym interfejsie. Właśnie z tego powodu w metodzie getElementName możemy wywołać metodę getName z tego interfejsu. Dziedziczenie typów generycznych Tutaj należy się dodatkowe zdanie wyjaśnienia poparte prostym przykładem. Proszę spójrz na początek na klasy Rectangle i Square poniżej: public class Rectangle implements Figure {    public String getName() {        return \"rectangle\";    }}public class Square extends Rectangle {    public String getName() {        return \"square\";    }}Jak wiesz każda klasa w języku Java dziedziczy po klasie Object (bezpośrednio, bądź pośrednio). W naszym przykładzie bezpośrednio po klasie Object dziedziczą klasy Rectangle, BoxForFigures&lt;Rectangle&gt; i BoxForFigures&lt;Square&gt;4. Natomiast Square dziedziczy po Rectangle.         Dziedziczenie typów generycznych.  Ma to swoje konsekwencje widoczne w przykładzie poniżej: Rectangle rectangle = new Square();BoxForFigures&lt;Rectangle&gt; rectangleBox = new BoxForFigures&lt;Square&gt;(new Square()); // compilation errorDzięki takiemu schematowi dziedziczenia do referencji typu Rectangle możemy przypisać obiekt Square. Jednak próba przypisania obiektu BoxForFigures&lt;Square&gt; do referencji BoxForFigures&lt;Rectangle&gt; powoduje błąd kompilacji. Jednak podobnie jak w przypadku zwykłych klas, klasy generyczne także mogą dziedziczyć po innych klasach. W szczególności mogą także dziedziczyć po klasach generycznych. class StandardBox&lt;T&gt; {    public T object;    public StandardBox(T object) {        this.object = object;    }}public class FancyBox&lt;T&gt; extends StandardBox&lt;T&gt; {    public FancyBox(T object) {        super(object);    }    public void saySomethingFancy() {        System.out.println(\"our \" + object + \" is cool!\");    }}public class Main {    public static void main(String[] args) {        FancyBox&lt;String&gt; box = new FancyBox&lt;&gt;(\"something\");        box.saySomethingFancy();    }}W naszym przykładzie klasa FancyBox dziedziczy po StandardBox, widoczne jest to na diagramie poniżej.         Dziedziczenie typów generycznych  Metody z generycznymi argumentami – wildcard FancyBox&lt;?&gt; Pisząc metody, które jako argumenty przyjmują typy generyczne nie zawsze chcesz dokładnie specyfikować typ. W takim wypadku z pomocą przychodzi znak ?, który może akceptować różne typy. private static void method1(FancyBox&lt;?&gt; box) {    Object object = box.object;    System.out.println(object);}private static void plainWildcard() {    method1(new FancyBox&lt;&gt;(new Object()));    method1(new FancyBox&lt;&gt;(new Square()));    method1(new FancyBox&lt;&gt;(new Apple()));}Jak widzisz w przykładzie powyżej metoda method1 może akceptować różne klasę FancyBox parametryzowaną dowolnym typem. Przypisanie wartości Ma to jednak swoje konsekwencje. Klasa, która parametryzowana jest ? nie przyjmie żadnych obiektów poza null. Przykład poniżej zakończy się błędem kompilacji: FancyBox&lt;?&gt; box = new FancyBox&lt;&gt;(\"object\");box.object = null;// box.object = \"xxx\"; // compilation errorFancyBox&lt;? extends Figure&gt; “upper bound” Znak ? może występować także w połączeniu ze słówkiem kluczowym extends. W takim przypadku możesz ograniczyć akceptowane typy “z góry”. W przykładzie poniżej metoda akceptuje jedynie instancje FancyBox, które parametryzowane są klasami dziedziczącymi po Figure. private static void method2(FancyBox&lt;? extends Figure&gt; box) {    Figure figure = box.object;    System.out.println(figure);}private static void method3(FancyBox&lt;Figure&gt; box) {    Figure figure = box.object;    System.out.println(figure);}private static void upperBoundWildcard() {    FancyBox&lt;Figure&gt; fancyFigureBox = new FancyBox&lt;&gt;(new Circle());    FancyBox&lt;Circle&gt; fancyCircleBox = new FancyBox&lt;&gt;(new Circle());    FancyBox&lt;Square&gt; fancySquareBox = new FancyBox&lt;&gt;(new Square());    method2(fancyFigureBox);    method2(fancyCircleBox);    method2(fancySquareBox);    // method3(fancySquareBox); // compilation error}W przykładzie tym możesz także zobaczyć, że typ FancyBox&lt;Figure&gt; jest bardziej restrykcyjny niż FancyBox&lt;? extends Figure&gt;. W konsekwencji próba wywołania method3 z argumentem innego typu niż FancyBox&lt;Figure&gt; skutkuje błędem kompilacji. Przypisanie wartości Podobnie jak w przypadku ? tutaj także są ograniczenia dotyczące przypisywania wartości. Spójrz jeszcze raz na przykład: private static void method2(FancyBox&lt;? extends Figure&gt; box) {    Figure figure = box.object;    System.out.println(figure);    // box.object = null;    // box.object = new Square(); // compilation error}Skoro wewnątrz metody parametr box może mieć zarówno typ FancyBox&lt;Square&gt; jak i FancyBox&lt;Circle&gt; (jak i wiele innych) kompilator nie może pozwolić na wstawienie tam obiektu innego niż null. Nie może tego zrobić bo nie wie jakiego typu obiekty przechowywane są w box. FancyBox&lt;? super Rectangle&gt; “lower bound” Poza ograniczeniem “z góry” możesz także ograniczyć akceptowalne typy “z dołu”. W przykładzie poniżej metoda akceptuje wyłącznie argumenty typu FancyBox&lt;Object&gt;, FancyBox&lt;Figure&gt; i FancyBox&lt;Rectangle&gt;. private static void method4(FancyBox&lt;? super Rectangle&gt; box) {    box.object = new Square();    // box.object = new Circle(); // compilation error}private static void lowerBoundWildcard() {    FancyBox&lt;Rectangle&gt; fancyRectangleBox = new FancyBox&lt;&gt;(new Rectangle());    FancyBox&lt;Figure&gt; fancyFiguraBox = new FancyBox&lt;&gt;(new Rectangle());    FancyBox&lt;Object&gt; fancyObjectBox = new FancyBox&lt;&gt;(new Object());    method4(fancyRectangleBox);    method4(fancyFiguraBox);    method4(fancyObjectBox);    // FancyBox&lt;Square&gt; fancySquareBox = new FancyBox&lt;&gt;(new Square());    // method4(fancySquareBox); // compilation error}Zauważ, ze w niektórych miejscach nie ma potrzeby podawania typu generycznego. Samo &lt;&gt; wystarczy, kompilator jest w stanie wywnioskować jakiego typu może się tam spodziewać. Typy generyczne są skomplikowane. Jeśli aktualnie masz mętlik w głowie nie przejmuj się, przeczytaj artykuł jeszcze raz, przejrzyj przykłady. Zrozumienie przyjdzie z doświadczeniem. Przypisanie wartości Wyżej wspomniałem, że przy ograniczeniu z dołu kompilator wie czego może się spodziewać. W przykładzie: private static void method4(FancyBox&lt;? super Rectangle&gt; box) {    box.object = null;    box.object = new Rectangle();    box.object = new Square();    // box.object = new Object(); // compilation error}Parametr box może być typu FancyBox&lt;Object&gt;, FancyBox&lt;Square&gt; i FancyBox&lt;Rectangle&gt;. Zatem w tym przypadku do pola box.object można przypisać null i każdy obiekt, który dziedziczy po Rectangle. Typy generyczne są skomplikowane Nie zostały one dodane do Javy od samego początku. W związku z tym, że twórcy chcieli zachować kompatybilność wstecz5 istnieje wiele kruczków, które nie są trywialne. Pominąłem w artykule np. “type erasure” czy generyczne metody, które nie są istotne na początku. Jeśli jesteś nimi zainteresowany odsyłam do materiałów dodatkowych. Materiały dodatkowe Wszystkie przykłady użyte w tym artykule dostępne są na githubie. Poniżej zebrałem dla Ciebie zestaw dodatkowy materiałów, jeśli chciałbyś poszerzyć swoją wiedzę na temat typów generycznych w języku Java.   https://docs.oracle.com/javase/tutorial/java/generics/index.html  https://docs.oracle.com/javase/tutorial/extra/generics/index.html  https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.5  https://pl.wikipedia.org/wiki/Programowanie_uog%C3%B3lnionePodsumowanie Nie jest to oczywiście kompletny artykuł dotyczący typów generycznych w Javie. Pominięte zostały aspekty wymazywania typów czy bardziej szczegółowe informacje dotyczące użycia ?. Jeśli któryś fragment jest dla Ciebie nie do końca zrozumiały daj znać, postaram się rozszerzyć artykuł o dodatkowe przykłady i opisy. Na koniec mam do Ciebie prośbę. Proszę podziel się artykułem ze swoimi znajomymi, którzy mogą być zainteresowani tematem programowania. Zależy mi na dotarciu do jak największej liczby czytelników. Jeśli nie chcesz ominąć żadnego kolejnego artykułu polub nas na Facebooku :) Do następnego razu!             Mała dygresja. Każdy błąd w kodzie kosztuje. Ktoś w końcu płaci za pracę testerów, programistów, administratorów. Im wcześniej wykryjemy błąd tym tańsze jest jego naprawienie. Poprawienie programu działającego na środowisku produkcyjnym może być bardzo drogie. Wykrywanie błędów w trakcie kompilacji, chociaż może być frustrujące dla programisty jest najtańszym rozwiązaniem :) &#8617;               W praktyce rzutowanie tam występuje jednak jest wykonywane automatycznie przez kompilator generujący bytecode. &#8617;               Tu właśnie objawia się to automatyczne rzutowanie generowane przez kompilator &#8617;               W rzeczywistości, po skompilowaniu powstanie jeden plik class z klasą BoxForFigures. &#8617;               Twórcom zależało na tym aby programy napisane w starej wersji Javy mogły być uruchamiane na najnowszych wersjach maszyny wirtualnej. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/typy-generyczne-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/03/23_java_typy_generyczne_artykul.jpg"},{
        "title": "Porównywanie obiektów, metody equals i hashCode w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Porównywanie typów prostych Do sprawdzenia “równości” typów prostych służą operatory == oraz !=. Dzięki nim możemy porównać ze sobą każdą zmienną typu prostego. Wynikiem takiego porównania jest wartość typu boolean – true jeśli porównywane obiekty są równe i false w przeciwnym wypadku. Proszę spójrz na przykład poniżej: System.out.println(\"10 == 10: \" + (10 == 10));System.out.println(\"10 != 10: \" + (10 != 10));System.out.println(\"true == true: \" + (true == true));System.out.println(\"true != true: \" + (true != true));System.out.println(\"'a' == 'a': \" + ('a' == 'a'));System.out.println(\"'a' != 'a': \" + ('a' != 'a'));System.out.println(\"500L == 500L: \" + (500L == 500L));System.out.println(\"500L != 500L: \" + (500L != 500L));Kolejne linijki porównują odpowiednio:   liczby typu int,  zmienne typu boolean,  znaki typu char,  liczby typu long.Priorytety operatorów Drobna dygresja dotycząca priorytetów operatorów. W języku Java wszystkie operatory mają tak zwany priorytet. Oznacza to tyle, że priorytet operatorów określa kolejność wykonywania działań. Proszę spójrz na przykład niżej 10 == 4 + 64 + 6 == 103 * 5 + 2Operator + ma wyższy priorytet niż operator ==. W związku z tym operacja dodawania wykonana zostanie jako pierwsza i porównanie zwróci true. Podobnie * ma wyższy priorytet niż +. Zatem na początku wykonana zostanie operacja mnożenia a na końcu dodawanie. Czasami jednak domyślny priorytet operatorów nie jest odpowiedni, chcielibyśmy wykonać operacje w innej kolejności. Z pomocą przychodzą nawiasy, które pozwalają na modyfikację zachowania programu. Przykład poniżej pomaga zrozumieć jak to działa: 3 * (5 + 2)Mimo tego, że operator * ma wyższy priorytet niż + operacja mnożenia zostanie wykonana jako druga. Pierwsze zostanie wykonane dodawanie ponieważ zostało otoczone parą nawiasów. Po tym wstępie mogę wyjaśnić dlaczego w przykładzie poniżej potrzebujemy nawiasów: \"10 == 10: \" + 10 == 10 // compilation error!\"10 == 10: \" + (10 == 10)Bez dodatkowej pary nawiasów pierwszeństwo miałby operator +. \"10 == 10: \" + 10 == 10 inaczej możemy zapisać jako \"10 == 10: 10\"  == 10, a taki zapis nie jest poprawny. Jest błędny, ponieważ operatorem == nie możemy porównać instancji typu String i wartości typu int.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Porównywanie zmiennoprzecinkowych typów prostych O ile sprawdzanie równości wartości liczb całkowitych nie jest trudne to ta sama operacja dla typów zmiennoprzecinkowych jest trochę bardziej skomplikowana. W związku ze sposobem reprezentacji liczb zmiennoprzecinkowych typu float i double w pamięci komputera nie jest możliwe ich dokładne porównywanie. Operacja taka jest dopuszczalna ale może prowadzić do dziwnych rezultatów (na przykład, liczby, które teoretycznie powinny być równe według komputera nie są). W związku z tym liczby zmiennoprzecinkowe powinno się porównywać z pewną dokładnością. System.out.println(\"0.3 == 0.1 + 0.2: \" + (0.3 == 0.1 + 0.2)); // !!!System.out.println(\"0.3 == 0.1 + 0.2: \" + (Math.abs(0.3 - (0.1 + 0.2)) &lt; 0.000001));W przykładzie powyżej została użyta metoda Math.abs(). Metoda ta zwraca wartość bezwzględną danej liczby. Następnie wartość tę porównujemy z bardzo małą liczbą. Liczba ta reprezentuje dokładność porównania. Jeśli różnica liczb jest mniejsza niż nasza założona dokładność uznajemy, że porównywane liczby są równe. Porównanie obiektów Używając operatora == do porównywania obiektów uzyskamy błędne rezultaty. Do porównania tego typu powinniśmy używać metody equals. System.out.println(\"test == test: \" + (new String(\"test\") == new String(\"test\")));System.out.println(\"test equals test: \" + new String(\"test\").equals(new String(\"test\")));Dlaczego tak się dzieje? Otóż w przypadku obiektów operator == porównuje referencje obiektów (adresy na stercie). Mając dwie różne instancje obiektów mają one dwa różne adresy w pamięci w związku z tym zawsze ich adresy są różne. Innymi słowy w przypadku obiektów przy pomocy operatora == możemy sprawdzić czy dwie referencje wskazują na ten sam obiekt. String reference1 = new String(\"something\");String reference2 = reference1;System.out.println(\"reference1 == reference2: \" + (reference1 == reference2));Metoda equals Metoda equals jest jedną z metod dostępnych w klasie Object. W związku z tym, że każdy obiekt w języku Java ma tę klasę w swojej hierarchii dziedziczenia możemy tą metodą wywołać na każdym obiekcie. W większości przypadków domyślna implementacja metody equals nie jest odpowiednia1 w związku z tym programista tworzący nowy obiekt musi tę metodę zaimplementować jeśli chce sprawdzać czy instancje tej klasy są równe. Istnieje zestaw wytycznych, które metoda equals powinna spełniać aby była poprawnie zaimplementowana. Opiszę je po kolei: Metoda equals powinna być zwrotna Oznacza to tyle, że dla każdego obiektu operacja object.equals(object) powinna zwrócić true. Metoda equals powinna być symetryczna Oznacza to tyle, że dla każdej pary obiektów X i Y powinna zachodzić właściwość jeśli X.equals(Y) == true wówczas także Y.equals(X) == true. Metoda equals powinna być przechodnia Jeśli mamy trzy obiekty X, Y i Z oraz jeśli X.equals(Y) == true i Y.equals(Z) == true to także X.equals(Z) jest prawdą. Metoda equals powinna być spójna Innymi słowy kilkukrotne wywołanie metody equals na tych samych obiektach zawsze powinno zwrócić ten sam wynik (zakładając, że obiekty nie były modyfikowane pomiędzy wywołaniami). Metoda equals powinna zwrócić false przy porówaniu z null Dla każdego obiektu X, który nie jest null porównanie typu X.equals(null) powinno zwrócić false. Załóżmy, że mamy klasę Chair. Możemy powiedzieć, że krzesła są “równe” jeśli zostały wyprodukowane w tym samym roku, przez tego samego producenta oraz są tego samego modelu. Założenia te zostały zaimplementowane poniżej. public class Chair {    private String model;    private String manufacturer;    private int productionYear;     public Chair(String model, String manufacturer, int productionYear) {        this.model = model;        this.manufacturer = manufacturer;        this.productionYear = productionYear;    }        public String getModel() {        return model;    }        public String getManufacturer() {        return manufacturer;    }        public int getProductionYear() {        return productionYear;    }     @Override    public boolean equals(Object obj) {        if (obj == null) {            return false;        }        if (obj instanceof Chair) {            Chair otherChair = (Chair) obj;            return model.equals(otherChair.model) &amp;&amp;                    manufacturer.equals(otherChair.manufacturer) &amp;&amp;                    productionYear == otherChair.productionYear;        }        return false;    }     @Override    public int hashCode() {        return 17 * model.hashCode() + 31 * manufacturer.hashCode() + 7 * productionYear;    }} Chair chair1 = new Chair(\"Adde\", \"IKEA\", 2016); Chair chair2 = new Chair(\"Janinge\", \"IKEA\", 2016); Chair chair3 = new Chair(\"Adde\", \"IKEA\", 2015); Chair chair4 = new Chair(\"Adde\", \"IKEA\", 2016); System.out.println(\"chair1.equals(chair2): \" + chair1.equals(chair2)); System.out.println(\"chair1.equals(chair3): \" + chair1.equals(chair3)); System.out.println(\"chair1.equals(chair4): \" + chair1.equals(chair4)); System.out.println(\"chair1.equals(null): \" + chair1.equals(null));Zauważ, że w naszej implementacji metody equals używamy także metody equals z typu String aby sprawdzić czy model i producent są równi. Nowy może być także operator instanceof, służy on do sprawdzenia czy dana instancja jest typu Chair. Po tym sprawdzeniu możemy bezpiecznie rzutować obiekt obj i mamy pewność, że nie zostanie rzucony wyjątek ClassCastException. Metoda hashCode Podobnie jak w przypadku equals hashCode jest zaimplementowane w klasie Object. Zawsze kiedy programista implementuję metodę hashCode powinien też zaimplementować metodęequals. Metoda ta zwraca liczbę typu int, która służy do przyporządkowania danego obiektu do grupy. Dzięki metodzie hashCode jesteśmy w stanie podzielić wszystkie możliwe instancje danej klasy na rozdzielne grupy. Każda z tych grup reprezentowana jest przez liczbę zwracaną przez metodę hashCode.         hashCode zasada działania.  Obrazowe przyporządkowanie obiektów do grup zostało przedstawione na diagramie powyżej. Koła i trójkąt zostały przyporządkowane do tej samej grupy, rąb i pięciokąt do grupy Hash#2 natomiast trapez został przyporządkowany do grupy Hash#3. Metoda hashCode wykorzystywana jest przez niektóre kolekcje (tablice na sterydach), o których przeczytasz w jednym z kolejnych artykułów. Implementacja metody hashCode sprowadza się do zwrócenia odpowiedniej liczby, tak zwanego hasha. Przyporządkuje on dany obiekt do grupy używanej w niektórych kolekcjach. Najczęściej metodę hashCode implementuje się w oparciu o hashe atrybutów danej instancji. Hashe atrybutów zazwyczaj mnoży się przez liczby pierwsze i sumuje ze sobą. Użycie liczb pierwszych pomaga w uzyskaniu “dobrych hashy”. Dobra implementacja hashCode pozwala na uzyskanie jak największej liczby grup (hashy), do których przyporządkowujemy obiekty. Posłużę sie tu klasą Chair wspomianą wyżej. Zakładając, że nasza klasa ma trzy atrybuty i żaden z nich nie może mieć wartości null przykładowa implemetacja może wyglądać następująco: @Overridepublic int hashCode() {    return 17 * model.hashCode() + 31 * manufacturer.hashCode() + 7 * productionYear;}W większości przypadków użycie metody Objects.hash przy implementacji metody hashCode jest dobrym pomysłem. Kontrakt między metodami equals i hashCode Metody hashCode i equals są ze sobą powiązane i ich implementacja powinna być spójna. Tą zależność określa się kontraktem między metodami hashCode i equals.   Jeśli X.equals(Y) == true wówczas wymagane jest aby X.hashCode() == Y.hashCode(),  Kilkukrotne wywołanie metody hashCode na tym samym obiekcie, który nie był modyfikowany pomiędzy wywołaniami musi zwrócić tę samą wartość,  Jeśli X.hashCode() == Y.hashCode() to nie jest wymagane aby X.equals(Y) == true.Trzeci przypadek jest ilustrowany na obrazku powyżej gdzie koła i trójkąt mają ten sam hashCode jednak koło i trójkąt nie są równe. Generatory metod hashCode i equals Implementacja tych metod w większości przypadków jest dość prosta. W większości z nich także nie jest to kod zbyt skomplikowany. Jednak za każdym razem pisanie tych metod jest uciążliwe. Z pomocą przychodzi IDE. Polecam generowanie tych metod przy jego pomocy. W przypadku InteliJ IDEA pomocny może okazać się skrót klawiaturowy Alt+Insert. Po jego naciśnięciu pokaże się menu kontekstowe pozwalające na wygenerowanie tych metod. Dodatkowo warto przyjrzeć się klasie Objects i bibliotekom Guava czy Apache commons-lang. Zawierają one metody pomocnicze użyteczne podczas implementacji metod hashCode i equals. Zadanie Na koniec krótkie zadanie dla Ciebie. Napisz klasę reprezentującą człowieka, zaimplementuj metody hashCode i equals. Zastanów się czy to, że ktoś ma to samo imię i nazwisko sprawia, że jest to ta sama osoba? Jaki atrybut może posłużyć do sprawdzenia czy dwie instancje klasy Human reprezentują tę samą osobę? Jeśli będziesz miał problem z rozwiązaniem zadania przykładowe rozwiązanie umieściłem na githubie. Jak zwykle zachęcam do samodzielnych prób, wtedy nauczysz się najwięcej. Materiały dodatkowe Kod źródłowy wszystkich przykładów użytych w artykule znajduje się na githubie. Jeśli chcesz poczytać więcej na temat metod equals i hashCode zapraszam do materiałów dodatkowych:   http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-  http://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#hashCode–  https://docs.oracle.com/javase/specs/jls/se7/html/jls-15.html#jls-15.21  http://kobietydokodu.pl/niezbednik-juniora-kontrakt-hashcode-i-equalsPodsumowanie Bardzo się cieszę, że dotarłeś do końca artykułu. Mam nadzieję, że był on dla Ciebie ciekawy i przydatny. Na koniec mam do Ciebie prośbę, podziel się artykułem ze swoimi znajomymi, zależy mi na dotarciu do jak największej liczby czytelników. Jeśli nie chcesz przegapić nowych artykułów polub nas na facebooku :) W przypadku jakichkolwiek pytań proszę zdaj je w komentarzach, postaram się odpowiedzieć. Do następnego razu!             Domyślna implementacja zachowuje się jak operator ==, porównuje adresy obiektów. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/porownywanie-obiektow-metody-equals-i-hashcode-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/04/17_equals_hashcode_w_jezyku_java_artykul.jpg"},{
        "title": "Kolekcje w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Biblioteka standardowa Java, podobnie jak wiele innych języków, w tak zwanej bibliotece standardowej1 zawiera zestaw kolekcji. Kolekcja to nic innego jak sposób grupowania obiektów. Kolekcją możemy także nazwać tablicę obiektów, którą już znasz. Jednak tego typu kolekcja na pewne ograniczenia, głównym z nich jest to, że rozmiar, który ustalimy na początku nie może być zmieniony. Kolekcje możemy opisać jako „tablice na sterydach”. Pozwalają one na dużo więcej niż przechowywanie obiektów w kolejności określonej przez tablicę. Kolekcje to implementacje tak zwanych struktur danych. O przykładowych implementacjach struktur danych na pewno przeczytasz w jednym z kolejnych artykułów. Na dzisiaj musisz zapamiętać, ze rodzaj kolekcji/struktury danych pozwala napisać program, który jest bardziej bądź mniej wydajny (działa szybciej lub wolniej). To, jaką kolekcję w danym momencie użyjemy ma znaczenie. W kolejnych akapitach postaram się przytoczyć podstawowe kolekcje wraz z przykładami ich użycia. Hierarchia dziedziczenia Kolekcje w standardowej bibliotece Javy implementują różne interfejsy, poniższy diagram pokazuje hierarchię dziedziczenia interfejsów dla podstawowych typów kolekcji dostępnych w Javie. Każdy z tych interfejsów ma kilka implementacji, których używa się w różnych sytuacjach.         Dziedziczenie kolekcji w języku Java.  Lista Lista (ang. list) podobnie jak tablica, grupuje elementy. Jej główną przewagą nad tablicą jest to, że programista nie musi się przejmować rozmiarem listy2, jest ona automatycznie powiększana wraz z dodawaniem nowych elementów. Listy w języku Java reprezentowane są przez interfejs java.util.List. Listy z definicji są kolekcjami dla których kolejność elementów jest istotna, mogą przechowywać ten sam obiekt po kilka razy. Podstawowymi przykładami implementacji interfejsu java.util.List są klasy java.util.LinkedList oraz java.util.ArrayList. Bez wdawania się w zbędne szczegóły, proszę zapamiętaj, że LinkedList lepiej jest używać jeśli często usuwasz elementy z listy, a ArrayList lepiej jest używać jeśli często chcesz mieć dostęp do losowych elementów w liście. Obiecuje, że dokładne wytłumaczenie dlaczego tak się dzieje znajdziesz w jednym z kolejnych artykułów.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Przydatne metody w java.util.List Chciałbym pokazać Ci parę metod, które mogą Ci się przydać przy pracy z listami. Jeśli jesteś zainteresowany pełną listą zachęcam do przeczytania dokumentacji dla interfejsu List, tam znajdziesz wszystkie niezbędne szczegóły. Załóżmy, że nasza zmienna jest typu List&lt;String&gt;. Wówczas będziesz mógł używać m.in. następujących metod:   add – dodaje element do listy,  addAll – jako parametr przyjmuje inną kolekcję i dodaje wszystkie elementy z tej kolekcji do listy,  contains – jako parametr przyjmuje element listy i zwraca flagę informującą czy dany element już istnieje (tutaj przyda Ci się artykuł o porównywaniu obiektów w języku Java),  isEmpty – bezargumentowa metoda zwracająca flagę informującą czy lista jest pusta,  size – bezargumentowa metoda zwracająca liczbę elementów w liście,  indexOf – metoda jako parametr przyjmuje element listy i zwraca indeks pierwszego wystąpienia,  lastIndexOf – metoda jako parametr przyjmuje element listy i zwraca indeks ostatniego wystąpienia.Opisane wyżej metody użyte zostały w kodzie poniżej. List&lt;String&gt; listWithNames = new LinkedList&lt;&gt;();listWithNames.add(\"Piotrek\");listWithNames.add(\"Krzysiek\");List&lt;String&gt; otherListWithNames = new LinkedList&lt;&gt;();otherListWithNames.add(\"Marek\");otherListWithNames.addAll(listWithNames);otherListWithNames.add(\"Marek\");System.out.println(otherListWithNames.contains(\"Marek\"));System.out.println(otherListWithNames.get(0));System.out.println(otherListWithNames.isEmpty());System.out.println(otherListWithNames.indexOf(\"Marek\"));System.out.println(otherListWithNames.lastIndexOf(\"Marek\"));Tutaj drobna dygresja, w kodzie wyżej widzisz zapis List&lt;String&gt; listWithNames = new LinkedList&lt;&gt;(). Dlaczego nie napisać LinkedList&lt;String&gt; listWithNames = new LinkedList&lt;&gt;()? Pierwsza wersja pokazuje dobrą praktykę, która polega na definiowaniu zmiennych typu interfejsu a nie klasy implementującej ten interfejs. Dzięki temu w przyszłości z łatwością moglibyśmy przypisać do listWithNames zmienną typu ArrayList&lt;String&gt; bez konieczności zmiany pozostałej części programu. Zbiór Zbiór (ang. set) to kolekcja, która służy do przechowywania unikalnych elementów. Zbiory w języku Java implementują interfejs java.util.Set. W przypadku zbioru nie jest istotna kolejność dodawanych elementów. Innymi słowy jeśli do zbioru dodamy na początku element X a później Y to przechodząc po kolei po elementach zbioru możemy dostać je w odwrotnej kolejności. Istnieją także implementacje zbioru, w których kolejność elementów jest zachowana, jednak jest to raczej „szczegół implementacyjny” niż szczególna właściwość zbiorów. Kolejną cechą zbioru jest to, że przechowuje on unikalne elementy. W odróżnieniu od listy, w zbiorze można przechowywać wyłącznie jedną instancję obiektu. Skąd możemy wiedzieć, że dana instancja jest już w zbiorze? Otóż służą do tego opisane już metody hashCode oraz equals. Jeszcze raz przypomnę o kontrakcie między tymi metodami. Poprawne działanie kolekcji wymaga poprawnie zaimplementowanych metod hashCode/equals. Jeśli ten warunek nie jest spełniony niektóre kolekcje mogą działać w dziwny, niespodziewany sposób. Najważniejszą implementacją interfejsu Set jest klasa java.util.HashSet. Przydatne metody w java.util.Set Podobnie jak w przypadku list zachęcam do zapoznania się z pełną listą metod dostępnych w interfejsie Set. Poniżej lista kilku przydatnych metod:   add – dodaje element do zbioru,  addAll – jako parametr przyjmuje inną kolekcję i dodaje wszystkie elementy z tej kolekcji do zbioru (pomijając duplikaty),  contains – jako parametr przyjmuje element zbioru i zwraca flagę informującą czy dany element już istnieje,  isEmpty – bezargumentowa metoda zwracająca flagę informującą czy zbiór jest pusty,  size – metoda zwraca ilość elementów w zbiorze.Przykład użycia metod znajduje się we fragmencie kodu poniżej. Set&lt;String&gt; setWithNames = new HashSet&lt;&gt;();setWithNames.add(\"Marcin\");setWithNames.add(\"Marek\");setWithNames.add(\"Marcin\"); Set&lt;String&gt; otherSet = new HashSet&lt;&gt;();otherSet.add(\"Zenon\");otherSet.add(\"Marek\"); setWithNames.addAll(otherSet); System.out.println(setWithNames.isEmpty());System.out.println(setWithNames.size());System.out.println(setWithNames.contains(\"Marcin\"));System.out.println(setWithNames.remove(\"Janusz\"));Mapa Mapa (ang. map) jest kolekcją, która pozwala przechować odwzorowanie zbioru kluczy na listę wartości. Innymi słowy w mapie możemy trzymać klucze, którym odpowiadają wartości. Klucze muszą być unikalne (dlatego pisałem o zbiorze kluczy), wartości natomiast mogą się powtarzać. Czyli pod kluczem A i pod kluczem B może być ta sama wartość X. Ale sytuacja odwrotna gdzie klucz X występuje dwa razy i jeden z nich wskazuje na element A a inny na element B nie jest możliwa3. Czytając inne źródła możesz natknąć się na inne nazwy. Słownik, tablica asocjacyjna, mapa – to pojęcia opisujące dokładnie tę samą strukturę danych. Kluczami w mapie powinny być obiekty, których nie można zmodyfikować (ang. immutable). Np dobrymi kandydatami na klucze są instancje takich klas jak String czy Integer – są to obiekty, których po zainicjalizowaniu nie możemy zmodyfikować. Ponadto klasy kluczy muszą poprawnie implementować metody hashCode/equals. Jeśli jakaś para (klucz, wartość1) istnieje jest w mapie, a Ty spróbujesz dodać kolejną (klucz, wartość2) (ten sam klucz). Wówczas ta ostatnia para będzie przechowywana przez mapę, nadpisze ona poprzedni element. Podobnie jak Set i List, Map jest interfejsem generycznym, jednak w tym przypadku wymaga on dwóch klas – pierwsza z nich definiuje typ kluczy, druga typ wartości przechowywanych w mapie. Standardową implementacją mapy w języku Java jest klasa java.util.HashMap. Przydatne metody w java.util.Map   put – dodaje parę klucz/wartość do mapy,  putAll – jako parametr przyjmuje inną mapę i dodaje wszystkie elementy z do mapy,  containsKey – jako parametr przyjmuje klucz i zwraca flagę informującą czy dany klucz już istnieje,  containsValue – jako parametr przyjmuje wartość i zwraca flagę informującą czy dana wartość już istnieje,  isEmpty – bezargumentowa metoda zwracająca flagę informującą czy mapa jest pusta,  size – bezargumentowa metoda zwracająca liczbę elementów w mapie,  remove – metoda jako parametr przyjmuje klucz i usuwa parę klucz/wartość z mapy,  get – metoda jako parametr przyjmuje klucz i zwraca odpowiadającą mu wartość.Przykłady użycia metod znajdziesz we fragmencie kodu poniżej. Map&lt;String, String&gt; pairsMap = new HashMap&lt;&gt;();pairsMap.put(\"Marcin\", \"Adela\");pairsMap.put(\"Marek\", \"Magda\"); Map&lt;String, String&gt; otherPairsMap = new HashMap&lt;&gt;();otherPairsMap.put(\"Marek\", \"Ewa\");otherPairsMap.put(\"Adam\", \"Ewa\"); pairsMap.putAll(otherPairsMap); System.out.println(pairsMap.get(\"Marek\"));System.out.println(pairsMap.remove(\"Marek\"));System.out.println(pairsMap.size());System.out.println(pairsMap.isEmpty());System.out.println(pairsMap.containsKey(\"Jan\"));System.out.println(pairsMap.containsValue(\"Adela\"));Pełna lista metod dostępna w interfejsie Map znajduje się w dokumentacji. Skróty klawiaturowe W IDE, które proponowałem na początku (InteliJ) jest skrót klawiaturowy, który bardzo może Ci się przydać w odkrywaniu nowych metod. Po wpisaniu zmiennej i kropki po niej naciśnij &lt;Ctrl + Spacja&gt; pojawi się menu kontekstowe z dostępnymi atrybutami/metodami tego obiektu.         Skróty klawiaturowe w InteliJ Idea  Kolejny przydatny skrót klawiaturowy to &lt;Ctrl + H&gt;. Najedź kursorem na interfejs List, po naciśnięciu tego skrótu pojawi się panel zawierający hierarchię dziedziczenia dla elementu pod kursorem. Także ten panel jest widoczny na zrzucie ekranu powyżej. Dzięki szybkiemu wglądowi w hierarchii dziedziczenia możesz w łatwy sposób odnaleźć inne implementacje danego interfejsu. Ograniczenia kolekcji Jak już napisałem wyżej „kolekcje to tablice na sterydach”. Z tymi sterydami przychodzą także pewne ograniczenia. Głównym ograniczeniem jest to że wraz z kolekcjami opisanymi powyżej nie możesz używać typów prymitywnych (Integer tak, int nie). Możesz to łatwo obejść poprzez używanie odpowiadających im obiektów, jednak obiekty takie zajmują więcej miejsca w pamięci niż typy prymitywne. Istnieją implementacje kolekcji, które pozwalają na używanie typów prymitywnych jednak na tym etapie nauki Javy nie zaprzątałbym sobie nimi głowy. Standardowe kolekcje są w zupełności wystarczające. Iterowanie po kolekcjach Z artykułu opisującego pętle dowiedziałeś się o różnych rodzajach pętli i to właśnie na nich tutaj się skupimy4. Iterowanie po listach Najprostszym sposobem jest iterowanie przy użyciu pętli foreach. Zgodnie z definicją listy elementy będą zwracane w kolejności dodawania ich do listy. Jeśli potrzebujemy dostępu do indeksu elementu możemy użyć także standardowej pętli for. Jeśli takie podejście jest wymagane lepiej jest używać implementacji ArrayList niż LinkedList. List&lt;String&gt; sampleList = new ArrayList&lt;&gt;();sampleList.add(\"Marcin\");sampleList.add(\"Adela\");sampleList.add(\"Marek\");sampleList.add(\"Magda\"); System.out.println(\"Iterowanie po liscie (foreach)\");for(String item : sampleList) {    System.out.println(item);} System.out.println(\"Iterowanie po liscie (for)\");for(int index = 0; index &lt; sampleList.size(); index++) {    System.out.println(sampleList.get(index));}Iterowanie po zbiorach Podobnie jak w przypadku list z pomocą przychodzi pętla foreach, jednak tutaj nie mamy już gwarancji zwrócenia obiektów zbioru w tej samej kolejności, w której były one do niego dodawane (zachęcam do sprawdzenia tego samodzielnie). Set&lt;String&gt; sampleSet = new HashSet&lt;&gt;();sampleSet.add(\"Marcin\");sampleSet.add(\"Adela\");sampleSet.add(\"Marek\");sampleSet.add(\"Magda\"); System.out.println(\"Iterowanie po zbiorze\");for(String item : sampleSet) {    System.out.println(item);}Iterowanie po mapach Z racji tego, że w mapach mamy zbiór kluczy mapowanych na wartości możemy iterować po samych kluczach, samych wartościach bądź parach klucz, wartość. Powinniśmy używać odpowiedniego sposobu w zależności od naszych potrzeb. Kolejna dygresja, nowością może być dla Ciebie zapis Map.Entry&lt;String, String&gt;. Jest to notacja wskazująca na tak zwaną klasę wewnętrzną (bądź inerfejs). Interfejs Entry został zdefiniowana wewnątrz Map dlatego odwołujemy się do niego poprzez Map.Entry. Jest to interfejs generyczny, który odpowiada parze klucz/wartość, dlatego typowany jest tymi samymi typami co mapa z przykładu. Map&lt;String, String&gt; sampleMap = new HashMap&lt;&gt;();sampleMap.put(\"Marek\", \"Magda\");sampleMap.put(\"Marcin\", \"Adela\"); System.out.println(\"Iterowanie po wartosciach\");for(String value : sampleMap.values()) {    System.out.println(value);} System.out.println(\"Iterowanie po kluczach i pobieranie wartosci\");for(String key : sampleMap.keySet()) {    String value = sampleMap.get(key);    System.out.println(key + \": \" + value);} System.out.println(\"Iterowanie po kluczach i wartosciach\");for(Map.Entry&lt;String, String&gt; entry : sampleMap.entrySet()) {    String key = entry.getKey();    String value = entry.getValue();    System.out.println(key + \": \" + value);}Porównanie typów kolekcji Na koniec dla ułatwienia przygotowałem dla Ciebie tabelkę, która grupuje właściwości poszczególnych kolekcji w jednym miejscu wraz z przykładem użycia.                    Lista      Zbiór      Mapa                  Zachowuje kolejność elementów      Tak      Nie      Nie              Pozwala na przechowywanie kliku takich samych elementów/kluczy      Tak      Nie      Nie              Przykład użycia (podróżowałeś przez Europę pociągiem)      Miasta, które odwiedziłeś (cała trasa z drogą powrotną, niektóre miasta odwiedziłeś także przy powrocie)      Zbiór miast, które odwiedziłeś (bez duplikatów).      Nazwy państw, które odwiedziłeś wraz z odpowiadającymi im stolicami.      Zadania   Napisz program, który będzie pobierał od użytkownika imiona. Program powinien pozwolić użytkownikowi na wprowadzenie dowolnej liczby imion (wprowadzenie „-” jako imienia przerwie wprowadzanie). Na zakończenie wypisz liczbę unikalnych imion.  Napisz program, który będzie pobierał od użytkownika imiona par dopóki nie wprowadzi imienia „-”, następnie poproś użytkownika o podanie jednego z wcześniej wprowadzonych imion i wyświetl imię odpowiadającego mu partnera.Jeśli będziesz miał problemy z rozwiązaniem któregokolwiek z zadań na githubie umieściłem przykładowe rozwiązania. Zachęcam do ich sprawdzenia dopiero po przygotowaniu swojej wersji :) Dodatkowe materiały do nauki Materiałów na temat kolekcji w internecie jest całkiem sporo, poniżej przygotowałem dla Ciebie zestaw linków do innych blogów/kursów gdzie autorzy także opisują kolekcje. Jeśli będzie brakowało Ci materiałów, bądź będziesz chciał poznać temat z innej strony zachęcam do zapoznania się z nimi. Na początek kod źródłowy przykładów i rozwiązań zadań oraz dokumentacja biblioteki standardowej.   https://docs.oracle.com/javase/8/docs/api/java/util/Map.html  https://docs.oracle.com/javase/8/docs/api/java/util/Set.html  https://docs.oracle.com/javase/8/docs/api/java/util/List.html  Kod źródłowy i przykłady rozwiązań zadań na githubieNo i zestaw pozostałych materiałów :)   http://wazniak.mimuw.edu.pl/index.php?title=PO_Kolekcje_wst%C4%99p  http://wazniak.mimuw.edu.pl/index.php?title=PO_Kolekcje_-_przegląd  ArrayList przykład użycia (youtube)  http://naukajavy.pl/kurs-jezyka-java/109-listy  http://naukajavy.pl/kurs-jezyka-java/105-zbiory  http://naukajavy.pl/kurs-jezyka-java/111-mapy  http://tutorials.jenkov.com/java-collections/index.html  http://kobietydokodu.pl/05-kolekcje-w-javie/Podsumowanie Cieszę się, że dotrwałeś do końca. Musisz wiedzieć, że bez kolekcji nie ma programowania, ten artykuł jest naprawdę ważny :). Na koniec mam do Ciebie prośbę, proszę pomóż mi dotrzeć do kolejnych Samouków, podziel się z nimi adresem tego bloga i polub stronkę na Facebooku. Z góry wielkie dzięki! Do następnego razu!             Biblioteka standardowa to zestaw klas, które może używać programista, dostarczonych wraz z językiem programowania. &#8617;               Oczywiście w granicach rozsądku, w skrajnych przypadkach utworzenie listy ze zbyt dużą liczbą elementów może prowadzić do wystąpienia błędu OutOfMemoryError. &#8617;               Tu znów dygresja, oczywiście istnieją implementacje, które pozwalają na takie zachowanie, jednak nie jest to „domyślne” zachowanie. &#8617;               Na początku pominiemy strumienie, którymi zajmiemy się w osobnym artykule. &#8617;       ","categories": ["Kurs programowania Java","Programowanie"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/kolekcje-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/08/09_kolekcje_w_jezyku_java_artykul.jpg"},{
        "title": "Operacje na plikach w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. System plików Na początku winien Ci jestem drobne wprowadzenie do czegoś co nazywa się systemem plików. Otóż dysk komputera może pomieścić pewną ilość danych, współczesne dyski twarde mają pojemność z przedziału kilkuset gigabajtów (GB) do kilku terabajtów (TB). Jest to ogromna przestrzeń, 1 GB to 1’000 MB, to z kolei przekłada się na 1’000’000’000B (109 bajtów). Każdy z tych bajtów to 8 bitów. Na zapisanie dowolnej liczby typu int w Javie potrzebujesz 32 bitów (4 bajtów). Czyli 1GB dysku w teorii może pomieścić 250’000’000 liczb zapisanych w tym formacie. Innymi słowy potrzeba około 3GB aby w tym formacie zapisać datę urodzenia każdego mieszkańca Europy (gdzie datę zapisujemy jako jedną liczbę) :) Aby komputer wiedział co znajduje się w którym miejscu w tym gąszczu cyferek potrzebny jest system plików. Istnieje wiele rodzajów systemów plików, jednak ich rozróżnienie nie jest nam w tym momencie potrzebne. Jeśli jesteś zainteresowany bardziej szczegółowymi informacjami zachęcam do przeczytania artykułu na wikipedii. Najważniejsze jest abyś zapamiętał, że system plików organizuje dane na dysku i daje do nich dostęp poprzez znane Ci foldery czy pliki. Pliki binarne a pliki tekstowe Wiesz już, że plik mapuje się na pewien obszar danych na dysku. Otwierając jakikolwiek plik czytasz te dane za pośrednictwem systemu plików. Dane te mogą być zapisane w trybie „tekstowym” bądź „binarnym”1. Sposób zapisu danych ma istotny wpływ na rozmiar pliku. Na przykład zapisanie liczby 1234567 binarnie jako int w Javie wymaga 4 bajtów. Zapisanie tej samej liczby jako łańcuch znaków w pliku tekstowym wymaga już 7 bajtów. Innymi słowy zapis binarny w ogromnej większości przypadków wymaga mniej miejsca na dysku. Niestety wiąże się to z pewnymi ograniczeniami. Otóż pliki binarne nie są czytelne dla ludzi (ang. human-readable). Czy zdarzyło Ci się kiedyś otworzyć plik binarny w notatniku? Zobaczyłbyś wtedy przysłowiowe „krzaki”, ponieważ notatnik interpretował dane binarne jako tekst.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Ścieżka do pliku System plików organizuje dane na dysku w hierarchiczną strukturę katalogów wewnątrz których znajdują się pliki. Każdy plik czy katalog ma ścieżkę, która jednoznacznie wskazuje jego miejsce w tej strukturze. Tutaj napotykamy na pewne różnice pomiędzy różnymi systemami operacyjnymi. Dyski mogą być podzielone na tak zwane partycje, systemy operacyjne z rodziny Windows przedstawiają te partycje jako osobne dyski np. dysk C czy dysk D. W związku z tym ścieżki nieznacznie różnią się pomiędzy różnymi systemami operacyjnymi. I tak ścieżka w systemie z rodziny Windows wygląda następująco: C:\\katalog\\plik.txtAnalogiczna ścieżka w systemach z rodziny Linux/Unix wygląda trochę inaczej: /katalog/plik.txtW kontekście języka Java taka różnica ma pewne konsekwencje. Otóż jeśli chcemy użyć literału String wówczas znak \\ musimy poprzedzić kolejnym \\. Dzieje się tak ponieważ symbol \\ jest wykorzystywany w specjalny sposób. Zatem ścieżka C:\\katalog\\plik.txt zapisana w Javie jako String wygląda następująco \"C:\\\\katalog\\\\plik.txt\". Ścieżka absolutna i relatywna Do każdego folderu/pliku możemy odnieść się poprzez ścieżkę absolutną bądź relatywną (możemy je także nazwać ścieżką bezwzględna i względną). Ścieżka absolutna jest ścieżką „od początku”, czyli przechodzi przez całą strukturę katalogów aż do samego pliku. Załóżmy, że dysk C ma strukturę jak przedstawiono poniżej: C:\\ ├── folder_1 │ └── plik_1.txt ├── folder_2 │ ├── folder_2_a │ │ └── plik_2_a.txt │ └── plik_2.txt └── plik.txtŚcieżka absolutna do pliku plik_2_a.txt wygląda następująco C:\\folder_2\\folder_2_a\\plik_2_a.txt. Możemy mówić również o ścieżce relatywnej. Mówimy o niej relatywna ponieważ określa adres pliku/katalogu relatywnie do miejsca, w którym się aktualnie znajdujemy. Zakładając że znajdujemy się w katalogu folder_2 wówczas nasza relatywna ścieżka do pliku plik_2_a.txt jet następująca folder_2_a\\plik_2_a.txt. Tryb dostępu do pliku Musisz wiedzieć, że plik możemy otworzyć „do odczytu”, „do zapisu” czy „w trybie dołączania”. Tryb ten jest bardzo istotny, otworzenie do zapisu pliku, który już istnieje i zapisanie choćby jednego znaku kasuje całą dotychczasową zawartość. Podobnie otworzenie do zapisu pliku, który jeszcze nie istnieje powoduje jego utworzenie (jeśli katalog w którym ma znaleźć się plik istnieje). Tryb „dołączania” nie kasuje zawartości istniejącego pliku, a jedynie dopisuje na końcu nową treść. Otwierając jakikolwiek plik w języku Java otwieramy go w pewnym trybie. Tryb ten określamy wprost, bądź jest określony domyślnie w zależności od klasy, którą użyjemy do tego celu. Klasy służące do pisania do pliku domyślnie otwierają go „do zapisu”. Klasy do obsługi operacji na plikach Musisz wiedzieć, że klasy z biblioteki standardowej do obsługi plików wprowadzają pewne warstwy abstrakcji ułatwiające pracę z plikami. Wygląda to w ten sposób, że mamy klasę X, która jest klasą podstawową udostępniającą bardzo ograniczony zakres operacji. Klasa Y używając interfejsu klasy X udostępnia interfejs wyższego poziomu, z którym programiście łatwiej jest pracować. Takie podejście można porównać do swego rodzaju cebuli ;) gdzie każda kolejna warstwa bazuje na poprzedniej i udostępnia trochę inny interfejs. Przekładając to na konkretny przykład klas ze standardowej biblioteki Javy mamy klasę java.io.File, która oferuje podstawowe operacje na pliku.Instancja File jest przyjmowana jako parametr do utworzenia instancji klasy java.io.FileReader, która pozwala programiście na tekstowy dostęp do pliku znak po znaku. Z racji tego, że taka forma może być uciążliwa mamy do dyspozycji kolejną klasę java.io.BufferedReader, która pozwala na dostęp do pliku linijka po linijce. new BufferedReader(new FileReader(new File(\"/path/to/text/file.txt\")));Z racji tego, że powyższy fragment jest dość długi i byłby uciążliwy do pisania za każdym razem twórcy biblioteki przygotowali zestaw konstruktorów, które umożliwiają skrócenie tego zapisu. W przykładzie poniżej programista nie tworzy wprost instancji klasy File, podaje jedynie ścieżkę do pliku. Ta instancja tworzona jest za nas wewnątrz konstruktora klasy FileReader. new BufferedReader(new FileReader(\"/path/to/text/file.txt\"));Po tym wstępie teoretycznym wiesz już na tyle dużo o systemie plików i plikach, że możemy przejść do ich zapisywania i odczytywania. Ścieżki użyte w przykładach są z systemów Linux/Unix, jeśli pracujesz na Windows powinieneś używać ścieżek zgodnych z opisem powyżej. W artykule tym zajmowali będziemy się wyłącznie sekwencyjnym dostępem do plików. Oznacza to, że pisząc do pliku zawsze dopisujemy linijkę na koniec a czytając, czytamy od początku pliku. Oczywiście możemy też czytać z pliku/pisać do pliku w sposób losowy, wybierając dowolną lokalizację. Takie podejście często jest wykorzystywane w przypadku plików binarnych, których strukturę doskonale znamy i wiemy, że na przykład od bajtu 10 do bajtu 13 włącznie w pliku zawsze znajduje się liczba, która reprezentuje datę urodzenia. Obsługa plików tekstowych Zapisywanie danych do pliku Zapis do pliku tekstowego przedstawiłem we fragmencie kodu poniżej. String filePath = \"/path/to/text/file.txt\"int number = 1234567;FileWriter fileWriter = null;try {    fileWriter = new FileWriter(filePath);    fileWriter.write(Integer.toString(number));} finally {    if (fileWriter != null) {        fileWriter.close();    }}Przeanalizujmy co się dzieje w tym fragmencie kodu linijka po linijce. Pierwsze trzy linijki to nic innego jak inicjalizacja zmiennych, których będziemy używali później. Nowy tutaj dla Ciebie jest typ FileWriter, jest to klasa ze standardowej biblioteki języka Java odpowiedzialna za zapis do pliku tekstowego. Zachęcam do przejrzenia pełnej dokumentacji klasy FileWriter. Klasa ta udostępnia wysokopoziomowy interfejs zapisu do pliku danych tekstowych. Polecam sprawdzenie hierarchii dziedziczenia klasy FileWriter w IDE (pamiętasz skrót klawiaturowy z poprzedniego artykułu?). Następnie wewnątrz klauzuli try tworzymy nową instancję klasy FileWriter przekazując jej ścieżkę do pliku, do którego chcemy pisać. Operacja ta otwiera plik, może się ona nie udać co będzie sygnalizowane odpowiednim wyjątkiem. Kolejna linijka to wywołanie metody write, które zapisuje tekstową reprezentację liczby 1234567 do pliku. Ważne jest abyś pamiętał, że właściwy zapis wcale nie musi w tym miejscu nastąpić ze względu na buforowanie, o którym przeczytasz w jednym z kolejnych akapitów. Bardzo istotne jest ciało klauzuli finally. Wewnątrz sprawdzamy czy nasz fileWriter został zainicjalizowany. Jeśli nie udałoby się stworzyć jego instancji rzucony zostałby wyjątek ale klauzula finally i tak by się wykonała. Następnie wywołując metodę close zamykamy dostęp do pliku, jeśli ta operacja się powiedzie mamy pewność, że dane zostały zapisane w pliku na dysku. Zamykanie dostępu do plików Proszę pamiętaj o zamknięciu strumienia danych. Dlaczego jest to ważne? Podstawowym powodem jest tutaj zarządzanie przez system operacyjny tak zwanymi uchwytami do otwartych plików. Otóż systemy operacyjne, które znam mają limity, które pozwalają na otwarcie np. 2048 plików jednocześnie przez każdy program. Liczba ta jest na tyle duża, że nie zauważasz tego ograniczenia w codziennym użytkowaniu. Jeśli jednak napiszesz program, który będzie otwierał pliki bez ich zamykania możesz z łatwością wyczerpać ten limit. Bardziej przyziemnym powodem jest tak zwane buforowanie. Zapis do pliku może być buforowany (i jest w części przypadków przez klasy ze standardowej biblioteki Javy). Oznacza to tyle, że wywołanie metody write tak naprawdę jeszcze niczego na dysku nie zapisuje. Zapisuje te dane w buforze, który zrzucany jest na dysk. Taki zabieg jest wykonywany aby przyspieszyć zapis danych. Jeśli nie zamkniesz pliku może do doprowadzić do sytuacji, w której w buforze zostaną dane, które jeszcze nie zostały do pliku zrzucone. Zostaną one wówczas utracone, a tego chcielibyśmy uniknąć :) Odczytywanie danych z pliku Przykład kodu poniżej służy do czytania danych z pliku. String filePath = \"/path/to/text/file.txt\"int number = 0;BufferedReader fileReader = null;try {    fileReader = new BufferedReader(new FileReader(filePath));    String numberAsString = fileReader.readLine();    number = Integer.parseInt(numberAsString);} finally {    if (fileReader != null) {        fileReader.close();    }}Podobnie jak poprzednio przeanalizujemy go linijka po linijce. Pierwsze trzy linijki inicjalizują zmienne, które będziemy używali. Wewnątrz klauzuli try znajduje się kod, który tworzy instancję klasy BufferedReader dzięki której możemy czytać z pliku linijka po linijce. Kolejne dwie linie to czytanie linijki z pliku, parsowanie łańcucha znaków i zapisanie go jako liczby typu int. Metoda readLine, która została użyta zwróci null jeśli w pliku nie znajduje się już więcej danych. Podobnie jak w przypadku plików otwartych do odczytu tak i w tym przypadku musimy pamiętać o ich zamknięciu, zapewnia to wnętrze bloku finally. Musisz też wiedzieć, że klasy które pozwalają Ci na czytanie pliku mają tak zwany „wskaźnik”, który zapamiętuje ostatnie miejsce z którego coś przeczytaliśmy. Kolejna próba odczytu przesuwa ten wskaźnik dalej. Obsługa plików binarnych Skupimy się teraz na obsłudze plików binarnych. Pewne aspekty pracy z plikami tekstowymi i binarnymi są podobne. W obu przypadkach musimy pamiętać o zamykaniu „strumieni” do plików. W obu przypadkach także skupimy się na dostępie sekwencyjnym. Zapisywanie danych do pliku Bez zbędnego wstępu proszę spójrz na przykład poniżej. String filePath = \"/path/to/binary/file.txt\"int number = 1234567;DataOutputStream outputStream = null;try {    outputStream = new DataOutputStream(new FileOutputStream(filePath));    outputStream.writeInt(number);} finally {    if (outputStream != null) {        outputStream.close();    }}Pierwsze trzy i ostatnie pięć linii jest dla Ciebie znajoma. Bardzo podobny kod widziałeś w przykładach powyżej. Skupmy się nad tym co dzieje się w środku klauzuli try. Tworzymy tam instancję klasy FileOutputStream, która zostaje przekazana do konstruktora klasy DataOutputStream. DataOutputStream zapewnia interfejs pozwalający na binarny zapis typów prymitywnych w Javie podczas gdy FileOutputStream pozwala na zapis danych bajt po bajcie. Używanie DataOutputStream pozwala programiście zapomnieć o szczegółach w jaki liczby powinny być zapisane binarnie, tymi szczegółami zajmuje się właśnie ta klasa przez wywołanie metody writeInt. Pozwala ona w łatwy sposób zapisać binarnie typy proste i łańcuchy znaków (w jednym z kolejnych artykułów przeczytasz o serializacji pozwalającej na zapisanie binarnie dowolnych obiektów). Po uruchomieniu programu, który zapisuje liczbę do pliku spróbuj otworzyć ten plik w notatniku. Co widzisz? :) Prawda, że jest to mniej czytelne niż tekstowy format pliku? Odczytywanie danych z pliku String filePath = \"/path/to/binary/file.txt\"int number = 0;DataInputStream inputStream = null; try {    inputStream = new DataInputStream(new FileInputStream(filePath));    number = inputStream.readInt();} finally {  if (inputStream != null) {      inputStream.close();  }}Podobnie jak poprzednio kod poza klauzulą try już znasz. Nowa tutaj dla Ciebie jest instancja klasy FileInputStream, która przekazana jest do konstruktora klasy DataInputStream. Widzisz tu pewną analogię do poprzedniego przykładu? Podobnie jak poprzednio DataInputStream pozwala na czytanie większych kawałków pliku zapisanego binarnie, dzięki tej klasie możemy przeczytać liczbę typu int zapisaną wcześniej w pliku. Podobnie jak poprzednio klasa ta pozwala na odczyt typów prostych i łańcuchów znaków zapisanych binarnie. Zadania Na koniec kilka zadań dla Ciebie:   Napisz program, który pobierze od użytkownika ścieżkę do pliku tekstowego oraz kilka linijek tekstu (dopóki użytkownik nie wprowadzi „-” jako linijki) i zapisze je do pliku tekstowego. Do wykonania tego zadania może Ci się przydać metoda System.lineSeparator() zwracająca znak nowej linii (jeśli chciałbyś oddzielić linie wprowadzone przez użytkownika).  Napisz program, który pobierze od użytkownika ścieżkę do pliku i wyświetli zawartość pliku na ekranie wraz z informacją ile linii znajduje się w pliku.  Napisz program, który poprosi użytkownika nazwę pliku wyjściowego oraz o podanie swojej daty urodzenia (osobno dzień, miesiąc i rok), a następnie zapisze te dane jako trzy osobne liczby binarnie.  Napisz program, który pobierze od użytkownika ścieżkę do pliku binarnego z datą urodzenia, a następnie wyświetli ją na ekranie.Jak zwykle przykładowe rozwiązania zadań znajdują się na githubie, jednak zachęcam do samodzielnej próby rozwiązania zadań, wtedy nauczysz się najwięcej. Dodatkowe materiały do nauki W każdym artykule zachęcam Cię do zapoznania się z dokumentacją, nie inaczej będzie i tym razem. Zapewniam Cię, że jest to najlepsze źródło z kompletną informacją na temat klas z biblioteki standardowej. Innymi słowy zestaw obowiązkowy to dokumentacja biblioteki standardowej, zawsze w przypadku wątpliwości tam znajdziesz dużo potrzebnych informacji:   File  FileWriter  FileReader  BufferedReader  FileOutputStream  FileInputStream  DataOutputStream  DataInputStreamDodatkowo parę wpisów w innych miejscach w sieci:   kod źródłowy przykładów i przykładowe rozwiązania zadań  http://naukajavy.pl/kurs-jezyka-java/114-zapis-tekstu-do-pliku  http://naukajavy.pl/kurs-jezyka-java/113-odczyt-tekstu-z-pliku  http://wazniak.mimuw.edu.pl/index.php?title=PO_StrumieniePodsumowanie Mam nadzieję, że artykuł się podobał. Dzisiaj nauczyłeś się całkiem sporo na temat pracy z plikami w Javie. Dowiedziałeś się czegoś więcej o systemie plików. Po wykonaniu zadań wiesz już jak odczytać/zapisać plik zarówno binarnie jak i w trybie tekstowym. Dużo tego :) Na koniec jak zwykle prośba do Ciebie, zależy mi na dotarciu do jak największego grona czytelników. Proszę pomóż mi przy tym poprzez polubienie strony na fb i udostępnienie linku do bloga :) Z góry dziękuję. Do następnego razu Samouku!             Jest to swego rodzaju uproszczenie, w rzeczywistości pliki tekstowe zapisane są także jako ciąg danych binarnych, jednak programy takie jak notatnik wiedzą jak te dane interpretować i wyświetlają zwykły tekst. &#8617;       ","categories": ["Kurs programowania Java","Programowanie"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/operacje-na-plikach-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/08/17_operacje_na_plikach_artykul.jpg"},{
        "title": "Maszyna losująca",
        "excerpt":"Opis zadania W dzisiejszej części napiszesz program, który użyłem do rozstrzygnięcia konkursu, w którym Samouczek Programisty rozdawał książki. W konkursie należało wypełnić prostą ankietę, wśród uczestników zostały rozlosowane dwie książki. Każdy, kto uzupełnił ankietę dostawał jeden los. Dodatkowo, jeśli osoba wskazała kogoś innego jako polecającego, polecający dostawał dodatkowy los w loterii. Ankieta została przeprowadzona przy pomocy narzędzia Google Forms, z którego następnie wyniki zostały wyeksportowane do pliku CSV (ang. comma separated values). Plik CSV to jeden z formatów plików tekstowych, w którym jedna linijka odpowiada jednemu rekordowi. Plik ten zawiera kilka kolumn, których zawartość oddzielona jest przecinkami. Plik zawiera też nagłówek, opisujący nazwy kolumn. W przykładzie poniżej mamy dwa rekordy z takiego pliku. Irek dostaje dwa losy, Mateusz jeden. Dzieje się tak ponieważ Irek polecił Samouczka Mateuszowi. \"Timestamp\",\"Jak masz na imię?\",\"Jaki jest Twój adres e-mail?\",\"Temat artykułu\",\"Kto polecił Ci stronę www.samouczekprogramisty.pl (podaj adres e-mail)?\"\"2016/08/15 7:16:38 PM GMT+2\",\"Irek\",\"xxx@gmail.com\",\"Scrum lub Agile\",\"\"\"2016/08/15 7:33:13 PM GMT+2\",\"Mateusz\",\"yyy@gmail.com\",\"Algorytmika\",\"xxx@gmail.com\"Twoim zadaniem jest napisanie programu, który pobierze od użytkownika dwa argumenty:   ścieżkę do pliku wejściowego w formacie CSV na dysku opisanym powyżej (możesz ściągnąć przykładowy plik, który dla Ciebie przygotowałem),  liczbę N &gt;= 1 przedstawiającą liczbę wygrywających.Program powinien wczytać zawartość pliku, wyłuskać adresy e-mail, a następnie wśród tych adresów wylosować N wygranych. Dla uproszczenia zakładamy, że format pliku jest poprawny oraz, że uczestnicy konkursu nie oszukiwali (nie było podwójnych losów). Sytuacja w której jeden uczestnik wygrywa dwie książki jest dopuszczalna.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Wskazówki Dla uproszczenia pokażę Ci parę fragmentów kodu czy metod, które mogą Ci się przydać w rozwiązaniu tego zadania. Aby podzielić rekord na poszczególne pola możesz użyć metody String.split jak w przykładzie poniżej String[] fields = line.split(\",\");Aby z pola otoczonego znakami \"\" uzyskać wyłącznie jego zawartość możesz użyć wyrażeń regularnych. Na tym etapie proszę użyj przykładowego kodu, o tym czym są wyrażenia regularne przeczytasz w innym artykule. private final static Pattern FIELD_PATTERN = Pattern.compile(\"^\\\"(.+)\\\"$\");private static String parseField(String field) { Matcher fieldMatcher = FIELD_PATTERN.matcher(field); if (fieldMatcher.matches()) { return fieldMatcher.group(1); } return null;}Metoda ta jako argument przyjmuje wartość pola i zwraca to co znajduje się wewnątrz \"\" bądź null jeśli pole nie było uzupełnione. Aby wybrać losowo X wartości musisz losowo rozłożyć adresy e-mail z pliku. Pomóc Ci w tym może metoda Collections.shuffle, która w losowy sposób miesza elementy listy. Z tymi narzędziami jesteś przygotowany do napisania swojej pierwszej maszyny losującej :) Jeśli będziesz miał jakiekolwiek pytania możesz zasugerować się przykładowym rozwiązaniem, które dla Ciebie przygotowałem. Jak zwykle zachęcam jednak do samodzielnego rozwiązania zadania, w ten sposób nauczysz się najwięcej. Podsumowanie Jeśli tego typu sposób nauki Ci się spodobał proszę daj znać ;) Rozwiązując zadania tego typu w praktyczny sposób przećwiczysz wiedzę, którą zdobyłeś do tej pory. Z biegiem czasu będziesz w stanie rozwiązać zadania o coraz większym poziomie trudności. Wszystko przed Tobą ;) Na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największego grona czytelników, proszę pomóż mi w tym :) Udostępnij link do bloga na FB swoim znajomym, możesz także zapisać się do newslettera jeśli nie chcesz pominąć kolejnych artykułów. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/zadanie-maszyna-losujaca/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/08/22_zadanie_maszyna_losujaca_artykul.jpg"},{
        "title": "Konstrukcja try-with-resources w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Try-with-resources Pamiętasz w jaki sposób musieliśmy obchodzić się ze strumieniami danych? Trzeba było koniecznie pamiętać o ich zamknięciu. Generowało to sporą masę powtarzalnego kodu (ang. boilerplate code). Dobrą praktyką jest unikanie, powtórzeń – mniej kodu źródłowego, mniej miejsc do popełniania potencjalnego błędu :). Tutaj z pomocą przyszli twórcy Javy, wprowadzając konstrukcję „try-with-resources”. Tego typu konstrukcję możemy nazwać cukrem syntaktycznym (ang. syntactic sugar). Takie konstrukcje upraszczają kod, jednak nie są niezbędne dla języka programowania. Innymi słowy programista mógłby sobie bez takich konstrukcji poradzić, jednak ich obecność zmniejsza ilość kodu, która jest potrzebna do wykonania tego samego zadania. Najlepiej będzie jeśli zobaczymy to na przykładzie. Poniższy fragment kodu prezentuje odczytanie linijki z pliku tekstowego. W tym przykładzie także obsługujemy wyjątki, nie są one wspomniane w sygnaturze metody po klauzuli throws więc odpowiednie bloki catch muszą się znaleźć aby kompilator pozwolił nam ten kod skompilować (pamiętasz wyjątki typu checked i unchecked?) BufferedReader fileReader = null;try {    fileReader = new BufferedReader(new FileReader(inputPath));    fileReader.readLine();} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();} finally {    if (fileReader != null) {        try {            fileReader.close();        } catch (IOException e) {            e.printStackTrace();        }    }}Prawda, że dużo tego? I tu z pomocą przychodzi konstrukcja try-with-resources, zobacz proszę jak ona wygląda: try(BufferedReader fileReader = new BufferedReader(new FileReader(inputPath))) {    fileReader.readLine();} catch (FileNotFoundException e) {    e.printStackTrace();} catch (IOException e) {    e.printStackTrace();}Konstrukcja wygląda jak try/catch z tym, że przez blokiem objętym try możemy zainicjalizować zmienne, które zostaną automatycznie zamknięte. Kompilator widząc konstrukcję try-with-resources wygeneruje za nas kod zbliżony do tego z pierwszego przykładu (w podobny sposób generuje np. domyślne konstruktory). Konstrukcję try-with-resources możemy nazwać także „menadżerem kontekstu”, automatycznie zarządza ona za nas kontekstem, w ramach którego dostępne są zmienne zdefiniowane wewnątrz nawiasów (). Co więcej, wewnątrz tych nawiasów możemy zainicjalizować więcej zmiennych, każda z nich zostanie poprawnie zamknięta (zostanie na nich wywołana metoda close). W przykładzie poniżej odczytujemy linijkę z pliku wejściowego i zapisujemy ją do pliku wyjściowego (tutaj pominąłem obsługę wyjątków): try(        BufferedReader fileReader = new BufferedReader(new FileReader(inputPath));        BufferedWriter fileWriter = new BufferedWriter(new FileWriter(outputPath))) {    String line = fileReader.readLine();    fileWriter.write(line);}Taka struktura tłumaczona jest przez kompilator na sekwencję zagnieżdżonych bloków try/catch/finally. W każdym z tych zagnieżdżonych bloków zarządza kolejną zmienną. Zmienne zamykane są w odwrotnej kolejności niż są deklarowane, zatem w naszym przykładzie pierwszy zostanie zamknięty fileWriter po nim fileReader.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Własne menadżery kontekstu Całość działa, ponieważ klasy takie jak BufferedFileWriter czy BufferedFileReader implementują interfejs java.lang.AutoCloseable. Właściwie to wszystkie znane mi klasy do obsługi strumieni wejściowych/wyjściowych w standardowej bibliotece Javy implementują ten interfejs. To jest właśnie główne wymaganie, które musi być spełnione przez zmienne definiowane wewnątrz () gdy używamy konstrukcji try-with-resources. Nasunąć się zatem może pytanie, czy możemy stworzyć własną klasę, która będzie działała z tą konstrukcją? Oczywiście! :) Poniżej przykład: public class MyContextManager implements AutoCloseable {    public MyContextManager() {        System.out.println(\"Wlasnie sie tworze!\");    }    public void doSomething() {        System.out.println(\"Wlasnie cos robie :)\");    }    public void close() {        System.out.println(\"Ktos mnie teraz zamyka!\");    }}public class MyContextManagerMain {    public static void main(String[] args) {        try (MyContextManager manager = new MyContextManager()) {            manager.doSomething();        }    }}MyContextManager implementuje interfejs AutoCloseable dzięki czemu możemy użyć go wewnątrz konstrukcji try-with-resources. Jeśli uruchomiłbyś metodę main z powyższego przykładu na konsoli pojawiłyby się następujące linijki: Wlasnie sie tworze!Wlasnie cos robie :)Ktos mnie teraz zamyka!Widzisz? Metody close nie wywoływałem nigdzie, a mimo to została automatycznie wykonana podczas działania programu. Stało się tak właśnie dzięki kompilatorowi, który przetłumaczył konstrukcję try-with-resources na kod, który poprawnie zamyka zmienne. Zadanie Teraz nadszedł czas na zadanie dla Ciebie. Strony w internecie tworzone są przy pomocy HTML, jest to język znaczników, który jest interpretowany przez przeglądarki internetowe wyświetlające strony www. Przykładem znaczników jest para &lt;em&gt;tekst&lt;/em&gt;, jak widzisz jest tu znacznik otwierający &lt;em&gt; oraz zamykający &lt;/em&gt; (akurat ta para odpowiedzialna jest za wyróżnianie tekstu). Wewnątrz znaczników znajduje się treść np. tekst. Istnieje wiele innych par znaczników np. &lt;h1&gt;&lt;/h1&gt;, &lt;p&gt;&lt;/p&gt;, &lt;ul&gt;&lt;/ul&gt; itd., Zaimplementuj klasę HtmlTag, która będzie menadżerem kontekstu. W konstruktorze powinna przyjmować nazwę znacznika np. em. Klasa powinna mieć metodę body, która przyjmie parametr typu String i wypisze go na konsoli. Uruchamiając kod try (        HtmlTag h1 = new HtmlTag(\"h1\");        HtmlTag em = new HtmlTag(\"em\")) {    em.body(\"moj tekst\");}Na konsoli powinien znaleźć się tekst &lt;h1&gt;&lt;em&gt;moj tekst&lt;/em&gt;&lt;/h1&gt;Jak zwykle zachęcam do samodzielnego rozwiązania zadania, jeśli jednak utknąłbyś przygotowałem przykładowe rozwiązanie, które może Ci pomóc. Materiały dodatkowe   dokumentacja interfejsu AutoCloseable  sekcja z Java Language Specification opisująca konstrukcję try-with-resources  kod źródłowy przykładów i rozwiązanie zadaniaPodsumowanie Po przeczytaniu artykułu wiesz już jak używać konstrukcji try-with-resources, wiesz czym jest cukier syntaktyczny. Mam nadzieję, że spędziłeś trochę czasu rozwiązując zadanie, które pozwoliło Ci przećwiczyć wiedzę w praktyce. Na koniec mam do Ciebie wielką prośbę, zależy mi na dotarciu do jak największej liczby czytelników, możesz mi w tym pomóc polecając blog znajomym i udostępniając link na facebooku, z góry dziękuję i do następnego razu. ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/konstrukcja-try-with-resources-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/08/25_try-with-resources_artykul.jpg"},{
        "title": "Serializacja w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Czym jest serializacja W jednym z poprzednich artykułów przeczytałeś o strumieniach danych, które pozwalały na zapisywanie oraz odczytywanie danych. Poznałeś wówczas między innymi klasy DataInputStream oraz DataOutputStream. Klasy te pomagają zapisywać typy proste i łańcuchy znaków. Serializacja to wbudowany mechanizm zapisywania obiektów, który pozwala na binarny zapis całego drzewa obiektów. Oznacza to tyle, że jeśli mamy obiekt X, który posiada referencję do obiektu Y to serializując X również Y zostanie automatycznie zapisany w strumieniu wyjściowym. Tak zapisany obiekt możesz później otworzyć przy kolejnym uruchomieniu programu. Jednak serializacja ma więcej zastosowań. Dzięki temu mechanizmowi można na przykład przesyłać obiekty przez sieć. Obiekt, który stworzyliśmy na jednym komputerze (wewnątrz pamięci jednej wirtualnej maszyny Java) może być zserializowany, przesłany przez sieć i zdeserializowany na drugim komputerze tworząc nową instancję obiektu (wewnątrz pamięci drugiej wirtualnej maszyny Javy). Na obu tych komputerach wirtualna maszyna Javy musi mieć dostęp do skompilowanej wersji klasy.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Warunki wymagane do serializacji Chociaż serializacja dostępna jest automatycznie dla większości obiektów z biblioteki standardowej to jeśli chcesz móc serializować instancje klas, które sam napiszesz musisz spełnić kilka warunków. Interfejs java.io.Serializable Jest to tak zwany interfejs znacznikowy, innymi słowy nie zwiera on żadnej metody. Służy on do pokazania wirtualnej maszynie, że instancje danej klasy implementującej ten interfejs mogą być serializowane. Musisz implementować ten interfejs jeśli chcesz aby twoje klasy były serializowalne. Jeśli będziesz próbował zserializować klasę, która nie implementuje tego interfejsu zostanie rzucony wyjątek typu NotSerializableException. Konstruktor bezparametrowy Tutaj reguła niestety nie jest trywialna. Pierwsza klasa w hierarchii dziedziczenia, która nie jest serializowalna musi mieć dostępny konstruktor bezparametrowy. Łatwiej to będzie zrozumieć na przykładzie: public class Fruit {}public class Apple extends Fruit implements Serializable {}public class Tomato implements Serializable {}W przykładzie powyżej klasa Fruit musi mieć konstruktor bezparametrowy abyśmy mogli poprawnie serializować instancje klasy Apple. Natomiast ani Apple, ani Tomato takiego konstruktora już nie wymagają (Tomato dziedziczy po Object, który taki konstruktor posiada). Dodatkowo istnieje interfejs java.io.Externalizable (opiszę go dokładnie kilka akapitów niżej), który również zapewnia, że obiekty go implementujące są serializowalne. Jednak w tym przypadku obiekt taki musi także zapewnić konstruktor bezparametrowy, który jest wywoływany w trakcie deserializacji. Określić pola, które nie są serializowalne Ten krok jest opcjonalny, jednak w bardziej zaawansowanych przypadkach niezbędny. Wyobraź sobie, że napisałeś klasę Human, która jako jeden z atrybutów posiada wiek zapisany w minutach od urodzenia. Zapisanie tego pola mogłoby prowadzić do odczytania niepoprawnego stanu (zapisujemy obiekt dzisiaj, odczytujemy jutro, wiek w minutach jest zupełnie inny). Tutaj dochodzimy do słowa kluczowego transient. Otóż słowo to może być stosowane przed atrybutami klasy. Oznacza ono, że dany atrybut nie jest serializowalny i zostanie pominięty przez mechanizm serializacji1. Przykład serializacji obiektu Proszę zwróć uwagę na fragment kodu poniżej, który pokazuje jak mechanizm serializacji działa w praktyce. try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"objects.bin\"))) {    outputStream.writeObject(Integer.valueOf(1));    outputStream.writeObject(Integer.valueOf(2));}try (ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"objects.bin\"))) {    Integer number = (Integer) inputStream.readObject();    System.out.println(number);    number = (Integer) inputStream.readObject();    System.out.println(number);}W pierwszym bloku try-with-resources otwieramy strumień typu ObjectOutputStream, na którym następnie wywołujemy metodę writeObject zapisując do strumienia dwie liczby. W kolejnym bloku dzięki instancji ObjectInputStream odczytujemy wcześniej zapisane obiekty. Obiekty odczytywane są w takiej samej kolejności w jakiej zostały zapisane, w naszym przypadku na konsoli zostaną wyświetlone liczby 1 a później 2. Serializacja drzewa obiektów Wspomniałem już wcześniej, że mechanizm serializacji automatycznie obsługuje drzewa obiektów. W przykładzie poniżej pokazana jest właśnie taka sytuacja. Instancja klasy Car posiada atrybuty typów Engine oraz Tyre[]. Serializując a następnie deserializując instancję tej klasy wszystkie jej atrybuty zostały także zapisane. Tyre[] tyres = new Tyre[] {new Tyre(16), new Tyre(16), new Tyre(16), new Tyre(16)};Engine engine = new Engine(\"some model\");Car serializedCar = new Car(engine, tyres);try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"object-graph.bin\"))) {    outputStream.writeObject(serializedCar);}Car deserializedCar = null;try (ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"object-graph.bin\"))) {    deserializedCar = (Car) inputStream.readObject();    System.out.println(deserializedCar.getEngine().getModel());    System.out.println(deserializedCar.getTyres().length);}System.out.println(serializedCar == deserializedCar);Zwróć proszę uwagę na ostatnią linię. W linijce tej porównywane są dwa adresy instancji klasy Car (pamiętasz różnicę między == a equals?). Oczywiście linijka ta wyświetli false na konsoli co dowodzi, że w procesie deserializacji został stworzony zupełnie nowy obiekt klasy Engine. Deserializacja atrybutów transient Zaraz, jak to? Przecież kilka akapitów wyżej napisałem, że atrybuty poprzedzone słowem kluczowym transient nie są serializowane. Tak to prawda, jednak podczas deserializacji atrybuty tego typu należy zainicjalizować pewną wartością. Otóż dla każdego typu mamy taką domyślną wartość:   boolean - false,  liczby całkowite (int, long, itd.) - 0,  liczby ułamkowe (float, duble) - 0.0,  obiekty (Integer, Float, String, CustomClass, itd.) - nullpublic class Human implements Serializable {    private static final long serialVersionUID = 1L;    private transient Integer age;    private String name;    public Human(String name, Integer age) {        this.age = age;        this.name = name;    }    public Integer getAge() {        return age;    }    public String getName() {        return name;    }    public static void main(String[] args) throws IOException, ClassNotFoundException {        Human human = new Human(\"Krzysiek\", 21);        try (ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"human.bin\"))) {            output.writeObject(human);        }        try (ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"human.bin\"))) {            Human readHuman = (Human) input.readObject();            System.out.println(readHuman.getName());            System.out.println(readHuman.getAge());        }    }}W przykładzie powyżej po deserializacji pole age będzie miało wartość null ponieważ jest to wartość domyślna dla atrybutów poprzedzonych słowem kluczowym transient, które są obiektami. Pola statyczne a serializacja Serializacja dotyczy instancji klasy, nie samej klasy. Zatem jeśli zmodyfikowałeś pole statyczne a następnie zdeserializowałeś taki obiekt wprowadzone zmiany zostaną pominięte. Proszę spójrz na przykład poniżej. StaticSerialization object = new StaticSerialization();object.someField = 200;System.out.println(object.someField);try (ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"static.bin\"))) {    output.writeObject(object);}W przykładzie tym modyfikujemy wartość pola statycznego someField a następnie serializujemy instancję klasy do pliku. try (ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"static.bin\"))) {    StaticSerialization otherObject = (StaticSerialization) input.readObject();    System.out.println(otherObject.someField);}W drugim uruchomieniu programu (w którym nie zmodyfikowaliśmy wartości atrybutu statycznego someField) deserializujemy ten sam plik. W tym przypadku otrzymamy wartość 100 a nie 200, które miał obiekt zapisywany do pliku. To co trzeba zapamiętać to to, że pola statyczne nie są serializowane a są pobierane z aktualnej definicji klasy (nie z klasy z momentu serializacji). Możemy powiedzieć, że atrybuty static są też domyślnie transient. Jak zatem takie zmiany odzwierciedlić podczas deserializacji? Jest na to sposób :) Specjalna obsługa serializacji/deserializacji W specyficznych przypadkach masz możliwość zmodyfikowania domyślnego zachowania mechanizmu serializacji. Możesz to zrobić jeśli zaimplementujesz poniższe metody. private void readObject(java.io.ObjectInputStream stream) throws IOException, ClassNotFoundExceptionprivate void writeObject(java.io.ObjectOutputStream stream) throws IOExceptionMetoda readObject(java.io.ObjectInputStream stream), którą zaimplementujesz jest automatycznie wywoływana w momencie odczytywania obiektu ze strumienia, czyli w trakcie wywołania metodyObjectInputStream.readObject(). Mechanizm ten wygląda podobnie w przypadku zapisu obiektu. Metoda writeObject(java.io.ObjectOutputStream stream), którą zaimplementujesz jest automatycznie wywoływana w momencie zapisywania obiektu do strumienia, czyli w trakcie wywołania metody ObjectOutputStream.writeObject(). Poniższy przykład powinien Ci pomóc w zrozumieniu tego mechanizmu: public class CustomSerialization implements Serializable {    private static final long serialVersionUID = 1L;    private transient int someField;    private String otherField;    public CustomSerialization(int someField, String otherField) {        this.someField = someField;        this.otherField = otherField;    }    public static void main(String[] args) throws IOException, ClassNotFoundException {        CustomSerialization writtenObject = new CustomSerialization(10, \"something\");        try (ObjectOutputStream outputStream = new ObjectOutputStream(new FileOutputStream(\"custom-serialization.bin\"))) {            outputStream.writeObject(writtenObject);        }        try (ObjectInputStream inputStream = new ObjectInputStream(new FileInputStream(\"custom-serialization.bin\"   ))) {            CustomSerialization readObject = (CustomSerialization) inputStream.readObject();            System.out.println(readObject.someField);            System.out.println(readObject.otherField);        }    }    private void readObject(ObjectInputStream stream) throws IOException, ClassNotFoundException {        stream.defaultReadObject();        someField = stream.readInt();    }    private void writeObject(ObjectOutputStream stream) throws IOException {        stream.defaultWriteObject();        stream.writeInt(someField + 1000);    }}Jak widzisz obie metody są tu zaimplementowane. writeObject jako argument dostaje strumień, do którego powinniśmy zapisać nasz obiekt. Metoda readObject jako jedyny argument przyjmuje strumień, z którego powinniśmy odczytać stan obiektu. Warto tutaj zwrócić uwagę na to, że klasa ObjectInputStream posiada metodę defaultReadObject, która przeprowadza standardową deserializację, którą możesz rozszerzyć. Podobnie wygląda to w przypadku klasy ObjectOutputStream i metody defaultWriteObject. Metody te mogą być wywołane wyłącznie w trakcie (de)serializacji obiektu. Zajmują się one (de)serializacją atrybutów klasy, które nie są oznaczone jako static lub transient. Serializacja a dziedziczenie W poprzednich przykładach użyliśmy klasy Engine, która implementuje interfejs Serializable. Załóżmy, że utworzyliśmy klasę DieselEngine, która dziedziczy po Engine. Automatycznie instancje klasy DieselEngine będą implementowały interfejs Serializable (dziedzicząc go z Engine). Co powinniśmy zrobić jeśli nie chcielibyśmy aby nasz DieselEngine był serializowalny? Należy użyć wspomnianego już wyjątku NotSerializableException jak w przykładzie poniżej: public class DieselEngine extends Engine {    public DieselEngine() {        super(\"diesel\");    }     private void writeObject(ObjectOutputStream out) throws IOException {        throw new NotSerializableException(\"DieselEngine isn't serializable!\");    }     private void readObject(ObjectInputStream in) throws IOException {        throw new NotSerializableException(\"DieselEngine isn't serializable!\");    }}Pełny wpływ na mechanizm serializacji Istnieje jeszcze jeden, dużo mniej popularny sposób zapewnienia iż obiekt może być serializowany. Jest nim interfejs Externalizable. W tym przypadku interfejs ten zawiera dwie metody, które musimy zaimplementować. Dodatkowo takie klasy muszą mieć konstruktor bezparametrowy, reszta pozostaje bez zmian. W przypadku tego podejścia cały protokół serializacji, kolejność zapisanych pól, format etc. leży po naszej stronie. Poniżej prosty przykład, w którym używam właśnie takiego podejścia. W tym przypadku do utworzenia obiektu mechanizm serializacji używa standardowego konstruktora bezparametrowego. Po czym wywołuje na tej instancji metodę readExternal. public class CustomProtocolSerialization implements Externalizable {    private String field;     public CustomProtocolSerialization() {    }     public CustomProtocolSerialization(String field) {        this.field = field;    }     public static void main(String[] args) throws IOException, ClassNotFoundException {        CustomProtocolSerialization object = new CustomProtocolSerialization(\"field value\");         try (ObjectOutputStream output = new ObjectOutputStream(new FileOutputStream(\"externalizable.bin\"))) {            output.writeObject(object);        }         try (ObjectInputStream input = new ObjectInputStream(new FileInputStream(\"externalizable.bin\"))) {            CustomProtocolSerialization readObject = (CustomProtocolSerialization) input.readObject();            System.out.println(readObject.field);        }    }     public void writeExternal(ObjectOutput out) throws IOException {        out.writeUTF(field);    }     public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {        field = in.readUTF();    }}Pole serialVersionUID Dodatkowo musisz wiedzieć o statycznym polu w klasie o nazwie serialVersionUID. Jego pełna definicja wygląda następująco: private static long serialVersionUID;Pole to ma specyficzne zastosowanie. Mechanizm serializacji używa go do upewnienia się, że deserializowany obiekt „pasuje” do danych zapisanych w strumieniu. Wie o tym na podstawie wartości tego pola. Jeśli w zdeserializowanym obiekcie wartość tego pola jest taka sama jak aktualnej definicji klasy wówczas można bezpiecznie przeprowadzić deserializację. Kiedy taka sytuacja może wystąpić? Załóżmy, że dzisiaj napiszesz klasę Human, zdeserializujesz jej instancję i zapiszesz w pliku na dysku. Po jakimś czasie wprowadzisz zmiany w klasie i będziesz chciał odczytać starą wersję z pliku. W niektórych przypadkach taka operacja nie będzie dozwolona. Właśnie wtedy pole serialVersionUID może pomóc w wykryciu takiej sytuacji. Pole to możesz ustawić samodzielnie, jeśli tego nie zrobisz kompilator wygeneruje tę wartość za Ciebie na podstawie definicji klasy. Materiały dodatkowe Na początek zestaw dokumentacji do klas, związanych z tematem, jak zwykle znajdziesz tam ogrom informacji.   Serializable  Externalizable  ObjectOutputStream  ObjectInputStream  NotSerializableExceptionDodatkowo możesz zajrzeć do specyfikacja mechanizmu serializacji albo artykułu na stronie Oracle. Znalazłem też inne opracowanie, które poruszą także zagadnienie serializacji, także do formatu XML. Możesz też rzucić okiem na przykłady użyte w tym artykule. Zadania Na koniec jak zwykle zadania dla Ciebie do przećwiczenia materiału z tego artykułu.   Napisz program, który poprosi użytkownika o wprowadzenie kilku imion, imiona te zapisz w liście a następnie zserializuj ją do pliku. Napisz metodę, która odczyta ten plik i wyświetli zawartość listy na konsoli. Wiesz, że właśnie napisałeś prostą bazę danych? ;)  Napisz klasę Human, która będzie miała dwa atrybuty name typu String oraz age typu int. Jak należałoby serializować instancje tej klasy aby zawsze poprawnie deserializować wiek (z dokładnością do roku)? (Wskazówka, możesz użyć metody Calendar.getInstance().get(Calendar.YEAR), która zwraca aktualny rok)Przygotowałem też dla Ciebie przykładowe rozwiązania powyższych zadań, jednak traktuj je proszę jako ostatnią deskę ratunku :) Więcej nauczysz się próbując samemu rozwiązać powyższe zadania. Podsumowanie Po przeczytaniu tego artykułu wiesz już czym są klasy ObjectOutputStream i ObjectInputStream. Znasz zasady serializacji, poznałeś słowo kluczowe transient. Teraz jesteś w stanie zapisać i odczytać każdą instancję klasy, którą stworzysz. Bardzo się cieszę, że przeczytałeś cały artykuł. Na koniec mam do Ciebie prośbę. Proszę przekaż adres bloga swoim znajomym, w grupie uczy się raźniej ;) Jeśli nie chcesz ominąć nowych artykułów dopisz się do newslettera i polub stronę Samouczka na Facebooku. Miłego dnia i do następnego razu :)             Istnieje też inny, mniej popularny sposób ominięcia pól podczas serializacji– użycie pola serialPersistentFields (jest ono dokładniej opisane w specyfikacji). &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/serializacja-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/09/02_serializacja_artykul.jpg"},{
        "title": "Typ wyliczeniowy w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Enum, typ wyliczeniowy Wyobraź sobie, że mamy klasę Tshirt, która posiada kilka atrybutów takich jak kolor, rozmiar czy producent. O ile producentów koszulek, podobnie jak ich kolorów jest dość dużo to rozmiary są już bardzo często wspólne dla różnych producentów. Rozmiary możemy wyliczyć: S, M, L czy XL. I właśnie do przechowywania danych tego typu Java ma specjalny typ. Jest to enum zwany także typem wyliczeniowym. Przejdźmy od razu do przykładu: public enum TshirtSize {    S,    M,    L,    XL}Fragment kodu powyżej pokazuje typ wyliczeniowy TshirtSize, który może mieć jedną z czterech wartości S, M, L lub XL. Kolejne wartości typu wyliczeniowego oddzielamy przecinkiem. Konwencja nadawania nazw zaleca aby wartości dla typu enum pisane były drukowanymi literami. Zatem TshirtSize.S jest w porządku, podczas gdy TshirtSize.s już nie. Proszę spójrz na przykład użycia: public class Tshirt {    private TshirtSize size;    private String manufacturer;    public Tshirt(TshirtSize size, String manufacturer) {        this.size = size;        this.manufacturer = manufacturer;    }    public static void main(String[] args) {        Tshirt tshirt = new Tshirt(TshirtSize.L, \"Polex\");        System.out.println(tshirt.size);    }}Jak widzisz w przykładzie wyżej mamy klasę Tshirt, reprezentującą koszulkę, która jako jeden z atrybutów ma właśnie rozmiar, który jest typu TshirtSize. Do wartości typu wyliczeniowego odnosimy się jak do pól statycznych klasy, zatem w naszym przypadku do rozmiaru L możemy odwołać się jako TshirtSize.L. Dzieję się tak ponieważ w rzeczywistości wartości typu wyliczeniowego mają automatycznie dodane modyfikatory public static final.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Typ wyliczeniowy a blok switch W jednym z poprzednich artykułów poznałeś konstrukcję switch. W tamtej części wspomniałem, o tym, że wewnątrz tej konstrukcji możemy używać liczb całkowitych czy łańcuchów znaków. Pominąłem wówczas jedną z dodatkowych wartości konstrukcji switch. Otóż wewnątrz możemy użyć także typu wyliczeniowego jak w przykładzie poniżej: switch (tshirt.size) {    case S:        System.out.println(\"Kupiles koszulke w rozmiarze small\");        break;    case M:        System.out.println(\"Kupiles koszulke w rozmiarze medium\");        break;    case L:        System.out.println(\"Kupiles koszulke w rozmiarze large\");        break;    case XL:        System.out.println(\"Kupiles koszulke w rozmiarze extra large\");        break;}W takim przypadku w zależności od wartości zmiennej size zostanie wywołana odpowiedni blok konstrukcji switch. Proszę zauważ, że w tym przypadku kompilator dokładnie wie jakiego typu są wartości L, M, S czy XL i nie możemy się do nich odwoływać poprzez pełną nazwę TshirtSize.M. Typ wyliczeniowy to też klasa Podobnie jak w przypadku normalnych klas tak i w przypadku typów wyliczeniowych może on posiadać atrybuty czy metody. Możesz także stworzyć klasę wyliczeniową, która będzie miała swój własny konstruktor inny od domyślnego. Spójrz na przykład poniżej public enum TshirtSize {    S(48, 71, 36),    M(52, 74, 38),    L(56, 76, 41),    XL(61, 79, 41);     private int chestWidth;    private int shirtLength;    private int sleeveLength;     TshirtSize(int chestWidth, int shirtLength, int sleeveLength) {        this.chestWidth = chestWidth;        this.shirtLength = shirtLength;        this.sleeveLength = sleeveLength;    }        public int getChestWidth() {        return chestWidth;    }     public int getShirtLength() {        return shirtLength;    }     public int getSleeveLength() {        return sleeveLength;    }}W przykładzie nasz enum został rozszerzony o trzy atrybuty: szerokość klatki piersiowej, długość koszulki i długość rękawa. Dzięki dodaniu atrybutów do typu wyliczeniowego wszystkie potrzebne dane związane z jednym rozmiarem mamy zgrupowane w jednym miejscu. Każdy typ wyliczeniowy, który napiszesz domyślnie tworzony jest jako typ final. Ograniczone są także modyfikatory dostępu, które możesz użyć, w przypadków enumów dopuszczalny jest wyłącznie modyfikator public lub brak jakiegokolwiek modyfikatora dostępu. Typ wyliczeniowy nie może określić żadnej nadklasy po której dziedziczy. Dzieje się tak ponieważ każdy enum domyślnie dziedziczy po java.lang.Enum. Dzięki tej nadklasie wszystkie typy wyliczeniowe zyskują kilka dodatkowych metod opisanych w kolejnych akapitach. Jeśli nasz enum ma także metody czy konstruktory to lista jego wartości musi znajdować się na początku. Słów kilka o konstruktorze enuma Mimo tego, że jesteś w stanie utworzyć swój konstruktor dla typu wyliczeniowego to nie możesz go wywołać poza definicją enuma. Każde inne użycie powoduje błąd kompilacji. To ile wartości ma typ wyliczeniowy określasz w kodzie, nie możesz tworzyć nowych instancji w trakcie działania programu. Konstruktor domyślne ma przypisane słowo kluczowe private „dodawane przez kompilator”. Porównywanie typów wyliczeniowych Poza konstrukcją switch typy wyliczeniowe możemy także stosować w blokach if. Możemy porównywać ich wartości przy pomocy operatora ==. Oczywiście metoda equals też będzie działała jak się tego spodziewasz. W rzeczywistości wewnątrz metody equals w typie wyliczeniowym do porównania użyty jest właśnie operator ==. Metody dostępne w każdym typie wyliczeniowym Dzięki nadklasie Enum, o której wspomniałem w jednym z poprzednich akapitów mamy dostęp do kilku dodatkowych metod. ordinal, metoda zwraca indeks aktualnej wartości typu wyliczeniowego. Indeks pierwszego elementu to zawsze 0. W związku z tym kolejność definiowania wartości typu wyliczeniowego jest istotna. Przydatna jest także metoda name, która zwraca nazwę wartości typu wyliczeniowego. W naszym przypadku TshirtSize.L.name() zwróci \"L\". Wszystkie typy wyliczeniowe mają także przydatne metody statyczne. Jedną z nich jest metoda values. Pozwala ona na iterowanie po wartościach typu wyliczeniowego. Zwraca tablicę wartości typu wyliczeniowego Dostępna jest także metoda valueOf, która przyjmuje łańcuch znaków i zwraca wartość typu wyliczeniowego. W naszym przypadku TshirtSize.valueOf(\"L\") zwróci TshirtSize.L. Kiedy i po co używać typów wyliczeniowych Typów wyliczeniowych/enumów używamy w momencie jeśli jakiś atrybut/zmienna może mieć określoną, ograniczoną listę wartości. Zastosowanie typu wyliczeniowego może pomóc ograniczyć liczbę błędów, na przykład w miejscu gdzie normalnie używalibyśmy łańcucha znaków reprezentującego rozmiar używamy dokładnie zdefiniowanego typu wyliczeniowego. Dzięki typom wyliczeniowym możemy w jednym miejscu zgrupować wszystkie dopuszczalne wartości. Pozwala to także na łatwe rozszerzanie tej listy. Metody abstrakcyjne w typie wyliczeniowym Poza zwykłymi metodami, konstruktorami czy atrybutami enumy mogą posiadać metody abstrakcyjne. Tylko gdzie mielibyśmy je zaimplementować jeśli jedyne instancje typu wyliczeniowego musimy zdefiniować w klasie? Proszę spójrz na przykład poniżej. public enum Formatter {    CALM {        public String format(String message) {            return \"Here is your message: \" + message;        }    },    NERVOUS {        public String format(String message) {            return \"ARGH! STOP BOTHERING ME WITH YOUR MESSAGE! \" + message + \" I'M NOT GOING TO ACCEPT ANYTHING MORE!\";        }    };     public abstract String format(String message);}Konstrukcja taka jak na przykładzie powyżej to nic innego jak zdefiniowanie ciała metody format wewnątrz poszczególnych wartości. Dzięki takiemu podejściu metody Formatter.CALM.format() i Formatter.NERVOUS.format() mogą mieć różną implementację. Materiały dodatkowe Przygotowałem dla Ciebie zestaw materiałów dodatkowych jeśli chciałbyś poczytać na temat typów wyliczeniowch w innych miejscach.   https://rpodhajny.wordpress.com/2009/02/17/typ-enum  https://www.youtube.com/watch?v=IHcTGxFQSm8  https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html  https://docs.oracle.com/javase/8/docs/api/java/lang/Enum.html  https://docs.oracle.com/javase/specs/jls/se8/html/jls-8.html#jls-8.9  http://tutorials.jenkov.com/java/enums.htmlKod źródłowy dla wszystkich przykładów użytych w artykule znajduje się na githubie. Zadania   Napisz klasę Human, która będzie reprezentowała człowieka. Niech klasa ta posiada atrybuty takie jak imię, wiek, kolor oczu, kolor włosów. Niech te dwa ostatnie atrybuty będą typami wyliczeniowymi. Stwórz instancję takiej klasy.  Napisz typ wyliczeniowy Computation, który będzie reprezentował prosty kalkulator. Niech typ ten posiada następujące wartości MULTIPY, DIVIDE, ADD, SUBTRACT. Niech typ ten posiada metodę public double perform(double x, double y), która zwróci wynik odpowiedniej operacji. Na przykład Computation.ADD.perform(1, -5) powinno zwrócić -4.Przygotowałem dla Ciebie przykładowe rozwiązania. Proszę jednak abyś spróbował rozwiązać zadania samodzielnie, wówczas najwięcej się nauczysz. Kod rozwiązań znajdziesz w repozytorium na githubie. Podsumowanie Po przeczytaniu artykułu i zrobieniu zadań wiesz już wszystko na temat typów wyliczeniowych w Javie. Żadne zakamarki enumów nie są Ci obce :) Na koniec mam do Ciebie prośbę, proszę podziel się informacją o blogu ze swoimi znajomymi, udostępnienie linka do artykułu na facebooku naprawdę pomaga mi dotrzeć do jak największej liczby czytelników a na tym właśnie mi zależy. Jeśli masz jakiekolwiek pytania zadaj je w komentarzach, postaram się pomóc. A.. zapomniałbym, jeśli chcesz być jako pierwszy informowany o nowościach na stronie zapisz się do mojego newslettera :) Do następnego razu! ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/typ-wyliczeniowy-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/09/09_typ_wyliczeniowy_artykul.jpg"},{
        "title": "Adnotacje w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Adnotacja Czasami mogłeś zobaczyć w kodzie dziwną konstrukcje z @ np. @Override czy @NotNull. To właśnie były adnotacje. Adnotacje są konstrukcją, która pozwala na przekazywanie dodatkowych informacji na temat kodu. Informacje te mogą być wykorzystane później w kilku miejscach. Każde z tych zastosowań opiszę bardziej szczegółowo w kolejnych akapitach. Mówi się, że adnotacje służą do przekazywania metadanych. Innymi słowy przekazują one dane o danych - dane o kodzie źródłowym. “Pod spodem” adnotacja to nic innego jak specjalny rodzaj interfejsu. Adnotacje a JavaDoc Chociaż w obu przypadkach możesz zauwaćyć znak @ musisz wiedzieć, że adnotacje to coś zupełnie innego niż dyrektywy JavaDoc. JavaDoc to standardowy mechanizm do generowania dokumentacji, która zaszyta jest kodzie źródłowym. Na przykład we fragmencie kodu poniżej widzisz metodę wraz z dokumentacją. Zwróć proszę uwagę, że JavaDoc znajduje się wewnątrz specjalne sformatowanego kometarza wieloliniowego. który rozpoczyna się od /**, każda linia wewnątrz komentarza rozpoczyna się od *. Wewnątrz komentarza znajdują się specjalne dyrektywy, takie jak @param czy @return. Opisują one odpowiednio parametr oraz wartość zwracaną metody. /** * Multipies number by 2 * @param parameter number that should be multipied * @return parameter multipied by 2 */public int timesTwo(int parameter) {    return parameter * 2;}Mogą tam znajdować się również inne dyrektywy takie jak @see, @author czy @version. Na podstawie tak zapisanych informacji o kodzie generowana jest dokumentacja, na przykład dla klasy String. Adnotacje, w odróżnieniu od dyrektyw JavaDoc, nie są umieszczane wewnątrz komentarzy a poza nimi. Taka ilość informacji w zupełności wystarczy Ci aby odróżnić adnotacje od dyrektyw JavaDoc, przejdźmy zatem do zastosowania adnotacji.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Zakres adnotacji – dozwolone miejsca gdzie możemy stosować adnotacje Każda adnotacja określa, w którym miejscu możemy ją stosować. Mamy kilka standardowych miejsc, gdzie możemy wstawić adnotację.   metoda,  klasa,  atrybut klasy,  parametr metody,  zmienna lokalna,  konstruktor,  adnotacja typu (ang. type annotations).Adnotację umieszczamy zawsze przed kokretnym elementem, na przykład przed klasą. Zastosowanie adnotacji Adnotacje mają trzy główne zastosowania. Poniższe sekcje dokładniej opisują każde z nich. Dodatkowe informacje dla kompilatora Adnotacje mogą służyć jako dodatkowa informacja dla komplilatora. Za przykład może tu posłużyć adnotacja @Override. Jest to informacja dla kompilatora, że dana metoda przesłania metodę w nadklasie. Adnotacja @Override może też być używana do oznaczania metod interfejsu, które implementujemy. W przypadku tej adnotacji kompilator może wychwycić więcej błędów w trakcie kompilacji. Spójrz na przykład poniżej: public class EqualsOverride {    public boolean equal(Object obj) {        return true;    }}Programista chciał nadpisać metodę equals. Brakujące s na końcu metody sprawia, że w momencie porównywania obiektów tej klasy używamy odziedziczonej metody equals z klasy Object, która ma zupełnie inną implementację. Jeśli dodalibyśmy adnotację @Override to tej metody kompilator już na etapie kompilacji znalazłby błąd. Kompilacja nie powiodłaby się ponieważ nasza metoda nie nadpisała żadnej metody z nadklasy. Poniżej przykład metody equals z adnotacją. @Overridepublic boolean equals(Object obj) {    return true;}Adnotacje przetwarzane w trakcie kompilacji W trakcie kompilacji także możemy przetwarzać adnotacj. Dzięki nim możemy na przykład automatycznie generować kod czy dać znać kompilatorowi aby zachowywał się trochę inaczej. Przykładem takiej adnotacji jest @SuppressWarnings z biblioteki standardowej. Adnotacja ta pozwala nam wstrzymać pewne ostrzeżenie kompilatora. Proszę spójrz na przykład kodu poniżej. public static void main(String[] args) {    List listOfUndefinedObjects = new ArrayList();    List&lt;Integer&gt; listOfIntegers = (List&lt;Integer&gt;) listOfUndefinedObjects;}W metodzie main tworzymy zmienną lokalną listOfUndefinedObjects, która jest zwykłą listą. Nie używam tu typów generycznych. Linijkę niżej natomiast rzutuję tę zmienną na typ List&lt;Integer&gt;. Jeśli w listOfUndefinedObjects mielibyśmy instancję klasy String, wówczas pobranie elementu z nowej listOfIntegers skończyłoby się rzuceniem wyjątku ClassCastException (nie możemy rzutować String na Integer). Kompilator ostrzega nas o takiej możliwości pokazując ostrzeżenie Warning:(10, 56) java: unchecked castrequired: java.util.List&lt;java.lang.Integer&gt;found: java.util.ListJeśli jesteśmy pewni, że ta operacja jest poprawna (mamy pewność, że będą tam tylko instancje klasy Integer) i chcemy aby kompilator takich wyjątków nie pokazywał możemy użyć adnotacji @SuppressWarnings Akurat tę adnotację możemy przypisać do typu, atrybutu, metody, parametru metody, konstruktora czy nawet zmiennej lokalnej, jak zrobiłem to w przykładzie poniżej. public static void main(String[] args) {    List listOfUndefinedObjects = new ArrayList();    @SuppressWarnings(\"unchecked\")    List&lt;Integer&gt; listOfIntegers = (List&lt;Integer&gt;) listOfUndefinedObjects;}@SupressWarnings(„unchecked”) mówi aby kompilator nie ostrzegał nas o potencjalnych zagrożeniach typu unchecked przy tej konkretnej zmiennej. Adnotacje przetwarzane w trakcie uruchomienia programu Adnotacje mogą być także używane w trakcie działania programu. Służy do tego mechanizm refleksji. Mechanizm refleksji opiszę w osobnym artykule. Na potrzeby tego artykułu wystarczy, że wiesz o jej istnieniu oraz o tym, że dzięki niej możemy w trakcie działania programu pobierać informacje o skompilowanym kodzie. Przykładem takiej adnotacji jest na przykład @PostConstruct. Składnia definiowania adnotacji Java Language Specification definiuje adnotację jako specjalny rodzaj interfejsu. Szczerze mówiąc to porównanie nasuwa się samo jak zobaczysz przykładową definicję adnotacji. public @interface Override {}Definicja powyżej to nic innego jak znana Ci już adnotacja @Override. Zauważ znak @ przed słowem kluczowym interface. Dodatkowo definicja adnotacji powinna także posiadać informację o tym do jakich elementów może być stosowana. Ponadto znajduje się tam także informacja o tym jak długo dane o adnotacji powinny być przetrzymywane – retencja. Czy tylko w trakcie kompilacji czy także w trakcie uruchomienia programu. Ta ostatnia cecha (ang. retention) jest bardzo istotna gdy chcesz wykorzystywać adnotację w trakcie uruchomienia programu. Pełna definicja adnotacji @Override wraz z tymi informacjami przedstawiona jest w przykładzie poniżej @Target(ElementType.METHOD)@Retention(RetentionPolicy.SOURCE)public @interface Override {}Dopuszczalny kontekst użycia adnotacji Do określenia gdzie możemy użyć adnotację służy inna „meta-adnotacja” @Target. Jeśli ją pominiemy przy definiowaniu nowej adnotacji, możemy jej używać w każdym miejscu. Z jednym małym wyjątkiem – adnotacji typów. Miejsca gdzie możmy użyć adnotacji określone są przez wartości typu wyliczeniowego ElementType. Spójrz na przykład poniżej. @Target(ElementType.FIELD)public @interface SampleFieldAnnotation {String id();}Nasza @SampleFieldAnnotation może być użyta wyłącznie przy atrybutach klasy, ponieważ przypisaliśmy do niej ElementType.FIELD. Retencja adnotacji Adnotacje, które przypiszesz mają swój “cykl życia”. W zależności od typu adnotacji informacja o tym, że była ona przypisana do jakiegoś elementu może (ale nie musi) być “wymazana” przez kompilator w trakcie kompilacji. Zachowanie takie ma sens ponieważ nie potrzebujemy informacji w trakcie uruchomienia programu o adnotacjach, które są wykorzystywane wyłącznie podczas kompilacji. Takie “wymazywanie” adnotacji pozwala na stworzenie bajtkodu (skompilowanej klasy), który ma mniejszą objętość. Retencję (informacja o tym jak długo informacja o adnotacji powinna być przechowywana) także określamy przy pomocy adnotacji. Służy do tego „meta-adnotacja” @Retention. Informacje o adnotacji mogą być:   usuwane przez kompilator w trakcie kompilacji,  umieszczanie w skompilowanej klasie, ale nie dostępne w trakcie uruchomienia programu,  dostępne w trakcie uruchomienia programu.Wszystkie trzy sposoby określone są przez typ wyliczeniowy RetentionPolicy. Jeśli nie określimy retencji naszej własnej adnotacji (nie dodamy @Retention), wówczas przyjmie ona wartość domyślną RetentionPolicy.CLASS. Innymi słowy, jeśli nie określimy inaczej informacje o adnotacji są zapisywane w pliku class jednak nie są dostępne w trakcie uruchomienia programu. Elementy adnotacji Zauważ, że niektóre adnotacje posiadają „argumenty”. W kontekście adnotacji argumenty te nazywamy elementami. Na przykład w przypadku adnotacji @SuppressWarnings przekazywaliśmy informację o tym jakiego typu ostrzeżenia kompilatora chcemy pomijać. Każda adnotacja może mieć elementy, które możemy uzupełnić przy przypisywaniu adnotacji. Możemy je rozumieć jako „parametry” dla adnotacji. Pozwalają one na przekazanie dodatkowych informacji. Spójrz na przykład poniżej: public @interface Retention {    RetentionPolicy value();}Jak widzisz, składnia definiująca elementy adnotacji używa nawiasów (), mogą przypominać one deklaracje metod, co po raz kolejny można skojarzyć z interfejsami. Adnotacja @Retention posiada jeden element o nazwie value. Nazwa value jest traktowana specjalnie. Jeżli jest jedyna, możemy ją pomijać gdy używamy danej adnotacji. W przykładzie poniżej oba użycia oznaczają dokładnie to samo. @Retention(RetentionPolicy.SOURCE)@Retention(value=RetentionPolicy.SOURCE)Elementy adnotacji będące tablicami Czasami może zdarzyć się tak, że do adnotacji chcesz przekazać kilka wartości dla danego elementu. Wówczas element adnotacji jest typu tablicowego. Dobrym przykładem tutaj jest adnotacja @Target, którą widziałeś już wyżej: public @interface Target {    ElementType[] value();}Jak widzisz posiada ona element value, który jest tablicą. Podobnie jak w poprzednim przykładzie jedyny element o nazwie value może być pominięty. Przykład poniżej pokazuje cztery różne sposoby użycia adnotacji mające ten sam efekt. Nawiasy {} służą do określenia tablicy wartości, w tym przykładzie jest to tablica jednoelementowa. @Target(ElementType.FIELD)@Target(value=ElementType.FIELD)@Target({ElementType.FIELD})@Target(value={ElementType.FIELD})Wartości domyślne elementów adnotacji Istnieje możliwość tworzenia adnotacji, które mają wartości domyślne. Używamy do tego słowa kluczowego default. Spórz na przykład poniżej @Retention(RetentionPolicy.RUNTIME)@Target({ElementType.FIELD, ElementType.CONSTRUCTOR, ElementType.METHOD})public @interface AnnotationWithDefaultValues {    String firstElement() default \"someDefaultValue\";    int [] secondElement() default {1, 2, 3};    float thirdElement();}Nasza adnotacja @AnnotationWithDefaultValues posiada trzy elementy, dwa z nich mają wartości domyślne. Adnotację tę możemy stosować do atrybutów klasy, konstruktorów i metod. Informacja o tej adnotacji jest dostępna w trakcie wykonania programu. Zadanie Na koniec mam dla Ciebie zadanie. Napisz adnotację @MyDocumentation, która będzie miała elementy author oraz comment. Informacja o tej adnotacji powinna być dostępna w trakcie uruchomienia programu. Napisałem krótki fragment, kodu używający mechanizmu refleksji, w którym możesz przetestować swoją adnotację. Wstaw adnotację w miejscu komentarza i uruchom program. Używa on mechanizmu refleksji (jej tłumaczenie możemy teraz pominąć). // TUTAJ DODAJ ADNOTACJEpublic class AnnotationProcessor {     private static List SKIP_METHODS = Arrays.asList(\"equals\", \"toString\", \"hashCode\", \"annotationType\");     public static void main(String[] args) throws InvocationTargetException, IllegalAccessException {        for (Annotation classAnnotation : AnnotationProcessor.class.getDeclaredAnnotations()) {            printAnnotationDetails(classAnnotation);        }    }     private static void printAnnotationDetails(Annotation annotation) throws InvocationTargetException, IllegalAccessException {        System.out.println(\"Znalazłem adnotacje: \" + annotation);        for (Method method : annotation.annotationType().getMethods()) {            if (SKIP_METHODS.contains(method.getName())) {                continue;            }            System.out.println(\"Nazwa elementu: \" + method.getName());            System.out.println(\"Wartosc domyslna elementu: \" + method.getDefaultValue());            System.out.println();        }    }}Jak zwykle zachęcam Cię do samodzielnego rozwiązania zadania. W przypadku jakichkolwiek wątpliwości przykładowe rozwiązanie umieściłem na githubie. Dodatkowe materiały do nauki Oczywiście Jak zwykle zachęcam do przejrzenia standardowej dokumentacji, jak zwykle znajdziesz tam mnóstwo wiedzy.   https://docs.oracle.com/javase/specs/jls/se8/html/jls-9.html#jls-9.7  http://tutorials.jenkov.com/java/annotations.html  kod źródłowy użyty w artykule.Podsumowanie W artykule przeczytałeś o adnotacjach, napisałeś swoją pierwszą adnotację i nawet udało Ci się ją wykryć w trakcie działania programu. Wiesz, kiedy i do czego używamy adnotacji. Dzięki temu artykułowi nie zgubisz się w gąszczu adnotacji Springa czy innych bibliotek :) Jak zwykle, jeśli masz jakiekolwiek pytania zadaj je w komentarzach, w miarę możliwości postaram się pomóc. Mam nadzieję, że artykuł Ci się podobał, na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największej liczby czytelników. Możesz mi w tym pomóc udostępniając link do bloga czy artykułu swoim znajomym :) Z góry dziękuję i do następnego razu! ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/adnotacje-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/10/03_adnotacje_artykul.jpg"},{
        "title": "Klasy wewnętrzne i anonimowe w języku Java",
        "excerpt":"To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Klas wewnętrznych jest wiele… Na początku pewne zastrzeżenie. W całym artykule posługuję się określeniem „klasy wewnętrzne”. Ważne jest żebyś zdawał sobie sprawę z tego, że równie dobrze możemy mieć do czynienia z wewnętrznym typem wyliczeniowym czy wewnętrznym interfejsem. Poznając klasy wewnętrzne, poznajesz także „interfejsy wewnętrzne” czy „wewnętrzne typy wyliczeniowe”. Istnieje kilka typów klas wewnętrznych:   (standardowe) klasy wewnętrzne,  statyczne klasy wewnętrzne,  lokalne klasy wewnętrzne,  anonimowe klasy wewnętrzne.Często mówimy po prostu o klasie wewnętrznej odwołując się do którejkolwiek z powyższych. W kolejnych akapitach postaram się pokazać różnice pomiędzy tymi typami klas.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Klasy wewnętrzne Standardowe klasy już znasz. Ot zwykłe public class Example {} i już mamy klasę. A czym jest klasa wewnętrzna? Zacznijmy od przykładu: public class OuterClass {    public class InnerClass {    }    public InnerClass instantiate() {        return new InnerClass();    }}W naszym przykładzie widzisz dwie klasy. Standardowa klasa OuterClass i klasa wewnętrzna InnerClass. Podobnie jak w przypadku atrybutów czy metod, klasy wewnętrzne mogą mieć standardowe modyfikatory dostępu public, protected czy private. Brak modyfikatora dostępu także i tutaj jest poprawny. Modyfikatory dostępu użyte przed definicją klasy wewnętrznej działają identycznie jak w przypadku atrybutów, metod czy konstruktorów. Jeśli chcesz przeczytać o nich więcej osobny akapit na ich temat znajdziesz w artykule o dziedziczeniu. Napisałem też osobny artykuł w pełni poświęcony modyfikatorom dostępu. Ważne jest także to, że klasa wewnętrzna ma dostęp do wszystkich atrybutów czy metod klasy zewnętrznej, w której została zdefiniowana. Tworzenie instancji klasy wewnętrznej Do stworzenia instancji klasy wewnętrznej potrzebujemy instancji klasy zewnętrznej. Proszę spójrz na przykład poniżej. private static void innerClassInstantiation() {    OuterClass outerClass = new OuterClass();    OuterClass.InnerClass instance1 = outerClass.instantiate();    OuterClass.InnerClass instance2 = outerClass.new InnerClass();}Widzisz tam typ OuterClass.InnerClass, to nic innego jak odwołanie się do typu wewnętrznego. W tym fragmencie kodu tworzymy dwie instancje. Pierwsza z nich powstaje w wyniku wywołania metody instantiate z klasy OuterClass. Ciało tej metody możesz zobaczyć w poprzednim fragmencie kodu. Proszę zwróć uwagę, że wewnątrz metody instantiate nie musimy podawać pełnej nazwy klasy, samo new InnerClass() wystarczy (jest to odpowiednik this.new InnerClass()). instance2 tworzymy posługując się instancją klasy OuterClass. Taka konstrukcja jest niezbędna w przypadku standardowych klas wewnętrznych.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Statyczne klasy wewnętrzne W języku Java istnieją także statyczne klasy wewnętrzne. Są to klasy wewnętrzne poprzedzone modyfikatorem static. Proszę spójrz na przykład poniżej. public class OuterClass2 {    public static class InnerClass2 {    }        private InnerClass2 instantiate() {        return new InnerClass2();    }   }Jak widzisz przykład ten jest bardzo podobny do pierwszego z tego artykułu. Nowością tutaj jest modyfikator static, reszta pozostaje bez zmian. Ważna jest natomiast różnica przy tworzeniu instancji statycznej klasy wewnętrznej. Domyślnie, wszystkie wewnętrzne interfejsy i typy wyliczeniowe są statyczne, modyfikator static jest przed nimi zbędny (możesz spróbować go dodać, IDE powinno zwrócić Ci na to uwagę). Tworzenie instancji statycznej klasy wewnętrznej W odróżnieniu od standardowych klas wewnętrznych, nie potrzebujemy instancji klasy zewnętrznej do stworzenia instancji statycznej klasy wewnętrznej. Może się to wydać trochę skomplikowane jednak całość na pewno będzie bardziej zrozumiała gdy popatrzysz na przykład. private static void staticInnerClassInstantiation() {    OuterClass2 outerClass = new OuterClass2();    OuterClass2.InnerClass2 instance1 = outerClass.instantiate();    OuterClass2.InnerClass2 instance2 = new OuterClass2.InnerClass2();}Różnica jest taka, że wystarczy pełne odwołanie się do typu klasy wewnętrznej, aby stworzyć jej instancję. W naszym przypadku jest to new OuterClass2.InnerClass2(). Lokalne klasy wewnętrzne Jako ostatni typ klas wewnętrznych zostały do omówienia lokalne klasy wewnętrzne. I wiesz co? W sumie poza tym, że możemy je zdefiniować wewnątrz bloku (wewnątrz metody, bloku if itp.) i nie poprzedzają ich modyfikatory dostępu (public, private, protected) niczym szczególnym nie różnią się od pozostałych klas wewnętrznych. Proszę spójrz na przykład: private static void localClassInstantiation(String[] args) {    class LocalClass {        @Override        public String toString() {            return \"Argumenty metody: \" + Arrays.toString(args);        }    }       LocalClass localClassInstance = new LocalClass();    System.out.println(localClassInstance);}Tutaj wewnątrz metody tworzymy naszą lokalną klasę wewnętrzną LocalClass. Linijkę później tworzymy jej instancję i wywołujemy na niej metodę. Głównym ograniczeniem/zaletą klas lokalnych jest ich zasięg. Podobnie jak w przypadku zmiennych lokalnych, dostęp do klas lokalnych jest wyłącznie w bloku, w którym zostały zdefiniowane. Kiedy używać klas wewnętrznych Właśnie, po co w ogóle są nam one potrzebne? Mam nadzieję, że przykład ze standardowej biblioteki Javy pomoże Ci to zrozumieć. W artykule o kolekcjach opisałem mapę i sposób w jaki możemy po niej iterować. Map&lt;String, Integer&gt; dayInMonths = new HashMap&lt;&gt;();dayInMonths.put(\"styczen\", 31);dayInMonths.put(\"luty\", 28);dayInMonths.put(\"marzec\", 31); for(Map.Entry&lt;String, Integer&gt; entry : dayInMonths.entrySet()) {    System.out.println(entry.getKey() + \" ma \" + entry.getValue() + \" dni.\");}W naszej mapie trzymamy nazwę miesiąca i odpowiadającą mu liczbę dni. Każda instancja obiektu implementującego interfejs Map posiada metodę entrySet, która zwraca typ Set&lt;Map.Entry&lt;K, V&gt;&gt;. Rozłóżmy ten typ na części pierwsze. K to nasz klucz (ang. key), V to wartość (ang. value) przechowywana w mapie. Map.Entry&lt;K, V&gt; to typ generyczny, który parametryzowany jest typem klucza i wartości. Set&lt;Map.Entry&lt;K, V&gt;&gt; to zbiór elementów mapy. Każdy element ma klucz i wartość. A czym jest Map.Entry? To nic innego jak interfejs wewnętrzny :) Jest to interfejs Entry zdefiniowany wewnątrz interfejsu Map. Więc po co używać klas wewnętrznych? Powodów jest kilka. Jak w przykładzie z Map.Entry dobrym pomysłem użycia klas wewnętrznych jest sytuacja, w której klasa wewnętrzna nie ma sensu bez klasy zewnętrznej i jest z nią ściśle związana. Kolejnym powodem może być lepsza enkapsulacja kodu (ukrywanie szczegółów działania klasy wewnątrz). Dzięki temu, że klasy wewnętrzne mają dostęp nawet do prywatnych zasobów klas otaczających, te drugie możemy bardziej „opakować”. Ukryć więcej szczegółów wewnątrz. Klasy anonimowe Zacznijmy od definicji. Klasy anonimowe to klasy definiowane w kodzie, które mają dokładnie jedną instancję1. Definicja klasy anonimowej połączona jest z tworzeniem jej jedynej instancji. Klasy anonimowe zawsze są klasami wewnętrznymi. Proszę spójrz na przykład poniżej: public interface GreetingModule {    void sayHello();} public void someMethod() {    GreetingModule greeting = new GreetingModule() {        @Override        public void sayHello() {            System.out.println(\"good morning\");        }    };}Na początku definicja interfejsu z jedną metodą sayHello. Ciekawsze są jednak ostatnie linijki. To właśnie definicja klasy anonimowej. Wewnątrz someMethod możesz zobaczyć taką konstrukcję: new TYP([ARGUMENTY]) {    CIAŁO KLASY}Pozwala ona na stworzenie instancji klasy anonimowej. W powyższym przykładzie kompilator tworzy nową klasę, która implementuje interfejs GreetingModule. W tym samym czasie tworzę jej nową instancję przy pomocy słowa kluczowego new. Upraszczając, można powiedzieć, że powyższy przykład to skrót: public interface GreetingModule {    void sayHello();}public class GreetingModuleImpl implements GreetingModule {    @Override    public void sayHello() {        System.out.println(\"good morning\");    }} public void someMethod() {    GreetingModule greeting = new GreetingModuleImpl();}Wewnątrz definicji klasy anonimowej możemy definiować atrybuty czy metody. W praktyce sprowadza się to przeważnie do zaimplementowania metod interfejsu dla którego tworzymy klasę anonimową. W większym fragmencie kodu użycie klas anonimowych może wyglądać następująco. public class AnonymousClasses {    public static class Robot {        private final GreetingModule greetingModule;         public Robot(GreetingModule greetingModule) {            this.greetingModule = greetingModule;        }         public void saySomething() {            greetingModule.sayHello();        }    }     public interface GreetingModule {        void sayHello();    }     public static void main(String[] args) {        Robot jan = new Robot(new GreetingModule() {            @Override            public void sayHello() {                System.out.println(\"dzien dobry\");            }        });        Robot john = new Robot(new GreetingModule() {            @Override            public void sayHello() {                System.out.println(\"good morning\");            }        });         jan.saySomething();        john.saySomething();    }}W naszym przykładzie tworzymy dwie instancje robotów jan i john, które używają innych „modułów powitań”. Każdy z nich jest instancją anonimowej klasy wewnętrznej. Niektóre z klas anonimowych można zastąpić wyrażeniami lambda. Klasa anonimowa to nie instancja interfejsu Ważne jest abyś pamiętał o tym, że klasa anonimowa nie tworzy instancji interfejsu. Kompilator tworzy nową klasę, która implementuje dany interfejs. Klasa stworzona przez kompilator tak na prawdę ma swoją nazwę. Możesz nawet do niej dotrzeć: public class AnonymousCheating {    private interface SomeInterface {        void doSomethingUseful();    }    public static void main(String[] args) {        SomeInterface anonymousInstance = new SomeInterface() {            @Override            public void doSomethingUseful() {                System.out.println(\"I'm doing something useful!\");            }        };        anonymousInstance.doSomethingUseful();        System.out.println(anonymousInstance.getClass());    }}Po uruchomieniu tego programu, na konsoli pokaże się tekst: I'm doing something useful!class pl.samouczekprogramisty.kursjava.inner.AnonymousCheating$1Zatem anonymousInstance jest instancją klasy pl.samouczekprogramisty.kursjava.inner.AnonymousCheating$1. Co to za nazwa? Nazwa klasy wewnętrznej oddzielona jest $ od nazwy klasy wewnątrz której została umieszczona. Zatem w tym przypadku kompilator utworzył wewnętrzną klasę o nazwie 1 wewnątrz AnonymousCheating znajdującej się w pakiecie pl.samouczekprogramisty.kursjava.inner. Jak myślisz, jaką nazwę będzie miała kolejna klasa anonimowa stworzona wewnątrz AnonymousCheating ;) ? Używanie zmiennych lokalnych w klasach wewnętrznych Wewnątrz definicji klas wewnętrznych (także klas anonimowych) możemy używać zmiennych lokalnych z otaczającego je kontekstu. Spójrz na przykład poniżej: public void someMethod() {    final String finalVariable = \"final variable\";    String effectivelyFinalVariable = \"effectively final variable\";    String nonFinalVariable = \"non final variable\";     class InnerClass {                 public void saySomething() {                    System.out.println(finalVariable);            System.out.println(effectivelyFinalVariable);        }       }        InnerClass instance = new InnerClass();    instance.saySomething();                 nonFinalVariable = \"new value\";}W metodzie saySomething używamy dwóch zmiennych lokalnych metody otaczającej finalVariable i effectivelyFinalVariable. Jest jednak jedno ograniczenie. Zmienna z “zewnątrz” użyta w klasie wewnętrznej musi być finalna albo „właściwie finalna”. Zmienna jest finalna jeśli poprzedza ją słowo kluczowe final. Kiedy jest „właściwie finalna”? Kiedy nie zmieniamy jej wartości i kompilator za nas wstawia brakujące słowo final ;). W związku z tym użycie zmiennej nonFinalVariable nie jest dozwolone ponieważ jej wartość jest zmieniana. Zadania Na koniec czekają na Ciebie dwa zadania, w których przećwiczysz zagadnienia omówione w artykule. Przygotowałem też zestaw przykładowych rozwiązań i umieściłem je na githubie. Jak zwykle zachęcam do samodzielnego rozwiązywania zadań, wtedy nauczysz się najwięcej. Samo przeczytanie artykułu nie wystarczy, do dzieła!   Rozszerz przykład z robotami z akapitu o klasach anonimowych o robota witającego się w innym języku np. niemieckim.  Zadanie to będzie wymagało dodatkowej lektury na temat interfejsu Comparator ze standardowej biblioteki Javy. Pobierz od użytkownika 5 wyrazów, zapisz je w List. Użyj metody Collections.sort, przekazując jako argumenty listę oraz klasę anonimową, która posortuje ją na podstawie długości wyrazów (najkrótsze wyrazy powinny być pierwsze). Do sprawdzenia długości słowa możesz użyć metody String.length. Wyświetl zawartość listy przed i po sortowaniu.Materiały dodatkowe Przygotowałem też dla Ciebie zestaw materiałów dodatkowych zawierających informacje na temat klas wewnętrznych i anonimowych. Dodatkowo wszystkie przykłady kodu użyte w tym artykule możesz znaleźć na samouczkowym githubie.   Tutorial na stronie Oracle dotyczący klas wewnętrznych i anonimowych,  Fragment książki opisujący klasy wewnętrzne,  Rozdział w JLS na temat klas wewnętrznych,  Rozdział w JLS na temat klas anonimowych.Podsumowanie Bardzo się cieszę, że przeczytałeś artykuł do końca. Po lekturze artykułu wiesz czym są klasy wewnętrzne. Wiesz też jakie rodzaje klas wewnętrznych występują. Znasz także klasy anonimowe i wiesz kiedy ich używać. Rozwiązując zadanie przećwiczyłeś całość w praktyce. Innymi słowy kawał solidnej wiedzy :) Na koniec mam do Ciebie prośbę. Proszę podziel się artykułem ze znajomymi i polub moją stronę na Facebooku. Zależy mi na dotarciu do jak największej liczby osób, które chcą uczyć się programowania. Z góry dziękuję i do następnego razu.             Pomijam tutaj mechanizm refleksji. Możesz utworzyć więcej instancji takiej klasy, na samouczkowym githubie możesz znaleźć przykład tego jak można to zrobić. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/klasy-wewnetrzne-i-anonimowe-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/10/13_klasy_wewnetrzne_anonimowe_artykul.jpg"},{
        "title": "Testy jednostkowe z JUnit",
        "excerpt":"Artykuł ten opisuje podstawy testów jednostkowych z wykorzystaniem biblioteki JUnit 4. Jeśli zapoznasz się już z JUnit 4 zapraszam Cię do artykułu na temat testów z JUnit 5. Po co testujemy oprogramowanie Oczywista odpowiedź jest prosta – żeby nie było błędów :). Błędy powodują frustrację użytkowników, a to jest coś czego chcemy uniknąć. Ile razy chciałeś rzucić myszką/klawiaturą/laptopem jak coś nie działało jak powinno? Brzmi znajomo? ;) Wszystkie powody testowania komercyjnego oprogramowania sprowadzają się do pieniędzy. Im wcześniej wykryjemy błąd, tym niższy jest koszt jego naprawienia. Pisanie testów jednostkowych pozwala wykryć błędy w najwcześniejszej możliwej fazie, w trakcie pisania kodu programu. Dlatego każdy porządny programista powinien testować kod, który napisze. Oddając kod do użytku powinien być pewny, że działa jak powinien. Pojawia się tu jednak pewien problem. Manualne testowanie to żmudna, czasochłonna i mozolna praca. Bardzo tu łatwo o drobne przeoczenie kończące się błędem w programie. Do tego w projektach IT wymagania zmieniają się bardzo często więc takie testy także muszą być bardzo często przeprowadzane. W związku z tym programiści testują swój kod pisząc testy jednostkowe. Czym jest test jednostkowy Test jednostkowy (ang. unit test) to sposób testowania programu, w którym wydzielamy mniejszą jego część, jednostkę i testujemy ją w odosobnieniu. W naszym przypadku taką jednostką do testowania może być pojedyncza klasa czy metoda, którą napiszemy. Testy jednostkowe można pisać bez bibliotek zewnętrznych jednak jest to uciążliwe. Dodatkowo warto używać istniejących bibliotek ponieważ IDE dobrze integrują się tymi bibliotekami. W tym artykule użyłem biblioteki JUnit. Spójrz na fragment kodu poniżej. Klasa ta reprezentuje zakres liczb, ma ona jedną metodę, która sprawdza czy liczba przekazana jako argument należy do danego zakresu. public class Range {    private final long lowerBound;    private final long upperBound;    public Range(long lowerBound, long upperBound) {        this.lowerBound = lowerBound;        this.upperBound = upperBound;    }    public boolean isInRange(long number) {        return number &gt;= lowerBound &amp;&amp; number &lt;= upperBound;    }}Poniżej przykład prostego testu jednostkowego, który sprawdza czy, liczba 15 jest w zakresie liczb od 10 do 20. @Testpublic void shouldSayThat15rIsInRange() {    Range range = new Range(10, 20);    Assert.assertTrue(range.isInRange(15));}Test jednostkowy to metoda testująca naszą jednostkę, metodę w innej klasie z dodaną adnotacją @Test. shouldSayThat15IsInRange jest testem, wewnątrz którego tworzę instancję klasy Range i wywołuję metodę sprawdzającą czy 15 jest wewnątrz zakresu. Wynik tej metody jest przekazywany do metody Assert.assertTrue(), jest to tak zwana asercja. Asercje to metody dostarczone przez bibliotekę JUnit, które pomagają przy testowaniu. W naszym przykładzie, jeśli metoda isInRange zwróci false, wówczas asercja assertTrue rzuci wyjątek, który przez IDE zostanie zinterpretowany jak test jednostkowy, który pokazuje błąd działania testowanego kodu. Mówimy wówczas, że „test nie przeszedł”, „wywalił się” :). Testy jednostkowe łączymy w klasy z testami, bardzo często nazywamy je tak samo jak klasy, które testujemy dodając do nich Test na końcu. W naszym przypadku klasa z testami dla klasy Range nazywa się RangeTest.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Przykłady użycia asercji Po co używać asercji? Otóż gotowe asercje tworzą komunikaty błędów (w trakcie testów jednostkowych), które ułatwiają znalezienie błędu. Komunikaty te są bardziej czytelne niż standardowy wyjątek AssertionError1. Asercje w bibliotece JUnit to nic innego jak metody statyczne w klasie Assert. Poniżej przedstawię Ci kilka najczęściej stosowanych asercji2.   assertTrue sprawdza czy przekazany argument to true,  assertFalse sprawdza czy przekazany argument to false,  assertNull sprawdza czy przekazany argument to null,  assertNotNull sprawdza czy przekazany argument nie jest nullem,  assertEquals przyjmuje dwa parametry wartość oczekiwaną i wartość rzeczywistą, jeśli są różne rzuca wyjątek,  assertNotEquals przyjmuje dwa parametry wartość oczekiwaną i wartość rzeczywistą, rzuci wyjątek jeśli są równe.Importy statyczne Tutaj drobna dygresja, w języku Java musimy importować klasy z innych pakietów, które chcemy użyć w definicji naszej klasy. Poza standardową konstrukcją ze słowem kluczowym import istnieją także tak zwane importy statyczne. Import statyczny pozwala na zaimportowanie metody/wszystkich metod statycznych znajdujących się w definicji jakiejś klasy. Proszę spójrz na przykład poniżej. import static org.junit.Assert.assertFalse;import static org.junit.Assert.*;W pierwszej linijce importujemy metodę assertFalse z klasy Assert, druga linijka to importowanie wszystkich metod statycznych z tej klasy. Dzięki takim importom później w definicji klasy nie musimy używać nazwy klasy używając danej metody statycznej: assertFalse(false);assertTrue(true);Z racji tego, że dużo metod pomocniczych (na przykład asercje) w przypadku pisania testów to metody statyczne, bardzo często używamy tam importów statycznych. Testowanie metod rzucających wyjątki Czasami zdarza się, że chcemy przetestować pewną sytuację wyjątkową. Na przykład nie powinniśmy móc utworzyć instancji klasy Range z niepoprawnymi argumentami. public Range(long lowerBound, long upperBound) {    if (lowerBound &gt; upperBound) {        throw new IllegalArgumentException(\"lowerBound is bigger than upperBound!\");    }    this.lowerBound = lowerBound;    this.upperBound = upperBound;}Wywołanie konstruktora w teście z niepoprawnymi argumentami kończyłoby się od razu rzuceniem wyjątku, czyli testem jednostkowym, który nie przeszedł. Z pomocą w takiej sytuacji przychodzi element expected adnotacji @Test. Przykład jego użycia widzisz poniżej: @Test(expected = IllegalArgumentException.class)public void shouldThrownIllegalArgumentExceptionOnWrongParameters() {    new Range(20, 10);}Taki test jednostkowy nie przejdzie jeśli wyjątek nie zostanie rzucony. Mimo tego, że w teście nie ma żadnej asercji testuje on właśnie rzucenie wyjątku. Istnieje też inny sposób. Możesz go użyć jeśli chcesz mieć dostęp do instancji rzuconego wyjątku. Pokazałem go w przykładzie poniżej: @Testpublic void shouldHaveProperErrorMessage() {    try {        new Range(20, 10);        fail(\"Exception wasn't thrown!\");    }    catch (IllegalArgumentException exception) {        assertEquals(\"lowerBound is bigger than upperBound!\", exception.getMessage());    }}Użyta tu statyczna metoda Assert.fail() powoduje zakończenie testu niepowodzeniem. Zostanie ona wywołąna wyłącznie jeśli wyjątek nie zostanie rzucony. Przygotowanie testów i cykl życia testów Czasami zdarza się, że kilka testów jednostkowych wymaga pewnego „przygotowania”. Na przykład trzeba utworzyć instancję, którą będziemy później testowali. Twórcy biblioteki JUnit przyszli nam z pomocą. Istnieje adnotacja @Before, którą możemy dodać do metody w klasie z testami. Metoda ta zostanie uruchomiona przed każdym testem jednostkowym. Proszę spójrz na przykład poniżej. public class RangeTest {    private Range range;     @Before    public void setUp() {        range = new Range(10, 20);    }     @Test    public void shouldSayThat15rIsInRange() {        assertTrue(range.isInRange(15));    }     @Test    public void shouldSayThat5IsntInRange() {        assertFalse(range.isInRange(5));    }}W naszym przykładzie metoda setUp zostanie wywołana przed uruchomieniem każdego z testów. Dzięki temu nie musimy tworzyć instancji wewnątrz testu. Odpowiednie użycie tej adnotacji pomaga pisać krótsze testy jednostkowe. Cykl życia klasy z testami jednostkowymi Adnotacja @Before jest jedną z czterech adnotacji, które pozwalają na wykonanie fragmentów kodu przed/po testach. Pozostałe trzy to:   @After – metoda z tą adnotacją uruchamiana po każdym teście jednostkowym, pozwala na „posprzątanie” po teście,  @AfterClass – metoda statyczna z tą adnotacją uruchamiana jest raz po uruchomieniu wszystkich testów z danej klasy,  @BeforeClass – metoda statyczna z tą adnotacją uruchamiana jest raz przed uruchomieniem pierwszego testu z danej klasy.Proszę spójrz na przykład poniżej: public class TestLifecycle {    @Before    public void setUp() {        System.out.println(\"set up\");        System.out.flush();    }     @After    public void tearDown() {        System.out.println(\"tear down\");        System.out.flush();    }     @BeforeClass    public static void setUpClass() {        System.out.println(\"set up class\");        System.out.flush();    }     @AfterClass    public static void tearDownClass() {        System.out.println(\"tear down class\");        System.out.flush();    }     @Test    public void test1() {        System.out.println(\"test 1\");        System.out.flush();    }     @Test    public void test2() {        System.out.println(\"test 2\");        System.out.flush();    }}Jeśli uruchomisz tę klasę na konsoli pojawi się: set up classset uptest 1tear downset uptest 2tear downtear down classTesty jednostkowe a testy automatyczne Testy jednostkowe bardzo często są testami automatycznymi. Test automatyczny to taki, który możemy wykonywać automatycznie :) Zaletą takiego podejścia jest to, że w momencie zmiany kodu możemy raz napisany test uruchomić ponownie wiedząc od razu czy napisany wcześniej fragment działa poprawnie czy nie. Pomagają przy tym wcześniej omówione asercje. Bardzo często testy jednostkowe uruchamiane są automatycznie podczas pracy nad projektem. Służą do tego osobne środowiska, w których testy te są uruchamiane. Istnieją także mechanizmy, które w trakcie pracy programisty wykrywają zmiany w części klas i automatycznie uruchamiają dla tych klas testy jednostkowe informując programistę o wynikach. Dzięki temu bardzo szybko jesteśmy w stanie dowiedzieć się czy zmiany, które wprowadziliśmy nie popsuły wcześniejszej funkcjonalności. Dobre praktyki przy pisaniu testów Poniżej postaram się zebrać dla Ciebie kilka dobrych praktyk, do których warto się stosować w czasie pisania testów:   Po pierwsze, pisz testy jednostkowe. Koniecznie. Zawsze.  Staraj się pisać testy jednostkowe, które są małe i dotyczą małego wycinka funkcjonalności. Później o wiele łatwiej jest zrozumieć taki test.  Nadawaj metodom z testem nazwy, które pomagają zrozumieć co dany test powinien sprawdzić.  Kolejność testów jednostkowych w klasie nie powinna mieć znaczenia. Innymi słowy nie możemy polegać na tym, że jako pierwszy musi się uruchomić test1 a po nim test2. Testy uruchomione w odwrotnej kolejności także powinny mieć dokładnie taki sam efekt.  Pisz testy jednostkowe tak, żeby nie zależały na Twojej lokalnej konfiguracji. Na przykład test jednostkowy czytający plik z Twojego dysku z katalogu C:\\mój\\katalog\\domowy (czy /home/uzytkownik) nie jest dobrym rozwiązaniem.  Pisz testy jednostkowe niezależne od zewnętrznych systemów. Innymi słowy testuj tylko „jednostkę”, nic ponadto. Jeśli klasa, którą testujesz potrzebuje dostępu np. do bazy danych użyj mocka czy stuba do jej zastąpienia w trakcie testów3 .  Testuj warunki brzegowe i sytuacje wyjątkowe. Załóżmy, że masz metodę, która przyjmuje tablicę, która musi mieć maksymalnie trzy elementy. Napisz kilka testów:          przekazując null zamiast tablicy,      przekazujac pustą tablicę,      przekazujac tablicę z trzema elementami,      przekazując tablicę z czterema elementami.      Dzięki takim testom będziesz pewien, jak zachowuje się Twoja metoda w sytuacjach wyjątkowych.   Testowany kod nie powinien być w tym samym miejscu, w którym są testy. Sprowadza się to do tego, że kod umieszczamy w katalogu np. src, testy natomiast w katalogu test. Oba katalogi pod spodem mają odpowiednią strukturę odzwierciedlającą pakiety. Jest to ważne ponieważ później przy większych projektach testy nie „mieszają się” z kodem programu.  Staraj się pisać testy, które są szybkie. Przy pierwszych programach nie jest to problemem, jednak przy większych projektach uruchamianie testów może być czasochłonne.  Uruchamiaj testy jednostkowe możliwie często. Uwierz mi, to Ci się opłaci :). Punkt ten jest powiązany z punktem poprzednim – nie będziesz uruchamiał często testów, które trwają długo.  Jeśli zauważysz, że część testów jednostkowych wymaga dokładnie takiego samego „przygotowania” wydziel je do osobnej klasy i użyć metod z adnotacją @Before lub @BeforeClass.Testy jednostkowe w IntejiJ Idea Zacznijmy od utworzenia testu jednostkowego dla istniejącej klasy. Z pomocą przychodzi skrót klawiaturowy &lt;Ctrl + Shift + T&gt; – naciśnij tę kombinację na nazwie klasy dla której chcesz utworzyć test. Pokaże się wówczas dialog pomagający utworzyć nową klasę testu.         Tworzenie nowego testu.  InteliJ jest na tyle mądry, że wykrywa brak biblioteki JUnit w projekcie. W oknie dialogowym widać wówczas przycisk „Fix it”, który automatycznie dodaję tę bibliotekę.         Tworzenie nowego testu.  Kolejnym skrótem klawiaturowym, który może się przydać podczas pisania testów jednostkowych jest &lt;Alt + Insert&gt;, naciśnięcie tego skrótu wewnątrz klasy grupującej testy pozwala nam w łatwy sposób stworzyć kolejny test.         Generowanie kodu w testach.  W końcu kombinacja &lt;Ctrl + Shift + F10&gt; pozwala na uruchomienie testów jednostkowych wewnątrz IDE. W zależności od tego na czym znajduje się nasz kursor myszy, ten skrót klawiaturowy może uruchomić pojedynczą metodę z testem, klasę grupującą testy czy pakiet z kilkoma klasami testowymi.         Testy bez błędów.  Zadanie do rozwiązania Napisz program, który będzie reprezentował koszyk w sklepie internetowym. Do koszyka reprezentowanego przez klasę Basket możemy dodawać bądź usuwać kolejne przedmioty. Każdy przedmiot powien mieć nazwę i cenę jednostkową. Koszyk powinien także pozwalać na dodanie/usunięcie od razu kilku egzemplarzy przedmiotu ze sklepu. Koszyk powinien także być w stanie policzyć sumaryczną wartość zamówienia oraz wyświetlić swoją zawartość. Pamiętaj o poprawnym obsłużeniu sytuacji wyjątkowych np. usunięcie elementów z pustego koszyka czy dodaniu ujemej liczby przedmiotów. Napisz zestaw testów jednostkowych potwierdzających poprawne działanie Twojego koszyka z zakupami. Drobna podpowiedź z przykładowym zestawem klas, które mogą rozwiązać ten problem:   Item, która posiada dwa atrybuty double price4 oraz String name,  Basket, który posiada atrybut Map orderedItems reprezentujący zamówione towary wraz z ich ilością.Przygotowałem też przykładowe rozwiązanie, znajduje się w repozytorium na githubie wraz z zestawem testów jednostkowych. Zachęcam jednak do samodzielnej próby rozwiązania zadania. Uwierz mi, że wtedy nauczysz się najwięcej :). Dodatkowe materiały do nauki   Test jednostkowy na Wikipedii  Strona biltioteki JUnit  Dokumentacja biblioteki JUnit  Kod źródłowy przykładów użytych w artykulePodsumowanie W artykule przeczytałeś o testach jednostkowych. Poznałeś zestaw dobrych praktyk dotyczących pisania testów, nauczyłeś się podstaw biblioteki JUnit. Wiesz czym jest test automatyczny i dlaczego takie testy są istotne. Całość przećwiczyłeś w sposób praktyczny rozwiązując zadanie końcowe. Na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największej liczby czytelników – proszę podziel się linkiem do artykułu ze znajomymi. Jeśli nie chcesz ominąć kolejnych artykułów możesz polubić moją stronę na facebooku ;). Do następnego razu!             W języku Java istnieje także słowo kluczowe assert, po którym musi wystąpić wartość logiczna, jeśli jest ona fałszem kończy się to rzuceniem wyjątku AssertionError – np. assert false rzuci wyjątek. &#8617;               Pominę tutaj metodę assertThat, którą omówię bardziej szczegółowo w kolejnych artykułach. &#8617;               O mockach czy stubach przeczytasz w kolejnych artykułach, jeśli jest to Twoja pierwsza styczność z testami możesz ten punkt pominąć. &#8617;               double nie jest dobrym typem do reprezentowania cen, na potrzeby tego przykładu jednak wystarczy. Dlaczego tak się dzieje przeczytasz w osobnym artykule. &#8617;       ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/testy-jednostkowe-z-junit/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/10/29_testy_jednostkowe_junit_artykul.jpg"},{
        "title": "Game of Life",
        "excerpt":"Convey’s Game of Life Gra w życie zakłada, że mamy planszę o nieskończonych wymiarach. Plansza ta podzielona jest na pola, w podobny sposób jak kartka w kratkę. Każda kratka reprezentuje pole. Każde pole ma dokładnie 8 sąsiadów, osiem kratek wokół. Każde z pól może być w dwóch stanach. Może być żywe bądź martwe.         Żywa komórka (1, 3)  W przykładzie powyżej widzisz wycinek planszy na którym mamy żywą komórkę o współrzędnych (1, 3). Oznaczona jest ona czarnym kwadratem. Gra sprowadza się do przygotowania kolejnych generacji planszy na podstawie jej aktualnego stanu. Kolejna generacja powstaje na podstawie czterech zasad:   Każda żywa komórka z mniej niż dwoma żywymi sąsiadami umiera w kolejnej generacji z powodu wyludnienia,  każda żywa komórka z dwoma lub trzema żywymi sąsiadami jest w stanie przetrwać do następnej generacji,  każda żywa komórka z więcej niż trzema żywymi sąsiadami umiera w kolejnej genracji z powodu przeludnienia,  każda martwa komórka z dokładnie trzema żywymi sąsiadami staje się żywa w kolejnej generacji.Zobacz jak te zasady wyglądają na kilku przykładach.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Przykład 1. W tym przykładzie pierwsza generacja planszy zawiera wyłącznie żywą komórkę na pozycji (1, 3). W kolejnej generacji komórka ta ginie ponieważ nie ma dwóch żywych sąsiadów.         Żywa komórka (1, 3)          Pusta plansza  Przykład 2. W tym przykładzie, w pierwszej generacji mamy trzy żywe komórki na pozycjach (1, 2), (2, 2) i (3, 2). W kolejnej generacji dzieje się już trochę więcej:   Komórka (1, 2) i (3, 2) giną ponieważ mają tylko jednego żywego sąsiada,  komórka (2, 2) przeżywa ponieważ ma dokładnie dwóch żywych sąsiadów,  komórki (2, 1) i (2, 3) ożywają ponieważ mają trzech żywych sąsiadów,  pozostałe komórki pozostają martwe.        Figura okresowa          Figura okresowa  Zauważ, że kolejna generacja prowadzi do kształtu podobnego do poprzedniej. W przypadku tego kształtu i kolejnych generacji okazuje się, że zawsze jakieś żywe komórki powstaną na planszy. Kolejne generacje można pokazać przy pomocy animacji:         Figura okresowa  Kolejne przykłady Bardziej skomplikowane kształty możesz zobaczyć na filmiku poniżej: Zadanie do wykonania Twoim zadaniem jest napisanie gry w życie. Aby trochę ułatwić wizualizację, nie będziemy implementowali nieskończonej planszy. Zodyfikujemy wymagania dotyczące planszy. W naszym przypadku planszę ograniczymy do kwadratu o boku N, gdzie N będzie parametrem konstruktora planszy. Nie będzie ona nieskończona, a będzie się „zawijała”. Co to oznacza? Na poniższym obrazku zaznaczyłem sąsiedztwo dla pola (1, 0). Jak widzisz, „zawija się” ono w taki sposób, że obejmuje także ostatni rząd planszy.         Sąsiednie pola dla (1, 0)  Podobnie ma się sytuacja dla narożników. Poniższy obrazek pokazuje sąsiedztwo dla narożnika (0, 0).         Sąsiednie pola dla (0, 0)  Napisz program, który będzie w stanie wygenerować kolejną generację planszy w „grze w życie”. Nie zapominaj o testach jednostkowych dla swojego programu. Dla przykładu poniżej umieściłem jeden z testów z przykładowego rozwiązania. @Testpublic void shouldBeAbleToProvideNextGenerationWithPeriod() {    String boardVisualisation = \"+----+\" + System.lineSeparator() +                                \"|    |\" + System.lineSeparator() +                                \"| o  |\" + System.lineSeparator() +                                \"| o  |\" + System.lineSeparator() +                                \"| o  |\" + System.lineSeparator() +                                \"+----+\";    Board board = new Board(4, Cell.live(1, 0), Cell.live(1, 1), Cell.live(1, 2));    assertEquals(boardVisualisation, board.toString());     String expected = \"+----+\" + System.lineSeparator() +                      \"|    |\" + System.lineSeparator() +                      \"|    |\" + System.lineSeparator() +                      \"|ooo |\" + System.lineSeparator() +                      \"|    |\" + System.lineSeparator() +                      \"+----+\";    Board boardNextGeneration = board.nextGeneration();    assertEquals(expected, boardNextGeneration.toString());}Przygotowałem też dla Ciebie przykładowe rozwiązanie wraz z testami jednostkowymi. Możesz zajrzeć na samouczkowego githuba. Materiały dodatkowe   Artykuł na wikipedii na temat gry w życie,  wywiad z autorem Game of Life – John H. Convey opowiada o Grze w Życie :)Podsumowanie Mam nadzieję, że udało Ci się napisać grę w życie. Nie jest to duży projekt jednak rozbudowany na tyle, że musisz przećwiczyć podstawowe zagadnienia programowania obiektowego. Niby prosty zestaw zasad, a jaki ciekawy efekt można uzyskać :). Jeśli chciałbyś dostawać informacje o kolejnych artykułach prosto na Twoją skrzynkę zapisz się na mojego newslettera. Na koniec proszę Cię, żebyś podzielił się informacją o Samouczku ze swoimi znajomymi, którzy też są zainteresowani programowaniem – zależy mi na dotarciu do jak największej liczby czytelników. ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/game-of-life/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/11/06_zadanie_game_of_life_artykul.jpg"},{
        "title": "Test Driven Development na przykładzie",
        "excerpt":"Jeśli tematyka testów, jest dla Ciebie nowa zachęcam Cię do przeczytania poprzedniego artykułu. W artykule tym od postaw opisuję zagadnienie testów jednostkowych. Czym jest TDD TDD to podejście do tworzenia oprogramowania. Na taki sposób tworzenia oprogramowania uwagę zwrócił Kent Beck1. Podejście to zakłada, że przed napisaniem właściwej funkcjonalności programista zaczyna od utworzenia testu. Test ten powinien testować funkcjonalność, którą dopiero chcemy napisać. TDD to podejście, które składa się z trzech faz. Te trzy fazy łączą się w cykl. Cały proces pisania kodu składa się z właśnie takich cykli, które powtarzasz jeden po drugim. Cykl to trzy fazy:   red,  green,  refactor.  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Faza Red Pierwszym krokiem jest napisanie testu. Test ten nie może się powieść, ponieważ sama funkcjonalność jeszcze nie jest zaimplementowana. Możliwe, że nawet po napisaniu takiego testu kod nie będzie się kompilował. Może się tak stać w przypadku, gdy napisałeś test dla metody, która jeszcze nie istnieje. Sytuacja, w której testy jednostkowe nie przechodzą bardzo często w IDE oznaczana jest kolorem czerwonym. Faza Green Kolejnym krokiem jest napisanie kodu, który implementuje brakującą funkcjonalność. W tym momencie istotne jest to aby ten kod nie był „idealny”. Chodzi o możliwe jak najszybszą implementację, która spełnia założenia testu, który był napisany w poprzedniej fazie. Następnie potwierdzamy to, że nasza implementacja działa jak powinna uruchamiając testy jednostkowe. Jeśli wszystko jest w porządku całość powinna zakończyć się testami jednostkowymi, które przechodzą. IDE sygnalizuje taką sytuację zielonym kolorem. Ważne jest aby w tej fazie uruchamiać wszystkie dotychczas napisane testy jednostkowe. Faza Refactor Refaktoryzacja (ang. refactor) to proces, w którym zmieniamy kod w taki sposób, że nie zostaje zmieniona jego funkcjonalność. Mówi się o „oczyszczaniu” kodu, doprowadzaniu go do lepszego stanu. Przykładem refaktoryzacji może być wydzielenie oddzielnej metody, która usuwa powielony kod czy stworzenie zupełnie nowej klasy odpowiedzialnej za pewną część zadań danej klasy. Jest to ostatnia z trzech faz cyklu TDD. Faza refaktoryzacji jest bardzo istotna. Nawet doświadczeni programiści bardzo często pomijają tę fazę. Jej brak może w dłuższej perspektywie prowadzić do kodu programu, który jest trudny w utrzymaniu. Praca z takim kodem może być wówczas dużo cięższa, proste zmiany mogą zajmować bardzo dużo czasu. Dzięki testom, które napisałeś w fazie Red czy wcześniejszych cyklach TDD, możesz czuć się swobodnie zmieniając istniejący kod. Z większą pewnością możesz zmieniać kod, po każdej zmianie uruchamiając istniejące testy jednostkowe. Takie podejście pozwala Ci bardzo szybko wychwycić potencjalne błędy, które mógłbyś wprowadzić refaktoryzując kod. Może się zdarzyć, że faza refaktoryzacji nie zawsze jest konieczna. Usprawnianie dobrego kodu na siłę nie koniecznie może prowadzić do dobrych rezultatów. Rady praktyczne Jedną z pierwszych wątpliwości, które mi się nasunęły gdy uczyłem się tego podejścia było – jak „długie” powinny być takie cykle? Jak duży fragment kodu powinienem testować pojedynczym testem? Na początku byłem zagorzałym fanem wyznawania możliwie jak najkrótszych cykli, wielkiej liczby testów, które testują bardzo mały wycinek kodu (w sumie takie jest jedno z założeń TDD). Takie podejście jest dobre, ma jednak swoje wady. Wymaga od programisty napisania bardzo dużej liczby testów jednostkowych. Dużej liczby cykli red-green-refactor. Nie jest to złe, wręcz przeciwnie. Jednak ja ze wszystkim nie możemy popadać w skrajności. Uważam, że cykle powinny być na tyle długie, że Ty jako programista czujesz się swobodnie. Czujesz, że masz kontrolę nad tym co się dzieje. Ogarniasz to co trzeba napisać aby ten test przeszedł. I na końcu ale – powinny być na tyle długie, że programista czuje, że kontroluje całość ale ani trochę dłuższe ;). Innymi słowy, moim zdaniem wraz z doświadczeniem przychodzi swego rodzaju wyczucie jak “duży” powinien być cykl. Nie możesz zapominać o uruchamianiu wszystkich testów jednostkowych podczas fazy refaktoryzacji. Może się zdarzyć tak, że drobna zmiana może powodować błędy w innej części programu. Uruchamianie wszystkich testów pomaga wykryć taką sytuację. Pamiętaj też o dobrych praktykach podczas pisania testów, opisałem je w artykule poświęconym tematyce testów jednostkowych. Przy TDD praktyki te jak najbardziej obowiązują. Jeśli używasz repozytorium kodu, to udostępniaj w nim kod, który jest poprawny. Innymi słowy udostępniaj kod, który jest zakończeniem pełnego cyklu. Kod się kompiluje i wszystkie testy przechodzą. Sytuacja, w której zmieniasz kod innego programisty, który się nie kompiluje lub nie przechodzą w nim testy potrafi być dość frustrująca. Lepiej jest unikać takich sytuacji ;). W moim przypadku bardzo dobrze sprawdza się praktyka, w której na koniec dnia zostawiam test jednostkowy, który nie przechodzi (nie udostępniając go w repozytorium kodu). Następnego dnia rano dokładnie wiem od czego mam zacząć. Takie podejście pomaga mi w następnym dniu pracy od razu skupić się na funkcjonalności, którą zaplanowałem dzień wcześniej. Pamiętaj o tym, że faza refaktoringu dotyczy także testów. Czasami testy także można oczyścić wprowadzając odpowiednie metody, czy stałe statyczne. Także tutaj trzeba unikać duplikacji. Może część testów jest niepotrzebna, bo to samo jest testowane w innym miejscu? Jeśli tak, śmiało można usunąć jeden z takich testów. Skróty klawiaturowe Zachęcam do przejrzenia skrótów, które opisałem w poprzednim artykule. Tutaj dodam jeszcze Ctrl+F5. Skrót ten uruchamia dokładnie to samo, co poprzednie uruchomienie. Innymi słowy jeśli poprzednio uruchomiłeś testy w pakiecie Ctrl+F5 uruchomi je ponownie. Jeśli uruchomiłeś tylko pojedynczy test jednostkowy skrót ten uruchomi go jeszcze raz. Jest on bardzo pomocny przy fazie refaktoryzacji. Będąc wewnątrz klasy, którą refaktoryzujesz możesz używać tego skrótu po każdej, najmniejszej zmianie, IDE uruchomi poprzedni zestaw testów automatycznie. Dodatkowe materiały do nauki Bez najmniejszego wahania mogę polecić książkę autorstwa Kent’a Beck’a, Test Driven Development by Example2. W książce tej autor na podstawie problemu do rozwiązania pokazuje krok po kroku jak wygląda technika TDD. Chociaż książka nie jest zbyt obszerna, zawiera także sporo informacji związanych z tematyką testów jednostkowych. Co prawda, nie jest to książka najnowsza, jednak moim zdaniem jak najbardziej warta przeczytania. Mogę powiedzieć, że sam uczyłem się TDD z tej książki :). Zadanie Na koniec czeka na Ciebie zadanie praktyczne. Przećwiczysz w nim TDD na przykładzie. Po tym zadaniu będziesz mógł śmiało powiedzieć, że napisałeś program używając TDD :). Zacznijmy od wymagań, które nasz program ma spełniać. Ma to być program, który przechowuje oceny jednego ucznia. Poniższe punkty opisują wymagania:   Jako nauczyciel chcę dodawać przedmioty do dzienniczka,  jako nauczyciel chcę dodać ocenę dla jednego z przedmiotów,  jako nauczyciel chcę policzyć średnią ocen dla danego przedmiotu,  jako nauczyciel chcę policzyć średnią ocen z wszystkich przedmiotów.Pisząc ten program użyję dwóch klas GradeBook reprezentującej dzienniczek oraz klasy Subject, która będzie opisywała przedmiot. Te wymagania podzielę na kilka etapów. Staraj się postępować zgodnie z nimi. W każdym z tych etapów możesz mieć kilka cykli, w których dodawał będziesz kolejne testy jednostkowe:   Utworzenie dzienniczka,  utworzenie przedmiotu,  dodanie przedmiotu do dzienniczka,  pobranie przedmiotu z dzienniczka,  dodanie oceny do przedmiotu,  obliczenie średniej dla przedmiotu,  obliczenie średniej dla dzienniczka.Przygotowałem też dla Ciebie przykładowe rozwiązanie. Proszę jednak żebyś przed sprawdzeniem rozwiązania przeszedł przez wszystkie kroki samodzielnie. Tak nauczysz się dużo więcej. W rozwiązaniu tym starałem się oddzielać każdy krok tak żeby wszystkie cykle wraz z etapami były widoczne. W prawdziwym projekcie oczywiście nie umieszczaj w repozytorium kodu, który się nie kompiluje ;). Przykładowe rozwiązanie nie sprawdza niektórych przypadków brzegowych. Czy Twoja wersja poprawnie zareaguje na przykład na liczenie średniej z pustego dziennika? Podsumowanie Wiesz czym jest TDD. Jesteś praktykiem TDD, rozwiązałeś zadanie przy użyciu tego sposobu pisania kodu. Wiesz jakie są cykle TDD (i wiesz, że nie wolno zapominać o refaktoryzacji). Skróty klawiaturowe pomagające w pisaniu testów masz w jednym paluszku ;). Dodam po raz kolejny. Testowanie kodu jest bardzo istotnie, nie zapominaj o nim. Na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największej liczby czytelników – proszę podziel się linkiem do artykułu ze znajomymi, może ktoś z nich chce poznać TDD od praktycznej strony?. Jeśli nie chcesz ominąć kolejnych artykułów możesz polubić moją stronę na Facebooku i zapisać się do mojego newslettera ;). Do następnego razu!             W artykule, w którym wymieniam książki dla programistów jest też pozycja napisana przez tego autora. &#8617;               To jest link afiliacyjny. Oznacza to tyle, że jeśli kupisz ten produkt pomożesz mi w dalszym prowadzeniu bloga. Nie jest to związane z żadnymi dodatkowymi kosztami dla Ciebie. Dziękuję! :) &#8617;       ","categories": ["Kurs programowania Java","Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/test-driven-development-na-przykladzie/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/11/21_test_driven_development_artykul.jpg"},{
        "title": "Wyrażenia regularne w języku Java",
        "excerpt":"  To jest wprowadzający artykuł na temat wyrażeń regularnych. Część bardziej zaawansowanych zagadnień związanych z wyrażeniami regularnymi opisana jest w drugiej części:   zachłanność wyrażeń regularnych,  alternatywa,  grupy nieprzechwytujące,  grupy nazwane,  ponowne użycie grup,  kotwice.Zachęcam do przeczytania drugiej części jeśli chciałbyś dowiedzieć się czegoś więcej o punktach wspomnianych powyżej. Czym są wyrażenia regularne Słowo wstępu zanim przejdziemy do teorii. W kilku poniższych akapitach pokażę kilka wyrażeń regularnych bez dokładnego ich omawiania. Posłużą one jako przykłady zastosowania wyrażeń. Proszę nie zrażaj się widząc kilka dziwnych znaczków, później dokładnie je opiszę :). Wyrażenie regularne (ang. regular expression) to „wzorzec”, który opisuje grupę łańcuchów znaków. Możemy powiedzieć, że łańcuch znaków pasuje do wzorca jeśli dane wyrażenie regularne go opisuje. Na przykład wyrażenie regularne \\d{2}-\\d{3} opisuje zbiór kodów pocztowych w Polsce. Wyrażenia regularne składają się ze znaków, część z nich w pewnych kontekstach ma specjalne znaczenie. Znaczenie to interpretowane jest przez tak zwany silnik wyrażeń regularnych. Istnieje wiele silników wyrażeń regularnych, w związku z tym istnieją też pewne różnice pomiędzy wyrażeniami regularnymi rozumianymi przez te silniki. Mówimy wówczas o dialekcie języka wyrażeń regularnych. Dialekty mogą różnić się między sobą pewnymi niuansami, jednak mają wspólną bazę, zrozumiałą dla pozostałych silników wyrażeń regularnych. Wyrażenia regularne są mechanizmem uniwersalnym, dostępne są w wielu językach programowania. Ucząc się ich raz, poznajesz język wyrażeń regularnych dostępny także w innych językach programowania. Siłą rzeczy skupię się tutaj na dialekcie wyrażeń regularnych w języku Java. Wyrażenie regularne to tak zwany wzorzec, który następne jest kompilowany przez silnik wyrażeń regularnych do wewnętrznej postaci. Po tym etapie używana jest „wewnętrzna reprezentacja” wyrażenia regularnego. Jeśli spróbujesz skompilować wzorzec, który nie jest poprawny zostaniesz o tym poinformowany odpowiednim wyjątkiem w trakcie działania programu. Sam etap kompilacji wyrażenia jest procesem relatywnie długim1. Z tego właśnie powodu zaleca się kompilowanie wyrażeń przed ich pierwszym użyciem. Podobnie sprawa ma się jeśli chodzi o tworzenie nowych instancji klasy wzorca. Im ich mniej tym lepiej. Ma to szczególne znaczenie w sytuacji w której używamy wyrażenia wielokrotnie2. W wyrażeniach regularnych poza „dziwnymi znaczkami” używa się także zwyczajnych liter. Domyślnie w wyrażeniach regularnych wielkość liter ma znaczenie. Wyrażenie regularne Kawa to nie to samo co kawa.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Kiedy używamy wyrażeń regularnych No właśnie, do czego używamy wyrażeń regularnych? Ogólnie można powiedzieć, że wyrażeń regularnych używamy do pracy z łańcuchami znaków. Wyszukiwanie, dzielenie, czy modyfikacja łańcuchów znaków, to wszystko można zrobić przy pomocy wyrażeń regularnych. W praktyce jednym z głównych zastosowań jest weryfikacja czy dany łańcuch znaków pasuje do wzorca. Wzorcem tym jest wyrażenie regularne. To czy łańcuch znaków pasuje do wzorca wykorzystywane jest w trakcie walidacji danych wejściowych. Dzięki wyrażeniom regularnym możemy sprawdzić, czy dane pochodzące od użytkownika mają poprawny format. Na przykład następujące wyrażenie regularne pozwala sprawdzić czy użytkownik podał poprawne imię [A-Z][a-z]+, czy rzeczywiście adres e-mail może być poprawny .+@.+\\.pl3, czy format daty, który prowadził użytkownik jest w porządku \\d{4}-\\d{2}-\\d{2}. Ponadto, wyrażeń regularnych możemy używać do „parsowania” łańcuchów znaków. Jeśli mamy większy łańcuch, z którego chcemy wyciągnąć jakąś część wyrażenia regularne mogą nam w tym pomóc. Na przykład jeśli w telefonie zapisujemy znajomych jako “imię (pseudonim) nazwisko”, wyrażenie regularne \\w+ \\((\\w+)\\) \\w+ pomoże nam wyciągnąć pseudonim. Wyrażenia regularne w języku Java W języku Java wyrażenia regularne obsługiwane są przez dwie klasy z biblioteki standardowej. Są to Pattern i Matcher. Spójrz na przykład poniżej: Pattern compiledPattern = Pattern.compile(\"Marcin\");Matcher matcher = compiledPattern.matcher(\"Nazywam sie Marcin Pietraszek\");System.out.println(matcher.find());System.out.println(matcher.matches());W przykładzie tym w pierwszej linijce kompiluję wyrażenie regularne Marcin uzyskując instancję klasy Pattern. W kolejnej linijce wywołując metodę matcher otrzymuję instancję klasy Matcher. Parametr przekazany w metodzie matcher to łańcuch znaków, na którym używamy wyrażenia regularnego. Klasa Matcher posiada, między innymi, następujące metody:   find() - metoda zwraca true jeśli w łańcuchu znaków znajduje się coś co pasuje do wyrażenia regularnego,  matches() - metoda zwraca true jeśli łańcuch znaków pasuje w całości do wyrażenia regularnego.Proszę spójrz na poniższą tabelkę. W nagłówkach kolumn umieściłem łańcuchy znaków, które dopasowywane są do wyrażeń umieszczonych w pierwszej kolumnie.                    Mam na imię Marcin      Marcinkowski      Marcin                  Marcin      find - truematches - false      find - truematches - false      find - truematches - true              Marcinkowski      find - falsematches - false      find - truematches - true      find - falsematches - false      Jak widzisz wyrażenia regularne mogą wyglądać jak „normalne” łańcuchy znaków. Jednak takie raczej nie są ciekawe i zbytnio użyteczne. Prawdziwa siła wyrażeń regularnych tkwi w tych wszystkich magicznych znaczkach :). Postaram się je teraz omówić. Składnia wyrażeń regularnych Wszystkie przykłady kodu to poprawne testy jednostkowe (więcej o testach przeczytasz w osobnym artykule). Zachęcam do ich skopiowania do IDE i samodzielnego kombinowania :). Jak już widziałeś w poprzednim przykładzie wyrażenia regularne mogą zawierać zwykłe literały znakowe, na przykład kot czy pies to poprawne wyrażenie regularne. Jednak są znaki, które interpretowane są w specjalny sposób. Wyrażenie takie jak 1 + 2 = 3 zawiera jeden ze znaków specjalnych – znak +. W związku z tym, jeśli znak + chcemy interpretować dosłownie musimy poprzedzić go znakiem \\, wówczas pomijamy jego specjalne znaczenie. W takim przypadku otrzymasz wyrażenie regularne 1 \\+ 2 = 3. Wyrażenia regularne a typ String Jednak to nie koniec „kłopotów”. W języku Java wyrażenia regularne zapisujemy używając typu String. Znak \\ jest w literałach znakowych traktowany specjalnie (podobnie jak w samych wyrażeniach regularnych). Na przykład literał znakowy \"\\t\" oznacza znak tabulacji, więc przy zapisie \"1 \\+ 2 = 3\" kompilator Javy doszukiwałby się specjalnego znaczenia dla \"\\+\" (podobnie jak przy \"\\t\") a nie o to nam tutaj chodzi. Dlatego właśnie w języku Java w wyrażeniach regularnych musimy „dublować” każdy ukośnik. Biorąc pod uwagę powyższe wytłumaczenie nasze wyrażenie regularne, w którym chcemy uciec od specjalnego znaczenia + musimy zapisać jako \"1 \\\\+ 2 = 3. Mi łatwiej jest to zrozumieć jeśli pomyślę o tym co dzieje się pod spodem:   pierwszy etap interpretacji literału znakowego (\"1 \\\\+ 2 = 3\") to etap w którym kompilator tworzy reprezentację łańcucha znaków zapisanego w definicji klasy, w trakcie tego etapu ukośniki interpretowane są przez kompilator,  kolejny etap to etap interpretacji łańcucha znaków z definicji klasy (1 \\+ 2 = 3) przez silnik wyrażeń regularnych. W tym etapie silnik wyrażeń regularnych interpretuje łańcuch znaków, który zapisał kompilator.W naszym przykładzie kompilator interpretując literał znakowy \"1 \\\\+ 2 = 3\" w pliku class zawierającym skompilowaną klasę zapisze 1 \\+ 2 = 3. Taka postać zostanie zinterpretowana przez silnik wyrażeń regularnych, który zobaczy, że ma pominąć specjalne znaczenie symbolu +. Pójdźmy o krok dalej. Ten przykład jest już zakręcony więc trzymaj się mocno ;). Co jeśli chcemy sprawdzić numer mieszkania. Załóżmy, że numer mieszkania to kilka cyfr oddzielonych ukośnikiem od kolejnej grupy cyfr. Przykładowy numer pasujący do tego opisu może wyglądać tak 123\\5. Jak już wiesz + dla silnika wyrażeń regularnych jest jednym z symboli specjalnych więc jego użycie trzeba poprzedzać \\. W związku z tym sam symbol \\ także jest traktowany w specjalny sposób więc i tu jego dosłowne użycie musi być poprzedzone \\. Więc w tym przypadku nasze wyrażenie regularne wygląda następująco 123\\\\5. A jak takie wyrażenie zapisać jako literał znakowy? Tak, trzeba zdublować każdy ukośnik, więc wychodzi nam taki potworek \"123\\\\\\\\5\". W dalszej części artykułu jeśli otoczę wyrażenie regularne \"\" wówczas będzie to poprawny literał (instancja String, z powtórzonymi ukośnikami). Jeśli nie będzie tych znaków, będzie to poprawne wyrażenie regularne (bez powtórzonych ukośników). Obsługa powtórzeń W wyrażeniach regularnych istnieje kilka mechanizmów, które pozwalają nam na obsługę powtórzeń, poniżej opiszę wszystkie z nich. Znak ? Znak ? oznacza – element znajdujący się wcześniej jest opcjonalny. Innymi słowy to co występuje przed ? może wystąpić raz lub może zostać pominięte. Na przykład do wyrażenia regularnego kr?at pasują zarówno \"krat\" jak i \"kat\" ale nie pasuje \"kot\" czy \"krrat\". @Testpublic void testSymbolQuestionMark() {    Pattern pattern = Pattern.compile(\"kr?at\");    assertTrue(pattern.matcher(\"krat\").matches());    assertTrue(pattern.matcher(\"kat\").matches());    assertFalse(pattern.matcher(\"krrat\").matches());    assertFalse(pattern.matcher(\"kot\").matches());}Znak * Znak * oznacza – powtórz dowolną liczbę razy element znajdujący się wcześniej. Dowolna liczba to powtórzenie 0 lub więcej razy. Na przykład wyrażenie regularne uwa*ga jest w stanie dopasować następujące łańcuchy znaków \"uwga\", \"uwaga\", \"uwaaaaaaga\" ale nie pasuje do \"uwagaaa\". @Testpublic void testSymbolAsterix() {    Pattern pattern = Pattern.compile(\"uwa*ga\");    assertTrue(pattern.matcher(\"uwga\").matches());    assertTrue(pattern.matcher(\"uwaga\").matches());    assertTrue(pattern.matcher(\"uwaaaaaaga\").matches());    assertFalse(pattern.matcher(\"uwagaaaa\").matches());}Znak + Znak + jest podobny do *. Oznacza on, że występujący przed nim element musi być powtórzony 1 lub więcej razy. Na przykład wyrażenie regularne trampo+lina może dopasować następujące łańcuchy znaków: \"trampolina\", \"trampooolina\" ale nie pasuje do \"tramplina\". @Testpublic void testSymbolPlus() {    Pattern pattern = Pattern.compile(\"trampo+lina\");    assertTrue(pattern.matcher(\"trampolina\").matches());    assertTrue(pattern.matcher(\"trampoooolina\").matches());    assertFalse(pattern.matcher(\"tramplina\").matches());}Powtórzenia inaczej Poza znakami ?, + i *, które określają dopuszczalną liczbę powtórzeń możesz też użyć {}. Jednak {} ma większe możliwości:   {x} - oznacza że element poprzedzający musi wystąpić dokładnie x razy,  {x,y} - oznacza, że element poprzedzający musi wystąpić od x do y razy,  {x,} - oznacza, że element poprzedzający musi wystąpić co najmniej x razy,  {,y} - oznacza, że element poprzedzający musi wystąpić co najwyżej y razy.Zauważ, że symbole ?, * i + możemy zastąpić {}. Na przykład wyrażenia regularne al*a i al{0,}a czy al+a i al{1,}a są sobie równoznaczne. Jednak zapis z ?, + czy * jest krótszy przez co częściej stosowany. Znak . Znak oznacza dowolny symbol (poza znakiem nowej linii). Innymi słowy do wyrażenia regularnego ko.ek pasują zarówno \"kotek\" jak i \"korek\" ale nie pasuje \"koek\" czy \"ktek\". @Testpublic void testSymbolDot() {    Pattern pattern = Pattern.compile(\"ko.ek\");    assertTrue(pattern.matcher(\"kotek\").matches());    assertTrue(pattern.matcher(\"korek\").matches());    assertFalse(pattern.matcher(\"koek\").matches());    assertFalse(pattern.matcher(\"ktek\").matches());}Zauważ, że wszystkie dotychczas omówione znaki możemy ze sobą połączyć uzyskując bardziej zaawansowane wyrażenie regularne. Na przykład k+a.*ta. Rozłóżmy to wyrażenie regularne na czynniki pierwsze:   k+ - oznacza literę k powtórzoną co najmniej raz,  a - litera a,  .* - oznacza dowolny znak (poza znakiem nowej linii) powtórzony 0 lub więcej razy,  ta - litery ta.Do takiego wyrażenia regularnego pasują następujące łańcuchy znaków \"kata\", \"katapulta\", \"karta\", \"kasia ma kota\" czy \"kkkka#$*&amp;JHDFStatata ale nie pasuje \"ata\" czy \"kta\". @Testpublic void testSymbolDotWithOthers() {    Pattern pattern = Pattern.compile(\"k+a.*ta\");    assertTrue(pattern.matcher(\"katapulta\").matches());    assertTrue(pattern.matcher(\"karta\").matches());    assertTrue(pattern.matcher(\"kasia ma kota\").matches());    assertTrue(pattern.matcher(\"kkkka#$*&amp;JHDFSta\").matches());    assertFalse(pattern.matcher(\"ata\").matches());    assertFalse(pattern.matcher(\"kta\").matches());}Teraz już wiesz jak można odczytać wyrażenie regularne użyte na początku artykułu do którego mogą pasować poprawne adresy e-mail .+@.+\\.pl. Rozkładając je na czynniki pierwsze mamy:   .+ - dowolny symbol użyty co najmniej raz,  @ - małpka,  .+ - ponownie dowolny symbol użyty co najmniej raz,  \\. - kropka rozumiana dosłownie (nie jako specjalny znak wyrażenia regularnego),  pl - następujące po sobie litery p i l.Klasy W wyrażeniach regularnych też istnieją klasy, jednak nie są to klasy jak w języku Java :). W kontekście wyrażeń regularnych klasy oznaczają grupy symboli, klasy oznaczamy przy pomocy nawiasów [ i ]. Na przykład wyrażenie regularne [rtmp]aca opisuje łańcuchy znaków \"raca\", \"taca\", \"maca\" czy \"paca\" ale już nie \"praca\" czy \"pacanów\". @Testpublic void testSimpleClasses() {    Pattern pattern = Pattern.compile(\"[rtmp]aca\");    assertTrue(pattern.matcher(\"raca\").matches());    assertTrue(pattern.matcher(\"taca\").matches());    assertTrue(pattern.matcher(\"maca\").matches());    assertTrue(pattern.matcher(\"paca\").matches());    assertFalse(pattern.matcher(\"praca\").matches());    assertFalse(pattern.matcher(\"pacanow\").matches());}Zakresy znaków Aby ułatwić zapisywanie grup znaków klasy pozwalają na definiowanie zakresów. Można to zrobić przy pomocy -. Na przykład do wyrażenia regularnego [a-d]uma pasują łańcuchy znaków \"auma\", \"buma\", \"cuma\" czy \"duma\" ale nie pasuje \"fuma\" czy \"abuma\". W podobnym sposób możemy podawać zakresy cyfr. Do wyrażenia regularnego [0-7]xyz pasują łańcuchy znaków \"0xyz\", \"1xyz\" czy \"7xyz\" ale nie pasuje \"8xyz\" czy \"07xyz\". @Testpublic void testClassWithRangeNumber() {    Pattern pattern = Pattern.compile(\"[0-7]xyz\");    assertTrue(pattern.matcher(\"0xyz\").matches());    assertTrue(pattern.matcher(\"1xyz\").matches());    assertTrue(pattern.matcher(\"7xyz\").matches());    assertFalse(pattern.matcher(\"8xyz\").matches());    assertFalse(pattern.matcher(\"07xyz\").matches());}Jak widzisz znak - wewnątrz klasy ma specjalne znaczenie, jeśli chcesz aby był interpretowany dosłownie umieść go jako ostatni w klasie [abc-]. Zakresy w klasie znaków można ze sobą łączyć. Na przykład do wyrażenia regularnego [a-cA-C0-3]bum pasują łańcucy znaków \"abum\", \"Bbum\" czy \"0bum\" ale nie pasują już \"dbum\" czy \"aA0bum\". @Testpublic void testClassWithMultipleRanges() {    Pattern pattern = Pattern.compile(\"[a-cA-C0-3]bum\");    assertTrue(pattern.matcher(\"abum\").matches());    assertTrue(pattern.matcher(\"Bbum\").matches());    assertTrue(pattern.matcher(\"0bum\").matches());    assertFalse(pattern.matcher(\"dbum\").matches());    assertFalse(pattern.matcher(\"aA0bum\").matches());}Negacja klasy A co jeśli chcę dopasować wszystkie znaki prócz x, y i z? Klasy też na to pozwalają. Służy do tego znak ^ umieszczony jako pierwszy w klasie. Na przykład do wyrażenia regularnego [^xyz]awa pasują słowa \"kawa\", \"pawa\" czy \"Wawa\" ale nie pasują \"zawa\" czy \"yawa\". @Testpublic void testClassNegation() {    Pattern pattern = Pattern.compile(\"[^xyz]awa\");    assertTrue(pattern.matcher(\"kawa\").matches());    assertTrue(pattern.matcher(\"pawa\").matches());    assertTrue(pattern.matcher(\"Wawa\").matches());    assertFalse(pattern.matcher(\"zawa\").matches());    assertFalse(pattern.matcher(\"yawa\").matches());}Jeśli chcesz aby ^ był rozumiany dosłownie wewnątrz klasy nie umieszczaj go na pierwszy miejscu. Teraz już wiesz jak można odczytać wyrażenie regularne użyte na początku artykułu do którego pasują imiona: [A-Z][a-z]+. Rozłóżmy je na czynniki pierwszej   [A-Z] - znak z tej klasy znaków, wielka litera,  [a-z]+ - mała litera użyta co najmniej raz.Predefiniowane klasy znaków Klasy poznałeś w poprzednich akapitach. Tak się składa, że mechanizm ten jest dość często wykorzystywany w wyrażeniach regularnych. Co więcej, bardzo często zdarzają się klasy, które są częściej używane od innych. Na przykład wszystkie cyfry, czy wszystkie znaki użyte w słowach. Takie często używane klasy zostały wbudowane w wyrażenia regularne pod postacią predefiniowanych klas. Wszystkie predefiniowane klasy prezentuje lista poniżej:   \\d - jakakolwiek cyfra [0-9],  \\D - jakikolwiek znak, który nie jest cyfrą [^0-9],  \\w - znak używany w słowach [a-zA-Z0-9_] (zauważ, że mamy tu znak _),  \\W - jakikolwiek znak, który nie jest używany w słowach [^a-zA-Z0-9_],  \\s - tak zwane białe znaki czyli znak spacji czy tabulacji [ \\t\\n\\r\\f\\x0B]. Możesz je opisać jako znaki, które nie są widoczne podczas wydruku,  \\S - negacja grupy \\s czyli [^ \\t\\n\\r\\f\\x0B].Dla przykładu do wyrażenia regularnego \\d\\w\\d pasują łańcuchy znaków \"0_0\" czy \"0X1\" ale nie pasują \"a0b\" czy \"0 0\". @Testpublic void testPredefinedClases() {    Pattern pattern = Pattern.compile(\"\\\\d\\\\w\\\\d\");    assertTrue(pattern.matcher(\"0_0\").matches());    assertTrue(pattern.matcher(\"0X1\").matches());    assertFalse(pattern.matcher(\"a0b\").matches());    assertFalse(pattern.matcher(\"0 0\").matches());}Pamiętasz o ukośniku? Wyrażenie regularne \\d zapisane jako String w języku Java potrzebuje dodatkowego ukośnika, powstaje nam zatem \"\\\\d\". Teraz już wiesz, jak można odczytać wyrażenie regularne użyte na początku artykułu, do którego pasują daty: \\d{4}-\\d{2}-\\d{2}:   \\d{4} - cztery cyfry oznaczające rok,  - - minus oddzielający rok od miesiąca,  \\d{2} - dwie cyfry oznaczające miesiąc,  - - minus oddzielający miesiąc od dnia,  \\d{2} - dwie cyfry oznaczające dzień.Dasz też sobie radę z \\d{2}-\\d{3} opisującym kody pocztowe. Grupy Do tej pory poznałeś mechanizmy wyrażeń regularnych które pozwalają na sprawdzenie czy dany łańcuch pasuje do danego wyrażenia regularnego. Teraz przejdziemy do mechanizmu grup, który pozwala na wyłuskanie z łańcucha znaków pewnego fragmentu wewnątrz. Weźmy za przykład zdanie \"Ala ma kota. Kot ma na imię --Zygmunt--. Kot jest czarny.\". Załóżmy, że chcielibyśmy wyciągnąć z tego zdania imię kota. Dla uproszczenia umieściłem je pomiędzy dwoma minusami. Następujące wyrażenie regularne może nam w tym pomóc: [^-]*--(\\w+)--.*. Rozłóżmy je na czynniki pierwsze:   [^-]* - Jakikolwiek znak tylko nie minus powtórzony dowolną ilość razy,  -- - dwa minusy,  ( - rozpoczęcie grupy,  \\w+ - znak użyty w słowach występujący co najmniej raz,  ) - zamknięcie grupy,  -- - dwa minusy,  .* - dowolny znak występujący 0 lub więcej razy.W naszym przykładzie imię Zygmunt znajdujące się pomiędzy podwójnymi minusami zostanie przypisane do grupy. Grupowanie oznaczamy nawiasami (). W wyrażeniu regularnym może być kilka grup, numerowane są one zawsze od jedynki. Jeśli dany łańcuch znaków pasuje do wyrażenia regularnego wówczas domyślnie ląduje on w grupie z numerem 0. Obiekt klasy Matcher posiada zestaw metod, które operują na grupach. Skupimy się na dwóch z nich:   groupCount() - zwraca liczbę grup w wyrażeniu regularnym (pomijając tę domyślną z indeksem 0),  group(int groupNumber) - zwraca grupę pod konkretnym numerem.@Testpublic void testBasicGroups() {    Pattern pattern = Pattern.compile(\"[^-]*--(\\\\w+)--.*\");    Matcher matcher = pattern.matcher(\"Ala ma kota. Kota ma na imie --Zygmunt--. Kot jest czarny.\");    matcher.matches();    assertEquals(\"Zygmunt\", matcher.group(1));}W przykładzie powyżej widzisz, kod który używa grupowania do pobrania imienia kota ze zdania. Operatory powtórzeń można stosować do grup. Wyrażenie regularne (\\w+ ){3} pasuje do trzech słów, które mogą być oddzielone spacją. Teraz już wiesz, jak można odczytać wyrażenie regularne użyte na początku artykułu, do odczytywania pseudonimu z książki adresowej \\w+ \\((\\w+)\\) \\w+. Rozkładając wyrażenie na czynniki pierwsze otrzymujemy:   \\w+ - cyfry, litery lub podkreślnik użyte co najmniej raz,  \\( - znak nawiasów użyty dosłownie,  (\\w+) - ponownie cyfry, litery lub podkreślnik użyte co najmniej raz ale tym razem złapane w grupę,  \\) - znak nawiasów użyty dosłownie,  \\w+ - po raz kolejny fragment pasujący tym razem do nazwiska.IDE pomaga IntelliJ Idea ma dość przydatną funkcję, która pomaga przy pracy z wyrażeniami regularnymi. Naciskając &lt;Alt + Enter&gt; na wyrażeniu regularnym i klikając na „Check RegExp” pokaże się okienko, w którym na żywo możesz sprawdzić działanie wyrażenia regularnego.         Check RegExp menu.          Check RegExp dialog.  Wady wyrażeń regularnych i praktyczne wskazówki Wyrażenia regularne to bardzo wszechstronne i skomplikowane narzędzie. Narzędzie, które ma dużo możliwości. Jednak niestety ma też swoje wady. Używanie wyrażeń regularnych gdzie zwykła manipulacja łańcuchami znaków jest możliwa nie zawsze jest dobrym rozwiązaniem. Jeśli można to zrobić prostymi metodami używaj ich zamiast wyrażeń regularnych. Wyrażenia regularne są wolne. Kompilacja wyrażenia i później ciężka praca silnika wyrażeń regularnych zajmuje więcej czasu niż zwykłe pobranie części łańcucha znaków na przykład od trzeciego do dziesiątego znaku włącznie. Skomplikowane wyrażenie regularne są ciężkie w utrzymaniu i zrozumieniu. Nadziubać potworka każdy może, gorzej jest później ze zrozumieniem takiego fragmentu miesiąc czy trzy miesiące później. Jeśli to możliwe, lepiej upraszczać je maksymalnie jak się da. Wyrażenia regularne nie zawsze są w stanie sprawdzić wszystko. Bo jak na przykład napisać wyrażenie regularne, które ze stuprocentową pewnością powie, że data jest poprawna? Podejmujesz się napisania takiego wyrażenia? :) Czy na przykład data 2015-02-29 jest poprawna? Na pierwszy rzut oka wszystko jest z nią w porządku prawda? Napisać wyrażenie regularne, które „udowodni”, że jest ona błędna jest nie lada sztuką, ja bym się chyba takiego zadania nie podjął ;). Jeśli w Twoim wyrażeniu regularnym jest dużo * zastanów się jeszcze raz czy aby na pewno + nie będzie w tym przypadku wystarczający. Rzadko kiedy zależy nam na „zerowej liczbie znaków”. Zadania do wykonania Twoim dzisiejszym zadaniem będzie napisanie kilku wyrażeń regularnych, które będą potrafiły walidować przykładowe dane pochodzące od użytkownika. Napisz wyrażenie regularne, które:   Sprawdza czy liczba zmiennoprzecinkowa podana przez użytkownika ma poprawny format. Na przykład liczba 123,2341515132135 czy -10 są poprawne ale 18-12 czy 123, już nie,  sprawdza czy numer domu jest w formacie numer\\numer. Poprawnym numerem jest 123\\2A, 24B\\3 czy 12\\5, ale już numer abc\\cba nie,  sprawdza czy użytkownik wprowadził poprawną nazwę miasta. Na przykład Wrocław, Zielona Gora czy Bielsko-Biala jest ok, jednak Ptysiow123 już nie. Dla uproszczenia załóżmy, że żadna nazwa miejscowości nie zwiera polskich znaków.Rozwiązania jak zwykle są na githubie jednak zachęcam do samodzielnej pracy. Próbując rozwiązać zadania samodzielnie nauczysz się najwięcej. Dodatkowe materiały do nauki Poniżej przygotowałem dla Ciebie kilka dodatkowych linków, które zawierają materiały związane z wyrażeniami regularnymi.   Rubular - narzędzie pozwalające na sprawdzenie wyrażenia regularnego. Co prawda dotyczy wyrażeń regularnych dla języka Ruby jednak w przypadku Javy też znajduje zastosowanie,  Regexr - kolejne narzędzie pomagające w testowaniu wyrażeń regularnych.  http://www.regular-expressions.info - bezsprzecznie najlepszy materiał w sieci jaki znalazłem na temat wyrażeń regularnych. Zawiera szczegółowy opis zarówno tych podstawowych jak i zaawansowanych technik. Sam bardzo często korzystam z tego źródła,  artykuł na temat wyrażeń regularnych na Wikipedii,  dokumentacja dla klasy Pattern,  dokumentacja dla klasy Matcher,  tutorial dotyczący wyrażeń regularnych na stronie Oracle,  kod źródłowy przykładów użytych w artykule.Podsumowanie Mimo, że artykuł zawiera dość sporą ilość informacji na temat wyrażeń regularnych nie mówi o wszystkich możliwościach. Pominąłem tu celowo na przykład kwestie tak zwanego backtrackingu, zachłanności, alternatyw, nazwanych grup, ponownego użycia grup w wyrażeniu, flag, kotwic itd. Te zagadnienia opisuję w drugiej części. Tymczasem dzięki za lekturę i na koniec mam do Ciebie prośbę. Proszę podziel się linkiem do artykułu ze swoimi znajomymi, zależy mi na dotarciu do jak największej grupy czytelników i możesz mi w tym pomóc. Jeśli nie chcesz pominąć żadnego kolejnego artykułu zapisz się do newslettera i polub moją stronę na Facebooku. Do następnego razu!             Mówię to o długim w kontekście innych operacji takich jak dodawanie czy pobranie trzeciej litery z łańcucha znaków. &#8617;               Co prawda w języku Java każda instancja klasy Pattern kompilowana jest dokładnie raz jednak warto zapamiętać tę regułę w przypadku innych języków programowania. &#8617;               Oczywiście to wyrażenie regularne można “oszukać”. Nawet jeśli łańcuch znaków pasuje do wzorca nie musi być poprawnym adresem e-mail. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/wyrazenia-regularne-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/11/28_wyrazenia_regularne_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 1",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/1 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Zadania celowo publikuję z opóźnieniem, aby rozwiązania nie miały wpływu na zabawę innych. Dodatkowo każdego dnia na stronie Advent of Code publikowane są dwa zadania. Drugie dostępne jest po rozwiązaniu pierwszego. Przykładowe rozwiązanie zawiera oba rozwiązania jednak prezentuję treść tylko pierwszego z nich. Mam nadzieję, że uda mi się rozwiązać wszystkie zadania, chociaż kto wie. Może jak pojawią się trudniejsze problemy algorytmiczne będę potrzebował pomocy? Zobaczymy :). Zarys historii Sanie Świętego Mikołaja potrzebują zegara o bardzo wysokiej dokładności do wskazywania kierunku, oscylator zegara regulowany jest przez gwiazdy. Niestety, gwiazdy zostały ukradzione przez Króliczka Wielkanocnego. Aby ocalić Święta Wielki Mikołaj musi odzyskać wszystkie 50 gwiazdek do 25 grudnia. Zbieraj gwiazdki rozwiązując zadania, każdego dnia udostępnione będą dwa zadania w kalendarzu adwentowym, drugie zadanie jest dostępne po ukończeniu pierwszego. Za rozwiązanie zadania otrzymujesz gwiazdkę. Powodzenia! Dzień 1 zadanie 1 Wylądowałeś niedaleko Kwatery Głównej Króliczka Wielkanocnego. Niestety „niedaleko”, nie oznacza w Kwaterze Głównej. Instrukcje na Dokumentach Rekrutacyjnych Króliczka Wielkanocnego pomagające w dotarcku do Kwater rozpracowały Elfy. Zaczynają się one od miejsca zrzutu, nikt nie miał czasu rozpracować ich do końca aby uzyskać dokładny adres Kwatery. Dokumenty mówią, że powinieneś rozpocząć swoją podróż do Kwatery w punkcie w którym wylądowałeś i zwrócić się na północ. Następnie powinieneś podążać zgodnie ze wskazówkami - skręcić w lewo (L) lub w prawo (R) o 90 stopni i iść prosto zadaną liczbę bloków kończąc na nowym skrzyżowaniu. Nie masz czasu na podążanie za tak absurdalnymi instrukcjami na pieszo, zanim ruszysz wolisz poznać dokładne współżędne celu. Zakładając, że możesz poruszać się wyłącznie ulicami miasta jak długa jest najkrótsza droga do celu? Na przykład:   Podążając za instrukcjami R2, L3 kończysz 2 bloki na wschód i 3 bloki na północ, lub 5 bloków od pozycji startowej,  podążając za R2, R2, R2 kończysz 2 bloki na południe od pozycji startowej,  podążając za R5, L5, R5, R3 kończysz 10 bloków na wschód i 2 bloki na północ, lub 12 bloków od pozycji startowej.Jak daleko od pozycji lądowania znajduje się Kwatera Główna Króliczka Wielkanocnego? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-1/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/advent_of_code_2016_01_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 2",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/2 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 2 zadanie 1 Docierasz do Kwatery Głównej Króliczka Wielkanocnego pod osłoną nocy. Zrzut odbył się w takim pośpiechu, że zapomniałeś skorzystać z toalety! Odjechane budynki, takie jak Kwatera Główna Króliczka Wielkanocnego, wejścia do toalet przeważnie mają chronione kodem. Zaczynasz szukać recepcji z nadzieją, że tam znajdziesz kod. Znalazłeś dokument, zaczynasz czytać “W celu poprawienia bezpieczeństwa kody do toalet nie będą już zapisywane na kartkach. Proszę je zapamiętać i podążać za instrukcjami poniżej aby dostać się do toalety.”. Dokument wyjaśnia, że każdy znak kodu, który ma być naciśnięty może być odnaleziony zaczynając od poprzedniego znaku. Ruch polega na poruszaniu się po sąsiadujących przyciskach według instrukcji:   U do góry,  D w dół,  L w lewo,  R w prawo.Każda linijka z instrukcjami odpowiada jednemu znakowi na klawiaturze. Każda kolejna instrukcja rozpoczyna od znaku, na którym skończyłeś poprzednio. Dla pierwszej linii zakładamy, że pozycją początkową jest “5”. Jeśli ruch “wychodzi” poza klawiaturę zignoruj go. Powoli nie możesz już wytrzymać więc decydujesz się odgadnąć kod w drodze do toalety. Wyobrażasz sobie klawiaturę w postaci: 1 2 34 5 67 8 9Zakładając, że instrukcje są następujące: ULLRRDDDLURDLUUUUD  Zaczysznasz na 5, idziesz do góry (2), w lewo (1) i w lewo (nie możesz wykonać tego ruchu więc zostajesz na 1), pierwszą cyfrą kodu jest 1,  Zaczynając z poprzedniego przycisku (1), poruszasz się w prawo dwa razy (3) i trzy razy w dół (9) (zatrzymujesz się na 9 po dwóch ruchach, ignorując trzeci), drugą cyfrą kodu jest 9,  Idąc dalej z 9 idziesz w lewo (8), do góry (5), w prawo (6), w dół (9) i w lewo (8), trzecią cyfrą kodu jest 8,  W końcu, z 8 idziesz do góry cztery razy (zatrzymując się na 2) i raz w dół kończąc na 5.W tym przypadku kod do toalety to 1985. Jaki jest kod do toalety jeśli instrukcje są jak w pliku day02_input.txt? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-2/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_02_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 3",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/3 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 3 zadanie 1 Po przygodach z wczorajszego dnia w końcu możesz się skupić i czysto myśleć. Zagłębiłeś się w labirynt korytarzy i boksów biurowych, które wypełniają tę część Kwatery Głównej Króliczka Wielkanocnego. To musi być dział projektantów graficznych, ściany pokryte są specyfikacjami dla trójkątów. Hmm, czy aby na pewno? Dokumenty z projektami pokazują długości boków każdego z trójkątów, ale… 5 10 25? Niektóre z nich nie są trójkątami. Musisz odrzucić te niepoprawne. W poprawnym trójkącie suma dwóch boków musi być krótsza od najdłuższego boku. Na przykład nie można zbudować trójkąta z odcinków o długościach 5, 10 i 25. 5 + 10 nie jest większe niż 25. Jak dużo poprawnych trójkątów znajduje się w pliku wejściowym? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-3/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_03_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 4",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/4 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 4 zadanie 1 Twoja pomoc z problemem trójkątów z wczoraj pozwoliła dotrzeć do automatu informacyjnego z listą pokoi. Oczywiście lista jest zaszyfrowana i pełna nieprawdziwych danych mających wprowadzić Cię w błąd. Całe szczęście udało Ci się znaleźć ledwo ukryte instrukcje jak dekodować te dane. Zacznij jednak od usunięcia danych, ktróre są niepoprawne. Każdy pokój składa się z zaszyfrowanej nazy (małe litery oddzielone minusami), po której jest minus, identyfikator sektoru i suma kontrolna w nawiasach kwadratowych. Nazwa pokoju jest prawdziwa jeśli suma kontrolna to pięć najczęściej spotykanych liter w zaszyfrowanej nazwie pokou. Litery powinny być ułożone w porządku malejącym według liczby wystąpień. Jeśli kilka liter ma taką samą liczbę wystąpień, to powinny być one posortowane alfabetycznie. Dla przykładu:   aaaaa-bbb-z-y-x-123[abxyz] jest poprawną nazwą pokoju ponieważ najczęściej występującymi literami są a (5), b (3). x, y i z mające po jednym wystąpieniu posortowane są alfabetycznie,  a-b-c-d-e-f-g-h-987[abcde] jest poprawną nazwą pokoju, chociaż wszystkie litery występują dokładnie taka samą liczbę razy suma kontrolna zawiera pierwszą piątkę posortowaną alfabetycznie,  not-a-real-room-404[oarel] jest poprawną nazwą pokoju,  totally-real-room-200[decoy] jest błędną nazwą pokju - suma kontrolna nie jest poprawna.Biorąc pod uwagę prawdziwe nazwy pokoi z powyższej listy suma ich sektorów wynosi 1514. Jaka jest suma sektorów prawdziwych pokoi z listy tej listy? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-4/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_04_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 5",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/5 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 5 zadanie 1 Dzięki temu, że wczoraj znalazłeś poprawny pokój, dzisiaj stoisz przed drzwiami bezpieczeństwa opracowanymi przez inżynierów Króliczka Wielkanocnego. Wydaje się, że większość swojej wiedzy o bezpieczeństwie wyciągnęli oglądając filmy o hakerach. Hasło chroniące drzwi o długości ośmiu znaków wygenerowane jest znak po znaku znajdując odpowiednią sumę MD5. Suma ta generowana jest na podstawie identyfikatora drzwi i numeru. Numer przy każdej iteracji zwiększamy o jeden zaczynając od 0. Hash zawiera kolejny symbol kodu jeśli jego heksadecymalna reprezentacja zaczyna się pięcioma zerami. Jeśli tak jest, szósty znak w sumie jest kolejnym znakiem hasła do drzwi. Dla przykładu, jeśli identyfikator drzwi to abc:   Pierwszy numer, przy którym otrzymamy sumę zaczynającą się od pięciu zer to 3231929. Tę sumę MD5 znajdziemy dla łańcucha abc3231929. Szósty znak otrzymanej sumy kontrolnej, jest kolejnym znakiem hasła. W tym przypadku szósty znak to 1 i jest pierwszy znakiem hasła,  przy 5017308 otrzymamy kolejną interesującą nas sumę kontrolną, zaczyna się ona od 000008f82, więc drugim znakiem hasła jest 8 (szósty znak w sumie),  trzecią suma zaczynająca się od pięciu zer otrzymamy dla łańcucha abc5278568, odnajdując kolejny znak hasła f.W tym przykładzie, kontynuując poszukiwania aż odnajdziemy osiem znaków hasło jakie otrzymamy to 18f47a30. Jakie będzie hasło jeśli identyfikator drzwi to abbhdwsy? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-5/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_05_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 6",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/6 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 6 zadanie 1 Wczorajsze złamanie kodu do drzwi pomogło Ci dostać się do odpowiedniego pokoju z prezentami. Dzisiaj próbujesz skontaktować się ze Świętym Mikołajem. Coś się jednak zacina. Na szczęście sygnał nie jest w pełni zakłócony i instrukcja w sytuacjach jak ta zaleca przełączenie się do kodu z powtórzeniami żeby przesłać wiadomość poprawnie. W tym modelu wiadomość wysyłana jest kilkukrotnie. Zachowałeś wszystkie otrzymane do tej pory sygnały, jednak dane wydają się być dość mocno zakłócone. Prawie niemożliwe do odzyskania. Prawie robi wielką różnicę :). Jedyne co musisz zrobić to odnaleźć, która litera powtarza się największą liczbę razy na każdej pozycji. Na przykład, zakładając, że otrzymałeś następujące sygnały: eedadndrvteeeandsrraavrdatevrstsrnevsdttsarasrtvnssdtsntnadasvetvetesnvtvntsndvrdeardvrsenenararNajczęściej pojawiającą się literą na pierwszej pozycji jest e, na drugiej a na trzeciej s i tak dalej. Łącząc te litery ze sobą otrzymasz prawdziwy sygnał bez zakłóceń, easter. Zakładając, że wszystkie przychodzące komunikaty zostały zapisane w tym pliku, jaka wiadomość (po oczyszczeniu zakłóceń) była rzeczywiście wysłana? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-6/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_06_artykul.jpg"},{
        "title": "Advent of Code dzień 7",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/7 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 7 zadanie 1 Wczoraj odebrałeś tajny kod od Świętego Mikołaja. Dzisiaj nadszedł czas na inwigilację sieci w Kwaterze Głównej Króliczka Wielkanocnego. W trakcie podsłuchiwania ruchu zebrałeś listę adresów IP (oczywiście są to adresy IPv71, IPv6 jest zbyt ograniczony…). Chciałbyś dowiedzieć się, które z tych adresów wspierają TLS. Adres IPv7 wspiera TLS jeśli zawiera sekwencję ABBA wewnątrz standardowych części adresu IP. Sekwencja ABBA to czteroznakowa sekwencja, które zawiera parę dwóch różnych znaków, po której znajduje się ta sama para ale odwrócona. Na przykład xyyx czy abba. Jednak aby adres IPv7 wspierał TLS, sekwencja ABBA nie może znajdować się w żadnej części “hypernet” adresu IP. Części “hypernet” znajdują się między nawiasami []. Na przykład:   abba[mnop]qrst wspiera TLS, sekwencja ABBA abba znajduje się poza nawiasami [],  abcd[bddb]xyyx chociaż sekwencja ABBA xyyx jest poza nawiasami, adres ten nie wspiera TLS, sekwencja ABBA znajduje się także wewnątrz nawiasów bddb,  aaaa[qwer]tyui nie wspiera TLS, aaaa nie jest poprawną sekwencją ABBA,  ioxxoj[asdfgh]zxcvbn wspiera TLS, sekwencja ABBA oxxo znajduje się poza nawiasami (nie ma znaczenia to, że znajduje się wewnątrz dłuższego łańcucha).Zakładając, że wszystkie adresy IP, które udało Ci się podsłuchać znajdują się na tej liście, ile z nich wspiera TLS? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu!             IPv7 w tym momencie nie istnieje. &#8617;       ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-7/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_07_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 8",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/8 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 8 zadanie 1 Dzięki Twoje pomocy poprzednio udało się znaleźć wszystkie adresy w Kwaterze Głównej Króliczka Wielkanocnego wspierające TLS. Dzisiaj czeka na Ciebie inne zadanie. Trafiłeś na drzwi. Wydaje się, że drzwi implementują coś w rodzaju uwierzytelniania dwuskładnikowego. Aby przez nie przejść na początku musisz użyć karty magnetycznej (z tym nie ma problemu, jedną znalazłeś na pobliskim biurku). Następnie, na malutkim ekranie pokazywany jest kod, który musisz wklepać na klawiaturze przy drzwiach. Później można tylko zakładać, że drzwi się otworzą. Niestety, wyświetlacz, na którym pokazywany jest kod jest rozbity. Po kilku minutach i rozłożeniu wszystkiego na części dowiedziałeś się dokładnie jak on działa. Teraz nie zostało już nic innego jak tylko dojść do tego co pokazałby wyświetlacz. Pasek magnetyczny na karcie, której możesz użyć do otworzenia drzwi zawiera sekwencje instrukcji dla wyświetlacza. Te instrukcje są także wejściem do zadania, które musisz rozwiązać. Ekran ma 50 pikseli szerokości i 6 pikseli wysokości. Wszystkie piksele na początku są wyłączone. Sam ekran jest w stanie wykonać trzy specyficzne polecenia:   rect AxB włącza wszystkie piksele w prostokącie w lewym górnym rogu ekranu. Prostokąt jest szeroki na A pikseli i wysoki na B pikseli,  rotate row y=A by B przesuwa wszystkie piksele w rzędzie A (gdzie 0 to pierwszy wiersz od góry) w prawo o B pikseli. Piksele, które “wypadłyby” za ekran pokazują się po lewej stronie ekranu,  rotate column x=A by B przesuwa wszystkie piksele w kolumnie A (gdzie 0 to pierwsza kolumna od lewej strony) w dół o B pikseli. Pikseke, które “wypadłyby za ekran pokazują się na górze kolumny.Dla przykładu poniższa sekwencja pokazuje operacje dla mniejszego ekranu o wymiarach 7 na 3 pikseli:   rect 3x2 tworzy mały prostokąt w lewym górnym rogu,###....###...........  rotate column x=1 by 1 przesuwa kolumnę 1 w dół o 1 piksel,#.#....###.....#.....  rotate row y=0 by 4 przesuwa wiersz 0 w prawo o 4 piksele,....#.####.....#.....  rotate column x=1 by 1 ponownie przesuwa kolumnę 1 w dół o 1 piksel. Tym razem piksel z ostatniego rzędu pojawia się w pierwszym rzędzie,.#..#.##.#.....#.....Jak widzisz, ta technologia obsługi ekranów ma niesamowite możliwości i niedługo zdominuje rynek małych wyświetlaczy. Przynajmniej tak twierdzi naklejka reklamowa z tyłu wyświetlacza. Twoim zadaniem jest policzenie pikseli, które będą świeciły się na ekranie po wprowadzeniu sekwencji komend z pliku wejściowego. Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-8/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_08_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 9",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/9 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 9 zadanie 1 Wczoraj, dzięki Twojej pomocy udało odczytać to co powinno być wyświetlone na zniszczonym wyświetlaczu. Dzięki temu dostałeś się do chronionej części Kwatery Głównej. Przechadzając się po korytarzach natknąłeś się na port, dzięki któremu możesz dostać się do pozostałej części sieci. Pobieżnie przeskanowałeś interesujące pliki, jeden z nich szczególnie przykuł Twoją uwagę. Plik ten jest skompresowany w pewnym eksperymentalnym formacie. Na szczęście dokumentacja tego formatu znajdowała się niedaleko. Format kompresuje sekwencje znaków. Białe znaki (spacje, znaki nowej linii itp.) są ignorowane. Aby zaznaczyć, że jakaś sekwencja powinna być powtórzona, umieszcza się przed nią odpowiedni znacznik, na przykład (10x2). Aby zdekompresować następującą po nim sekwencję należy wziąć kolejne 10 znaków i powtórzyć je dwa razy. Następnie należy kontynuować czytanie skompresowanej zawartości po powtórzonej sekwencji. Sam znacznik nie jest dołączany do zdekompresowanego wyjścia. Jeśli nawiasy, czy inne znaki wystąpią wewnątrz sekwencji, która powinna być powtórzona - wszystko jest w porządku. Należy traktować je jak normalne dane, nie znacznik i kontynuować poszukiwanie znaczników po sekcji, która została powtórzona. Dla przykładu:   ADVENT nie zawiera żadnych znaczników, więc po dekompresji otrzymamy ADVENT bez żadnych zmian, wynik po dekompresji ma długość 6,  A(1x5)BC powtarza tylko B pięć razy, finalnie otrzymujemy ABBBBBC o długości 7,  (3x3)XYZ po dekompresji otrzymujemy XYZXYZXYZ o długości 9,  A(2x2)BCD(2x2)EFG, powtarzamy znaki BC i EF, otrzymujemy ABCBCDEFEFG o długości 11 znaków,  (6xa)(1x3)A po dekompresji otrzymujemy (1x3)A, chociaż (1x3) wygląda jak znacznik nie jest przetwarzany bo znajdował się wewnątrz zakresu obsługiwanego przez (6x1), podobnie jak A nie jest traktowany specjalnie. Finalnie otrzymujemy łańcuch o długości 6,  X(8x2)(3x3)ABCY po dekompresji otrzymujemy X(3x3)ABC(3x3)ABCY o długości 18 znaków.Jaka jest długość zdekompresowanej sekwencji jeśli skompresowane dane zapisane są w tym pliku? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-9/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_09_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 10",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/10 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 10 zadanie 1 Dzięki Twojej pomocy przy wczorajszym zadaniu udało się zdekompresować kilka interesujących plików. Doszedłeś do fabryki w której małe latające robociki przekazują sobie mikrochipy. Po dokładniejszym przyjrzeniu się zauważyłeś, że każdy robot przekazuje cokolwiek dalej tylko jeśli ma dwa mikrochipy. Jeśli już je ma, przekazuje je innemu robotowi lub wrzuca je do jednego z koszy oznaczających “wyjście”. Czasami roboty pobierają mikrochipy z koszy oznaczonych napisem “wejście”. Patrząc na jeden z mikrochipów wydaje się, że zawierają one pojedynczy, unikalny numer. Roboty używają pewnej logiki aby zdecydować co zrobić z każdym z chipów. Dostałeś się do lokalnego komputera i udało Ci się ściągnąć instrukcje sterujące robotami (wejście do zadania). Niektóre z instrukcji określają, że mikrochip o konkretnej wartości powinien być przekazany konkretnemu robotowi. Reszta instrukcji określa co każdy robot powinien zrobić z mikrochipami które posiada. Instrukcja ta mówi o tym co robot powinien zrobić z chipem o niższej i o wyższej wartości. Na przykład, biorąc pod uwagę poniższy zestaw instrukcji: value 5 goes to bot 2bot 2 gives low to bot 1 and high to bot 0value 3 goes to bot 1bot 1 gives low to output 1 and high to bot 0bot 0 gives low to output 2 and high to output 0value 2 goes to bot 2Początkowo, robot 1 zaczyna z chipem o wartości 3 a robot 2 zaczyna z chipami o wartości 2 i 5. Ponieważ robot 2 ma dwa mikrochipy przekazuje ten o mniejszej wartości (2) do robota 1 a ten o większej wartości (5) do robota 0. Po tych instrukcjach robot 1 ma dwa chipy. Mikrochip o wartości 2 umieszcza w koszu wyjściowym o numerze 1 i przekazuje mikrochip o wartości 3 do robota 0. Jako ostatni robot 0 mający dwa mikrochipy przekazuje ten o mniejszej wartości (3) do wyjścia 2 a ten o większej wartości (5) do kosza 0. Na końcu:   kosz wyjściowy 0 zawiera mikrochip o wartości 5,  kosz wyjściowy 1 zawiera mikrochip o wartości 2,  kosz wyjściowy 2 zawiera mikrochip o wartości 3.W tej konfiguracji robot numer 2 był odpowiedzialny za porównywanie wartości mikrochipów o wartości 5 i 2. Bazując na instrukcjach dla robotów umieszczonych w tym pliku, robot o którym numerze odpowiedzialny jest za porównywanie mikrochipów o wartościach 61 i 17? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-10/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_10_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 11",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/11 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 11 zadanie 1 Wczoraj, dzięki Twojej pomocy udało się poprawnie sterować dronami, dziś czeka na Ciebie duuużo trudniejsze zadanie. Nie zrażaj się jeśli coś nie będzie szło po Twojej myśli, nie jest to trywialny problem :). Dzisiaj doszedłeś do miejsca gdzie cztery piętra, poza małym korytarzem, zostały zupełnie odseparowane od reszty budynku. Przechodząc przez niego widzisz znaki ostrzegające o promieniowaniu i wielki znak na którym widnieje napis “Dział Badania Cząstek Radioaktywnych”. Według konsoli pokazującej status cząstek ten obiekt jest aktualnie wykorzystywany do eksperymentowania z generatorami radioizotopów z przetwornikami termoelektrycznymi (ang. Radioisotope Thermoelectic Generators) zwanymi także RTG lub generatorami. Generatory są zaprojektowane tak aby mogły być sparowane ze specjalnie przygotowanymi mikrochipami. Sam generator jest wysoce radioaktywnym kamieniem, który generuje energię elektryczną odzyskiwaną z ciepła. Niestety eksperymentalne RTG mają słabą ochronę przeciwko promieniowaniu. Przez tę wadę są radioaktywne i niebezpieczne. Mikrochipy jako prototypy nie mają normalnej osłony przeciwko promieniowaniu ale mają możliwość generowania pola elektromagnetycznego, które chroni przez promieniowaniem. Aby móc wydzielić tę osłonę mikrochipy muszą być zasilane. Niestety mogą one być zasilone wyłącznie przez odpowiadające im RTG. RTG zasilające dany mikrochip jest nadal niebezpieczny dla innych mikrochipów. Innymi słowy, jeśli mikrochip jest pozostawiony w tym samym obszarze co inny RTG i nie jest połączony do swojego własnego RTG, usmaży się. Zakłada się więc, że będziesz postępował zgodnie z procedurą i trzymał mikrochipy podłączone do odpowiadających im RTG i z dala od RTG dla innych mikrochipów. Mikrochipy wydają się być bardzo interesujące i przydatne do Twoich aktualnych planów, chciałbyś je zdobyć dla własnych celów. Na 4 piętrze znajduje się maszyna, która jest w stanie złożyć komputer z mikrochipów i generatorów, który będziesz mógł bezpiecznie zabrać ze sobą. Oczywiście aby działał musisz dostarczyć na 4 piętro wszystkie mikrochipy wraz z odpowiadającymi im generatorami. Wewnątrz części budynku osłonionej przed promieniowaniem (gdzie bezpiecznie jest przechowywać niezłożone RTG), jest winda, która może poruszać się pomiędzy czterema piętrami. Winda maksymalnie może przewozić Ciebie i dwa urządzenia (generatory czy mikrochipy). Jako środek bezpieczeństwa, winda działa wyłącznie jeśli przewozi co najmniej jeden generator lub mikrochip. Winda zawsze zatrzymuje się na każdym piętrze aby doładować swoje baterie. Ładowanie zajmuje tak dużo czasu, że elementy w windzie i elementy na piętrze oddziałują na siebie. Zrobiłeś notatki dotyczące położenia każdego z elementów (wejście do programu). Zanim założysz strój chroniący przed promieniowaniem i zaczniesz przenosić elementy warto opracować plan w jakiej kolejności należy przenosić poszczególne części. Gdy wchodzisz do strefy zagrożonej wraz z windą znajdujecie się na pierwszym piętrze. Dla przykłady, załóżmy, że komponenty w odizolowanej strefie rozłożone są następująco:   Pierwsze piętro zawiera mikrochip hydrogen i mikrochip lithium,  drugie piętro zawiera generator hydrogen,  trzecie piętro zawiera generator lithium,  czwarte piętro jest puste.Początkowy układ możemy zapisać jako (F# oznacza numer piętra, E windę (ang. elevator), H hydrogen, L lithium, M mikrochip i G generator) F4 .  .  .  .  .F3 .  .  .  LG .F2 .  HG .  .  .F1 E  .  HM .  LMAby przewieźć wszystko na górę do maszyny składającej na 4 piętrze możesz postępować według następujących kroków:   Zabrać mikrochip hydrogen na drugie piętro (jest to bezpieczne ponieważ znajduje się tam odpowiadający generator),F4 .  .  .  .  .F3 .  .  .  LG .F2 E  HG HM .  .F1 .  .  .  .  LM  zabrać mikrochip hydrogen razem z odpowiadającym generatorem na trzecie piętro (jest to bezpiecznie ponieważ HM ma HG),F4 .  .  .  .  .F3 E  HG HM LG .F2 .  .  .  .  .F1 .  .  .  .  LM  zostawić generator hydrogen na trzecim piętrze i zjechać z mikrochipem hydrogen na drugie piętro (musisz mieć coś ze sobą, żeby winda ruszyła),F4 .  .  .  .  .F3 .  HG .  LG .F2 E  .  HM .  .F1 .  .  .  .  LM  zjechać na pierwsze piętro (jest to bezpieczne, mikrochipy nie oddziałują na siebie),F4 .  .  .  .  .F3 .  HG .  LG .F2 .  .  .  .  .F1 E  .  HM .  LM  zabrać oba mikrochipy na drugie piętro (ponownie, nie ma tu żadnego generatora, który by je usmażył),F4 .  .  .  .  .F3 .  HG .  LG .F2 E  .  HM .  LMF1 .  .  .  .  .  ponownie zabrać oba mikrochipy wyżej, na trzecie piętro (tym razem każdy z nich ma odpowiadający generator, który chroni je od usmażenia),F4 .  .  .  .  .F3 E HG HM LG LMF2 .  .  .  .  .F1 .  .  .  .  .  zabrać oba mikrochipy na czwarte piętro,F4 E  .  HM .  LMF3 .  HG .  LG .F2 .  .  .  .  .F1 .  .  .  .  .  zostawić mikrochip lithium na czwartym piętrze i zabrać mikrochip hydrogen na trzecie piętro (musisz coś zabrać, żeby winda działa, na trzecim piętrze będziesz bezpieczny, chociaż jest tam generator lithium, jest też generator hydrogen, który chroni odpowiadający mu mikrochip),F4 .  .  .  .  LMF3 E  HG HM LG .F2 .  .  .  .  .F1 .  .  .  .  .  zabrać oba generatory na czwarte piętro (jest to bezpieczne bo mikrochip lithium będzie chroniony przez generator lithium),F4 E  HG .  LG LMF3 .  .  HM .  .F2 .  .  .  .  .F1 .  .  .  .  .  zjechać w dół z mikrochipem lithium (musisz coś zabrać, żeby winda działała),F4 .  HG .  LG .F3 E  .  HM .  LMF2 .  .  .  .  .F1 .  .  .  .  .  zabrać na górę generator i mikrochip lithiumF4 E HG HM LG LMF3 .  .  .  .  .F2 .  .  .  .  .F1 .  .  .  .  .Przy takim podejściu potrzeba 11 kroków aby zebrać wszystkie elementy na czwartym piętrze aby móc je złożyć w jedną całość. Każde zatrzymanie się windy liczone jest jako jeden krok, nawet jeśli nic nie jest dodane czy usunięte z windy. Jaka jest minimalna liczba kroków potrzebna do przeniesienia wszystkich elementów jeśli ich układ opisany jest w tym pliku? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-11/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_11_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 12",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/12 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 12 zadanie 1 W końcu udało Ci się dotrzeć na ostatnie piętro budynku. Piękny ogród ze skośnym szklanym sufitem. Siedząc na ławce pomiędzy liliami odszyfrowałeś kilka plików, które udało Ci się wykraść z serwera piętro niżej. Według tych dokumentów Kwatera Główna Królicza Wielkanocnego nie jest jednym budynkiem. Jest kompleksem budynków w okolicy. Wszystkie z nich połączone są kolejką i jeden z nich znajduje się całkiem niedaleko! Niestety, w nocy kolejka nie jeździ. Udało Ci się zdalnie połączyć do systemu sterującego kolejką i odkryłeś, że sekwencja początkowa wymaga hasła. Logika sprawdzagtjąca hasło (wejście dla Twojego programu) jest łatwa do pozyskania, jednak kod jest dość dziwny. Używa on specjalnego języka assembunny zaprojektowanego dla komputera, który złożyłeś wczoraj. Musisz wywołać kod, żeby uzyskać hasło. Kod assembunny, który udało Ci się zdobyć operuje na czterech rejestrach (a, b, c i d), które przechowują wartość początkową 0 i mogą trzymać dowolną liczbę całkowitą. Wygląda na to, że wykorzystywany jest dość ubogi zestaw instrukcji:   cpy x y kopiuje x (zawartość rejestru albo liczbę) do rejestru y,  inc x zwiększa wartość rejestru x o jeden,  dec x zmniejsza wartość rejestru x o jeden,  jnz x y skacze do instrukcji oddalonej o y (dodatnie wartości oznaczają skok do przodu, ujemne do tyłu) jeśli x (liczba lub zawartość rejestru) nie jest zerem.Instrukcja jnz przesuwa się relatywnie względem siebie, skok o -1 oznacza skok do poprzedniej instrukcji, skok o 2 przeskoczy następną instrukcję. Mając na przykład następujący zestaw instrukcji: cpy 41 ainc ainc adec ajnz a 2dec aPowyższy kod ustawi rejestr a na wartość 41, zwiększy wartość rejestru o 1 dwukrotnie, zmniejszy wartość rejestru o 1 i następnie przeskoczy ostatnią instrukcję (ponieważ wartość rejestru a != 0). Ostateczna wartość rejestru a to 42. Program kończy się kiedy przejdzie za ostatnią instrukcję. Zakładając, że kod assembunny znajduje się w tym pliku, jaka będzie wartość rejestru a na koniec programu? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-12/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_12_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 13",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/13 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 13 zadanie 1 Dzięki Twojej pomocy przy wczorajszych instrukcjach assemblera udało się uruchomić kolejkę. Dotarłeś do pierwszego piętra nowego budynku. Niestety hall jest dużo mniej przyjazny niż świecące wnętrza w poprzednim budynku. Zamiast tego trafiłeś do plątaniny korytarzy i małych pomieszczeń. Każde pomieszczenie w tym rejonie może być zidentyfikowane przez parę nieujemnych liczb całkowitych (x, y). Każda taka współrzędna odpowiada albo ścianie albo otwartej przestrzeni. Nie możesz poruszać się na ukos. Labirynt zaczyna się na współrzędnych (0, 0) i wydaje się dążyć do nieskończoności dodatnich wartości x i y. Ujemne wartości są niepoprawne, przedstawiają położenie poza budynkiem. Znajdujesz się w małej poczekalni, która znajduje się na współrzędnych (1, 1). Wszystko wydaje się bardzo chaotyczne, jednak plakat znajdujący się na ścianie przekonuje Cię, że całość jest dość logiczna. Możesz stwierdzić czy dana pozycja (x, y) to ściana czy otwarta przestrzeń używając prostego systemu:binarną reprezentację   Oblicz wartość równania x*x + 3*x + 2*x*y + y + y*y,  dodaj ulubiony numer projektanta biura (wejście do programu),  znajdź binarną reprezentację tej sumy, policzyć ile bitów w tej reprezentacji to 1,  jeśli liczba bitów 1 jest parzysta (x, y) reprezentuje otwartą przestrzeń,  jeśli liczba bitów 1 jest nieparzysta (x, y) reprezentuje ścianę.Na przykład, jeśli ulubionym numerem projektanta biura jest 10, poniżej widzisz układ biura gdzie ściany pokazane są jako # a otwarta przestrzeń jako .. Narożnik budynku wygląda tak:   01234567890 .#.####.##1 ..#..#...#2 #....##...3 ###.#.###.4 .##..#..#.5 ..##....#.6 #...##.###Załóżmy, że chciałbyś dotrzeć do pozycji (7, 4). Najkrótsza droga, którą mógłbyś obrać oznaczona jest O:   01234567890 .#.####.##1 .O#..#...#2 #OOO.##...3 ###O#.###.4 .##OO#OO#.5 ..##OOO.#.6 #...##.###Więc dotarcie do punktu (7, 4) wymaga 11 kroków (zaczynając od pozycji (1, 1)). Zakładając, że ulubionym numerem projektanta biura jest 1362, jaka jest minimalna liczba kroków potrzebna do dotarcia do punku (31, 39)? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-13/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_13_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 14",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/14 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 14 zadanie 1 Po udanej przeprawie przez labirynt chciałbyś przesłać wiadomość do Świętego Mikołaja. Żeby bezpiecznie połączyć się ze Świętym Mikołajem w trakcie misji używałeś haseł jednorazowych. Generowałeś je używając algorytmu, który został wcześniej zatwierdzony. Niestety hasła, które miałeś wygenerowane już się skończyły. Musisz wygenerować kolejne. Do wygenerowania haseł potrzebujesz strumienia danych losowych. Strumień ten uzyskasz licząc sumę MD5 z odpowiednio przygotowanego łańcucha znaków. Łańcuch ten składa się z dwóch części. Pierwsza z nich jest stała (wejście do twojego programu), druga to zwiększająca się o 1 liczba całkowita zapisana dziesiętnie. Suma MD5 z takiego łańcucha powinna być przestawiona w postaci heksadecymalnej. Niestety, nie wszystkie takie sumy MD5 to hasła a Ty potrzebujesz kolejnych 64 do dalszej komunikacji z Mikołajem. Suma MD5 jest hasłem jeśli:   Zawiera trzy takie same znaki pod rząd, na przykład 777, weź pod uwagę wyłącznie pierwszą trójkę w sumie,  w kolejnych 1000 sum ten sam znak powtórzony jest pięć razy pod rząd, na przykład 77777.Jeśli jakaś suma zawiera pięć znaków pod rząd także powinieneś ją traktować jako potencjalne hasło (mając pięć powtórzonych znaków, oczywiście suma ma też trzy powtórzone znaki). Na przykład, jeśli wejściem do programu jest abc:   Pierwszy indeks, w którym suma MD5 zawiera potrojony znak to 18. Suma MD5 z abc18 zawiera ...cc38887a5.... Mimo to, indeks 18 nie liczy się jako poprawne hasło, ponieważ żadna z kolejnych 1000 sum (indeksy 19 do 1018 włącznie) nie zawiera 88888,  kolejny indeks, który zawiera potrojony znak to 39. Suma MD5 z abc39 zawiera eee. Jest to także pierwsze poprawne hasło, ponieważ jedna z kolejnych 1000 sum (ta z indeksem 816) zawiera eeeee,  żadna z kolejnych sześciu trójek występująca w kolejnych sumach nie jest hasłem, jednak kolejna już tak. Suma z indeksu 92 zawiera 999 a indeks 200 zawiera 99999.  w końcu indeks 22728 spełnia wszystkie wymagania i produkuje sześćdziesiąte czwarte hasło.Więc w naszym przykładzie, jeśli wejściem do programu jest abc, indeks 22728 produkuje sześćdziesiąte czwarte hasło jednorazowe. Jeśli wejściem do Twojego programu jest yjdafjpo który indeks generuje sześćdziesiąte czwarte hasło? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-14/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_14_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 15",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/15 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 15 zadanie 1 Poprzedni udało Ci się wygenerować listę haseł jednorazowych. Po czym zacząłeś zwiedzać pozostałą część Kwatery Głównej. Wielki korytarz prowadzi do placu umieszczonego wewnątrz budynku. Na środku placu znajduje się ruchoma rzeźba. Rzeźba zamknięta jest pod przeźroczystą kopułą, wewnątrz niej krążą nieduże kapsuły. Kapsuły są przenoszone na górę rzeźby i spadają swobodnie odbijając się od kręcących się elementów rzeźby. Część rzeźby jest nawet interaktywna. Kiedy naciśniesz przycisk kapsuła spuszczana jest w dół i próbuje przelecieć przez dziury w zestawie obracających się dysków. Jeśli przeleci przez nie wszystkie wypada przez niewielką dziurę na dole rzeźby. Jeśli którykolwiek z otworów nie jest “zgrany” z kapsułą kiedy ta opada, kapsuła odbija się od niego i wznosi się z powrotem na górę rzeźby. Chcesz mieć jedną z tych kapsuł :). Dyski zatrzymują się co sekundę, każdy z nich ma inny rozmiar. Każdy z dysków ma określoną liczbę pozycji, na których się zatrzymuje. Pozycja z dziurą na dysku oznaczona jest numerem 0, na kolejnych pozycjach nie ma dziur przez które może przelecieć kapsuła. Dyski są oddalone od siebie. Kiedy naciśniesz przycisk potrzeba jednej sekundy zanim kapsuła osiągnie pierwszy dysk, kolejna sekunda mija kiedy kapsuła przemieszcza się od jednego dysku do kolejnego pod spodem. Więc jeśli przyciśniesz przycisk w czasie 100, wtedy kapsuła dotrze do pierwszego dysku o czasie 101, do drugiego o czasie 102, do trzeciego o czasie 103 i tak dalej. Przycisk wypuści kapsułę tylko o pełnych sekundach, nie można wypuścić jej w połowie sekundy. Załóżmy, że w czasie 0 widzisz następujący układ dysków:   Dysk #1 ma 5 pozycji, w czasie 0 jest na pozycji 4,  dysk #2 ma 2 pozycje, w czasie 0 jest na pozycji 1.Jeśli naciśniesz przycisk o czasie 0, kapsuła zacznie opadać. Dotrze do pierwszego dysku o czasie 1. Jako, że dysk #1 w czasie 0 był na pozycji 4, o czasie 1 przemieścił o jedną pozycję do przodu. Jako dysk z pięcioma pozycjami, kolejną pozycją jest 0 więc kapsuła swobodnie przelatuje przez otwór. Następnie o czasie 2 kapsuła dociera do drugiego dysku. Drugi dysk przesunął się do przodu o dwie pozycje. Zaczął na pozycji 1, przesunął się do 0 i ostatecznie ponownie przemieścił się do pozycji 1. Ponieważ w każdym dysku jest tylko jeden otwór kapsuła nie może przelecieć przez dysk #2. Jeśli jednak poczekasz z naciśnięciem przycisku do czasu 5, wtedy kapsuła może przelecieć swobodnie przez wszystkie dyski. Pierwszy dysk przesunie się w tym czasie 5 + 1 = 6 razy (do pozycji 0), drugi dysk przesunie się 5 + 2 = 7 razy, także do pozycji 0. Twoja sytuacja jest bardziej skomplikowana, rzeźba ma więcej niż 2 dyski. Kiedy najszybciej możesz nacisnąć przycisk żeby kapsuła wypadła z rzeźby jeśli układ dysków opisany jest w tym pliku? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-15/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_15_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 16",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/16 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 16 zadanie 1 Wczoraj wyciągnąłeś kapsułę z ruchomej rzeźby, dzisiaj czeka na Ciebie zupełnie inne zadanie. Wróciłeś do skanowania sieci w Kwaterze Głównej Króliczka Wielkanocnego, niestety tym razem zostawiłeś ślady, które mogą Cię zdradzić. Musisz nadpisać część dysków z danymi, które wyglądają jak losowe żeby zatrzeć ślady i zaktualizować lokalny system bezpieczeństwa sumą kontrolną tych danych. Aby te wygenerowane dane nie wyglądały podejrzanie muszą spełniać kilka warunków. Czysto losowe dane zostaną wykryte. Aby wygenerować odpowiednią sekwencję danych, które oszukają mechanizmy wykrywania intruzów musisz użyć zmodyfikowanego fraktala “smoka Heighwaya”. Zacznij od stanu początkowego (wejście do Twojego programu). Następnie, do momentu kiedy nie będziesz miał wystarczającej ilości danych do wypełnienia dysku powtarzaj następujące kroki:   Nazwij dane, które masz na tym etapie jako “a”,  zrób kopię “a”, nazywając ją “b”,  odwróć kolejność znaków w “b”,  zamień wszystkie 0 na 1 i wszystkie 1 na 0,  połącz ze sobą “a” i “b” wstawiając 0 pomiędzy nimi.Na przykład, po jednym kroku takiego algorytmu:   1 zamienia się w 100,  0 zamienia się w 001,  11111 zamienia się w 11111000000,  111100001010 zamienia się w 1111000010100101011110000.Powtarzaj te kroki dopóki nie będziesz miał wystarczającej ilości danych żeby wypełnić dysk. Kiedy już wygenerujesz dane, musisz także policzyć sumę kontrolną dla tych danych. Do liczenia sumy użyj wyłącznie tych danych, które zmieszczą się na dysku, nawet jeśli w ostatnim kroku wygenerowałeś więcej danych. Suma kontrolna danych jest stworzona na podstawie każdej nie nakładającej się pary znaków w danych. Jeśli oba znaki są takie same (00 lub 11), kolejny numer sumy kontrolnej to 1. Jeśli znaki są różne (01 lub 10), następny numer sumy kontrolnej to 0. Ten proces powinien stworzyć nowy łańcuch znaków, który będzie krótszy dokładnie o połowę. Jeśli długość sumy kontrolnej jest parzysta powtórz ten proces tak długo dopóki nie otrzymasz sumy kontrolnej z nieparzystą liczbą znaków. Na przykład, załóżmy, że chcemy wypełnić dysk danymi o długości 12 znaków. Po wygenerowaniu danych pierwsze 12 znaków to 110010110100. Aby wygenerować sumę kontrolną:   Weź pod uwagę każdą parę: 11, 00, 10, 11, 01, 00,  pary odpowiednio mają identyczne, identyczne, różne, identyczne, różne i identyczne numery, w wyniku czego uzyskujemy 110101,  suma ma długość parzystą więc powtarzamy proces,  pary tym razem to 11 (identyczne), 01 (różne) i 01 (różne),  tym razem suma kontrolna 100 ma nieparzystą długość co kończy proces.Więc w naszym przypadku, suma kontrolna dla 110010110100 to 100. Łącząc te wszystkie kroki ze sobą, załóżmy, że chcesz wypełnić dysk o długości 20 znaków używając danych wejściowych 10000:   ponieważ 10000 jest za krótkie, musimy wygenerować więcej danych,  po pierwszej rundzie algorytmu uzyskujemy 10000011110 (11 znaków), nadal za mało,  po drugiej rundzie algorytmu uzyskujemy 10000011110010000111110 (23 znaki), wystarczy,  ponieważ potrzebujemy 20 znaków a wygenerowaliśmy 23 pozbywamy się trzech ostatnich uzyskując 10000011110010000111,  następnie liczymy sumę kontrolną, po pierwszej rundzie mamy 0111110101, suma ma 10 znaków więc kontynuujemy,  po dwóch rundach suma kontrolna to 01100, ponieważ długość sumy kontrolnej jest nieparzysta przerywamy algorytm.W tym przypadku poprawna suma kontrolna to 01100. Zakładając, że dysk, który chcesz wypełnić ma 272 znaki i sekwencja początkowa to 10011111011011001 jaka jest poprawna suma kontrolna? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-16/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_16_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 17",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/17 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 17 zadanie 1 Wczoraj udało Ci się wygenerować sumę kontrolną, która pozwoliła oszukać system bezpieczeństwa. Dzisiaj próbujesz dostać się do sejfu, znajdującego się na końcu małego zbioru pokoi. Pokoje ułożone są w czterech rzędach i kolumnach. Pomiędzy pokojami znajdują się drzwi. Zaczynasz w pokoju w lewym górnym rogu (oznaczonym S), do sejfu możesz się dostać jeśli dojdziesz do pokoju, który znajduje się w prawym dolnym rogu (oznaczonym literą V). ##########S| | | ##-#-#-#-## | | | ##-#-#-#-## | | | ##-#-#-#-## | | |V##########Mury przez które nie możesz przejść oznaczone są #, drzwi natomiast - lub |. Drzwi w aktualnym pokoju są otwarte lub zamknięte. To w jakim są stanie zależy od heksadecymalnej sumy z hasła (wejście do programu) z dołączoną sekwencją wielkich liter reprezentujących ścieżkę, którą obrałeś do tej pory:   U jeśli poszedłeś do góry,  D jeśli poszedłeś w dół,  L jeśli poszedłeś w lewo,  R jeśli poszedłeś w prawo.Tylko pierwsze cztery znaki sumy kontrolnej są wykorzystywane. Przedstawiają one odpowiednio drzwi z góry, z dołu z lewej i z prawej strony względem Twojej aktualnej pozycji. Którakolwiek z liter b, c, d, e czy f oznaczają, że odpowiadające im drzwi są otwarte. Każdy inny znak (numer czy a) znaczy, że drzwi są zamknięte i nie możesz ich otworzyć. Aby dotrzeć do sejfu, jedyne co musisz zrobić to dotrzeć do pokoju w prawym dolnym rogu. Dotarcie do tego pokoju otwiera sejf i wszystkie pozostałe drzwi w labiryncie. Dla przykładu załóżmy, że hasło to hijkl. Początkowo, nie ruszyłeś się do żadnego pokoju więc aktualna ścieżka jest pusta. Po prostu znajdujesz sumę kontrolną MD5 z hijkl. Pierwsze cztery znaki tej sumy to ced9. Oznacza to, że góra jest otwarta (c), dół jest otwarty (e), lewa strona jest otwarta (d) i prawa strona jest zamknięta (9). Ponieważ zaczynasz w lewym górnym rogu nie ma drzwi u góry ani po lewej stronie więc możesz pójść tylko w dół. Następnie po jednym kroku (w dół), znajdujesz sumę kontrolną dla hijklD. Otrzymujesz sumę kontrolną f2bc, co oznacza, że możesz pójść z powrotem do góry, w lewo (tylko tam znów jest mur) lub w prawo. Pójście w prawo oznacza znajdowanie sumy z hijklDR, otrzymasz wtedy 5745 - wszystkie drzwi są zamknięte. Jednak gdy wrócisz do góry sytuacja wygląda inaczej. Mimo tego, że już w tym pokoju byłeś, teraz Twoja ścieżka jest inna, suma kontrolna też będzie inna więc też i inne drzwi mogą zostać otwarte. Po udaniu się DU (i policzeniu sumy kontrolnej z hijklDU aby otrzymać 528e), tylko prawe drzwi są otwarte. Po udaniu się w prawo i policzeniu sumy kontrolne wszystkie drzwi są zamknięte… Na szczęście Twoje hasło to nie hijkl :). Wszystkie kody użyte przez Ochronę Sejfu Króliczka Wielkanocnego pozwalają na dotarcie do sejfu jeśli znasz poprawną ścieżkę. Na przykład:   jeśli hasło to ihgpwlah najkrótsza ścieżka to DDRRRD,  jeśli hasło to kglvqrro najkrótsza ścieżka to DDUDRLRRUDRD,  jeśli hasło to ulqzkmiv najkrótsza ścieżka to DRURDRUDDLLDLUURRDULRLDUUDDDRR.Zakładając, że Twoje hasło to udskfozm jaka jest najkrótsza ścieżka, która pozwala dotrzeć do sejfu? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-17/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_17_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 18",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/18 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 18 zadanie 1 Rozwiązanie poprzedniego zadania pozwoliło Ci dostać się do sejfu. W sejfie były tylko wskazówki jak dotrzeć do pewnego pokoju, był nieźle ukryty. Jak tylko wszedłeś do pokoju usłyszałeś głośne kliknięcie. Okazuje się, że część kafli na podłodze to pułapki. Ta, którą właśnie wyzwoliłeś wystrzeliła, cudem udało Ci się uniknąć tego co miała z Tobą zrobić. Następnym razem nie będziesz miał tyle szczęścia… Po dokładniejszym przyjrzeniu się, ułożenie pułapek i bezpiecznych kafli w pokoju wydaje się pasować do pewnego wzoru. Kafle ułożone są w rzędach o tej samej szerokości. Znalazłeś karteczkę z zapisem bezpiecznych kafli (.) i pułapek (^) w pierwszym rzędzie (wejście do programu). Rodzaj kafla (pułapka czy normalne, bezpieczne pole) w każdym rzędzie bazuje na typach kafli w rzędzie poprzednim. Z poprzedniego rzędu istotne są kafel w poprzedniej kolumnie, w tej samej kolumnie i w następnej kolumnie. Jeśli kafel jest w pierwszej lub ostatnie kolumnie jego odpowiedniki w poprzednim rzędzie znajdującie się “w ścianie” uznawane są za bezpieczne. Na przykład, załóżmy, że znasz pierwszy rząd (oznaczony literami) i chciałbyś dowiedzieć się o kaflach w następnym rzędzie (oznaczonym liczbami): ABCDE12345Rodzaj kafla 2 zależy od rodzaju kafli A, B i C. Rodzaj kafla 5 zależy od kafli D, E i “bezpiecznego kafla w ścianie”. Nazwijmy kafle z poprzedniego rzędu lewym, środkowy i prawym. Wówczas kafel jest pułapką wtedy i tylko wtedy gdy spełniona jest jedna z poniższych sytuacji:   lewy i środkowy kafel są pułapkami, prawy kafel jest bezpieczny,  środkowy i prawy kafel są pułapkami, lewy kafel jest bezpieczny,  tylko lewy kafel jest pułapką,  tylko prawy kafel jest pułapką.Każda inna sytuacja oznacza, że kafel jest bezpieczny. Załóżmy, że pierwszy rząd to ..^^., stosując reguły przedstawione powyżej możesz poznać kafle w kolejnych rzędach:   Pierwszy kafel w następnym rzędzie bierze pod uwagę “nieistniejący kafel ze ściany”, środkowy (pierwsza . oznaczająca bezpieczny kafel) i prawy (druga ., także bezpieczny) kafel z poprzedniego rządu. Ponieważ żadna z reguł określająca pułapkę nie została spełniona, kafel jest bezpieczny,  kolejny kafel w następnym rzędzie bierze pod uwagę lewy (.), środkowy (.) i prawy (^) kafel z poprzedniego rzędu. Taki układ pasuje do czwartej reguły więc ten kafel to pułapka,  trzeci kafel bierze pod uwagę .^^, taki uład pasuje do drugiej reguły, ten kafel to także pułapka,  ostatnie dwa kafle pasują odpowiedni do pierwszej i trzeciej reguły dla pułapek - oba kafle to pułapki.Po zastosowaniu tych kroków poznałeś kolejny rząd kafli w pokoju .^^^^. Następnie używając tych samych reguł możesz poznać trzeci rząd ^^..^. Układ kafli w pierwszych trzech rzędach wygląda następująco: ..^^..^^^^^^..^Poniżej jest przykład z trochę większego pokoju o dziesięciu rzędach i kolumnach: .^^.^.^^^^^^^...^..^^.^^.^.^^...^^...^^^.^^^^.^^.^^^..^.^^..^^^^..^^^.^..^^^^.^^.^^^..^.^^^^.^^^..^^W powyższym przykładzie, w dziesięciu rzędach jest 38 bezpiecznych kafli. Zakładając, że pierwszy rząd dla pokoju, w którym się znajdujesz jest w tym pliku - ile jest bezpiecznych kafli w pierwszych 40 rzędach (wliczając podany)? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-18/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_18_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 19",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/19 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 19 zadanie 1 Wczoraj przeszedłeś przez pokój pełen pułapek. Dzisiaj przydałyby się pomoc przy znalezieniu elfa, który został se wszystkimi prezentami. Elfy kontaktują się z Tobą przez bardzo bezpieczny kanał bezpieczeństwa. Pogubiły się w zabawie z prezentami. Każdy elf ma prezent. Wszystkie elfy siedzą w kółku na ponumerowanych krzesłach. Numery zaczynają się od 1. Pierwszy elf zabiera wszystkie prezenty od elfa, który siedzi po jego lewej stronie, elf bez prezentów odchodzi z kółka i nie bierze udziału w dalszej grze. Na przykład, jeśli w kółku byłoby 5 elfów:    15     2 4   3  Elf 1 bierze prezent drugiego elfa,  elf 2 nie ma prezentów więc wypada z gry,  elf 3 bierze prezent czwartego elfa,  elf 4 nie ma prezentów więc wypada z gry,  elf 5 bierze prezenty elfa pierwszego,  ani elf 1 ani elf 2 nie mają już prezentów więc nie są brane pod uwagę,  elf 3 zabiera prezenty piątego elfa.Więc, gdy w kółku siedzi pięć elfów, ten na pozycji 3 zostanie ze wszystkimi prezentami. Zakładając, że kółku siedzi 3014603 elfów, który z nich zostanie ze wszystkimi prezentami? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-19/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_19_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 20",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/20 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 20 zadanie 1 Dzięki Tobie wczoraj udało się znaleźć Elfa, który ma wszystkie prezenty. Dzisiaj chciałbyś wpiąć do sieci swój mały mikroprocesor żeby mieć dostęp do sieci później. Jednak firewall w Kwaterze Głównej pozwala tylko na komunikację z kilkoma zewnętrznymi adresami IP. Udało Ci się dostać do listy blokowanych adresów IP, jednak lista jest strasznie słabo utrzymana. Wszystkie IP są pomieszane i nie jest jasne które adresy IP są dozwolone. Ponadto, adresy nie są zapisane w standardowej notacji a jako zwykłe liczby całkowite, które mogą mieć wartość od 0 do 4294967295 włącznie. Na przykład, załóżmy, że tylko wartości od 0 do 9 były poprawne i udało Ci się wyciągnąć następującą listę zablokowanych adresów: 5-80-24-7Lista określa zakresy adresów IP, zarówno startowa jak i końcowa wartość są zabronione. W takim przypadku wyłącznie adresy IP 3 i 9 są dozwolone, jako jedyne nie są w żadnym z zablokowanych zakresów. Zakładając, że lista zablokowanych adresów znajduje się w tym pliku, jaka jest najniższa wartość IP, który nie jest zablokowany? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-20/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_20_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 21",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/21 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 21 zadanie 1 Wczoraj znalazłeś adres IP komputera, który nie jest blokowany przez firewall. Komputer, do którego systemu próbujesz się włamać używa dziwnego mechanizmu mieszającego do przechowywania haseł. Mimo to, nie powinno nastręczyć Ci żadnych trudności utworzenie samemu takiego hasła, które możesz dodać do systemu. Wystarczy, że zaimplementujesz odpowiednie przekształcenia. Operacja mieszająca składa się z serii operacji (dokładna ich lista jest wejściem do programu). Zaczynając od hasła, które ma być pomieszane aplikujesz każdą operację kolejno. Pojedyncze operacje opisane są poniżej:   swap position X with position Y oznacza, że litery pod indeksami X i Y (zaczynając od 0) powinny być zamienione,  swap letter X with letter Y oznacza, że litery X i Y powinny być zamienione (niezależnie na jakich pozycjach się znajdują),  rotate left/right X step(s) oznacza, że cały łańcuch znaków powinien być “przesunięty” w lewo lub prawo o X znaków, na przykład przesunięcie łańcucha abcd o jedną literę w prawo da Ci dabc,  rotate based on position of letter X oznacza, że cały łańcuch znaków powinien być “przesunięty” w prawo. To o ile powinien być przesunięty zależy od indeksu litery X zanim łańcuch będzie przesunięty. Jak poznasz indeks litery X przesuń łańcuch znaków o jedną pozycję w prawo, dodatkowo przesuń łańcuch w prawo o indeks na którym znajduje się litera X. Jeśli indeks był równy bądź większy 4 przesuń łańcuch o jeszcze jedną pozycję w prawo,  reverse positions X through Y oznacza, że zakres pomiędzy X i Y (włączając oba indeksy) powinien być odwrócony,  move position X to position Y oznacza, że litera, która jest pod indeksem X powinna być usunięta z łańcucha i włożona pod indeks Y.Na przykład, zakładając, że hasło początkowe to abcde i chcesz przeprowadzić następującą serię przekształceń:   swap position 4 with position 0 zamienia pierwszą i ostatnią literę, otrzymujesz ebcda, wynik ten jest wejściem do kolejnego kroku,  swap letter d with letter b zamienia literę d z literą b, w wyniku czego otrzymasz edcba,  reverse positions 0 through 4 sprawia, że cały łańcuch znaków jest odwrócony produkując abcde,  rotate left 1 step przesuwa w lewo cały łańcuch o jedną literę, w wyniku tego przekształcenia pierwsza litera ląduje na końcu bcdea,  move position 1 to position 4 usuwa literę na pozycji 1 (c), wkładając ją na pozycję 4 (na koniec łańcucha): bdeac,  move position 3 to position 0 usuwa literę z pozycji 3 (a), wkładając ją na pozycję 0 (początek łańcucha): abdec,  rotate based on position of letter b znajduje indeks litery b (1), później rotuje cały łańcuch o 1 plus indeks litery (2): ecabd,  rotate based on position of letter d znajduje indeks litery d (4), później rotuje cały łańcuch o 1 plus indeks litery (4), dodając dodatkową jedynkę ponieważ indeks był większy bądź równy 4, finalnie rotuje łańcuch o 6 pozycji: decab.Po tych wszystkich krokach, hasło to decab. Teraz Twoja kolej. Musisz wygenerować hasło, którego użyjesz aby dostać się do systemu. Zakładając, że lista przekszałceń znajduje się w tym pliku, a hasło początkowe to abcdefgh jakie będzie hasło po przekształceniach? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-21/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_21_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 22",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/22 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 22 zadanie 1 Dzięki Twojej pomocy poprzednio udało się utworzyć odpowiednie hasło. Hasło to pozwoliło Ci się dostać do potężnego klastra maszyn. Każdy komputer w tym klastrze połączony jest maksymalnie z czterema najbliższymi maszynami (trzema jeśli jest na krawędzi lub dwoma jeśli jest w rogu). Bezpośrednio możesz dostać się tylko do maszyny /dev/grid/node-x0-y0, ale możesz także przeprowadzić pewne, ograniczone operacje na pozostałych maszynach w klastrze:   możesz dostać informacje na temat zużycia dysku (dzięki df), wynik tego polecenia jest wejściem do programu,  możesz poinstruować maszynę aby przeniosła całe dane na sąsiednią maszynę (oczywiście jeśli maszyna docelowa ma wystarczająco dużo miejsca do przyjęcia danych). Maszyna z której przenosisz dane zostaje pusta w wyniku takiej operacji.Maszyny mają nazwy, które pozwalają poznać ich położenie w klastrze. Na przykład maszyna o nazwie node-x10-y10 sąsiaduje z maszynami node-x9-y10, node-x11-y10, node-x10-y9 i node-x10-y11. Zanim zaczniesz kombinować z klastrem musisz zrozumieć ułożenie danych na maszynach w klastrze. Chociaż możesz tylko przenosić dane pomiędzy sąsiadującymi maszynami będziesz potrzebował przenieść sporo danych aby dostać się do tych, które potrzebujesz. Aby to zrobić musisz dowiedzieć się jak możesz przenosić dane pomiędzy maszynami. Aby to zrobić, musisz poznać liczbę poprawnych par maszyn, między którymi możesz kopiować dane. Poprawna para maszyn (A, B) niezależnie od tego czy są bezpośrednio połączone czy nie, to para, w której:   maszyna A nie jest pusta (kolumna Used nie zawiera 0),  maszyny A i B nie są tą samą maszyną,  dane na maszynie A (kolumna Used) zmieszczą się na maszynie B (kolumna Avail).Zakładając, że lista opisująca maszyny w klastrze znajduje się w tym pliku, ile poprawnych par maszyn jest w klastrze? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-22/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_22_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 23",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/23 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 23 zadanie 1 Dzięki Twojej pomocy wczoraj udało się znaleźć odpowiednie pary maszyn w klastrze. Znajdujesz się na jednym z górnych pięter najwyższego budynku w Kwaterze Głównej Króliczka Wielkanocnego. Prywatne biuro Króliczka znajduje się właśnie tutaj, wraz z sejfem ukrytym za obrazem. Kto nie schowałby cennych dokumentów w sejfie ukrytym właśnie tam? Sejf ma wyświetlacz cyfrowy i klawiaturę, na której trzeba wpisać odpowiedni kod. Żółta karteczka przyczepiona do sejfu daje wskazówkę dotyczącą hasła: “jajka”. Na obrazie z dużym królikiem malującym jajka, doliczyłeś się 7 jajek. Kiedy próbujesz wpisać kod nic nie pojawia się na ekranie. Zamiast tego klawiatura rozpada się w Twoich rękach. Najwyraźniej została wcześniej zniszczona. Pod spodem ma swego rodzaju gniazdo, takie do którego pasuje Twój prototypowy komputer. Rozmontowując roztrzaskaną klawiaturę wyciągasz układ logiczny ze środka, podłączasz go do swojego komputera, który następie podłączasz do sejfu. Teraz musisz tylko dowiedzieć się jakie wyjście wyprodukowałaby klawiatura po naciśnięciu odpowiedniego klawisza. Wyciągasz kod assembunny z chipa (wejście do programu). Kod wygląda, prawie dokładnie jak ten, który użyty był poprzednio do sterowania kolejką! Powinieneś być w stanie użyć tego samego interpretera, którego użyłeś poprzednio. Wymagał on będzie jednak drobnego rozszerzenia o jedną nową instrukcję:   tgl x przełącza instrukcję znajdującą się x pozycji dalej, x wskazuje na instrukcje podobnie jak jnz. Dodatnia wartość oznacza instrukcję z przodu, ujemna z tyłu.Instrukcja tgl działa w następujący sposób:   dla jednoargumentowych instrukcji, inc staje się dec, każda inna jednoargumentowa instrukcja staje się inc,  dla dwuargumentowych instrukcji, jnz staje się cpy, każda inna dwuargumentowa instrukcja staje się jnz,  argumenty przełączanej instrukcji nie są zmieniane,  jeśli tgl próbuje przełączyć instrukcję znajdującą się poza programem, nic się nie dzieje,  jeśli tgl wyprodukuje niepoprawną instrukcje (na przykład cpy 1 2) i później interpreter spróbuje wywołać taką instrukcję, powinien ją ominąć,  jeśli tgl przełącza samą siebie (na przykład jeśli a ma wartość 0, tgl a przełączy się na inc a), wynikowa instrukcja nie jest wywołana dopóki interpreter nie dotrze do niej po raz kolejny.Na przykład jeśli pod uwagę weźmiesz taki program: cpy 2 atgl atgl atgl acpy 1 adec adec a  cpy 2 a inicjalizuje rejestr a wartością 2,  pierwsza instrukcja tgl a przełącza instrukcję odległą o wartość rejestru a (2), w wyniku czego zmienia trzecią instrukcję tgl a na inc a,  druga instrukcja tgl a także zmienia instrukcje oddaloną o 2, co zmienia cpy 1 a na jnz 1 a,  czwarta linia, która teraz jest inc a zwiększa o jeden a do wartości 3,  ostatecznie piąta linia, która jest teraz jnz 1 a skacze o a (3) instrukcji do przodu przeskakując obie instrukcje dec a.W tym przykładzie ostateczna wartość rejestru a to 3. Pozostała część układu scalonego zdaje się ustawiać wartość rejestru a na wejście z klawiatury (liczbę jajek z obrazu, 7), uruchamia kod i przesyła wynikową wartość rejestru a do sejfu. Zakładając, że lista poleceń znajduje się w tym pliku, jaka wartość zostanie przesłana do sejfu? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-23/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_23_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 24",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/24 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 24 zadanie 1 W końcu udało Ci się przezwyciężyć klawiaturę z sejfu. Dzięki dokumentom, które tam znalazłeś dotarłeś do drzwi prowadzących na dach. Niestety są zamknięte na głucho, nie możesz się nawet to nich dostać, widzisz je za szybą kuloodporną. Jednak, robot, który czyści kanały wentylacyjne może. Niestety nie jest to szybki robot, możesz go przekonfigurować tak, że będzie mógł połączyć się z kablami prowadzonymi z sytemu HVAC (ogrzewanie, wentylacja, klimatyzacja). Jeśli będziesz w stanie pokierować go tak, żeby dotarł do kilku miejsc będziesz mógł ominąć system bezpieczeństwa chroniący drzwi. Udało Ci się zdobyć plany kanałów wentylacyjnych, na których zaznaczone są istotne miejsca na mapie (wejście do programu). 0 to Twoja aktualna pozycja, z której robot czyszczący zaczyna się poruszać. Pozostałe numery (kolejność nie ma znaczenia) oznaczają miejsca, które robot musi odwiedzić co najmniej raz. Mury oznaczone są # a kanały, po których może się poruszać robot .. Numery oznaczające miejsca to także miejsca dostępne dla robota. Na przykład, zakładając, że mapa kanałów wentylacyjnych wygląda następująco: ############0.1.....2##.#######.##4.......3############Aby dotrzeć do wszystkich istotnych miejsc tak szybko jak to możliwe robot wybrał następującą ścieżkę:   od miejsca startowego do 4 (2 kroki),  od miejsca 4 do 1 (4 kroki, robot nie może poruszać się na ukos),  od miejsca 1 do miejsca 2 (6 kroków),  od miejsca 2 do miejsca 3 (2 kroki).Z racji tego, że robot jest raczej powolny musisz znaleźć najkrótszą drogę. Przykład pokazuje najkrótszą możliwą drogę (14 kroków) wymaganych do odwiedzenia wszystkich istotnych punktów co najmniej raz. Zakładając, że mapa kanałów wentylacyjnych znajduje się w tym pliku i że robot zaczyna z pozycji 0, jaka jest najmniejsza liczba kroków potrzebna aby odwiedzić wszystkie miejsca oznaczone numerami co najmniej raz? Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu! ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-24/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_24_artykul.jpg"},{
        "title": "Advent of Code 2016 dzień 25",
        "excerpt":"Wprowadzenie Oryginalna strona z zadaniami z Advent of Code 2016. Zadanie z artykułu dostępne jest pod adresem http://adventofcode.com/2016/day/25 Advent of Code to inicjatywa, w której codziennie publikowane są zadania algorytmiczne dla programistów. Ich rozwiązywanie pomaga rozwijać umiejętności nie tyko początkujących programistów. W tej serii artykułów pokazuję zadanie opublikowane w ramach Advent of Code 2016 wraz z przykładowym rozwiązaniem.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dzień 25 zadanie 1 Dzięki robocikowi sprzątającemu udało Ci się obejść zabezpieczenia. Otwierasz drzwi prowadzące na dach, wielkie miasto ciągnie się aż po horyzont. Nie zostało dużo czasu, to już Boże Narodzenie1 a Ty bynajmniej nie jesteś blisko Mikołaja. Może olbrzymia antena na dachu pomoże Ci nawiązać łączność? Podłączasz swój prototypowy komputer do anteny i zaczynasz transmisję. Niestety nic się nie dzieje. Dzwonisz pod numer serwisanta znajdujący się z boku anteny i szybko opisujesz problem, mimo świąt serwisant odpowiada “nie jestem pewien jaki sprzęt podłączyłeś do tej anteny, ale potrzebuje on odpowiedniego sygnału zegara”. Tak, tak odpowiadasz zegar dał już sygnał, to już najwyższy czas. W słuchawce słyszysz odpowiedź “nie o taki sygnał chodzi, potrzebny jest sygnał zegara dla komputera anteny, taki który mówi kiedy powinien czytać dane, które chcesz wysłać. Nieskończony naprzemienny wzór z 0, 1, 0, 1, 0, 1, 0, 1… Pytasz czy antena obsłuży sygnał zegara o częstotliwości Twojego prototypowego komputera. “Nie ma szans! Jedyna antena, która potrafi to obsłużyć znajduje się na szczycie budynku w Kwaterze Króliczka Wielkanocnego a Ty na pewno nie jesteś”, odłożyłeś słuchawkę. Udało Ci się wyciągnąć kod assembunny anteny odpowiedzialny za generowanie sygnału zegara (wejście do programu). Wygląda na to, że jest w większości kompatybilny z kodem, który obsługiwałeś poprzednio. Dodatkową instrukcją, którą używa antena jest:   out x wysyła x (będący liczbą lub wartością rejestru) jako następną wartość sygnału zegara.Kod pobiera pewną wartość (przechowywaną w rejestrze a), która opisuje sygnał, który powinien być wygenerowany ale nie jesteś pewien jak ta wartość jest użyta. Musisz znaleźć poprawną wartość rejestru eksperymentując. Jaka jest najniższa dodatnia wartość rejestru a, która może być użyta do zainicjalizowania programu, która spowoduje, że wyjście do zegara będzie nieskończonym ciągiem 0, 1, 0, 1…? Program dla anteny znajduje się w tym pliku. Podsumowanie Zachęcam do dalszej zabawy z drugim zadaniem, jego treść pokaże się na stronie AoC2016 po rozwiązaniu pierwszego. Takie zadania pomagają w rozwijaniu umiejętności nie tylko początkujących programistów. Jeśli będziesz miał jakikolwiek problem z rozwiązaniem zadania możesz rzucić okiem do przykładowego rozwiązania, jednak zrób to raczej w ostateczności. Na koniec mam do Ciebie prośbę - podziel się linkiem do artykułu ze znajomymi, może Oni także będą chcieli pomóc Świętemu Mikołajowi ;) ? Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu!             W oryginalnym Advent of Code to zadanie było opublikowane 25 grudnia. &#8617;       ","categories": ["Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/advent-of-code-2016-dzien-25/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2016/12/aoc_2016_dzien_25_artykul.jpg"},{
        "title": "Wyrażenia regularne część 2",
        "excerpt":"  To jest drugi artykuł na temat wyrażeń regularnych. Część zagadnień związanych z wyrażeniami regularnymi opisana jest w pierwszej części:   czym są wyrażenia regularne,  kiedy używamy wyrażeń regularnych, praktyczne wskazówki,  API wyrażeń regularnych w języku Java,  obsługa powtórzeń (+, *, ?, {}),  klasy znaków (., [], \\d, \\w, itd.),  grupy (()),  wsparcie IDE dla wyrażeń regularnych.Zachęcam do przeczytania pierwszej części jeśli chciałbyś dowiedzieć się czegoś więcej o punktach wspomnianych powyżej. Tutaj bez zbędnego wstępu przejdę do konkretów. Na pierwszy ogień idzie zachłanność wyrażeń regularnych. Zachłanność wyrażeń regularnych Wyrażenia regularne są zachłanne. Oznacza to tyle, że wyrażenie regularne dopasuje największą możliwą część łańcucha znaków, która pasuje do wzorca. Najłatwiej będzie to zobaczyć na przykładzie. @Testpublic void shouldBeGreedy() {    Pattern pattern = Pattern.compile(\"&lt;(.+)&gt;\");    Matcher matcher = pattern.matcher(\"&lt;em&gt;some emphasized text&lt;/em&gt;\");    assertTrue(matcher.find());    assertEquals(\"em&gt;some emphasized text&lt;/em\", matcher.group(1));}Powyżej widzisz standardowy przykład wykorzystywany do pokazania tej właściwości wyrażeń regularnych. Tekst, który chcemy dopasować jest kodem HTML zawierającym znacznik &lt;em&gt;1. Załóżmy, że chciałbyś wyciągnąć nazwę znacznika znajdującego się pomiędzy &lt; i &gt;. Okazuje się, że wyrażenie regularne użyte w przykładzie powyżej nie zadziała tak jakbyś tego chciał. Zgodnie z tym co opisałem wcześniej dopasuje najwięcej tekstu jak to tylko możliwe zatem w grupie (.+) znajdzie się em&gt;some emphasized text&lt;/em. Istnieje standardowy sposób na obejście tego typu zachowania, możesz zastosować tutaj negację grupy znaków. Wyrażenie regularne &lt;([^&gt;]+)&gt; dopasuje wszystko co znajduje się pomiędzy &lt; &gt; i nie jest znakiem &gt;. @Testpublic void shouldBeAbleToCheatGreadiness() {    Pattern pattern = Pattern.compile(\"&lt;([^&gt;]+)&gt;\");    Matcher matcher = pattern.matcher(\"&lt;em&gt;some emphasized text&lt;/em&gt;\");    assertTrue(matcher.find());    assertEquals(\"em\", matcher.group(1));}Wyrażenia regularne działają w ten sposób, ponieważ mechanizm do obsługi powtórzeń jest zachłanny. Symbole powtórzeń {}, ?, * czy + dopasowują zawsze najwięcej jak tylko się da. Istnieje jednak przełącznik, który zmienia to zachowanie. Jest to znak ?. Znów najlepiej będzie przeanalizować całość na przykładzie: @Testpublic void shouldTurnOffGreedinessForPlus() {    Pattern pattern = Pattern.compile(\"&lt;(.+?)&gt;\");    Matcher matcher = pattern.matcher(\"&lt;em&gt;some emphasized text&lt;/em&gt;\");    assertTrue(matcher.find());    assertEquals(\"em\", matcher.group(1));}Jak widzisz, tym razem .+ nie pochłonął nam prawie całego łańcucha. Grupa zawiera najmniej tekstu jak to możliwe. W posobny sposób ? wyłącza zachłanność dla *: @Testpublic void shouldTurnOffGreedinessForAsterix() {    Pattern pattern = Pattern.compile(\"&lt;(.*?)&gt;\");    Matcher matcher = pattern.matcher(\"&lt;em&gt;some emphasized text&lt;/em&gt;\");    assertTrue(matcher.find());    assertEquals(\"em\", matcher.group(1));}Z kolei w przykładzie poniżej pokazałem jak ? wpływa na {}. Chociaż wyrażenie mogłoby dopasować cały łańcuch znaków, w grupie znajdują się wyłącznie pierwsze trzy znaki (ponieważ {} nie jest tu zachłanny). @Testpublic void shouldTurnOffGreadinessForCurlyBraces() {    Pattern pattern = Pattern.compile(\"(.{3,5}?)\");    Matcher matcher = pattern.matcher(\"12345\");    assertTrue(matcher.find());    assertEquals(\"123\", matcher.group(1));}  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Alternatywa Załóżmy, że program, który piszesz musi przetworzyć zestaw instrukcji dla samochodu, którym kieruje. Niektóre z instrukcji mówią w którą stronę należy skręcić   skręć w prawo,  skręć w lewo.Aby przy pomocy jednego wyrażenia regularnego dopasować obie instrukcje możesz użyć alternatywy. Spójrz na przykład poniżej: @Testpublic void shouldParseAlternative() {    Pattern pattern = Pattern.compile(\"skręć w (prawo|lewo)\");    Matcher matcher = pattern.matcher(\"skręć w lewo\");    assertTrue(matcher.find());    assertEquals(\"lewo\", matcher.group(1));    matcher = pattern.matcher(\"skręć w prawo\");    assertTrue(matcher.find());    assertEquals(\"prawo\", matcher.group(1));}Jak widzisz, wewnątrz grupy użyłem tam znaku |. Znak ten jest jednym ze znaków specjalnych. Jeśli występuje wewnątrz wyrażenia regularnego oznacza, że łańcuch znaków pasuje do wyrażenia regularnego jeśli pasuje do części znajdującej się przed znakiem | lub do części znajdującej się po znaku |. Jeśli chcesz ograniczyć zakres alternatywy użyj nawiasów jak w przykładzie powyżej, w takim przypadku alternatywa dopasuje to co znajduje się po lewej stronie znaku | do (, lub po prawej stronie znaku | do ). Możesz też użyć alternatywy do dopasowania więcej niż dwóch elementów oddzielając każdy z nich znakiem | jak w przykładzie poniżej: @Testpublic void shouldPickOneFromMultipleAlternatives() {    Pattern pattern = Pattern.compile(\"pies|kot|lew\");    Matcher matcher = pattern.matcher(\"lew\");    assertTrue(matcher.matches());    assertEquals(\"lew\", matcher.group());}Grupy nieprzechwytujące Mechanizm wyrażeń regularnych domyślnie zapamiętuje grupy, które zostały użyte w wyrażeniu regularnym. Tak zapamiętane grupy są później dostępne za pośrednictwem metody group. W większości przypadków jest to pożądane zachowanie, jednak czasami to co wyląduje w grupie nie jest dla Ciebie interesujące. W takich przypadkach możesz użyć grupy, która nie zostanie zapamiętana. Grupa nie będzie przechwytująca jeśli pierwszymi znakami wewnątrz grupy będą ?:. Proszę spójrz na przykład poniżej: @Testpublic void shouldUseNonCapturingGroups() {    Pattern pattern = Pattern.compile(\"(?:Ala|Ola) ma (kota|psa)\");    Matcher matcher = pattern.matcher(\"Ola ma psa\");    assertTrue(matcher.matches());    assertEquals(\"psa\", matcher.group(1));}W przykładzie tym nie interesuje nas właścicielka zwierzaka. Za to sam zwierzak jest ważny. W wyrażeniu tym użyte są dwie grupy, pierwsza nieprzechwytująca i druga, która zawiera zwierzaka. Grupy nazwane Grupy, których użyjemy w wyrażeniu regularnym możemy też nazwać. W takim przypadku do zawartości takiej grupy możemy odwoływać się w standardowy sposób, czyli używając indeksu, który już znasz lub poprzez nazwę. Spójrz na przykład poniżej, w którym poszczególne elementy daty zapamiętane są w nazwanych grupach: @Testpublic void shouldUseNamedGroups() {    Pattern pattern = Pattern.compile(\"(?&lt;day&gt;\\\\d{2})\\\\.(?&lt;month&gt;\\\\d{2})\\\\.(?&lt;year&gt;\\\\d{4})\");    Matcher matcher = pattern.matcher(\"04.01.2017\");    assertTrue(matcher.matches());    assertEquals(\"04\", matcher.group(\"day\"));    assertEquals(\"04\", matcher.group(1));    assertEquals(\"2017\", matcher.group(\"year\"));    assertEquals(\"2017\", matcher.group(3));}Jak widziałeś w przykładzie grupy nazwane mają ?&lt;nazwa&gt; wewnątrz grupy. Następnie używając nazwa możemy dostać się do zawartości danej grupy używając metody group. Ponowne użycie grup w wyrażeniu Tutaj ponownie posłużę się przykładem znaczników HTML. Załóżmy, że mamy następujący kod HTML &lt;p&gt;Some paragraph &lt;em&gt;emphasized&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Other paragraph&lt;/p&gt;. Jak mógłbyś wyciągnąć tekst znajdujący się wewnątrz pary znaczników? Na przykład to co znajduje się wewnątrz pierwszej pary &lt;p&gt; i &lt;/p&gt;? Z pomocą przychodzi tu mechanizm ponownego użycia grup wewnątrz wyrażenia regularnego. Spójrz proszę na przykład: @Testpublic void shouldReuseGroupsInsideRegexp() {    Pattern pattern = Pattern.compile(\"&lt;(.+?)&gt;(.+?)&lt;/\\\\1&gt;\");    Matcher matcher = pattern.matcher(\"&lt;p&gt;Some paragraph &lt;em&gt;emphasized&lt;/em&gt;&lt;/p&gt;&lt;p&gt;Other paragraph&lt;/p&gt;\");    assertTrue(matcher.find());    assertEquals(\"p\", matcher.group(1));    assertEquals(\"Some paragraph &lt;em&gt;emphasized&lt;/em&gt;\", matcher.group(2));}Jak widzisz, na samym końcu wyrażenia znajduje się \\1. Jest to nic innego jak odwołanie się do pierwszej grupy, która została dopasowana. W naszym przypadku jest to p. Podobnie możesz używać kolejnych grup używając kolejnych indeksów. Kotwice Nadszedł czas na kotwice. Kotwice to znaki specjalne w wyrażeniach regularnych. Kotwice służą do przekazania informacji o tym gdzie chcemy szukać dopasowania w danym łańcuchu znaków. Na przykład do wyrażenia regularnego c$ pasują łańcuchy znaków abc czy bac ale nie pasuje cab. Innymi słowy c$ mówi, że „c powinno wystąpić na końcu łańcucha znaków”. Istnieje kilka kotwic, poniżej pokażę Ci te dwie najczęściej używane:   ^ oznacza początek łańcucha znaków,  $ oznacza koniec łańcucha znaków.Kotwice są bardzo często używane w przypadku walidacji danych wejściowych od użytkownika. Na przykład jeśli chcemy mieć pewność, że użytkownik wprowadził tylko liczby możemy użyć wyrażenia z ^ i $. Oczywiście można też wykorzystać metodę matches zamiast find. Różnicę pomiędzy zachowaniem tych metod wraz z użyciem kotwic pokazałem w przykładzie poniżej: @Testpublic void shouldShowDifferenceBetweenFindAndMatches() {    Pattern pattern = Pattern.compile(\"\\\\d+\");    Matcher matcher = pattern.matcher(\"abc123def\");    assertTrue(matcher.find());    assertFalse(matcher.matches());}@Testpublic void shouldShowDifferenceBetweenFindAndMatchesWithAncors() {    Pattern pattern = Pattern.compile(\"^\\\\d+$\");    Matcher matcher = pattern.matcher(\"abc123def\");    assertFalse(matcher.find());    assertFalse(matcher.matches());}Zadanie do wykonania W ramach zadania do wykonania aby przećwiczyć wyrażenia regularne w praktyce odeślę Cię do zadań z Advent of Code 2016. Poniżej jest lista zadań, w których możesz użyć wyrażeń regularnych. Są tam zadania o różnym poziomie trudności, na pewno znajdziesz coś dla siebie. Każde z tych zadań zawiera także przykładowe rozwiązanie:   dzień 4,  dzień 8,  dzień 10,  dzień 12,  dzień 21.Dodatkowe materiały do nauki Zbiór linków z dodatkowymi materiałami do nauki zebrałem w pierwszej części artykułu, jeśli chcesz dowiedzieć się więcej na temat wyrażeń regularnych zapraszam do tamtego zbioru. Jeśli chcesz, możesz także przeglądać kod źródłowy przykładów z tego artykułu, wszystkie przykłady dostępne są na githubie. Podsumowanie Po obu artykułach na temat wyrażeń regularnych i rozwiązaniu zadań możesz śmiało powiedzieć, że używałeś wyrażeń regularnych w praktyce :). Poznałeś większość mechanizmów dostępnych w wyrażeniach regularnych. Jednak musisz wiedzieć, że to nadal nie wszystko. Znajomość wyrażeń regularnych na poziomie opisanym w obu artykułach w zupełności wystarczy Ci do codziennej pracy. Mam nadzieję, że ta dwuczęściowa seria przypadła Ci do gustu. Jeśli tak proszę podziel się artykułem ze znajomymi. Zależy mi na dotarciu do jak największej liczby czytelników, możesz mi w tym pomóc. Jeśli nie chcesz pominąć kolejnych artykułów zapisz się do mojego newslettera i polub stronę na facebooku. Do następnego razu!             Znacznik ten służy do wyróżnienia tekstu na stronie www. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/wyrazenia-regularne-czesc-2/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/01/06_wyrazenia_regularne_2_artykul.jpg"},{
        "title": "Wstęp do Gradle",
        "excerpt":"Czym jest Gradle Starając się opisać Gradle jednym zdaniem powiedziałbym, że Gradle jest narzędziem służącym do budowania projektów1. Pozwala ono na zautomatyzowanie tego procesu. Używa się do tego tak zwanego języka domenowego - DSL (ang. Domain Specific Language), który ułatwia wykonywanie standardowych zadań związanych z budowaniem projektu. Jeśli do tej pory miałeś styczność wyłącznie z niezbyt dużymi projektami, nad którymi pracowałeś samodzielnie prawdopodobnie nie odczuwałeś potrzeby używania narzędzi tego typu. Jednak przy większych projektach narzędzie, które pozwala na zautomatyzowanie tego procesu jest bardzo pomocne. Inne narzędzia do budowania projektów Oczywiście Gradle nie jest jedynym narzędziem, które pomaga przy budowaniu projektów. Wymienić tu trzeba byłoby kilka innych jak Ant, Maven, Ivy, Make czy Buildr. Oczywiście nie jest to kompletna lista. Dodatkowo „problem budowania” projektu występuje w każdym języku programowania, więc analogiczne narzędzia występują także dla innych języków. Instalacja gradle Gradle sam w sobie jest programem, abyś mógł go używać musisz „zainstalować” go na swoim komputerze. Najnowszą wersję Gradle możesz ściągnąć z tej strony. Następnie rozpakuj ściągnięty plik, ustaw zmienną środowiskową GRADLE_HOME, która będzie wskazywała na katalog, w którym rozpakowałeś wcześniej ściągniętą paczkę. Następnie zmodyfikuj zmienną PATH (linux/macos) lub Path (windows), tak żeby zawierała katalog bin znajdujący się wewnątrz wcześniej ustawionego GRADLE_HOME. Tutaj znajdziesz krótki filmik, pokazujący jak zmodyfikować zmienną Path w systemie Windows, w podobny sposób możesz dodać zmienną GRADLE_HOME. Po takim zestawie ustawień i ponownym uruchomieniu terminala powinieneś móc wywołać polecenie gradle --version, które wypisze na konsolę informacje o Twojej wersji Gradle.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. W czym może pomóc Gradle Jak wspomniałem wcześniej Gradle służy do budowania projektów. Pod pojęciem „budowania projektów” tak naprawdę kryje się cała masa drobnych czynności. Zaczynając od najbardziej podstawowych, takich jak kompilowanie kodu źródłowego czy tworzenie pliku ze skompilowanymi klasami, na przykład pliku JAR (ang. Java Archive)2. Jednak to nie koniec, dobrze byłoby uruchomić wszystkie testy, które sprawdzają poprawność działania kodu przed utworzeniem pliku JAR. W tym także pomoże Ci Gradle. Gradle pomoże też przy zarządzaniu zależnościami projektu. Zarządzanie zależnościami Większe projekty bazują na zewnętrznych bibliotekach. Przykładem takich zewnętrznych bibliotek jest na przykład Hibernate, Spring czy Guava. Zewnętrzne biblioteki dostępne są jako skompilowane klasy spakowane w pliki JAR. Można je ściągnąć z tak zwanych repozytoriów. Jednym z najczęściej używanych repozytoriów jest centralne repozytorium Maven’a. Tak samo jak Twój projekt może zależeć od innych bibliotek, podobnie może być z tymi bibliotekami, też mogą mieć swoje zależności. Innymi słowy Twój projekt może mieć tak zwane zależności pośrednie/przechodnie. Jeśli Twój projekt wymaga wielu dodatkowych bibliotek, zarządzanie wszystkimi zależnościami (pośrednimi i bezpośrednimi) nie jest takim łatwym zadaniem. Gradle pobiera zależności, które wskażesz (w odpowiedni sposób), zajmując się także zależnościami pośrednimi. Konwencje Programując w Javie (i nie tylko) dobrze jest stosować do pewnych przyjętych konwencji, które możemy spotkać w wielu projektach. Takie podejście pomaga w pracy nad różnymi projektami, wprowadza swego rodzaju „porządek”. Gradle także używa takich konwencji, poniżej opiszę dwie z nich, strukturę katalogów w projekcie i sposób identyfikowania projektu. Pomogą one w zrozumieniu podstaw DSL, które znajdą się w kolejnych akapitach. Struktura projektu Przy prostych projektach, nie ma potrzeby używania specjalnej struktury dla projektu. Jednak przy tych bardziej zaawansowanych pewna konwencja ułatwia zrozumienie tego „co w danym projekcie się dzieje”. Gdzie szukać plików z testami, w którym miejscu mogą znajdować się pliki z kodem źródłowym, gdzie może znajdować się plik JAR, który powstał po zbudowaniu projektu. To wszystko można osiągnąć, dzięki pewnej konwencji, która jest powszechnie stosowana w świecie projektów Java. Proszę spójrz na przykład poniżej, pokazuje on strukturę katalogów w projekcie 01_witaj_swiecie, który stworzyłem na potrzeby tego artykułu (użyłem tu programu tree) do pokazania struktury katalogów): $ tree ..├── build.gradle└── src├── main│   ├── java│   │   └── pl│   │   └── samouczekprogramisty│   │   └── Hello.java│   └── resources│   └── log4j.ini└── test├── java│   └── pl│   └── samouczekprogramisty│   └── HelloTest.java└── resources└── log4j.iniProjekt ten zawiera jedną klasę Hello, znajdującą się w pakiecie pl.samouczekprogramisty i odpowiadający jest test znajdujący się w pliku HelloTest.java. Proszę zauważ, że oba te pliki znajdują się w zupełnie różnych katalogach, odpowiednio src/main/java i src/test/java. Tego typu podejście pozwala na oddzielenie kodu aplikacji od testów. Na produkcyjnym środowisku nie potrzebujemy testów, potrzebne są wyłącznie klasy, które zapewniają poprawne działanie aplikacji. Taki podział pozwala osiągnąć ten cel w bardzo prosty sposób. Dodatkowo w tej strukturze znajdują się także katalogi src/main/resources i src/test/resources, zawierają one odpowiednio konfigurację dla właściwej aplikacji i konfigurację dla testów. Bezpośrednio w katalogu projektu znajduje się plik build.gradle, który zawiera informacje jak budować taki projekt. Unikalna identyfikacja projektu Przed powstaniem Gradle do budowania projektu używałem między innymi Maven’a. Wraz z Maven’em używanym na szerszą skalę rozpowszechniło się pewne standardowe nazewnictwo, które pozwala jednoznacznie zidentyfikować projekt. Służy do tego trójka:   groupId,  artifactId,  version.Gradle także używa tej trójki, jednak pod troszkę innymi nazwami, są to odpowiednio group, name i version. group to pierwszy identyfikator. Konwencja zakłada, że zaczynał się on będzie od odwróconej domeny, podobnie jak package w klasach. Do odwróconej domeny można dołączyć dodatkowe człony, które dokładniej specyfikują „grupę” projektu. W przypadku samouczka może to być pl.samouczekprogramisty czy pl.samouczekprogramisty.kursjava. name to drugi identyfikator, jest on częścią finalnej nazwy pliku JAR ze skompilowanymi klasami. W przypadku projektu, z przykładami do kursu Java na Samouczku name może mieć wartość examples czy code-samples. version określa wersję projektu. Standardowo wersję określa się przez trójkę liczb oddzielonych kropkami na przykład 1.0.0 czy 5.0.12. Dodatkowo jeśli jest to wersja „deweloperska” można do niej dołączyć -SNAPSHOT uzyskując 1.0.0-SNAPSHOT. Finalnie nazwa pliku JAR ze skompilowanymi klasami będzie składała się z name i version oddzielonych minusem, na przykład code-samples-1.0.0-SNAPSHOT.jar, czy examples-5.0.12.jar. Podstawy Gradle DSL Gradle do działania potrzebuje konfiguracji. Domyślnie konfigurację umieszcza się w pliku build.gradle. Wewnątrz tego pliku możemy umieszczać komendy, które następnie zostaną wykonane przez gradle. Poniżej pokażę kilka podstawowych konstrukcji dostępnych w DSL dostarczonym przez Gradle. Zadania Gradle działa w oparciu o zadania. Wewnątrz nich definiujemy co tak naprawdę gradle powinien zrobić. Na przykład zadaniem może być utworzenie pliku JAR czy uruchomienie testów. Zadania te definiujemy wewnątrz pliku build.gradle. Poniższy przykład pokazuje prosty plik, który zawiera wyłącznie jedno zadanie buildJar, wypisujące na konsolę odpowiedni komunikat: task buildJar &lt;&lt; {    println 'now I am building JAR file, in theory'}Jeśli następnie uruchomisz gradle poleceniem gradle -q buildJar na konsoli pokaże się napis now I am building JAR file, in theory. Gratuluję, właśnie uruchomiłeś swój pierwszy plik konfigurujący budowanie projektu, co prawda niewiele on jeszcze robi, ale od czegoś trzeba zacząć :). Zależności między zadaniami Gradle pozwala także na wprowadzanie zależności pomiędzy zadaniami. Dzięki temu mechanizmowi możemy określić kolejność, w której zadania powinny być uruchamiane. Na przykład przed zbudowaniem pliku JAR uruchom testy jednostkowe. Proszę spójrz na przykład poniżej, który rozbudowuje poprzedni fragment: task runAllTests &lt;&lt; {    println 'now I am checking if all tests are passing, in theory'} task buildJar(dependsOn: runAllTests) &lt;&lt; {    println 'now I am building JAR file, in theory'}Uruchamiając gradle poleceniem gradle -q buildJar na konsoli pokaże się now I am checking if all tests are passing, in theorynow I am building JAR file, in theoryProgram gradle Teraz trochę wyjaśnień, gradle -q buildJar, uruchamia zadanie buildJar zdefiniowane w pliku build.gradle. Przełącznik -q (lub --quiet) wyłącza część informacji wypisywanych na konsolę. Teraz przeanalizuję wyjście komendy bez tego przełącznika: $ gradle buildJar:runAllTestsnow I am checking if all tests are passing, in theory:buildJarnow I am building JAR file, in theoryBUILD SUCCESSFULTotal time: 2.276 secsJak widzisz, pierwsza linijka zawiera :runAllTests, tak gradle informuje Cię o uruchomieniu tego właśnie zadania. Następna linijka zawiera odpowiedni komunikat, który wypisywane jest w trakcie uruchomienia zadania runAllTests, kolejnym zadaniem jest buildJar, także wypisujące komunikat. Zauważ, że Gradle uwzględnił zależności pomiędzy zadaniami – uruchomił runAllTests przed buildJar, tak jak było to zdefiniowane w build.gradle. Ostatnie linijki informują o tym, że proces budowania się powiódł i ile trwał. Wtyczki Gradle wspiera tak zwane wtyczki. Zawierają one zestaw gotowych zadań, które możesz uruchamiać. Przykładem takiej wtyczki jest java, która zawiera zestaw zadań przydatnych przy projektach. Wtyczki dodajemy w pliku build.gradle w następujący sposób: apply plugin: ‘java’Załóżmy, że plik build.gradle zawiera wyłącznie tę linijkę. Zobacz co zostanie wypisane na konsolę po uruchmieniu gradle build (build jest jednym z zadań udostępnionych przez wtyczkę): $ gradle build:compileJava:processResources:classes:jar:assemble:compileTestJava:processTestResources:testClasses:test UP-TO-DATE:check UP-TO-DATE:build BUILD SUCCESSFUL Total time: 2.917 secsWidzisz jakie zadania zostały uruchomione? Cała masa ;). Na przykład kompilowanie kodu (:compileJava), kompilowania testów (:compileTestJava), uruchomienia testów (:test) czy budowanie pliku JAR (:jar). Także w tym przypadku widać jak Gradle rozstrzyga zależności pomiędzy zadaniami zdefiniowanymi przez wtyczkę. Mimo tego, że uruchomiłem zadanie build, wcześniej uruchomiona została seria zadań, od których zależy build. Zależności Wspomniałem o tym, że Gradle pomaga w zarządzaniu zależnościami – tym razem chodzi o zależności od innych projektów. Tutaj także z pomocą przychodzi wtyczka java. Pozwala ona na określenie repozytoriów z których powinny być ściągane zależności. Na przykład poniższy fragment poinstruuje gradle aby użył domyślnego repozytorium Maven’a repositories {    mavenCentral()}Następnie możemy już opisywać zależności jak w przykładzie poniżej. dependencies {    compile group: 'com.google.guava', name: 'guava', version: '21.0'}Powyższa sekcja mówi, że nasz kod potrzebuje w trakcie kompilacji innej biblioteki. W tym przypadku jest to biblioteka guava w wersji 21.0. Gradle pozwala też na troszkę krótszy zapis. Poniższy przykład da dokładnie ten sam efekt co poprzedni: dependencies {    compile 'com.google.guava:guava:21.0'}Słówko compile w powyższych przykładach mówi o tym, w jakiej sytuacji będziemy potrzebowali tej zależności. Mówimy w tym przypadku o „obszarze” (ang. scope) gdzie dana zależność będzie używana. Na początku wystarczy abyś wiedział, że istnieje wiele takich obszarów, najczęściej używane z nich to compile i testCompile. Ten drugi określa zależności używane i dostępne wyłącznie w trakcie testów. W bardziej zaawansowanych przypadkach gradle pozwala na tworzenie swoich własnych „obszarów”. Poniższy przykład pokazuje jak może wyglądać przykładowy plik build.gradle z wieloma zależnościami: apply plugin: 'java' repositories {    mavenCentral()} dependencies {    compile 'com.google.guava:guava:21.0'    testCompile 'junit:junit:4.11'}Program gradle pozwala na wypisane wszystkich zależności możesz to zrobić uruchamiając gradle dependencies. Wiesz, że poznałeś właśnie nowy język? Tak naprawdę, Gradle w pliku konfiguracyjnym do projektu używa języka skryptowego Groovy. Język domenowy, którego używa się w pliku build.gradle jest na tyle rozbudowany, że w większości przypadków nie będzie potrzeby używania języka Groovy, jednak pamiętaj o tym, kiedy będziesz chciał zrobić coś nietypowego (na przykład wysłać smsa do siebie jeśli testy nie będą przechodziły, chociaż jak znam życie, ktoś już napisał wtyczkę, która to robi i możesz jej użyć bazując wyłącznie na DSL udostępnionym przez tę wtyczkę). W rzeczywistości sam DSL także jest poprawnym kodem Groovy ;). Projekty Gradle w InteliJ Idea IntliJ IDEA domyślnie wspiera projekty budowane przy pomocy Gradle. Poniżej pokazuję sposób w jaki możesz założyć przykładowy projekt. Aby to zrobić wybierz z menu File, New i następnie Project. Pokaże Ci się się następujące okienko.         Gradle nowy projekt InteliJ  Zaznaczasz gradle i klikasz next. Kolejne okienko, to nic innego jak uzupełnienie wcześniej omówionych groupId, artifactId i version, które będą identyfikowały Twój projekt:         Gradle nowy projekt InteliJ  Kolejne okienko daje InteliJ informacje jak ma się zachować w przypadku tworzenia projektu, na przykład tutaj podajesz informację, gdzie zainstalowany jest Gradle na Twoim komputerze. Istotne jest abyś zaznaczył drugą opcję, która spowoduje utworzenie struktury projektu zgodnie z opisaną wcześniej konwencją.         Gradle nowy projekt InteliJ  Kolejny ekran to informacja dla InteliJ jak powinien nazywać się projekt, domyślnie uzupełnia to pole wartością artifactId oraz gdzie na dysku projekt, powinien być utworzony.         Gradle nowy projekt InteliJ  Po przejściu przez tę serię kroków InteliJ utworzy pusty projekt wraz z plikiem build.gradle. Warto jest rzucić okiem na to co się w nim znajduje. Plik build.gradle utworzony przez IntliJ IDEA Poniżej znajduje się plik build.gradle, który utworzył za mnie InteliJ. group 'pl.samouczekprogramisty'version '1.0-SNAPSHOT' apply plugin: 'java' sourceCompatibility = 1.5 repositories {    mavenCentral()} dependencies {    testCompile group: 'junit', name: 'junit', version: '4.11'}Pierwsze dwie linijki informują o grupie i wersji – dwóch komponentach pozwalających na unikalną identyfikację projektu. Atrybut name został pominięty, przyjmuje on wartość domyślną czyli nazwę katalogu, w którym znajduje się projekt. Kolejna linijka jest Ci znana, włączamy wtyczkę do obsługi Javy. Ta linijka wymaga trochę szerszego omówienia. Java ewoluowała, na przestrzeni lat pojawiały się kolejne wersje. Wersje te wprowadzały pewne konstrukcje językowe, które nie były dostępne wcześniej. sourceCompatibility informuje kompilator javac (poprzez przełącznik -source) jakiej wersji Javy trzeba użyć do kompilowania klas z kodem. Kolejny blok mówi o repozytoriach, z których powinny być ściągane zależności. Jak widzisz InteliJ domyślnie zakłada, że korzystali będziemy z centralnego repozytorium Maven’a. Kolejny blok specyfikuje zależności, domyślnie występuje tylko jedna zależność dostępna w trakcie kompilowania testów (testCompile), jest to bilblioteka JUnit w wersji 4.11. Podsumowanie Po przeczytaniu artykułu dowiedziałeś się podstaw o Gradle. Wiesz już czym są zadania, jak łączyć je między sobą. Utworzyłeś swój pierwszy projekt w Gradle w InteliJ IDEA. Przeczytałeś o konwencjach stosowanych w większych projektach programistycznych. Temat bynajmniej nie jest wyczerpany. W kolejnych artykułach, bez wstępu, któremu poświęcony jest ten artykuł skupię się na omawianiu bardziej zaawansowanych możliwości Gradle. Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do mojego newslettera i polub Samouczka na facebooku. Na koniec mam do Ciebie standardową prośbę, podziel się linkiem do artykułu ze znajomymi, zależy mi na dotarciu do jak największej liczby zapaleńców chcących uczyć się i doskonalić w programowaniu :). Do następnego razu!             Oczywiście z racji swoje elastyczności Gradle może być użyte także w wielu innych przypadkach, jednak to budowanie projektów jest tym “standardowym”. &#8617;               Programy, które napiszemy pakowane są w paczki, tego typu paczki używane są do uruchamiania programów w środowisku produkcyjnym. &#8617;       ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/wstep-do-gradle/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/01/19_wstep_do_gradle_artykul.jpg"},{
        "title": "XML dla początkujących",
        "excerpt":"Czym jest XML XML (ang. Extensible Markup Language) to specyfikacja zapisu danych, która została opracowana w 1998 roku przez W3C (ang. World Wide Web Consortium). Jest to format tekstowy, który pozwana na zapisywanie danych w postaci, która jest łatwa do odczytu zarówno przez maszyny jak i przez ludzi1. Aby dane w formacie XML uważano za poprawne muszą one mieć pewną strukturę, proszę spójrz na przykład poniżej, który pokazuje poprawne dane w formacie XML: &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;kurs-java&gt;    &lt;artykul publikacja=”2017-03-01”&gt;        &lt;tytul&gt;Wprowadzenie do XML w Javie&lt;/tytul&gt;        &lt;autor&gt;Marcin Pietraszek&lt;/autor&gt;     &lt;/artykul&gt;     &lt;artykul&gt;         &lt;!-- do uzupelnienia --&gt;     &lt;/artykul&gt;    &lt;opis status=”do uzupelnienia”/&gt;    &lt;wydawca:opis&gt;Zestaw artykułów dotyczących programowania w języku Java&lt;/wydawca:opis&gt;&lt;/kurs-java&gt;Przykładowy dokument powyżej może służyć do opisu kursu programowania Java znajdującego się na Samouczku. Równie dobrze możesz stworzyć plik, który zawierał będzie informacje na temat pogody, stopni w szkole czy jakiegokolwiek innego tematu. Opis formatu XML Dokument XML składa się z zagnieżdżonych elementów. Są one zapisywane jako znaczniki w postaci &lt;znacznik&gt;&lt;/znacznik&gt;. Na początek drobna dygresja na temat węzłów i elementów. Czytając inne źródła po polsku na temat XML natkniesz się na nazwę węzeł. Sam próbując znaleźć poprawny odpowiednik w języku polskim nie znalazłem zbyt wielu wzmianek o węzłach (ang. node) w specyfikacji. Specyfikacja opisuje elementy (ang. element). Dlatego w tym artykule posługiwał będę się wyłącznie określeniem element. Z racji tego, że XML ma strukturę drzewiastą, a w “pracy z drzewami” mówi się o węzłach często też ten termin używany jest w odniesieniu do elementów dokumentu XML. Element główny Każdy poprawny dokument XML musi mieć wyłącznie jeden element główny (ang. root element). W przykładzie powyżej jest to element &lt;kurs-java&gt;. Zawartość elementów Elementy wewnątrz mogą zawierać treść. Na przykład wewnątrz elementu &lt;tytul&gt; znajduje się treść Wprowadzenie do XML w Javie. Elementy wewnątrz mogą zawierać kolejne elementy. Na przykład element &lt;artykul&gt; zawiera wewnątrz elementy &lt;tytul&gt; i &lt;autor&gt;. Można to porównać do drzewa gdzie z jednego pnia (elementu głównego) wyrasta kilka gałęzi (elementów zagnieżdżonych), zakończonych liśćmi. W praktyce mówiąc o liściach dokumentu XML mamy na myśli właśnie te najbardziej zagnieżdżone elementy. W naszym przykładzie będą to na przykład &lt;tytul&gt; czy &lt;autor&gt;. Atrybuty Elementy mogą posiadać dowolną liczbę atrybutów. Za przykład mogą posłużyć tu element &lt;artykul&gt; zawierający atrybut publikacja. Zawartość atrybutu to zwykły tekst. W przeciwieństwie do elementów nie możemy stosować “zagnieżdżania” - wewnątrz atrybutu nie możemy umieścić niczego poza jego wartością. Przestrzenie nazw Nazwy elementów elementów i atrybutów mogą zawierać tak zwaną “przestrzeń nazw” (ang. namespace). Do oddzielenia nazwy elementu czy atrybutu od przestrzeni nazw używa się dwukropka. W przykładzie powyżej element &lt;wydawca:opis&gt; pochodzi z przestrzeni nazw wydawca. Przestrzenie nazw stosuje się aby móc odróżnić znaczenie elementów o tej samej nazwie. W przykładzie elementy &lt;opis&gt; i &lt;wydawca:opis&gt; mogą zawierać zupełnie różne dane - różne rodzaje opisów.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Komentarze Wewnątrz dokumentu XML możesz umieszczać komentarze. W przykładzie powyżej komentarz to &lt;!-- do uzupelnienia --&gt;. Wszystko co znajduje się pomiędzy &lt;!-- i --&gt; uważane jest jako komentarz. Prolog Dokument XML powinien zawierać prolog. Częścią prologu jest deklaracja &lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt; zawiera ona informację o wersji XML, której używamy. Może także wskazać kodowanie znaków jakie zostało użyte w danym dokumencie. Wewnątrz prologu mogą znajdować się także deklaracje DTD (ang. Document Type Declaration) opisujące dany dokument. W opisie tym możemy na przykład określić, że element &lt;artykul&gt; powinien zawsze zawierac element &lt;autor&gt;. Pozostałe wymagania dotyczące formatu Każdy element musi się poprawnie zamykać. Na przykład &lt;autor&gt;Marcin Pietraszek&lt;/autor&gt;. Jeśli element nie ma treści, bądź innych zagnieżdżonych elementów zamyka się go w następujący sposób &lt;opis status=\"do uzupelnienia\"/&gt;. Elementy powinny być poprawnie zagnieżdżone. Łatwiej będzie mi to wytłumaczyć na przykładzie. Poniżej możesz zobaczyć niepoprawny fragment dokumentu XML: &lt;artykul&gt;   &lt;tytul&gt;       &lt;autor&gt;   &lt;/tytul&gt;       &lt;/autor&gt;&lt;/artykul&gt;Zauważ, że element tytul zamknięty jest przed elementem autor. Jest to niepoprawny sposób zagnieżdżania elementów. Możemy powiedzieć, że elementy, które nie są poprawnie zagnieżdżone “nachodzą” na siebie. Białe znaki pomiędzy elementami są ignorowane. W praktyce często używa się znaków tabulacji czy spacji do robienia “wcięć”. Dzięki temu tak sformatowane dokumenty są bardziej czytelne. Rodzice, dzieci i rodzeństwo a XML W przypadku poprawnie sformatowanych dokumentów XML możemy mówić o pewnych relacjach pomiędzy elementami. Specyfikacja XML mówi o rodzicach (ang. parent) i dzieciach (ang. child). W praktyce używa się także określenia rodzeństwo (ang. sibling). Element może mieć wiele dzieci, na przykład element &lt;kurs-java&gt; ma czworo dzieci - dwa elementy &lt;artykul&gt;, element &lt;opis&gt; i element &lt;wydawca:opis&gt;. Każdy element, poza elementem głównym, posiada dokładne jednego rodzica. Na przykład element &lt;tytul&gt; ma rodzica &lt;artykul&gt;. Każdy element, poza elementem głównym, może mieć rodzeństwo. Na przykład rodzeństwem dla elementu &lt;artykul&gt; jest kolejny element &lt;artykul&gt;, &lt;opis&gt; i &lt;wydawca:opis&gt;. Walidacja dokumentów XML Jak widzisz w dokumencie XML możemy zawrzeć praktycznie wszystko. Liczba dostępnych formatów jest nieskończona. W związku z tym istnieją różne mechanizmy pozwalające na walidację poprawności dokumentów XML. Za przykład mogą tu posłużyć wspomniane wcześniej elementy DTD (ang. Document Type Definition) znajdujace się wewnątrz dokumentu XML. Innym sposobem na walidację poprawnej struktury dokumentu XML jest używanie XSD (ang. XML Schema Definition). Jest to zewnętrzny plik, który także jest w formacie XML. Wewnątrz tego pliku możemy dokładnie określić strukturę jaką powinien mieć inny dokument XML. Dzięki takiej walidacji możemy na przykład zastrzec, że zawsze wewnątrz elementu &lt;artykul&gt; musi znajdować się element &lt;tytul&gt; a element &lt;autor&gt; jest opcjonalny. Wady i zalety formatu XML Główną zaletą pracy z dokumentami XML jest to, że istnieje mnóstwo narzędzi pozwalających na ich przetwarzanie. Dokumenty te są w miarę czytelne dla człowieka. Z łatwością format ten może służyć do wymiany informacji pomiędzy różnymi programami. Niestety nie jest to format idealny. Przy pracy z dużymi plikami XML przekonasz się, że wcześniej wspomniana czytelność nie jest już tak oczywista. Ponadto pliki XML są dość “rozwlekłe”. Z racji konieczności zamykania każdego elementu, znaczników w dokumencie XML jest dużo i często to one znacząco zwiększają ostateczną wielkość dokumentu. Ponadto dokumenty bardziej czytelne dla człowieka automatycznie zajmują więcej miejsca. To człowiek potrzebuje wcięć w dokumencie XML, dla programu używającego plików XML takie wcięcia są zbędne. Zastosowanie dokumentów w formacie XML Z racji swojej dobrze zdefiniowanej struktury i ogromnego zestawu narzędzi dokumenty w formacie XML są bardzo popularne. Dedykowane narzędzia do pracy z XML dostępne są w wielu językach programowania. Dokumenty w formacie XML świetnie nadają się do zapisywania wszelkiego rodzaju ustawień. Poniżej pokażę Ci kilka przykładowych zastosowań dokumentów w formacie XML:   “poprzednik” opisanego przeze mnie Gradle’a - Maven używa XML w swoich plikach konfiguracyjnych - na przykład settings.xml, profiles.xml czy plugin-registry.xml. Główny plik konfiguracyjny dla projektu to także dokument XML - pom.xml,  w jednym z banków, w którym pracowałem dokumenty XML wraz z XSLT służyły do generowania wszystkich drukowanych dokumentów,  każda aplikacja na system Android używa plików XML. W uproszczeniu można powiedzieć, że opisują one wygląd ekranu aplikacji,  dokumenty ODT (format używany na przykład przez Open Office), czy DOCX (format używany przez Microsoft Word) to tak na prawdę pliki zip, które wewnątrz zawierają dokumenty XML opisujące zawartość pliku, rozpakuj je a sam się przekonasz :)Na XML świat się nie kończy Oczywiście dokumenty XML nie są jedynym formatem, który może pomóc w wymianie danych. Poniżej wspominam o kilku innych formatach, które mogą być także użyte w tym celu.   CSV - (ang. Comman Separated Values) zwykły plik tekstowy, w którym każdy wiersz zawiera dane oddzielone przecinkami2. Z racji tego, że jest to plik tekstowy można go z łatwością odczytać używając edytora tekstu.  YAML - (ang. Yet Another Markup Language lub YAML Ain’t Markup Language) tekstowy format, w którym możemy zapisywać bardziej złożone struktury czy kolekcje.  JSON - (ang. JavaScript Object Notation) podobnie jak YAML jest w stanie opisać listę elementów czy kolekcję par klucz-wartość. Format ten, jak jego nazwa wskazuje, powstał na potrzeby JavaScript, jednak obecne jest szeroko stosowany także w innych językach. Jest to format tekstowy.Oczywiście poza formatami tekstowymi istnieją też formaty binarne:   ProtocolBuffers - binarny format opracowany przez Google. Pozwala na zapisanie praktycznie dowolnych struktur. Z racji tego, że jest to format binarny jest bardziej “zwięzły” od wspomnianych powyżej. Oczywiście nie można odczytać tego formatu bez odpowiedniego “dekodowania” zawartości,  Avro - binarny format serializacji danych, podobnie jak ProtoclBuffers zapewnia dużo bardziej zwięzłą reprezentację danych. Ma wbudowany mechanizm kompresji co pozwala na jeszcze większe zmniejszenie objętości dokumentów.Bynajmniej nie są to wszystkie dostępne formaty wymiany danych. Wspomniałem o tych kilku aby pokazać Ci, że na XML świat się nie kończy :) Każdy z tych formatów dorobił się szerokiego wsparcia w różnych językach programowania. Inne specyfikacje i narzędzia związane z XML XML jako dość dojrzały format zapisu danych “dorobił się” zestawu narzędzi i specyfikacji. Na początek ten zestaw może okazać się przytłaczający, ale spokojnie - nie wszystkich tych narzędzi używa się w każdym projekcie. W większości przypadków wystarczy wiedza o poprawnym formacie dokumentu XML i znajomość jednego z narzędzi do tworzenia/czytania plików XML. Lista poniżej to specyfikacje/narzędzia pozwalające na parsowanie i tworzenie plików w formacie XML:   DOM (ang. Document Object Model),  SAX (ang. Simple API for XML),  StAX (ang. Streaming API for XML),  JAXB (ang. Java Architecture for XML Binding).W jednym z klejnych artykułów skupię się na praktycznym wykorzystaniu powyższych narzędzi. Dodatkowo możesz też zainteresować się następującymi specyfikacjami związanymi z XML. Przydają się one w bardziej zaawansowanej pracy z dokumentami XML:   XSD (ang. XML Schema Definition) - wcześniej wspomniana specyfikacja pomagająca w walidacji poprawności dokumentów XML,  XPath (ang XML Path Language) - język pozwalający na wskazywanie elementów czy atrybutów w dokumencie XML, przy jego pomocy możesz na przykład określić “zwróć mi wszystkie elementy X, które mają atrybut Y o wartości Z”,  XSLT (ang. Extensible Stylesheet Language Transformations) - język służący do tranformowania dokumentów XML. Przy jego pomocy można przekształcić dokument XML do innych formatów, na przykład do pliku PDF.Podsumowanie Po przeczytaniu artykułu wiesz już czym jest XML. Poznałeś część dozwolonych konstrukcji, wiesz czym są elementy i jak wygląda poprawnie sformatowany dokument XML. Potrafisz wskazać praktyczne zastosowania tego formatu, znasz też kilka jego zalet i wad. Przed Tobą użycie XML w praktyce, ale to już temat na kolejny artykuł :). Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do mojego newslettera i polub Samouczka na facebooku. Na koniec mam do Ciebie standardową prośbę, podziel się linkiem do artykułu ze znajomymi, zależy mi na dotarciu do jak największej liczby samouków, którzy chcą pogłębiać swoją wiedzę. Do następnego razu!             Moim zdaniem skomplikowane pliki XML w cale nie są czytelne dla ludzi, ale to już temat na osobną dyskusję ;). &#8617;               Istnieją też inne wersje gdzie przecinek zastąpiony jest średnikiem czy znakiem tabulacji. &#8617;       ","categories": ["Wiedza ogólna","DSP2017"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/xml-dla-poczatkujacych/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/03/02_xml_dla_poczatkujacych_artykul.jpg"},{
        "title": "Projekt Pogodynka - wprowadzenie",
        "excerpt":"Opis architektury Więc pracę nad Pogodynką czas zacząć. Zacznę od tego, że przybliżę Ci moje plany dotyczące zakresu projektu. Hardware Stare Raspberry PI (nazwijmy je Malinką ;)) wygrzebane gdzieś z szafy ma posłużyć jako “mini komputer”, do którego podłączę czujnik temperatury. Czujnik ten będę musiał sam oprogramować - kupiłem go jakiś czas temu w sklepie dla elektroników.         Pogodynka - Raspberry Pi  Jak widzisz czujnik jest całkiem drobny.         Czujnik temperatury  Całość na początku połączę kabelkami, może jak starczy czasu pobawię sę w lutowanie a może nawet w wytrwawienie swojej płytki. Czas pokaże :)   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Software Kolejnym krokiem będzie napisanie prostego programu, który będzie odpalany na Malince. Nazwijmy go Termometrem. Zadaniem programu będzie pobieranie odczytu czujnika - odczytanie aktualnego poziomu temperatury. Następnie to wskazanie chcę wysłać do aplikacji webowej, która doda dany odczyt do bazy. Ta sama aplikacja webowa odpowiedzialna będzie za udostępnienie dodatkowego interfejsu. Interfejs ten będzie udostępniał historię wskazań temperatury.Więc na tym etapie mamy dwie osobne aplikacje. Pierwsza z nich to Termometr uruchamiany z linii poleceń, bez żadnego interfejsu graficznego. Druga z nich to aplikacja webowa, która udostępni interfejs dodawania wskazania temperatury oraz pobrania historii odczytów. Tu także nie będzie żadnego interfejsu graficznego. Ostatnim etapem będzie interfejs użytkownika, który będzie prezentował historyczne odczyty w formie grafów. Tu też pojawią się trudności - ten etap to aplikacja napisana w JavaScript, za którym niestety nie przepadam ;) Składając te klocki w całość projekt można pokazać na takim uproszczonym diagramie.         Pogodynka - diagram architektury  Wymyśliłem taką architekturę, ponieważ nie mam publicznego IP i nie mógłbym aplikacji webowej “wystawić na świat” jeśli uruchomiona byłaby na Malince. Tutaj drobna dygresja dla początkujących. Każda strona internetowa, na przykład www.samouczekprogramisty.pl utrzymywana jest na serwerze. Serwer ten ma tak zwany adres IP. Upraszczając możemy powiedzieć, że jest to jakaś liczba. Istnieje mechanizm, który pozwala na “tłumaczenie” adresu strony internetowej na adres IP, nazywa się on DNS (ang. Domain Name System). Dzięki temu nie musimy zapamiętywać liczb żeby zobaczyć stronę internetową. Wystarczy, że pamiętamy jej adres. Publiczny adres IP to nic innego jak taki numer, który jest stały. Dzięki temu, że adres IP się nie zmienia mapowanie adresu strony na adres IP zawsze jest poprawne. Baza danych Nasze dane to nic innego jak standardowe szeregi czasowe (ang. time series). Istnieją dedykowane bazy danych, które bardzo dobrze dają sobie radę z danymi tego typu. Jednak żeby niepotrzebnie nie komplikować samej aplikacji dane będą zapisywane w najzwyklejszej relacyjnej bazie danych. Zdaję sobie sprawę, że z czasem danych może być sporo - jednak baza relacyjna powinna dać sobie z taką ilością bez problemu radę. Zakładając odczyty temperatury co 5 minut dopiero po prawie dziesięciu latach dojdziemy do miliona rekordów ;). Oczywiście interfejs zwracający historię, będzie musiał dokonywać pewnego rodzaju agregacji, ale o tym będę decydował później. Postęp prac Cały postęp prac nad projektem wraz z zadaniami, które będę realizował możesz śledzić w Trello: https://trello.com/b/yqZHTqSN/pogodynka. Jest to proste narzędzie pomagające w śledzeniu zadań. W “prawdziwych” projektach programistycznych też używa się takich narzędzi, czasami dużo bardziej rozbudowanych. Zacząłem od tego, że pół nocy spędziłem na próbie zmuszenia Malinki do współpracy, oczywiście się to nie udało ;). Więc żeby pchnąć całość do przodu zacząłem od innego komponentu - Termometru. Jeśli jesteś zainteresowany postępem prac nad kodem zachęcam do zajrzenia do repozytorium: https://github.com/SamouczekProgramisty/Pogodynka. Aktualnie znajduje się tam zestaw kilku obiektów, które reprezentują pomiar temperatury. Pomiar ten jest transformowany do formatu JSON i wysyłany jako żądanie HTTP. Testy Do testowania całego rozwiązania, poza testami jednostkowymi, użyłem usługi http://requestb.in, która pozwala na sprawdzanie wysyłanych żądań. Wygląda na to, że całość działa. Brakuje tu oczywiście warstwy uwierzytelniania. Nie chcę, żeby każdy mógł wysłać żądanie na adres, który będzie akceptował odczyty temperatury. Podsumowanie Na koniec możesz zadać sobie pytanie. Do czego jest MI to potrzebne? Po co mam czytać tę serię artykułów? Pytania są jak najbardziej zasadne. Wydaje mi się, że mam też na te pytania dobrą odpowiedź ;). Moim zdaniem nie ma lepszego sposobu nauki programowania, niż na rzeczywistych problemach, które pojawiają się właśnie w takich projektach. Poza tym każdy programista w swoim życiu więcej kodu czyta niż pisze :). Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do mojego newslettera i polub Samouczka na facebooku. Na koniec mam do Ciebie standardową prośbę, podziel się linkiem do artykułu ze znajomymi, zależy mi na dotarciu do jak największej liczby samouków, którzy chcą pogłębiać swoją wiedzę. Do następnego razu! ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/projekt-pogodynka-wprowadzenie/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/03/04_pogodynka_01_artykul.jpeg"},{
        "title": "Java z linii poleceń",
        "excerpt":"Java z poziomu linii poleceń Dzisiaj na przekór moim wszystkim radom, proszę Cie nie korzystaj z IDE. Wyłącz IntelliJ Idea czy Eclipse. Przejdź przez cały artykuł używając wyłącznie podstawowego edytora tekstu. Moim celem jest przeprowadzenie Cię przez cały proces pisania kodu w Javie używając podstawowych narzędzi. Moim zdaniem takie podejście pozwoli Ci zrozumieć te podstawy, na których opiera się cała reszta. Osobiście dużo łatwiej jest mi pojąć bardziej skomplikowane rzeczy jeśli dokładnie wiem jak działają podstawowe klocki, których używa się do budowania tych bardziej skomplikowanych elementów. Dzisiaj używał będę programu gedit, pracując w systemie Windows możesz użyć standardowego systemowego notatnika. Istotne jest to, aby program ten był w stanie utworzyć zwykły plik tekstowy, któremu nadasz rozszerzenie java. Narzędzia dostępne w JDK O tym czym jest JDK i czym różni się od JRE pisałem w jednym z pierwszych artykułów na blogu - o przygotowaniu środowiska programisty. Dowiesz się też tam jak zainstalować JDK. Dzisiaj będą dla Ciebie istotne trzy programy. java dostarczana jest wraz z JRE, javac i jar dostępne są wyłącznie w JDK:   java uruchamia maszynę wirtualną, wywołując metodę main w odpowiedniej klasie,  javac to kompilator, który jest w stanie utworzyć plik class z pliku java,  jar to narzędzie, które jest w stanie tworzyć pliki jar.    Programy javac, java czy jar dostępne są w katalogu, w którym zainstalowałeś JDK. W zależności od systemu operacyjnego katalog ten może być różny. W niektórych systemach operacyjnych po instalacji programy te od razu dostępne są na ścieżce przeszukiwania. Innymi słowy dostępne są w jednym z katalogów wskazanych przez zmienną środowiskową PATH. Jeśli w Twoim przypadku katalog gdzie zainstalowałeś JDK nie znajduje się w zmiennej środowiskowej PATH wówczas każdy z tych programów będziesz musiał poprzedzać pełną ścieżką. Na przykład:   C:\\Program Files\\Java\\jdk1.8.0_162\\bin\\javac  /home/mapi/custom/path/jdk/bin/javacNa dłuższą metę wygodniej jest ustawić odpowiednią wartość zmiennej PATH. Szczegółową instrukcję jak to zrobić znajdziesz pod tym adresem. Pierwsza klasa w notatniku Zacznijmy od początku, od programu wyświetlającego Twoje imię na konsoli. Będzie to zwykła klasa o nazwie DisplayName w pakiecie domyślnym, która będzie miała metodę public static void main(String ... args). Wewnątrz tej metody wpisz instrukcję, która wypisze Twoje imię. Spróbuj napisać ten program bez IDE i zapisz go w pliku z rozszerzeniem java. Dla mnie takie ćwiczenia na początku były dość trudne, pokazywały jak ważne i pomocne jest IDE w codziennej pracy. Mam nadzieję, że Tobie też pomoże to uświadomić. Po tym wszystkim powinieneś mieć plik DisplayName.java, który będzie wyglądał podobnie do przykładu poniżej: public class DisplayName {    public static void main(String ... args) {        System.out.println(“Marcin”);    }}javac - skompiluj swoją klasę I teraz dochodzimy do sedna sprawy, jak uruchomić taki program? Otóż trzeba go na początku skompilować. Do tego celu służy jedno z podstawowych i najczęściej używanych narzędzi dostarczonych wraz z JDK - kompilator języka Java. Jest to program javac. Wpisując w konsoli polecenie javac -help pokaże Ci się taka lista opcji (tutaj pokazałem wyłącznie kilka pierwszych linijek): $ javac -helpUsage: javac &lt;options&gt; &lt;source files&gt;where possible options include:  -g                         Generate all debugging info  -g:none                    Generate no debugging info  -g:{lines,vars,source}     Generate only some debugging info  -nowarn                    Generate no warnings  -verbose                   Output messages about what the compiler is doing  -deprecation               Output source locations where deprecated APIs are used  -classpath &lt;path&gt;          Specify where to find user class files and annotation processors  -cp &lt;path&gt;                 Specify where to find user class files and annotation processors...Więc skompilujmy tę pierwszą klasę :). Aby to zrobić należy uruchomić komendę javac DisplayName.java. Po jej uruchomieniu kompilator powinien utworzyć plik binarny z rozszerzeniem class - DisplayName.class. Plik ten zawiera instrukcje, które są zrozumiałe dla wirtualnej maszyny Javy. A oto jak wygląda katalog, w którym aktualnie znajduje się kod źródłowy razem ze skompilowaną klasą: $ tree ..├── DisplayName.class└── DisplayName.java0 directories, 2 files  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. java - uruchom swoją klasę Skoro mamy już kod, mamy też skompilowaną klasę przydałoby się ją jakoś uruchomić :). Z pomocą przychodzi kolejny bardzo ważny program - java. Program ten uruchamia wirtualną maszynę Javy. Wpisując w konsoli java -help ponownie pokażą się dostępne opcje (skróciłem je także tutaj): $ java -helpUsage: java [-options] class [args...]           (to execute a class)   or  java [-options] -jar jarfile [args...]           (to execute a jar file)where options include:    ...    -server      to select the \"server\" VM                  The default VM is server,                  because you are running on a server-class machine.    -cp &lt;class search path of directories and zip/jar files&gt;    -classpath &lt;class search path of directories and zip/jar files&gt;                  A : separated list of directories, JAR archives,                  and ZIP archives to search for class files.    ...Teraz masz już wszystkie potrzebne składniki do uruchomienia programu. Możesz to zrobić wpisując java DisplayName: $ java DisplayNameMarcinPracowity skrzat, IDE Niby prosty program, a do jego uruchomienia trzeba użyć 2 magicznych programów, jak tak można? ;). Okazuje się, że właśnie podobne czynności robi za nas IDE. Za każdym razem1 gdy w InteliJ użyjesz klawiszy Ctr+Schift+F10 (uruchom program) InteliJ Idea robi podobne rzeczy. Kompiluje kod używając do tego programu javac a następnie uruchamia w odpowiedni sposób JRE używając programu java. Pakiety A teraz zrób krok do przodu - utwórz tę samą klasę w pakiecie pl.samouczekprogramisty.commandline i skompiluj ją przy pomocy javac. Przykład poniżej pokazuje poprawna strukturę katalogów dla klasy w takim pakiecie $ tree ..└── pl    └── samouczekprogramisty        └── commandline            └── DisplayName.java3 directories, 2 filesAby to zrobić musisz utworzyć plik ze źródłem w odpowiednim folderze, oczywiście wtedy deklaracja package na początku pliku powinna odzwierciedlać tę ścieżkę. W moim przypadku plik wygląda następująco: package pl.samouczekprogramisty.commandline;public class DisplayName {    public static void main(String ... args) {        System.out.println(\"Marcin pakiet\");    }}Następinie używając programów javac i java mogę skompilować i uruchomić odpowiednią klasę używając poleceń: javac pl/samouczekprogramisty/commandline/DisplayName.javajava pl.samouczekprogramisty.commandline.DisplayNameJak widzisz javac przyjmuje jako parametr ścieżkę do pliku, który chcesz skompilować. Program java natomiast przyjmuje pełną nazwę klasy (wraz z pakietem) wewnątrz której znajduje się metoda main. Dochodzimy tutaj do pewnej istotnej rzeczy, gdzie program java ma “szukać” tej klasy? Odpowiedzią na to pytanie jest classpath. Po polsku będę to nazywał ścieżką przeszukiwania. W przypadku systemów z rodziny Windows katalogi w ścieżce do klasy, którą kompilujesz oddzielone są znakiem \\ a nie / jak w przykładzie. Czym jest classpath No właśnie, czym jest classpath, magiczna ścieżka przeszukiwania? Wyjaśniając to pojęcie w jednym zdaniu - classpath to ścieżka, gdzie program java szuka klas, które potrzebne są w trakcie uruchomienia programu. Możesz zatem zapytać “dlaczego poprzednio java DisplayName działało?” Działało, ponieważ jeśli nie ustawisz żadnej wartości, ścieżka przeszukiwania przyjmuje wartość domyślną - .. Ta kropka oznacza katalog, w którym aktualnie się znajdujesz. Jako ćwiczenie możesz spróbować przejść do innego katalogu i uruchomić to samo polecenie, przykład poniżej pokazuje zachowanie jakie możesz uzyskać: $ tree ..└── pl    └── samouczekprogramisty        └── commandline            ├── DisplayName.class            └── DisplayName.java 3 directories, 2 files~$ java pl.samouczekprogramisty.commandline.DisplayNameMarcin pakiet~$ cd pl~/pl$ java pl.samouczekprogramisty.commandline.DisplayNameError: Could not find or load main class pl.samouczekprogramisty.commandline.DisplayNameJak widzisz w ostatniej linii program java wyświetlił błąd informujący, że nie może znaleźć klasy pl.samouczekprogramisty.commandline.DisplayName na aktualnej ścieżce przeszukiwania. Program szukał struktury pakietów pl/samouczekrogramisty/commandline, a w katalogu pl był jedynie katalog samouczekprogramisty, nie było katalogu pl. Ścieżka przeszukiwania to lista katalogów oddzielonych odpowiednim znakiem gdzie program java powinien szukać klas. Na tej ścieżce poza katalogami mogą znajdować się też pliki zip czy pliki jar2. Przykład poniżej pokazuje ścieżkę przeszukiwania na której znajdują się 3 elementy: some/path:.:other/path/file.jarPierwszy z nich to katalog some/path. Drugi z nich to katalog bieżący oznaczony znakiem .. Ostatni to ścieżka do pliku jar, wewnątrz którego znajdują się skompilowane klasy. W przypadku sytemów z rodziny Windows do rozdzielenia elementów na ścieżce przeszukiwania używa się znaku ;. W pozostałych znanych mi systemach jest to znak : jak widzisz w przykładzie powyżej. Jak ustawić classpath Ścieżka przeszukiwania może być ustalona na dwa sposoby. Pierwszym z nich jest użycie argumentu linii poleceń -cp lub -classpath. Drugim jest ustawienie zmiennej środowiskowej CLASSPATH. Jeśli nie użyjesz żadnej z tych metod, ścieżka przeszukiwania przyjmie wspomnianą już domyślną wartość. Classpath w trakcie kompilacji Nie tylko program java używa ścieżki przeszukiwania. Jest ona także używana w trakcie kompilacji. Wyobraź sobie swoją klasę, która zależy od innych klas. Na przykład używasz biblioteki Apache Commons Lang i klasy StringUtils. Załóżmy, że chcesz użyć metody StringUtils.containsIgnoreCase. Spróbuj napisać kod w notatniku, bez pomocy IDE, który pobierze od użytkownika łańcuch znaków. Następnie sprawdzi (ignorując wielkość liter), czy w tym łańcuchu znajduje się Twoje imię. Zdaję sobie sprawę, że jest to trudne ćwiczenie, jednak spróbuj wykonać je samodzielnie. Do wykonania tego ćwiczenia możesz użyć klasy java.util.Scanner i wspomnianej klasy StringUtils. Nie zapomnij o odpowiednich deklaracjach import. Prawdopodobnie bez dostępu do IDE nie zrobisz tego zadania bezbłędnie za pierwszym razem. Nie przejmuj się, to właśnie przy poprawianiu błędów nauczysz się najwięcej. Plik JAR z tą biblioteką możesz pobrać z repozytorium Mavena (jeśli nie wiesz czym jest takie repozytorium odsyłam Cię do artykułu Wstęp do Gradle). Kod, który napisałeś mógłby wyglądać jak w przykładzie poniżej: package pl.samouczekprogramisty.commandline; import java.util.Scanner;import org.apache.commons.lang3.StringUtils; public class CheckName {    public static void main(String ... args) {        System.out.println(\"Podaj zdanie\");        Scanner scanner = new Scanner(System.in);        String sentence = scanner.nextLine();         if (StringUtils.containsIgnoreCase(sentence, \"Marcin\")) {            System.out.println(\"To zdanie zawiera moje imie!\");        }        else {            System.out.println(\"To zdanie nie zawiera mojego imienia!\");        }    }}Jak widzisz, użyłem tu klasy wcześniej wspomnianej klasy Scanner i StringUtils. Pierwsza z nich znajduje się w bibliotece standardowej Javy. Jest ona domyślnie dostępna w trakcie uruchomienia i kompilacji. Jednak w przypadku klasy StringUtils jest inaczej. Jest to klasa zewnętrza więc musi być dostarczona zarówno w trakcie kompilacji jak i uruchomienia programu. Spójrz proszę na komendy użyte do kompilacji i uruchomienia programu: javac -cp commons-lang3-3.5.jar pl/samouczekprogramisty/commandline/CheckName.javajava -cp .:commons-lang3-3.5.jar pl.samouczekprogramisty.commandline.CheckNameW pierwszej linii jako ścieżkę przeszukiwania ustawiamy plik jar zawierający klasę StringUtils. To wywołanie kompiluje klasę CheckName. Dzięki temu uzyskamy plik CheckName.class, który chcemy uruchomić. Kolejna linijka to właśnie to uruchomienie. Zauważ, że w tym przypadku ścieżka przeszukiwania zawiera zarówno aktualny katalog jak i plik jar. Aktualny katalog jest niezbędny żeby znaleźć klasę CheckName. Plik jar natomiast jest wymagany do odnalezienia klasy StringUtils. Teraz czas na Twoje eksperymenty. Co się stanie jeśli uruchomisz swój program bez z -cp? :) Pliki JAR No dobrze, a co jeśli chcemy w łatwy sposób przekazać komuś skompilowany kod? Bardzo dobrze do tego celu nadają się pliki JAR. JAR czyli Java Archive to nic innego jak plik zip, wewnątrz którego znajduje się zestaw plików class ze skompilowanymi klasami3. Klasy wewnątrz archiwum znajdują się w odpowiednich katalogach, które odzwierciedlają strukturę pakietów. Spróbujmy teraz przygotować Twój pierwszy jar z linii poleceń. Program jar ma także inne zastosowania. Na przykład przy jego pomocy możesz wyświetlić zawartość istniejącego pliku JAR. Służy do tego komenda pokazana poniżej: jar tf commons-lang3-3.5.jarTworzenie pliku JAR jest dość proste. Wystarczy podać odpowiedni zestaw parametrów jak w przykładzie poniżej: jar cf &lt;nazwa pliku wyjściowego&gt; &lt;lista katalogów, klas do umieszczenia w pliku JAR&gt;W przypadku przykładu używanego poprzednio cały zestaw komend wyglądałby następująco: $ tree ..└── pl    └── samouczekprogramisty        └── commandline            ├── CheckName.class            ├── CheckName.java            ├── DisplayName.class            └── DisplayName.java 3 directories, 4 files$ jar cf JavaCommandline.jar .$ jar tf JavaCommandline.jarMETA-INF/META-INF/MANIFEST.MFpl/pl/samouczekprogramisty/pl/samouczekprogramisty/commandline/pl/samouczekprogramisty/commandline/DisplayName.javapl/samouczekprogramisty/commandline/DisplayName.classpl/samouczekprogramisty/commandline/CheckName.classpl/samouczekprogramisty/commandline/CheckName.javaJak widzisz, pliki znajdujące się w katalogu zostały dodane do pliku JAR. Program tutaj nie przeprowadził żadnego filtrowania - umieścił w archiwum także pliki java. Dlatego właśnie bardzo często pliki class umieszczamy w zupełnie innym katalogu niż pliki źródłowe. Dodatkowo wewnątrz pliku JAR znajduje się też plik MANIFEST.MF, który zawiera metadane na temat tego archiwum. Wewnątrz tego pliku możemy skonfigurować na przykład domyślną klasę, która powinna być uruchamiana podczas wykonania polecenia $ java -jar &lt;ścieżka do pliku JAR&gt;Dodatkowe materiały do nauki Artykuł ten był wybitnie praktyczny. Zależało mi na tym abyś krok po kroku realizował poszczególne etapy. Jeśli tego nie zrobiłeś, bardzo proszę spróbuj. Jeśli chciałbyś dowiedzieć się więcej o narzędziach, które opisałem w artykule mam dla Ciebie zestaw kilku dodatkowych dokumentów:   dokumentacja programu java,  dokumentacja programu javac,  dokumentacja programu jar,  specyfikacja plików jar,  kod źródłowy przykładów użytych w artykule.Podsumowanie Mam nadzieję, że taki praktyczny przewodnik krok po krodu po podstawowych narzędziach dostepnych z JRE i JDK przypadł Ci do gustu. Daj znać w komentarzach jak Ci poszło z przerobieniem ćwiczeń z treści artykułu :). Po przeczytaniu tekstu znasz podstawowe narzędzia używane przy programowaniu w języku Java. Jesteś w stanie stworzyć swój plik jar i uruchomić klasy, które skmpilujesz podstawowymi narzędziami. Dzięki temu lepiej rozumiesz “magię”, którą na codzień robi IDE. Wiesz jak bardzo upraszcza ono Twoją pracę z kodem. Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do mojego newslettera i polub Samouczka na facebooku. Na koniec mam do Ciebie standardową prośbę, podziel się linkiem do artykułu ze znajomymi, zależy mi na dotarciu do jak największej liczby samouków, którzy chcą pogłębiać swoją wiedzę. Do następnego razu!             Jak zwykle są wyjątki, ale nie są one istotne w tym przypadku. &#8617;               Tak na prawdę plik jar to plik zip z innym rozszerzeniem. &#8617;               Oczywiście pliki jar mogą zawierać także pliki innego rodzaju, jednak na tym etapie wystarczy wiedza o class i pliku tekstowym Manifest. &#8617;       ","categories": ["Kurs programowania Java","DSP2017"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/java-z-linii-polecen/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/03/08_java_z_linii_polecen_artykul.jpg"},{
        "title": "Pogodynka - naiwny termometr",
        "excerpt":"Malinka padła Niestety poprzedni tydzień minął pod znakiem kolejnych nieudanych prób wskrzeszenia mojej Malinki. Leżała ona już prawie 5 lat w szafie, przerzucana z miejsca na miejsce. Miała prawo “wysiąść”. Idę na łatwiznę - nie próbuję jej teraz naprawić. Wczoraj kupiłem nowszą wersję płytki, tym razem jest to Rasperry Pi 3 B, więc jest to już dużo mocniejszy układ, niż poprzedni. Ta nowa wersja ma też więcej portów USB, czego przyznam brakowało mi w wersji poprzedniej (jeszcze 5 lat temu jak płytka działała…). Używa też wbudowanego modułu do komunikacji WiFi co też jest sporym ułatwieniem. Przesyłka jest już w drodze, więc jeśli wszystko dobrze pójdzie powinienem mieć nową malinkę w poniedziałek u siebie. Termometr Pchnąłem do przodu moduł termometru. Kilka nowych linijek kodu się pojawiło, jednak “serce” czyli właściwe odczytywanie temperatury nie działa, z oczywistych względów. Aktualnie działa “naiwny” termometr, który zwraca aktualną godzinę jako wskazanie temperatury ;). Przy okazji tego wpisu przybliżę Ci trochę narzędzia, które są niezbędne do realizacji tej części projektu. Zacznę od crontab'a.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. crontab W systemach operacyjnych są programy, które działają w tle. Programy tego typu nazywa się serwisami lub demonami. Jednym z takich demonów w systemach z rodziny Linux jest cron. Jest to demon, który odpowiada za uruchamianie poleceń zdefiniowanych przez użytkownika z odpowiednią częstotliwością. Dzięki temu demonowi możesz na przykład sprawdzić aktualną temperaturę co pięć minut :). Idealne zastosowanie dla mojej pogodynki. crontab używa specyficznej składni, która pozwana na określenie kiedy dana komenda powinna być uruchamiana: ┌───────────── minuta (0 - 59)│ ┌───────────── godzina (0 - 23)│ │ ┌───────────── dzień miesiąca (1 - 31)│ │ │ ┌───────────── miesiąc (1 - 12)│ │ │ │ ┌───────────── dzień tygodnia (0 - 6) (0 - niedziela, 6 - sobota)│ │ │ │ ││ │ │ │ ││ │ │ │ │* * * * * &lt;polecenie do wykonania&gt;Kilka przykładów, powinno pomóc Ci lepiej zrozumieć ustawienia crontab’a:   * * * * * &lt;komenda&gt; - uruchom komendę co minutę,  * 0 * * * &lt;komenda&gt; - uruchom komendę co minutę w trakcie godziny 0,  30 17 * * * &lt;komenda&gt; - uruchom komendę codziennie o 17:30,  15 4 ? * 0 &lt;komenda&gt; - uruchom komendę co sobotę o 4:15,  0-15 * * * * &lt;komenda&gt; - uruchom komendę co minutę w pierwszych 16 minutach każdej godziny,  0,5,10 * * * * &lt;komenda&gt; - uruchom komendę w zerowej, piątek i dziesiątej minucie każdej godziny,  */5 * * * * &lt;komenda&gt; - uruchom komendę co pięć minut,Właśnie ta ostatnia linijka przyda się w przypadku pogodynki - co 5 minut będę chciał pobierać aktualne wskazanie temperatury. Monitorowanie programu W związku z tym, że zadanie sprawdzania temperatury będzie się odbywało w regularnych odstępach i będzie działo się automatycznie potrzebuję mechanizmu do monitorowania żeby zapewnić poprawnie i ciągłe działanie termometru. Z doświadczenia wiem, że tego typu zadania dość często płatają figle i nie wykonują się poprawnie. Postanowiłem użyć serwisu https://healthchecks.io. Jest to darmowy serwis, który umożliwia wysyłanie stanu programu1 na skonfigurowany adres URL. Serwis ten monitoruje czy takie zapytanie jest wysyłanie z odpowiednią częstotliwością. Jak widzisz na obrazku poniżej pokazuję przykładowe ustawienia healthchecks         Interfejs healthchecks  Następnie healthchecks poinformuje mnie mailem o tym, że termometr nie mierzył temperatury z częstotliwością, którą skonfigurowałem. Logowanie Załóżmy, ze coś poszło nie tak. Dostałem maila z informacją o tym, że temperatura nie jest mierzona. Co teraz? :) Z pomocą przychodzą logi. Logi, czyli informacje, które zapisywane są do pliku w trakcie działania programu. W pliku z logami zapisuje się różne informacje, zaczynając od “stanu programu” na rzuconych wyjątkach kończąc. Właśnie na podstawie takich plików będzie można później dojść co poszło “nie tak”. W tym tygodniu zaimplementowałem właśnie logowanie, zapraszam do rzucenia okiem na kod źródłowy. Do logowania używam standardowych bibliotek dosępnych dla Javy SL4J i LOG4J. Logi będą generowane cały czas. Program w końcu ma uruchamiać się co 5 minut. Naturalne jest więc, że po pewnym czasie plików z logami będzie sporo. Mogą też one zajmować dużo miejsca. Z pomocą po raz kolejny przychodzi crontab. Raz dziennie będę usuwał logi, które będą starsze niż tydzień. Komenda do mierzenia temperatury Z artykułu, w którym opisywałem Javę w linii poleceń wiesz jak zbudować plik jar i jak uruchomić program z linii poleceń. Właśnie tę wiedzę potrzebujesz to wpisania programu uruchamianego cyklicznie do cron’a. W moim przypadku będzie to polecenie java -jar /opt/pogodynka/thermometer-1.0-SNAPHSOT.jarAby nie wypisywać długiej listy zależności i nie dodawać ich do classpath przy uruchomieniu programu użyłem tu pewnej sztuczki. Wszystkie zależności programu zostały zapakowane do jednego pliku jar. Tego typu zachowanie skonfigurowałem w pliku thermometer.gradle. O podstawach Gradle przeczytasz w osobnym artykule. Przekazywanie parametrów Aby nie musieć kompilować kodu za każdym razem istotne ustawienia przekazywane będą jako parametry linii poleceń. Użytkownik, jego hasło czy adres gdzie ma być wysłane aktualny odczyt temperatury przekazane będą jako argumenty. “Parsowaniem” tych argumentów zajmuje się osobna klasa Arguments. Monitorowanie Dodatkowo “zintegruję” to z wcześniej opisanym serwisem healthchecks. Z pomocą przyjdzie operator &amp;&amp; w bashu, który wykonuje to co jest po prawej stronie jeśli kod zakończenia komendy po lewej stronie jest równy 0. Zatem finalnie komenda w crontab będzie wyglądała następująco: java -jar /opt/pogodynka/thermometer-1.0-SNAPSHOT.jar dummyUsername dummyPassword \\http://www.samouczekprogramisty.pl/getrealaddress &amp;&amp; \\curl -fsS --retry 3 https://hchk.io/89941a75-5e1a-4b0b-a864-59d584e579a8Magiczna część po &amp;&amp; odpowiada za wysłanie zapytania do healtchecks. Całość opakowałem w drobny skrypt w bash’u, który automatyzuje dodanie wpisu do cron’a. Skrypt dostępny jest na githubie.Tak oto wygląda crontab po uruchomieniu tego skryptu: $ crontab -l*/5 * * * * java -jar /opt/pogodynka/thermometer-1.0-SNAPSHOT.jar dummyUsername dummyPassword http://www.samouczekprogramisty.pl/getrealaddress &amp;&amp; curl -fsS --retry 3 https://hchk.io/89941a75-5e1a-4b0b-a864-59d584e579a81 0 * * * find /var/log/pogodynka/*.log -mtime +7 -exec rm {} \\;Efekt finalny Aktualnie moduł termometru jest popchnięty najdalej jak tylko mogłem. Teraz czas na pozostałe elementy o czym przeczytasz za tydzień. W przyszłym tygodniu skupię się na kolejnym elemencie - aplikacji webowej, która będzie przyjmowała odczyt temperatury. Podsumowanie Zachęcam Cię do śledzenia zadań, które wykonuję w ramach realizacji tego projektu. Możesz je zobaczyć na trello. Najnowszą wersję kodu źródłowego zawsze znajdziesz na githubie. Zapisz się do mojego newslettera i polub stronę na facebooku jeśli nie chcesz pominąć kolejnych artykułów. Do następnego razu!             W sumie nie jest to stan, a jedynie “ping”, co w zupełności spełnia wymagania. &#8617;       ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pogodynka-naiwny-termometr/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/03/11_pogodynka_02_artykul.jpeg"},{
        "title": "Wprowadzenie do aplikacji webowych",
        "excerpt":"Z przeglądarką czy bez? Używając przeglądarki czy programów z pakietu Office1 używasz aplikacji zainstalowanych na komputerze. Potocznie o takich programach czy aplikacjach mówi się “aplikacje desktopowe”. Możesz je zainstalować pobierając odpowiednie pliki z internetu lub z innego nośnika jak na przykład płyta CD. Podczas takiej instalacji pliki niezbędne do działania aplikacji zapisywane są na dysku komputera. Aplikacje webowe, to zupełnie oddzielna grupa aplikacji. Nie są one instalowane na Twoim komputerze. Można powiedzieć, że są zainstalowane na serwerze, a Ty dostajesz się do nich za pośrednictwem internetu. Otwierając przeglądarkę internetową i wchodząc na stronę dostajesz się do aplikacji webowej. Jak już wspomniałem do działania takiej aplikacji potrzebny jest ów “magiczny” serwer. Czym jest serwer Słowo serwer ma wiele znaczeń. Jednym ze znaczeń tego słowa jest określenie maszyny, komputera. Serwerem możemy także nazywać aplikację, która jest na takim komputerze zainstalowana. Przykładem takich serwerów są Apache HTTP Server czy nginx. Wymienione wyżej serwery to serwery HTTP (ang. Hypertext Transfer Protocol), ich zadaniem jest serwowanie stron internetowych. Wpisując adres www.samouczekprogramisty.pl w okienku przeglądarki wysyłasz zapytanie HTTP do serwera firmy, w której wykupiłem taką usługę. Serwer ten widząc twoje zapytanie odpowiada treścią, która jest zrozumiała dla przeglądarki. Przeglądarka wyświetla następnie tę treść w formie strony internetowej. W najprostszym przykładzie jakim jest serwer HTTP, serwer (aplikacja) w odpowiedzi wysyła zawartość plików znajdujących się na dysku serwera (komputera). W takim przypadku możemy mówić o serwowaniu plików statycznych. Aplikacje webowe pokazują zawartość, która jest zmienna. Nie można jej uzyskać wyłącznie z plików statycznych znajdujących się na dysku serwera. Przykładem takiej aplikacji może być ten blog - masz wpływ na zawartość strony na przykład przez dodawanie komentarzy.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Język aplikacji webowej Aplikacje webowe mogą być napisane w wielu językach. Może to być Ruby, Python, PHP czy Java. Bynajmniej nie jest to kompletna lista :). Języków jest bardzo dużo, jednak mechanizm działania jest zawsze ten sam. Aplikacja webowa napisana w języku X interpretuje żądanie wysłane przez przeglądarkę użytkownika do serwera i odpowiada na nie generując odpowiednią zawartość. Zawartość to plik generowany dynamicznie, który jest zrozumiały przez przeglądarkę internetową. Zauważ, że taki sposób komunikacji pozwala na zastosowanie praktycznie dowolnego języka. W takiej sytuacji mówimy o protokole komunikacji. Protokole czyli zbiorze reguł, których przestrzeganie pozwoli się “dogadać” :). Protokół ten używany jest w komunikacji pomiędzy klientem a serwerem. W tym przypadku klientem jest przeglądarka internetowa a serwerem jest aplikacja, która przetwarza żądanie wysłane przez klienta. W takim przypadku często też mówimy o aplikacjach typu klient-serwer. Język, który rozumie przeglądarka W dużym uproszczeniu przeglądarka internetowa to program, który wyświetla strony internetowe. Strony internetowe składają się z plików. Pliki te tworzone są przy pomocy różnych “języków”:   HTML (ang. Hypertext Markup Language) - język znaczników, można powiedzieć, że jest podzbiorem języka XML (wprowadzenie do XML). Znaczniki te opisują strukturę strony, to z jakich elementów się składa,  CSS (ang. Cascading Style Sheets) - język stylów, który pozwala na opisanie wyglądu strony internetowej. W połączeniu z HTML pozwala na tworzenie stron internetowych “przyjaznych dla oka”,  JavaScript - język programowania. Kod JavaScript jest interpretowany przez przeglądarkę. Pozwala na uruchamianie skryptów po stronie przeglądarki. Bardzo często animacje widoczne na stronach to właśnie wynik działania skryptów JavaScript.Aplikacje webowe w Javie Aplikacje webowe w języku Java można tworzyć dzięki specyfikacji JEE (ang. Java Enterprise Edition). Jest to właściwie zbiór innych specyfikacji opisujących różne mechanizmy wykorzystywane przy budowaniu aplikacji webowych. Podobnie jak w przypadku innych języków tak i w Javie potrzebny jest odpowiedni serwer. W przypadku Javy możemy mówić o serwerze aplikacji jeśli implementuje on funkcjonalności opisane w specyfikacji JEE. Z racji tego, że specyfikacja ta jest rozległa dostępne są “prostsze serwery”. W takim przypadku mówimy o kontenerze serwletów. Jest to “uproszczony serwer aplikacji”, który implementuje jedynie część specyfikacji JEE. Częścią specyfikacji JEE jest specyfikacja serwletów. Serwlety w aplikacjach webowych Serwlet to serce aplikacji webowych napisanych w Javie. Serwlet to klasa, która wie w jaki sposób obsłużyć zapytanie wysłane do serwera. Potrafi też odpowiedzieć na to zapytanie. W artykule opisującym Javę z linii poleceń mogłeś przeczytać o plikach JAR. W przypadku aplikacji webowych wprowadzono dodatkowy plik, plik WAR (ang. Web Archive). Wewnątrz tego pliku znajduje się kod (skompilowane klasy) potrzebny do uruchomienia aplikacji webowej. Między innymi są to serwlety. Dodatkowo wewnątrz pliku WAR znajdować się mogą pliki JAR zawierające zależności niezbędne do działania aplikacji webowej. Plik war instaluje się w kontenerze serwletów (ang. deploy). Kontener serwletów pośredniczy w obsłudze zapytań. Jak to wygląda w praktyce pokaże Ci profesjonalny diagram poniżej :), pokazuje on w dużym uproszczeniu obsługę żądań do aplikacji webowej:         Obsługa żądania w aplikacji webowej    wysłanie żądania z przeglądarki do serwera (maszyny)  przekazanie żądania do kontenera serwletów/serwera aplikacji  przetworzenie żądania przez serwlet/aplikację webową  przekazanie odpowiedzi z kontenera serwletów do serwera  wysłanie odpowiedzi do klienta (przeglądarki internetowej)Istnieje wiele serwerów aplikacji i kontenerów serwletów. Te najpopularniejsze z nich znajdziesz poniżej:   Tomcat  Jetty  Glassfish  WildFly  WeblogicZalety aplikacji webowych Główną zaletą aplikacji webowych jest to, że nie trzeba instalować ich na komputerze użytkownika. Aby korzystać z takiej aplikacji wystarczy przeglądarka z dostępem do internetu. Dzięki temu użytkownik może korzystać z takiej aplikacji praktycznie na dowolnym komputerze. Nie bez znaczenie jest też dostępność aplikacji webowej na różnych typach urządzeń. Część aplikacji webowych można używać zarówno na komputerze, tablecie czy telefonie. Równie istotna jest łatwość poprawiania błędów. W aplikacjach desktopowych jest to utrudnione, ponieważ w jakiś sposób aktualizacja musi być dostarczona do użytkownika. W przypadku aplikacji webowych taka aktualizacja może być dla użytkownika niewidoczna. Dzięki temu poprawki błędów czy nowe funkcjonalności są szybciej dostępne dla użytkowników. Podsumowanie Aplikacje webowe to coś dzięki czemu moim zdaniem Java zyskała tak dużą popularność. Ogromna większość ofert pracy na rynku związana z technologią Java dotyczy aplikacji webowych. Artykuł ten jedynie musnął ich tematykę. Mam nadzieję, że po jego lekturze będzie Ci łatwiej zrozumieć zasadę działania tego typu aplikacji. Zapisz się do mojego newslettera i polub stronę na Facebooku jeśli nie chcesz pominąć kolejnych artykułów. Jeśli masz jakiekolwiek pytania proszę zadaj je w komentarzu :). Do następnego razu!             Chodzi mi to o tę “instalowalną” część pakietu, a nie tę dostępną online ;). &#8617;       ","categories": ["Kurs programowania Java","DSP2017"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/wprowadzenie-do-aplikacji-webowych/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/03/17_wprowadzenie_do_aplikacji_webowych_artykul.jpg"},{
        "title": "Pogodynka - działający termometr",
        "excerpt":"Postęp w module Thermometer Mogę powiedzieć, że pierwszy moduł całej aplikacji jest “gotowy”. Podłączyłem czujnik temperatury do Malinki, udało mi się nawet odczytać wskazania temperatury. Klasa FromFileThermometer jest w stanie przeczytać zawartość takiego pliku i odpowiednio ją zinterpretować, udowadnia to test jednostkowy FromFileThermometerTest. Praca z czujnikiem DS18B20 na Malince Czujnik temperatury DS18B20 można połączyć bezpośrednio pod wyjścia GPIO (ang. General Purpose Input Output). Wystarczy do tego sam czujnik i opornik 4.7k. W moim przypadku na zdjęciu poniżej widać to połączenie:         Podpięcie czujnika temperatury.  U siebie zastosowałem opornik 4.6k (akurat taki udało mi się dostać w sklepie). Jeśli wszystko działa poprawnie Malinka wykryje czujnik i w katalogu /sys/bus/w1/devices znajdzie się katalog o nazwie 28-00000xxxxxx. xxxxxx może być różne i jest unikalnym identyfikatorem danego czujnika. Wewnątrz tego katalogu znajduje się plik w1_slave, który zawiera aktualne wskazanie czujnika.         Wskazanie czujnika temperatury.  Odczytanie temperatury sprowadza się do poprawnego parsowania zawartości tego pliku. Przykład realizacji możesz znaleźć we wcześniej wspomnianej klasie FromFileThermometer.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Zmiany w Gradle Sporo też zmieniło się w samej strukturze projektu. Od teraz pogodynka to projekt, który składa się z wielu modułów. Jest to możliwe dzięki dodaniu pliku settings.gradle, który opisuje strukturę takiego projektu. Jeden z modułów już znasz thermometer. Nowy, który się pojawił to datavault. Dla przypomnienia jest to moduł, który odpowiedzialny będzie za zapisywanie wskazań temperatury w bazie. Udostępniał też będzie usługi, które używane będą przez interfejs użytkownika w przeglądarce internetowej. Całość na prostym diagramie wygląda następująco:         Diagram aplikacji Pogodynka  Jeśli chcesz poznać podstawy Gradle zapraszam do osobnego artykułu. Szablon aplikacji webowej Moduł datavault będzie aplikacją webową. Aplikacja ta nie będzie posiadała żadnego interfejsu graficznego. Wystawi jedynie usługi, które będą realizowały całą funkcjonalność:   zapis aktualnej temperatury,  odczyt temperatur z N ostatnich dni.Jeśli wcześniej nie miałeś do czynienia z aplikacjami tego typu zachęcam do przeczytania wprowadzenia do aplikacji webowych. Aktualnie moduł datavault to pusty szablon aplikacji webowej. Całość sprowadza się do pliku datavault.gradle, który definiuje aplikację tego typu: apply plugin: 'war'apply from: 'https://raw.github.com/akhikhl/gretty/master/pluginScripts/gretty.plugin' dependencies {    providedCompile group: 'javax.servlet', name: 'javax.servlet-api', version: '3.1.0'}W pierwszej linijce dodaję rozszerzenie war, dzięki któremu Gradle wie, że jest to aplikacja webowa. Druga linijka dodaje rozszerzenie, które pozwala na wygodne uruchamianie kontenerów aplikacji/serwletów. Dzięki wtyczce gretty w prosty sposób możemy uruchomić taki kontener. Zachęcam to tego żebyś pobrał kod z repozytorium i sam spróbował: $ ./gradlew appRun:datavault:prepareInplaceWebAppFolder UP-TO-DATE:datavault:createInplaceWebAppFolder UP-TO-DATE:datavault:compileJava NO-SOURCE:datavault:processResources NO-SOURCE:datavault:classes UP-TO-DATE:datavault:prepareInplaceWebAppClasses UP-TO-DATE:datavault:prepareInplaceWebApp UP-TO-DATE:datavault:appRun18:48:10 INFO Jetty 9.2.15.v20160210 started and listening on port 808018:48:10 INFO datavault runs at:18:48:10 INFO http://localhost:8080/datavaultPress any key to stop the server.&gt; Building 87% &gt; :datavault:appRunNastępnie otworzenie w przeglądarce adresu http://localhost:8080/datavault powinno zadziałać :). Podsumowanie Powoli, ale skutecznie idę do przodu :). Jeden z modułów jest gotowy, pozostałe dwa czekają na swoją kolej. Datavautl wezmę na tapetę w kolejnych tygodniach. Na dzisiaj to wszystko z frontu, do następnego razu! :) ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pogodynka-dzialajacy-termometr/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/03/19_pogodynka_03_artykul.jpg"},{
        "title": "Serwlety w aplikacjach webowych",
        "excerpt":"    Chociaż artykuł ten pisany jest z myślą o początkujących do jego pełnego zrozumienia przyda się wiedza, którą zawarłem w kliku innych artykułach. Zachęcam do zapoznania się z nimi przed podejściem do tego artykułu:   Wstęp do aplikacji webowych  Wstęp do Gradle  Java z linii poleceńArtykuł ten bazuje na specyfikacji serwletów w wersji 3.1, która jest częścią specyfikacji Java Enterprise Edition 7. Planowany termin wydania specyfikacji Java Enterprise Edition 8 to koniec 2017 roku, w ramach tej specyfikacji wydana ma być także nowa specyfikacja serwletów w wersji 4.0. Wprowadzenie do protokołu HTTP Napisałem osobny artykuł na temat protokołu HTTP. Tutaj przedstawię jedynie niezbędne podstawy. Aby zacząć poważnie myśleć o tworzeniu aplikacji webowych niezbędna jest wiedza dotycząca protokołu HTTP (ang. Hypertext Transfer Protocol). Poniżej znajdziesz kilka podstawowych informacji, które będą Ci potrzebne w pracy z aplikacją webową.   Protokół HTTP jest oparty na komunikacji pomiędzy klientem a serwerem. Klientem może być na przykład przeglądarka internetowa. Serwer to aplikacja, która odpowiada na żądania klienta.  Komunikacja pomiędzy klientem a serwerem oparta jest na żądaniach (ang. request) i odpowiedziach (ang. response). Klient wysyła żądanie, na które serwer udziela odpowiedzi.  Zarówno żądania, jak i odpowiedzi mogą zawierać nagłówki i treść. Nagłówki służą do przekazania części informacji. W nagłówku na przykład zawarte mogą być informacje o przeglądarce, z której wysłano żądanie. Treścią odpowiedzi może być na przykład zawartość strony internetowej.  Protokół HTTP oparty jest o tak zwane “czasowniki HTTP”. Można powiedzieć, że czasownik ten określa rodzaj żądania jakie wysyła klient. Wszystkich czasowników jest 9, podstawowe rodzaje żądań to GET, POST, PUT, DELETE.  W większości przypadków używane są żądania typu GET i POST. Na przykład do wysłania informacji, które uzupełniłeś w formularzu używa się żądania typu POST. Natomiast zwykłe otworzenie strony, wpisanie adresu strony w przeglądarce to żądanie typu GET.Adres URL Każde z żądań dotyczy jakiegoś zasobu. Na przykład otwierając stronę www.samouczekprogramisty.pl w przeglądarce wysyłasz żądanie GET http://www.samouczekprogramisty.pl. Ta część po GET to nic innego jak URL (ang. Uniform Resource Locator). Innymi słowy adres strony www. Adres URL może składać się z kilku części (scheme://)(user:password@)host(:port)(/)(path)(?query)(#fragment)http://marcin:tajnehaslo@www.samouczekprogramisty.pl:80/kurs-programowania-java?parametr=wartosc&amp;innyParametr=wartosc#xxxW ogromnej większości przypadków część z użytkownikiem i hasłem jest pomijana. Używana jest ona do uwierzytelniania, jednak metoda ta nie jest powszechnie używana. Port także jest pomijany. Pomijamy go ponieważ dla protokołu http domyślny port to właśnie 80 więc nie ma potrzeby go dodawać. Odrzucając rzadziej używane elementy adres url wygląda następująco http://www.samouczekprogramisty.pl:80/kurs-programowania-java?parametr=wartosc&amp;innyParametr=wartoscMamy tutaj informację o protokole (http), serwerze (www.samouczekprogramisty.pl), ścieżce (/kurs-programowania-java) i parametrach (parametr=wartosc&amp;innyParametr=wartosc).   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Czym jest serwlet Serwlet to klasa, która implementuje interfejs Servlet. Instancje tej klasy tworzone są przez kontener serwletów (na przykład Jetty). Instancje te wiedzą jak odpowiadać na żądania, które dostają od klienta. Do obsługi żądania klienta służy metoda service. Metoda ta przyjmuje jako parametry żądanie i odpowiedź. Na podstawie parametrów żądania odpowiednio modyfikuje przekazany argument odpowiedzi. Szczerze mówiąc do tej pory ani razu nie napisałem klasy, która bezpośrednio implementuje ten interfejs. Używa się do tego klas, które upraszczają tworzenie serwletów. Są to klasy GenericServlet i HttpServlet. Chociaż specyfikacja serwletów, nie wymaga użycia serwletów z protokołem HTTP w praktyce nie spotkałem się z innym zastosowaniem. Zatem z dwóch wyżej wspomnianych klas powinieneś zapamiętać HttpServlet1. Interfejs serwletów Wcześniej wspomniałem Ci już o metodzie service. Metodę tę musiałbyś zaimplementować jeśli utworzyłbyś klasę, która implementuje interfejs Servlet bezpośrednio. W przypadku klasy, która dziedziczy po HttpServlet wystarczy nadpis odpowiednie metody. Na przykład, jeśli twój serwlet ma obsłużyć żądania typu GET musisz zaimplementować metodę doGet. Istnieją też metody dla pozostałych “czasowników”, na przykład doPost czy doPut. W interfejsie serwletów znajdują się też metody, które są wykorzystywane w trakcie cyklu życia serwletu. Jak wspomniałem wyżej kontener odpowiedzialny jest za tworzenie instancji serwletu. Ponadto kontener zarządza cyklem życia serwletu używając metod z tego interfejsu. Cykl życia serwletu Każda instancja serwletu ma swój cykl życia. Jest to jasno zdefiniowana lista etapów, przez które przechodzi każdy serwelt. Lista ta wygląda następująco: Utworzenie instancji serwletu Kontener wyszukuje klas serwletów i następnie tworzy jedną instancję serwletu2. Inicjalizacja serwletu Z racji tego, że to kontener serwletów odpowiedzialny jest za tworzenie instancji klasy serwletu nie ma możliwości przekazania odpowiednich parametrów do konstruktora. Do inicjalizacji stanu serwletu służy metoda init i jest ona wywoływana przez kontener przed rozpoczęciem obsługi żądań przez dany serwlet. Obsługa żądań W trakcie tego etapu kontener serwletów może wielokrotnie użyć tej samej instancji to obsługi wielu żądań. Pociąga to za sobą dość poważne konsekwencje. Możliwa jest sytuacja, w której w tym samym czasie instancja serwletu będzie obsługiwała kilka żądań jednocześnie. Na przykład jest to możliwe gdy kilku użytkowników wejdzie na ten sam adres. Obsługa każdego żądania do wywołanie przez kontener metody service. Zniszczenie serwletu Kontener może usunąć daną instancję serwletu. Przed zniszczeniem instancji wywołana zostanie metoda destroy. Dzięki temu wewnątrz serweltu masz szansę na “posprzątanie”. Metoda ta może na przykład służyć do zamknięcia połączenia z bazą danych. Nie masz pewności jak długo serwlet będzie żył, o tym decyduje kontener. Kontener serwletów Z poprzednich paragrafów dowiedziałeś się już, że kontener serwletów zarządza cyklem życia serwletów. Nie jest to jedyna odpowiedzialność kontenera. Kontener serwletów odpowiedzialny jest za “wyszukanie” klas odpowiedzialnych za działanie aplikacji. W pierwszych wersjach specyfikacji niezbędny był do tego plik web.xml (tak zwany deskryptor wdrożenia), teraz aplikację webową można skonfigurować przy pomocy adnotacji. Dalej jednak to kontener musi “znaleźć” te klasy. Poza serwletami istnieją też inne komponenty aplikacji webowej opisane w specyfikacji serlwetów. Na przykład filtry czy “listnenery” (ang. listener) (ma ktoś z was pomysł jak przetłumaczyć to słowo na polski :)?). Także i tutaj kontener serwletów pełni kluczową rolę. Kontener zarządza cyklem życia tych elementów. Przy konstruowaniu odpowiedzi na żądania pomocne są pliki typu JSP (ang. Java Server Pages). Powtórzę się - kontener zarządza cyklem życia takich plików. W przypadku aplikacji webowych możemy mówić o kilku kontekstach. Możemy wyróżnić na przykład kontekst żądania czy kontekst aplikacji. Także tutaj kontener serwletów za nie odpowiada. Jest jeszcze wiele innych aspektów, za które odpowiada kontener wybiegają jednak poza zakres tego artykułu. Napiszę jeszcze o jednym z nich. Kontener także odpowiedzialny jest za instalowanie aplikacji webowej, wiąże się to z “czytaniem” zawartości pliku war, w którym znajduje się aplikacja webowa. Plik war W artykule opisującym Javę z linii poleceń możesz przeczytać o plikach jar. W przypadku aplikacji webowych plik war pełni kluczową rolę. W skład aplikacji webowej mogą wchodzić:   serwlety,  strony jsp,  inne klasy Java,  zależności aplikacji webowej,  statyczne pliki (na przykład html czy css),  pliki konfiguracyjne opisujące aplikację webową.Wszystkie te pliki pakowane są w odpowiednią strukturę wewnątrz pliku war. Struktura aplikacji webowej Podobnie jak w przypadku pliku jar jest to zwykłe archiwum zip ze zmienionym rozszerzeniem (war a nie zip). Buduje się go przy pomocy tych samych narzędzi jak plik jar . Struktura przykładowego pliku war jest następująca: struktura_pliku.war├── index.html├── publiczny_katalog│   └── strona.html├── style.css└── WEB-INF    ├── classes    │   └── pl    │   └── samouczekprogramisty    │   └── SomeServlet.class    ├── lib    │   └── some-jar-file.jar    └── web.xmlPliki takie jak index.html, publiczny_ktalog/strona.html czy style.css są publicznie dostępne. Oznacza to tyle, że kontener serwletów może serwować te pliki. Sprawa wygląda zupełnie inaczej w przypadku katalogu WEB-INF. Jest to katalog, który zawiera dane, które nigdy nie mogą być bezpośrednio “serwowane” przez kontener. Wewnątrz WEB-INF znajdują się inne katalogi:   classes - zawiera on skompilowane klasy aplikacji webowej,  lib - zawiera on spakowane pliki jar potrzebne do działania aplikacji webowej.Dodatkowo aplikacja webowa może zawierać tak zwany deskryptor wdrożenia (ang. deployment descriptor). Jest to plik web.xml, który konfiguruje działanie aplikacji webowej. W przypadku prostych aplikacji nie jest on wymagany, całą konfigurację można dostarczyć przy pomocy adnotacji. Sekret działania Spring MVC W codziennej pracy z aplikacjami webowymi programiści bardzo rzadko (wcale?) tworzą swoje serwlety. W ogromnej większości przypadków to biblioteka pomagająca przybudowaniu aplikacji webowych zawiera “główny serwlet”. Ten serwlet pośredniczy przy wszystkich zapytaniach do danej aplikacji webowej. Następnie w zależności od ścieżki, której dotyczy dane żądanie przekazuje je do odpowiedniej klasy. I to właśnie te klasy pisane są przez programistów. Dla przykładu w Spring MVC takim “głównym serwletem” jest DispatcherServlet. Zachęcam do zajrzenia do źródeł tego serwletu. Zobaczyć możesz tam jakie mechanizmy użyte są do przekazania żądania dalej. Jak przeszukasz DispatcherServlet i klasy po których dziedziczy dogrzebiesz się do dobrze znanych metod, takich jak service czy doGet. Pierwsza aplikacja webowa Nadszedł czas, żeby wykorzystać tę wiedzę w praktyce. Proszę spójrz na przykład poniżej: @WebServlet(\"/date\")public class DateServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException {        DateTime now = DateTime.now();        PrintWriter responseOutput = response.getWriter();        responseOutput.append(\"&lt;html&gt;&lt;body&gt;\" + now.toString() + \"&lt;/body&gt;&lt;/html&gt;\");    }}DateServlet to serwlet, który odpowiada na żądania typu GET wysłane na adres /date. Oczywiście w produkcyjnych aplikacjach w inny sposób konstruuje się odpowiedzi, jednak przykład ten pokazuje ogólną zasadę działania. response.getWriter() zwraca instancję klasy PrintWriter. Należy traktować ją jako zawartość pliku, która zostanie wysłana w odpowiedzi na żądanie. Jeśli użyjemy tej metody odpowiedź, którą wygenerujemy musi być tekstowa (nie binarna). Ostatnia linijka metody doGet to właśnie generowanie treści odpowiedzi, gdzie odpowiadamy aktualną datą umieszczoną wewnątrz podstawowych znaczników html. Taką klasę serwletu umieszczamy w projekcie. W moim przypadku jego struktura wygląda następująco: .├── 01_serwlety│   ├── build│   ├── build.gradle│   └── src│   └── main│   ├── java│   │   └── pl│   │   └── samouczekprogramisty│   │   └── kursaplikacjewebowe│   │   └── serwlety│   │   └── DateServlet.java│   └── webapp├── build.gradle├── gradle│   └── wrapper│   ├── gradle-wrapper.jar│   └── gradle-wrapper.properties├── gradlew├── gradlew.bat└── settings.gradleNa tym etapie proszę użyj przykładowych plików umieszczonych w repozytorium kodu. W osobnym artykule wytłumaczę zasadę działania Gradle w przypadku aplikacji webowych. Bazowy plik build.gradle i plik 01_serwlety/build.gradle pozwalają na uruchomienie tak utworzonej aplikacji webowej: KursAplikacjeWebowe$ ./gradlew appRun:01_serwlety:prepareInplaceWebAppFolder NO-SOURCE:01_serwlety:createInplaceWebAppFolder UP-TO-DATE:01_serwlety:compileJava UP-TO-DATE:01_serwlety:processResources NO-SOURCE:01_serwlety:classes UP-TO-DATE:01_serwlety:prepareInplaceWebAppClasses UP-TO-DATE:01_serwlety:prepareInplaceWebApp UP-TO-DATE:01_serwlety:appRun10:19:57 INFO Jetty 9.2.15.v20160210 started and listening on port 808010:19:57 INFO 01_serwlety runs at:10:19:57 INFO http://localhost:8080/01_serwletyPress any key to stop the server.&gt; Building 87% &gt; :01_serwlety:appRunNastępnie uruchomienie przeglądarki i wpisanie adresu http://localhost:8080/01_serwlety/date powinno pokazać działającą aplikację, która wyświetla datę:         Odpowiedź z DataServlet  Ćwiczenie do wykonania Na podstawie przykładowej aplikacji napisz serwlet, który wyświetli liczbę sekund, od dnia Twojego urodzenia. Po wejściu na stronę, którą obsługuje dany serwlet powinna pokazać się liczba sekund, od Twoich urodzin. Dodatkowe materiały do nauki Poniżej przygotowałem dla Ciebie kilka dodatkowych linków, które pomogą Ci rozszerzyć wiedzę z tego artykułu:   Protokół HTTP  Specyfikacja serwletów wersja 3.1  Specyfikacje Java EE 7  Przykłady użyte w tym artykulePodsumowanie Gratulacje! Udało Ci się przeczytać cały artykuł, a nie należał on do najkrótszych ;). Po jego przeczytaniu wiesz czym jest serwlet. Poznałeś strukturę pliku war, znasz podstawowy zakres odpowiedzialności kontenera serwletów. Poznałeś też część magii, która kryje się pod spodem biblioteki Spring MVC. No i oczywiście utworzyłeś swoją pierwszą dynamiczną aplikację webowową! Mimo objętości artykułu nie wyczerpałem tematu aplikacji webowych, jest to jeden z serii artykułów opisujących podstawy aplikacji webowych w Javie. Jeśli nie chcesz pominąć kolejnych artykułów polub Samouczka na facebooku i zapisz się do newslettera. Do następnego razu!             Prawda jest taka, że używając bibliotek pomagających tworzyć aplikacje webowe sam nie będziesz pisał serwletów. Będą to zwykłe klasy, które będą przez bibliotekę wywoływane. Biblioteka dostarczy “główny” serwlet, który będzie przekazywał żądania dalej. &#8617;               Chodzi o zachowanie domyślne, kontener może utworzyć kilka instancji jeśli zaimplementujesz interfejs SingleThreadedModel. Takie podejście nie jest jednak polecane. &#8617;       ","categories": ["DSP2017","Kurs aplikacji webowych"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/serwlety-w-aplikacjach-webowych/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/03/25_serwlety_w_aplikacjach_webowych_artykul.jpeg"},{
        "title": "Pogodynka - szkielet aplikacji webowej",
        "excerpt":"W tym tygodniu przygotowałem dla Was dość obszerny wpis dotyczący serwletów w aplikacjach Java. Jego przygotowanie zajęło mi sporo czasu więc automatycznie zostało go mniej na samą Pogodynkę. Jednak i tutaj udało się pchnąć sprawy do przodu. W tym momencie datavault jest już “działającą” aplikacją webową opartą o Spring MVC. Uparłem się i całą konfigurację zrobiłem bez użycia Spring Boot i plików XML. Chcę to zrobić w ten sposób, aby pokazać Wam przykład takich właśnie aplikacji. W tym momencie obsługiwane są żądania typu POST i GET, które będą odpowiednio dodawały nowy wpis dotyczący temperatury i pobierały listę temperatur. Warstwa widoku W pierwotnej wersji zakładałem, że napiszę osobną aplikację w Java Script, która będzie odpowiadała za generowanie widoku. Coraz bardziej się nad tym zastanawiam. Widzę pewną wartość w zrobieniu tego w “stary” sposób. W “stary”, czyli z wykorzystaniem plików JSP. Dzięki temu będę miał dla Was przykład aplikacji używającej właśnie takiego podejścia do kolejnych artykułów, a artykuł o JSP na pewno powstanie. Spring MVC Aktualnie aplikacja używa Spring MVC. Konfiguracja w większości używa ustawień domyślnych, które włączone są przy pomocy kilku “springowych” adnotacji:   @Configuration  @EnableWebMvc  @ComponentScanPrzykład ich użycia możesz zobaczyć w klasie WebAppConfiguration. Klasa ta jest użyta jako bazowy “applicationContext”, włącza obsługę Spring MVC oraz wskazuje pakiety, w których Spring szuka klas, którymi zarządza (potocznie mówi się tu o bean’ach). Kolejną istotną klasą jest DatavaultInitializer, która konfiguruje instancję DispatcherServlet obsługującego aplikację (o tym jak to ustrojstwo magicznie działa możesz przeczytać we wcześniej wspomnianym artykule o serwletach), Przygotowałem też naiwną implementację klasy odpowiedzialnej za zarządzanie temperaturami TemperatureServiceImpl, w obecnym kształcie nie robi ona jeszcze nic użytecznego. Podsumowanie Kodu w tym tygodniu nie pojawiło się za wiele, jednak “szkielet” aplikacji webowej już jest i czeka na lepsze czasy ;). Jak zwykle całość kodu dostępna jest w repozytorium. Do następnego razu! ","categories": ["DSP2017","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pogodynka-szkielet-aplikacji-webowej/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/03/26_pogodynka_04_artykul.jpg"},{
        "title": "Nagłówki, sesje i ciasteczka",
        "excerpt":"Wprowadzenie Zacznijmy od żądań i odpowiedzi. Wiesz już, o hierarchii dziedziczenia serwletów Servlet, GenericServlet i HttpServlet. W przypadku klasy opakowującej żądanie i odpowiedź sytuacja wygląda podobnie. Istnieją bazowe interfejsy ServeltRequest i ServletResponse. W przypadku serwletów opartych o protokół HTTP interfejsy te są rozszerzane przez HttpServletRequest i HttpServletResponse. Rozszerzone interfejsy zawierają metody specyficzne dla protokołu HTTP. Zauważ, że piszę tu wyłącznie o interfejsach. Są to interfejsy określone przez specyfikację serwletów. Kontener serwletów, który implementuję tę specyfikację dostarcza także konkretnych implementacji. To właśnie kontener odpowiedzialny jest za tworzenie instancji klas, które implementują te interfejsy. Z poprzedniego artykułu opisującego serwlety wiesz już z jakich elementów składa się adres URL. Klasy opakowujące żądanie pozwalają na pracę z poszczególnymi elementami adresu URL. Jedą z części tego adresu są parametry. W artykule i przykładach używam bardzo prostego mechanizmu do generowania widoków. Nie jest to sposób “poprawny”. To są jedynie przykłady, które mają wprowadzić Cię w “świat aplikacji webowych”. W kolejnych artykułach poznasz lepszą metodę na generowanie stron HTML. HTTPServletRequest Parametry URL Jedną z części adresu URL są parametry. Są one dostępne po znaku ?. Parametry zapisane są w formie klucz=wartość, z tym że jeden parametr może wystąpić wiele razy. Poszczególne pary klucz=wartość rozdzielone są znakami &amp;. W interfejsie HttpServletRequest istnieje kilka metod, które pozwalają na pracę z parametrami. Proszę spójrz na przykład poniżej. @WebServlet(\"/parameters\")public class ParametersServlet extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        PrintWriter responseWriter = resp.getWriter();        responseWriter.write(\"&lt;html&gt;&lt;body&gt;\");        for (Map.Entry&lt;String, String[]&gt; entry : req.getParameterMap().entrySet()) {            responseWriter.write(\"&lt;p&gt;\" + entry.getKey() + \": \" + Arrays.toString(entry.getValue()) +\"&lt;/p&gt;\");        }        responseWriter.write(\"&lt;/body&gt;&lt;/html&gt;\");    }}W przykładzie tym widzisz serwlet, który w odpowiedzi wypisuje wszystkie parametry z adresu URL żądania. Poza metodą getParameterMap możesz użyć także kilku innych:   getParameter()  getParameterNames()  getParameterValues()Po uruchomieniu aplikacji, która posiada taki serwlet i wpisaniu w przeglądarce adresu http://localhost:8080/02_serwlety/parameters?parameter1=value1&amp;parameter2=value2&amp;parameter1=value11Powinna wyświetlić się strona zawierająca dwie linijki: parameter2: [value2]parameter1: [value1, value11]Żądania POST a parametry Powyżej opisałem sytuację, w której parametry przesyłane są jako fragment adresu URL żądania. Dzieje się tak w przypadku żądań typu GET. W przypadku wysyłania formularzy (zazwyczaj zapytania typu POST), parametry te przesyłane są w ciele żądania. Nie są one częścią adresu. Mimo tego, że parametry przesyłane są w inny sposób możesz z nimi pracować używając tego samego zestawu metod.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Adres URL Obiekt opakowujący żądanie pozwala także na pracę z adresem URL, którego żądanie dotyczy. Zestaw metod pozwala na pobranie informacji na temat adresu żądania:   getContextPath() zwraca fragment ścieżki, która jest “podstawą” wszystkich ścieżek obsługiwanych przez daną aplikację. W przypadku prostego instalowania aplikacji przy pomocy gradle będzie to nazwa pliku war,  getServletPath() zwraca fragment ścieżki, która została użyta w konfiguracji serwletu,  getRequestURL() metoda zwraca adres URL żądania bez parametrów zawartych w adresie,  getRequstURI() zwraca adres URI (ang. Uniform Resource Identifier). Od aresu URL różni się on tym, że nie zawiera protokołu, serwera i portu.Zakładając, że nasz sewlet obsługuje ścieżkę /path wówczas wywołanie powyższych metod po żądaniu http://localhost:8080/02_serwlety/path?xxx=yyyPowinno zwrócić następujące wartości:   getContextPath() /02_serwlety  getServletPath() /path  getRequestURI() /02_serwlety/path  getRequestURL() http://localhost:8080/02_serwlety/pathPrzykładowy serwlet, który używa tych metod możesz znaleźć na samouczkowym githubie. HttpServletResponse Obiekt, implementujący ten interfejs także tworzony jest przez kontener serwletów. Służy on do przygotowania odpowiedzi na żądanie wysłane do serwera. W przypadku obiektu odpowiedzi musisz wiedzieć o następujących metodach   getOutputStream() zwraca instancję ServletOutputStream, która służy do tworzenia odpowiedzi zawierającej dane binarne,  getWriter() zwraca instancję PrintWriter, która służy do tworzenia odpowiedzi zawierającej tekst.Ważne jest aby pamiętać, że w trakcie obsługi żądania możemy posługiwać się wyłącznie jedną z tych metod. Nagłówki Specyfikacja protokołu HTTP definiuje tak zwane nagłówki. Nagłówki dołączane są zarówno do żądań jak i odpowiedzi. Nagłówki to nic innego jak pary klucz-wartość, które zapisane są w formacie nazwa nagłówka: treść nagłówka. Na przykład Content-Type: text/html; charset=utf-8Content-Length: 13358Przeglądarki internetowe posiadają wbudowane “narzędzia developerskie”, które pozwalają na podejrzenie nagłówków. Jeśli chcesz dowiedzieć się więcej o tych narzędziach zachęcam do odwiedzenia strony dedykowanej dla Twojej przeglądarki   Firefox  Chrome  Opera  Internet Explorer        Narzędzia developerskie - nagłówki  Obiekty HttpServletResponse i HttpServletRequest pozwalają na pracę z nagłówkami przy pomocy metod:   setHeader()  addHeader()Pierwsza z nich ustawia wartość nagłówka, druga dodaje nową wartość nagłówka (i tworzy go jeśli wcześniej nie był ustawiony). W rzeczywistości nagłówek mający wiele wartości to dalej jedna para klucz-wartość. W tym przypadku wartość zawiera kilka elementów oddzielonych przecinkami. Nagłówki możesz pobierać z obiektu żądania używając metod:   getHeaderNames()  getHeader()  getHeaders()Poniższy serwlet używa tych metod aby ustawić kilka nagłówków. W odpowiedzi na żądanie tworzy stronę, która zawiera listę ustawionych nagłówków. Jak zwykle mocno zachęcam do eksperymentowania, sam zobacz jak taki serwlet działa. @Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    PrintWriter responseWriter = resp.getWriter();     responseWriter.write(\"&lt;html&gt;&lt;body&gt;\");    Enumeration&lt;String&gt; headerNames = req.getHeaderNames();    while (headerNames.hasMoreElements()) {        String headerName = headerNames.nextElement();        Enumeration&lt;String&gt; headerValues = req.getHeaders(headerName);        while (headerValues.hasMoreElements()) {            String headerValue = headerValues.nextElement();            responseWriter.write(\"&lt;p&gt;\" + headerName + \": \" + headerValue + \"&lt;/p&gt;\");        }    }     resp.addHeader(\"my-custom-header\", \"value1\");    resp.addHeader(\"my-custom-header\", \"value2\");    resp.setIntHeader(\"my-custom-int-header\", 123);     responseWriter.write(\"&lt;/body&gt;&lt;/html&gt;\");}Zastosowanie nagłówków Nagłówki jako część protokołu HTTP pełnią bardzo istotną rolę. Dla przykładu poniżej pokazuję zestaw nagłówków wysyłanych wraz z każdą odpowiedzią dla adresu www.samouczekprogramisty.pl: $ curl -I www.samouczekprogramisty.plHTTP/1.1 200 OKSet-Cookie: PHPSESSID=xxxxxxxxxxxxxxxxxxxxxx; path=/Expires: Thu, 19 Nov 1981 08:52:00 GMTCache-Control: no-store, no-cache, must-revalidate, post-check=0, pre-check=0Pragma: no-cacheContent-Type: text/html; charset=UTF-8Link: &lt;http://www.samouczekprogramisty.pl/wp-json/&gt;; rel=\"https://api.w.org/\"Date: Sun, 02 Apr 2017 10:46:08 GMTAccept-Ranges: bytesServer: LiteSpeedConnection: Keep-AliveUżyłem do tego programu curl, który pozwala na wysyłanie żądań HTTP z linii poleceń. Fragment powyżej powoduje wysłanie żądania typu HEAD, które zwraca wyłącznie nagłówki (bez właściwej zawartości strony). Przykładowe zastosowanie nagłówków:   Pozwalają na ustawianie ciasteczek (przeczytasz o nich w kolejnym akapicie) (Set-Cookie),  Pozwalają na określenie zawartości strony. To dzięki nim przeglądarka wie jak interpretować odpowiedź, którą dostanie. To nagłówek określa czy w odpowiedzi znajduje się plik HTML (Content-Type: text/html; charset=UTF-8). Czy może są dane binarne reprezentujące obrazek do wyświetlenia (Content-Type: image/jpeg),  Mogą przyspieszyć ładowanie strony w przeglądarce. Jeśli odwiedziłeś już jakąś stronę to przeglądarka mogła zapisać część danych, które wyświetliła (w tym część nagłówków). Następnym razem nie wyśle żądania typu GET (aby pobrać całą zawartość) a jedynie HEAD (aby pobrać nagłówki). Po sprawdzeniu nagłówków stwierdzi, że dane się nie zmieniły i wyświetli poprzednio zapamiętaną zawartość (Cache-Control: public, max-age=63115200, Last-Modified: Thu, 16 Mar 2017 17:12:14 GMT).  Takie sprawdzenie może odbyć się też w inny sposób. Przeglądarka może wysłać zapytanie typu GET dołączając odpowiednie nagłówki. Później żądanie z nagłówkami interpretowane jest przez serwer. Jeśli serwer stwierdzi, że przeglądarka ma aktualną treść (potwierdza to nagłówek), wówczas wysyła odpowiedź informującą przeglądarkę, że jej kopia treści jest najnowsza. W takim przypadku zamiast przesyłać przez sieć obrazek o wielkości 400kB wysyła odpowiedź, która ma dużo mniej danych - kilka kilobajtów (ETag: \"9db5f14aeaa00872\",  Nagłówki to metadane (dane o danych). Zdarza się, że są wykorzystywane do przesyłania dodatkowych informacji na temat danego żądania/odpowiedzi.Mimo tego, że nagłówki są powszechnie stosowane w codziennej pracy z aplikacjami webowymi (szczególnie na początku) nie są one “kluczowe”. Większość z nich ustawiają za nas biblioteki zewnętrzne. Niemniej jednak dobrze jest wiedzieć o tym, że istnieją i do czego służą. Ciasteczka Ciasteczka to mechanizm opisany w specyfikacji protokołu HTTP. W uproszczeniu można powiedzieć, że ciasteczka to informacje, które dołączane są do żądania i mogą być ustawiane w odpowiedzi. Ciasteczka połączone są z adresem, pod który wysyłane jest żądanie. Przeglądarka internetowa wysyłając żądanie pod adres www.samouczekprogramisty.pl wyszukuje jakie ciasteczka ma zapisane dla tej domeny i dołącza je automatycznie do każdego żądania.         Ciasteczka - diagram  Po stronie serwera, w odpowiedzi można ustawiać ciasteczka. Można to robić przy pomocy nagłówka Set-Cookie. Z racji tego, że jest to bardzo popularny mechanizm istnieje osobny zestaw metod, które pomagają pracować z ciasteczkami:   addCookie()  getCookies()Samo ciasteczko reprezentowane jest przez klasę Cookie. Podstawowymi atrybutami ciasteczka jest jego nazwa i wartość. Dodatkowo możesz ustawić też inne atrybuty, takie jak czas życia ciasteczka. Jeśli jest on ustawiony, wówczas przeglądarka dołącza ciasteczka do żądań tak długo jak są one “ważne”. Przykładowy serwlet poniżej w odpowiedzi generuje stronę, która wyświetla wszystkie dostępne ciasteczka. Ustawia też jedno ciasteczko o nazwie custom-cookie, jego czas życia ustawiony jest na 10 sekund. @Overrideprotected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {    PrintWriter responseWriter = resp.getWriter();     responseWriter.write(\"&lt;html&gt;&lt;body&gt;\");    for (Cookie cookie : req.getCookies()) {        responseWriter.write(\"&lt;p&gt;\" + cookie.getName() + \" \" + cookie.getValue() + \"&lt;/p&gt;\");    }     Cookie cookie = new Cookie(\"custom-cookie\", \"bum bum cyk cyk\");    cookie.setMaxAge(10);    resp.addCookie(cookie);     responseWriter.write(\"&lt;/body&gt;&lt;/html&gt;\");}Przy drugim otworzeniu strony generowanej przez ten serwlet1 zobaczysz ciasteczko custom-cookie Wcześniej opisane narzędzia developerskie dostępne w przeglądarkach internetowych pozwalają na podejrzenie zawartości ciasteczek.         Narzędzia developerskie - ciasteczka  Zastosowanie ciasteczek Jak wiesz z poprzedniego artykułu protokół HTTP jest bezstanowy. Ciasteczka pomagają obejść tę właściwość. Bardzo często ciasteczka wykorzystywane są do zapisania informacji czy użytkownik jest zalogowany w aplikacji. Aplikacja sprawdza czy takie ciasteczko istnieje, jeśli tak udostępnia użytkownikowi jakieś dane. Jeśli ciasteczka brakuje wówczas przekierowuje go na stronę logowania. Po zalogowaniu aplikacja ustawia ciasteczko, które następnie dołączane jest do kolejnych żądań automatycznie. Użytkownik ma możliwość ustawienia przeglądarki internetowej w ten sposób aby nie zapamiętywała ciasteczek. Nie jest to popularne, ale warto wiedzieć, że jest taka możliwość. Podobnie jak w przypadku nagłówków - w codziennej pracy z aplikacjami webowymi często nie używa się ciasteczek bezpośrednio. Dzieje się to niejako “pod spodem” - zewnętrzne biblioteki wykorzystują ten mechanizm. Sesja Można powiedzieć, że sesja to połączenie kilku żądań/odpowiedzi w jedną całość. Dzięki temu aplikacja webowa może powiązać te żądania z jednym użytkownikiem. Sesje najczęściej zaimplementowane są przy pomocy ciasteczek. Specyfikacja serwletów określa nawet domyślną nazwę takiego ciasteczka - jest to JSESSIONID. Innym mechanizmem, na którym może być oparta sesja jest przepisywanie adresu URL (ang. URL rewriting). Polega ono na dołączaniu identyfikatora sesji do adresu. W takim przypadku adres może wyglądać następująco http://www.samouczekprogramisty.pl/kurs-programowania-java;jsessionid=1234. To kontener serwletów decyduje o metodzie, która powinna być użyta do “podtrzymywania” sesji. Podobnie jak w przypadku ciasteczek sesja ma swój dedykowany obiekt. Po stronie serwera sesja reprezentowana jest przez HttpSession. Czas trwania sesji Sesja nie jest trzymana wiecznie. To jak długo powinna być utrzymywana przez kontener serwletów określone jest przez parametr metody setMaxInactiveInterval. Określa on w sekundach jak długo pomiędzy żądaniami klienta sesjsa powinna być utrzymywana. Atrybuty sesji Sesję można porównać do mapy, w której przechowujemy pary klucz-wartość. Są to atrybuty sesji. Dzięki nim mamy możliwość przekazywania informacji wewnątrz aplikacji webowej pomiędzy żądaniami klienta. Poniższy zestaw metod pozwala na pracę z atrybutami sesji:   getAttributeNames()  getAttribute()  removeAttribute()  setAttribute()Wartościami atrybutów są obiekty, jednak musisz pamiętać o tym aby nie były one “duże”. Atrybuty sesji powinny być także serializowalne. Jeśli nie miałeś do czynienia z serializacją zapraszam do artykułu poświęconemu serializacji w języku Java. Mechanizm przechowywania sesji Sesje mogą być przechowywane w pamięci kontenera serwletów. Nie jest to jedyna metoda ich przechowywania. Naiwny mechanizm może być oparty o ciasteczka, w takim przypadku wszystkie atrybuty sesji byłyby ciasteczkami. Kontener serwletów do zapisywania sesji może użyć standardowych plików. Sesja może być także zapisana w różnych bazach danych. To w jaki sposób będzie to realizowane zależy od konfiguracji kontenera serwletów. W podstawowych przypadkach nie musisz się przejmować tą konfiguracją. @WebServlet(\"/session\")public class SessionServlet extends HttpServlet {     public static final String VISIT_COUNTER_ATTR = \"visitCounter\";     @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        PrintWriter responseWriter = resp.getWriter();         responseWriter.write(\"&lt;html&gt;&lt;body&gt;\");         HttpSession session = req.getSession();        Enumeration&lt;String&gt; attributeNames = session.getAttributeNames();        while (attributeNames.hasMoreElements()) {            String attributeName = attributeNames.nextElement();            responseWriter.write(\"&lt;p&gt;\" + attributeName + \": \" + session.getAttribute(attributeName) + \"&lt;/p&gt;\");        }        responseWriter.write(\"&lt;/body&gt;&lt;/html&gt;\");        increaseVisitCounter(session);    }     private void increaseVisitCounter(HttpSession session) {        Object counter = session.getAttribute(VISIT_COUNTER_ATTR);        Integer numberOfVisits;        if (counter != null) {            numberOfVisits = (Integer) counter + 1;        }        else {            numberOfVisits = 1;        }        session.setAttribute(VISIT_COUNTER_ATTR, numberOfVisits);    }}Ćwiczenie do wykonania Napisz serwlet, który pobierze wartość wszystkich parametrów przekazanych w adresie. Pobierze wszystkie parametry, których wartości są liczbami całkowitymi, następnie sumę tych parametrów wyświetli na ekranie. Serwlet ten powinien dodatkowo w sesji zapamiętać sumaryczną wartość wszystkich takich operacji. Ta całkowita suma także powinna być wyświetlona Na przykład, pierwsze żądanie pod adres /serwlet?parametr=123&amp;inny-parametr=abc&amp;test=-3 powinno wyświetlić stronę: requestSum: 120totalSum: 120Kolejne żądanie pod adres /serwlet?parametr=336 powinno wyświetlić stornę requestSum: 336totalSum: 456W przypadku jakichkolwiek problemów z wykonaniem ćwiczenia możesz rzucić okiem na przykładowe rozwiązanie. Dodatkowe materiały do nauki   Artykuł na wikipedi na temat ciasteczek,  Lista standardowych nagłówków HTTP,  Specyfikacja serwletów,  Specyfikacja protokołu HTTP/1.1,  Kod źródłowy przykładów użytych w artykule.Podsumowanie Po lekturze tego artykułu znasz już zestaw podstawowych klocków, z których buduje się aplikacje webowe. Wiesz już czym są parametry adresu URL i jak z nimi pracować. Znasz mechanizm nagłówków. Potrafisz powiedzieć czym jest ciasteczko i sesja. Po wykonaniu ćwiczenia znasz te zagadnienia także od praktycznej strony. Innymi słowy kawał wiedzy ;). Na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największego grona Samouków takich jak Ty. Podziel się proszę linkiem do artykułu ze swoimi znajomymi. Mam nadzieję, że im także spodoba się artykuł. Jeśli nie chcesz ominąć kolejnych artykułów dopisz się do samouczkowego newslettera i polub stronę na facebooku. Do następnego razu!             Jeśli zrobisz to szybciej niż 10 sekund po pierwszym wywołaniu. &#8617;       ","categories": ["DSP2017","Kurs aplikacji webowych"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/naglowki-sesje-i-ciasteczka/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/04/01_naglowki_ciasteczka_sesje_artykul.jpeg"},{
        "title": "Filtry w aplikacjach webowych",
        "excerpt":"  Artykuł ten zakłada, że wiesz czym są serwlety i adnotacje. Pownieneś potrafić już napisać serwlet i używać adnotacji. Powinieneś wiedzieć czym są parametry URL i jak z nimi pracować. Jeśli chcesz uzupełnić wiedzę z tego zakresu zapraszam do artykułów:   serwlety w aplikacjach internetowych,  parametry URL, ciasteczka, nagłówki i sesje,  adnotacje w języku Java.Czym jest filtr Filtry to nic innego jak klasy, które są wywoływane przed uruchomieniem właściwego serwletu. Po wykonaniu serwletu odpowiedź wraca przez ten sam filtr do klienta, który wysłał żądanie. Przed serwletem może być wywołanych wiele filtrów. Poniższy rysunek pokazuje zapytanie od klienta, które przechodzi przez dwa filtry. Następnie uruchamiany jest serwlet. Przed przekazaniem odpowiedzi wracamy do tych samych filtrów w odwrotnej kolejności.         Łańcuch wywołania filtrów.  Filtry oznacza się adnotacją @WebFilter1. Podobnie jak wszystkie inne elementy specyfikacji serwletów także filtry mają swój cykl życia. Cykl życia filtrów Każdy z filtrów ma swój cykl życia. Podobnie jak w serwletach mamy tu metody init i destroy. Właściwa praca serwletu odbywa się wewnątrz metody doFilter.   init - metoda odpowiedzialna za inicjalizację serwletu. Musi się powieść aby kontener serwletów używał tego filtra,  doFilter - tu odbywa się właściwa praca filtra. Metoda ta wywołana jest przed przekazaniem żądania do klasy serwletu,  destroy - metoda, w które filtr ma szansę “posprzątać” po sobie :)  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Mapowanie filtrów Adnotacja @WebFilter posiada kilka elementów. Opiszę te, które pozwalają na przypisywanie filtrów do poszczególnych serwletów/zasobów:   urlPatterns - lista szablonów adresów URL do których filtr powinien być zaaplikowany,  servletNames - lista nazw serwletów. Każdy serwlet może mieć nazwę, którą możesz ustawić za pomocą elementu name adnotacji @WebServlet,  value - domyślny element, stosowany zamiennie z urlPatterns.Szablony adresów URL pozwalają na mapowanie filtrów do adresów URL. Wewnątrz tych szablonów możesz używać znaku *, który pozwala na dopasowanie większej liczby adresów URL. Spójrz na kilka przykładów:   /some/url/address - szablon pasuje tylko do jednego adresu URL - /some/url/pattern,  /some/other/resource.* - szablon pasuje do wielu adresów URL różniących się rozszerzeniami. Na przykład /some/other/resource.html czy /some/other/resource.jpeg,  /some/*/address - szablon pasuje do wielu adresów URL. Na przykład /some/url/address czy /some/picture/addresss,  * - szablon pasuje do wszystkich adresów URL. Jeśli stworzysz filtr, który będzie miał taki szablon będzie on aplikowany do wszystkich zapytań.Kilka przykładów z użyciem adnotacji:   @WebFilter(\"/chainingServlet\") - filtr będzie zaaplikowany wyłącznie do żądań dotyczących adresu /chainingServlet,  @WebFilter(urlPatterns = \"/chainingServlet\", servletNames = \"someRandomServletName\") - filtr będzie zaaplikowany do żądań dotyczących adresu /chainingServlet i żądań obsługiwanych przez serwlet o nazwie someRandomServletName  @WebFilter(urlPatterns = {\"/some/*/thing\", \"/other/*/thing\"}) - filtr będzie zaaplikowany do żądań dotyczących wielu adresów pasujących do jednego z wzorców.Łańcuch filtrów Na diagramie pokazanym wyżej widziałeś dwa filtry. Filtrów uruchomionych przed właściwym serwletem może być wiele. Tworzą one tak zwany łańcuch filtrów (ang. filter chain). Łańcuch ten reprezentowany jest przez instancję klasy implementującej interfejs FilterChain. Instancja ta przekazana jest jako parametr do metody doFilter wewnątrz filtra. Interfejs ten zawiera wyłącznie jedną metodę doFilter, która wykonuje kolejny filtr w łańcuchu. Jeśli filtr był ostatnim spowoduje to wywołanie właściwego serwletu. Pociąga to za sobą ważną konsekwencję. Jeśli wewnątrz filtra nie wywołasz tej metody właściwe żądanie nigdy nie dotrze do serwletu. Przykłady użycia filtrów Zacznijmy od definicji prostego serwletu. Serwlet w odpowiedzi wyświetla wszystkie atrybuty żądania. Jeśli żaden atrybut nie jest ustawiony, w odpowiedzi wysłana zostanie pusta strona HTML. @WebServlet(urlPatterns = \"/simpleServlet\", name = \"simpleServletName\")public class SimpleServlet extends HttpServlet {     @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws IOException {        PrintWriter responseWriter = resp.getWriter();         responseWriter.write(\"&lt;html&gt;&lt;body&gt;\");        Enumeration&lt;String&gt; attributeNames = req.getAttributeNames();        while (attributeNames.hasMoreElements()) {            String attributeName = attributeNames.nextElement();            Object attributeValue = req.getAttribute(attributeName);            responseWriter.write(\"&lt;p&gt;\" + attributeName + \": \" + attributeValue + \"&lt;/p&gt;\");        }        responseWriter.write(\"&lt;/html&gt;&lt;/body&gt;\");    }}Następnie filtr, który dodaje jeden atrybut wewnątrz metody doFilter: @WebFilter(servletNames = \"simpleServletName\")public class SimpleFilter implements Filter {     @Override    public void init(FilterConfig filterConfig) throws ServletException {    }     @Override    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {        System.out.println(\"before\");        request.setAttribute(\"simpleServletAttribute\", \"simpleServlet\");        chain.doFilter(request, response);        System.out.println(\"after\");    }     @Override    public void destroy() {    }}Po uruchomieniu takiej aplikacji i wysłaniu żądania na adres /simpleServlet powinieneś zobaczyć jeden atrybut dodany prez filtr. Kolejność wykonywania filtrów Wiesz już, że do jednego zasobu/serwletu można aplikować wiele filtrów. Bardzo często kolejność ich wykonania jest bardzo istotna. Na przykład nie ma potrzeby kompresowania odpowiedzi jeśli użytkownik nie ma prawa do wykonania danego żądania. Równie ważne jest logowanie wszystkich żądań, niezależnie od tego czy użytkownik ma do nich prawo czy nie. Mając zatem trzy filtry:   loggingFilter - loguje podstawowe informacje o żądaniu,  authenticationFilter - weryfikuje tożsamość użytkownika,  compressionFilter - kompresuje odpowiedź.Muszą one być uruchomione w dokładnej tej kolejności: loggingFilter, authenticationFilter, compressionFilter, aby aplikacja działa poprawnie. Tutaj mam dla Ciebie smutną wiadomość. Używając adnotacji, bez pliku web.xml (nazywanego deskryptorem wdrożenia) nie mamy nad tym kontroli. Specyfikacja serwletów nie definiuje kolejności filtrów definiowanych wyłącznie przy pomocy adnotacji @WebFilter. Co za tym idzie kolejność ta może być różna w różnych implementacjach i nie powinieneś na niej polegać. Sprawa wygląda zupełnie inaczej w przypadku użycia pliku web.xml. W tym przypadku kolejność jest dobrze zedfiniowana:   wszystkie filtry pasujące do danego żądania używające urlPattern według kolejności w pliku web.xml,  wszystkie filtry pasujące do danego żądania używające servletName według kolejności w pliku web.xml.Na tym etapie ważne jest żebyś wiedział o tym ograniczaniu. Sam plik web.xml opiszę w osobnym artykule, wtedy też dowiesz się jak dokładnie określać kolejność wykonania filtrów. Zastosowanie filtrów Teraz jak już wiesz jak wyglądają filtry musisz dowiedzieć się o ich zastosowaniu. Filtry pozwalają na uniknięcie duplikacji kodu. Najczęściej to właśnie dzięki filtrom realizowane są następujące funkcjonalności:   uwierzytelnianie - sprawdzenie czy użytkownik ma prawo do uzyskania odpowiedzi na dane żądanie. Innymi słowy, sprawdzenie czy jest zalogowany,  logowanie, audyt - tworzenie logów aplikacji webowej, część informacji (na przykład URL żądania) można logować już na etapie filtrów,  kompresja - filtry kompresują odpowiedź. Dzięki zmniejszonej objętości przeglądarka szybciej dostaje odpowiedź,  cache - czasami przez uruchomieniem serwletu można stwierdzić, że odpowiedź się nie zmieniła.Poplularny Spring MVC także używa filtrów. Kilka z nich znajduje się w osobnym pakiecie. Na przykład:   CharacterEncodingFilter ustawia kodowanie znaków użyte w żadaniu, odpowiedzi2,  CommonsRequestLoggingFilter logowanie, filtr loguje informacje o przychodzących żądaniach.Ćwiczenia Na koniec czekają na Ciebie dwa ćwiczenia, w których przećwiczysz wiedzę dotyczącą filtrów w praktyce.   Napisz serwlet, który wyświetli wszystkie atrybuty żądania. Serwlet powinien być poprzedzony dwoma filtrami, każdy z nich powinien ustawić co najmniej jeden atrybut żądania,  Napisz filtr, który zablokuje wykonanie serwletu jeśli w adresie URL występuje jakikolwiek parametr o wartości “blokuj”.Jak zwykle, pytaj jeśli ukniesz na którymś etapie. W ostateczności możesz rzucić okiem na przykładowe rozwiązanie. Zachęcam jednak do samodzielnego rozwiązania ćwiczeń, wtedy nauczysz się najwięcej. Podsumowanie Filtry w aplikacjach webowych pełnią bardzo ważną rolę. Dzisiaj udało Ci się tę rolę poznać. Wiesz czym jest filtr, wiesz także jak używać łańcuch filtrów. Poznałeś przykłady filtrów w Spring MVC. Przykładowe ćwiczenia pozwoliły Ci utrwalić materiał. Innymi słowy poznałeś kolejny klocek niezbędny do budowy aplikacji webowych. Gratulacje! Pochwal się o tym znajomym przesyłając im link do tego artykułu ;). Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę dopisz się do samouczkowego newslettera i polub stronę na facebooku. Do następnego razu!             Do tej pory nie wspomniałem Ci jeszcze o pliku web.xml, w którym także można filtry konfigurować. Aby niepotrzebnie nie komplikować plik ten opiszę w osobnym artykule. &#8617;               Upraszczając, kodowanie znaków to sposób w jaki reprezentujemy tekst. To dzięki niemu wiadomo jak interpretować polskie znaki. Jeśli używa się błędnego kodowania mogą pojawić się “krzaki”. &#8617;       ","categories": ["DSP2017","Kurs aplikacji webowych"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/filtry-w-aplikacjach-webowych/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/04/15_filtry_artykul.jpeg"},{
        "title": "Pogodynka - JSON i walidacja",
        "excerpt":"Zabawa z JSONem Nie mogę powiedzieć, że zrobiłem to “w tym tygodniu”. Nad pogodynką pracowałem wyłącznie dzisiaj :). Pierwszym problemem, który musiałem rozwiązać była serializacja i deserializacja obiektów klasy DateTime z biblioteki Joda. Okazuje się, że biblioteka Gson, którą wybrałem domyślnie robi to w “dziwaczny sposób”. Jako proste i przejrzyste rozwiązanie zaimplementowałem swój własny konwerter DateTime -&gt; String -&gt; DateTime. Data przekazywana jest jako łańcuch znaków zapisany w formacie ISO8601. Na tym etapie funkcjonalność testowałem wyłącznie z linii poleceń używając programu curl. Przykładowe zapytanie, które wysyła pomiar temperatury do komponentu Data Vault może wyglądać następująco: $ curl -H 'Content-Type: application/json' http://localhost:8080/datavault/temperatures -d '{\"temperature\": 123, \"whenMeasured\": \"2017-04-16T17:06:36.652+02:00\"}' -v* Trying 127.0.0.1...* Connected to localhost (127.0.0.1) port 8080 (#0)&gt; POST /datavault/temperatures HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.47.0&gt; Accept: */*&gt; Content-Type: application/json&gt; Content-Length: 69&gt;* upload completely sent off: 69 out of 69 bytes&lt; HTTP/1.1 201 Created&lt; Date: Sun, 16 Apr 2017 18:32:07 GMT&lt; Content-Type: application/json;charset=UTF-8&lt; Content-Length: 30&lt; Server: Jetty(9.2.15.v20160210)&lt;* Connection #0 to host localhost left intact{\"result\":\"Temperature added\"}W wyniku widzimy “piękną” odpowiedź w formacie JSON. Oczywiście sama temperatura jeszcze się nigdzie nie zapisuje - nie podłączyłem do tego bazy danych. Zajmę się tym w najbliższym tygodniu. Cała konwersja możliwa jest dzięki klasie CustomDateTimeAdapter. Następnie do automatycznego mechanizmu konwersji Springa dodaję to właśnie rozszerzenie. Dzięki takiej konfiguracji obiekty zawierające instancję DateTime poprawnie tworzone są na podstawie zapytań zawierających dane w formacie JSON. Walidacja danych wejściowych Nie można ufać użytkownikom. Nawet jeśli jedynym użytkownikiem w trym przypadku jest aplikacja, którą ja napisałem. Zakrawa to trochę o schizofrenię, ale takie są “dobre praktyki” pisania aplikacji. Dane wejściowe trzeba walidować, koniec i kropka. Specyfikacja Bean Validation 1.0 doczekała się swojego następcy Bean Validation 1.1 i Bean Validation 2.0. Aktualnie wersja 1.1 jest “obowiązującą”. Jako implementację walidatora wybrałem Hibernate. Proste dołączenie biblioteki w pliku datavault.gradle wraz z użyciem adnotacji @NotNull i @Valid pokazuje siłę Springa: curl -H 'Content-Type: application/json' http://localhost:8080/datavault/temperatures -d '{\"temperature\": 123}' -v* Trying 127.0.0.1...* Connected to localhost (127.0.0.1) port 8080 (#0)&gt; POST /datavault/temperatures HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.47.0&gt; Accept: */*&gt; Content-Type: application/json&gt; Content-Length: 20&gt;* upload completely sent off: 20 out of 20 bytes&lt; HTTP/1.1 400 Bad Request&lt; Date: Sun, 16 Apr 2017 18:46:30 GMT&lt; Content-Type: application/json;charset=UTF-8&lt; Content-Length: 52&lt; Server: Jetty(9.2.15.v20160210)&lt;* Connection #0 to host localhost left intact{\"errors\":[\"Field whenMeasured must not be empty!\"]}Kontroler - serce aplikacji Ta aplikacja to w praktyce jeden kontroller. Dodatkowo aplikacja zawiera drobną konfigurację rozszerzającą domyślne ustawienia. @Controller@RequestMapping(\"/temperatures\")public class TemperatureController {    private static final Logger LOG = LoggerFactory.getLogger(TemperatureController.class);    private final TemperatureService temperatureService;    private final MessageSource messageSource;    @Autowired    public TemperatureController(TemperatureService temperatureService, MessageSource messageSource) {        this.messageSource = messageSource;        this.temperatureService = temperatureService;    }    @PostMapping(consumes = MediaType.APPLICATION_JSON_UTF8_VALUE, produces = MediaType.APPLICATION_JSON_UTF8_VALUE)    @ResponseBody    public ResponseEntity addTemperature(@Valid @RequestBody TemperatureMeasurement temperature, Errors errors) {        if (errors.hasErrors()) {            List&lt;String&gt; errorMessages = errors.getAllErrors().stream()                .map(e -&gt; messageSource.getMessage(e.getCode(), e.getArguments(), null))                .collect(Collectors.toList());            return new ResponseEntity&lt;&gt;(Collections.singletonMap(\"errors\", errorMessages), HttpStatus.BAD_REQUEST);        }        temperatureService.addTemperature(temperature);        return new ResponseEntity&lt;&gt;(Collections.singletonMap(\"result\", \"Temperature added\"), HttpStatus.CREATED);    }    @GetMapping(produces = MediaType.APPLICATION_JSON_UTF8_VALUE)    @ResponseBody    public Map&lt;String, List&lt;TemperatureMeasurement&gt;&gt; listTemperatures() {        LOG.debug(\"Listing all temperatures\");        List&lt;TemperatureMeasurement&gt; temperatures = temperatureService.getTemperatures();        Map&lt;String, List&lt;TemperatureMeasurement&gt;&gt; responseMap = new HashMap&lt;&gt;();        responseMap.put(\"temperatures\", temperatures);        return responseMap;    }}Podsumowanie Czasu już dużo nie zostało. Teraz zamierzam pracować nad pogodynką także w tygodniu, nie tylko w weekendy jak do tej pory. Trzymajcie za mnie kciuki ;) ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pogodynka-json-i-walidacja/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/04/16_pogodynka_05_artykul.jpg"},{
        "title": "Kontekst serwletu i obiekty nasłuchujące w aplikacjach webowych",
        "excerpt":"ServletContext Obiekt implementujący ServletContext tworzony jest przez kontener serwletów. Istnieje tylko jeden taki obiekt dla każdej aplikacji webowej1. Służy on głównie do współdzielenia informacji w ramach aplikacji internetowej. Czytając poprzednie artykuły z serii:   serwlety w aplikacjach webowych,  nagłówki, sesje i ciasteczka w aplikacjach webowych,  filtry w aplikacjach webowych,poznałeś inne konteksty/zakresy. Na przykład kontekst zapytania i kontekst sesji HTTP. W każdym z tych kontekstów mogłeś ustawić zestaw atrybutów. Atrybuty te “żyły” tak długo, jak aktywny był dany kontekst. Podobnie jest tutaj. Z tym, że kontekst serwletu jest tylko jeden i aktywny jest przez cały czas “życia” aplikacji webowej. Podobnie jak w poprzednich przypadkach możesz w nim ustawiać atrybuty. Atrybuty kontekstu Podobnie jak Servlet czy HttpRequest mają atrybuty, tak samo jest z ServletContext. Możesz ustawiać dowolne atrybuty w kontekście. Dzięki temu, że istnieje jeden kontekst dla całej aplikacji możesz w ten sposób przekazywać informacje pomiędzy serwletami. Do pracy z atrybutami przechowywanymi w obiekcie implementującym ServletContext służą metody:   setAttribute,  getAttribute,  getAttributeNames,  removeAttribute.Instancję implementującą ten interfejs możemy uzyskać wywołując metodę getServletContext znajdującą się w interfejsie ServletRequest. Dzięki dostępowi do kontekstu serwletów możesz przekazywać atrybuty pomiędzy poszczególnymi serwletami. Przykładowy serwlet poniżej wyświetla wszystkie atrybuty kontekstu ustawiając wcześniej wartość jednego z nich. @WebServlet(\"/servlet1\")public class Servlet1 extends HttpServlet {    @Override    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {        PrintWriter writer = resp.getWriter();        writer.write(\"&lt;html&gt;&lt;body&gt;\");        ServletContext context = req.getServletContext();        context.setAttribute(\"pl.samouczekprogramisty.servlet1\", \"servlet1 attribute\");        Enumeration&lt;String&gt; attributeNames = context.getAttributeNames();        while (attributeNames.hasMoreElements()) {            String attributeName = attributeNames.nextElement();            writer.write(\"&lt;p&gt;\" + attributeName + \": \" + context.getAttribute(attributeName) + \"&lt;p&gt;\");        }        writer.write(\"&lt;/body&gt;&lt;/html&gt;\");    }}Spróbuj uruchomić aplikację, która ma taki serwlet. Wpisując adres serwletu w przeglądarce zobaczysz wszystkie atrybuty kontekstu. Poza atrybutem ustawionym przez serwlet zobaczysz także inne, część z nich jest ustawiona przez sam kontener serwletów. Dokumentacja zaleca aby nazwy atrybutów były zapisane w podobnej konwencji jak pakiety. Innymi słowy nazwy powinny wyglądać jak “odwrócone adresy www”, na przykład pl.samouczekprogramisty.servelet1. Dynamiczna konfiguracja Ponadto twórcy bibliotek dzięki dostępowi do obiektu ServletContext mogą dynamicznie tworzyć serwlety, filtry czy obiekty nasłuchujące zdarzenia (ang. listener). Funkcjonalność ta raczej nie jest wykorzystywana w innych przypadkach.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Obiekty nasłuchujące Szczerze mówiąc miałem tu problem z tłumaczeniem :). Chodzi tu o obiekty, które potocznie nazywamy “listenerami”. Obiekty nasłuchujące nie są specyficzne dla aplikacji webowych. Koncept tego typu używany jest także w innych miejscach. Jest to jeden z szeroko znanych wzorców projektowych. Wzorzec ten nazywany jest obserwatorem (ang. observer). Kontener serwletów ma informację o wystąpieniu pewnych zdarzeń. Ty jako programista możesz chcieć być informowany o tych zdarzeniach. Na przykład chcesz dostać informację kiedy obiekt ServletContext zostanie utworzony. Aby to zrobić tworzysz własną instancję obiektu nasłuchującego, który implementuje interfejs ServletContextListener. Dodatkowo tę implementację oznaczasz adnotacją @WebListener. Dzięki temu kontener serwletów wie o twojej klasie. Wie, że musi ją powiadomić o takim zdarzeniu. Poniższy diagram pokazuje jak te komponenty układają się w całość:         Wzorzec obserwator.  Kontener przechowuje listę obiektów implementujących interfejs ServletContextListener. Jedną z implementacji może być klasa MyOwnImplementation pokazana na diagramie. Następnie w każdym momencie kiedy wystąpi zdarzenie, którym interesuje się nasza implementacja kontener uruchamia odpowiednie metody. Metody te są zdefiniowane w iterfejsie ServletContextListener. Zdarzenia dotyczące kontekstu nie są jedynymi. W trakcie działania aplikacji webowej występuje wiele zdarzeń. Zdarzenia te związane są z cyklem życia poszczególnych elementów aplikacji. Na przykład możesz być poinformowany o tym, że została utworzona sesja HTTP, albo o tym, że jakieś zapytanie zostało wysłane do aplikacji. Poniżej znajduje się lista kilka przykładowych interfejsów obiektów nasłuchujących:   ServletContextListener,  ServletContextAttributeListener,  ServletRequestListener,  ServletRequestAttributeListener,  HttpSessionListener,  HttpSessionAttributeListener.Na przykład, obiekt implementujący interfejs ServletContextAttributeListener zostanie poinformowany o wszystkich operacjach na atrybutach kontekstu serwletu. Aby kontener serwletów wiedział o obiekcie nasłuchującym trzeba go odpowiednio skonfigurować. Każdy z obiektów nasłuchujących powinien być dekorowany wspomnianą adnotacją @WebListener2. Poniżej znajduje się przykładowa implementacja interfejsu ServletContextListener, która dodaje dodatkowy atrybut w momencie utworzenia kontekstu serwletu: @WebListenerpublic class MyServletContextListener implements ServletContextListener {    @Override    public void contextInitialized(ServletContextEvent sce) {        sce.getServletContext().setAttribute(\"pl.samouczekprogramisty.listener\", \"listener value\");    }    @Override    public void contextDestroyed(ServletContextEvent sce) {        // do nothing    }}Praktyczne wykorzystanie W poprzednich artykułach opisujących elementy specyfikacji serwletów odwoływałem się do Spring MVC. Nie inaczej będzie i tym razem. Przykładowym obiektem nasłuchującym zaimplementowanym w Spring MVC może być WebAppRootListener. Obiekt ten reaguje na utworzenie/zniszczenie kontekstu serwletów. Zachęcam Cię do przeszukania kodu źródłowego Spring MVC pod kątem innych obiektów, które reagują na zdarzenia w aplikacji webowej. Implementacja odpowiednich interfejsów, które pozwalają reagować na zdarzenia umożliwia konfigurację Spring MVC. W praktyce “magiczny Spring” nie robi nic innego jak wykorzystuje elementy specyfikacji serwletów. Ćwiczenie do wykonania Napisz serwlet, który wyświetli wszystkie atrybuty kontekstu. Dodatkowo niech serwlet ten dodaje parametry przekazane w adresie URL jako atrybuty kontekstu. Na przykład żądanie na adres .../serwlet?pl.parametr=xxx powinno utworzyć atrybut kontekstu o nazwie pl.parametr z wartością xxx. Uzupełnij tę aplikację o implementację interfejsu ServletContextAttributeListener. Niech twój słuchacz w momencie dodawania nowego atrybuty kontekstu doda kolejny atrybut z datą jego dodania. Na przykład jeśli dodamy atrybut o nazwie pl.parametr to automatycznie powinien zostać dodany atrybut pl.parametr.when. Wartością nowego atrybutu powinna być data dodania atrybutu. Pamiętaj żeby zabepieczyć się przed “nieskończoną pętlą” - twój obiekt zostanie także powiadomiony o dodaniu atrybutu pl.parametr.when i wtedy spróbuje dodać kolejny pl.pamrater.when.when, o którym także byłby powiadomiony. Jeśli będziesz miał problem z rozwiązaniem zadania możesz rzucić okiem na przykładowe rozwiązanie. Jak zwykle jednak zachęcam do samodzielego rozwiązania zadania. Wtedy nauczysz się najwięcej. Dodatkowe materiały do nauki   Specyfikacja serwletów,  Artykuł na wikipedii nt. wzorca projektowego observer,  Kod źródłowy przykładów użytych w artykule.Podsumowanie Wiesz już czym jest ServletContext i do czego może być używany. Poznałeś przykłady obiektów nasłuchujących zdarzeń w aplikacjach webowych. Znasz przykłady praktycznego ich wykorzystania. Po wykonaniu ćwiczenia potrafisz zastosować tę wiedzę w praktyce. Innymi słowy poznałeś mechanizmy, pozwalające na działanie aplikacji webowych :). Mam nadzieję, ze artykuł Ci się podobał. Jeśli nie chcesz pominąć kolejnych zapisz się do samouczkowego newslettera i polub stronę na facebooku. Na koniec mam do Ciebie prośbę. Zależy mi na dotarciu do jak największego grona czytelników. Możesz mi w tym pomóc przekazując link do artykułu swoim znajomym. Z góry dziękuję i do następnego razu!             Właściwie to, istnieje tylko jeden taki obiekt dla każdej wirtualnej maszyny Java. Jeśli twoja aplikacja webowa jest rozproszona wówczas obiektów implementujących ten interfejs jest tyle, ile instancji JVM. &#8617;               Może też być zdefiniowany w pliku web.xml, web-fragment.xml czy dodany dynamicznie przez metody dostępne w ServletContext, jednak te sposoby wykraczają poza zakres tego artykułu. &#8617;       ","categories": ["DSP2017","Kurs aplikacji webowych"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/kontekst-serwletu-i-obiekty-nasluchujace-w-aplikacjach-webowych/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/04/21_listener_kontekst_servlet_context_artykul.jpeg"},{
        "title": "Pogodynka - JPA i Spring Data",
        "excerpt":"Baza danych Dla celów testowych i na “środowisku developerskim” (czytaj moim własnym komputerze) używam prostej bazy danych. Mam tu na myśli HyperSQL. Jest to baza danych, której zawartość może być trzymana wyłącznie w pamięci. Tego typu rozwiązanie idealnie nadaje się do pracy na środowisku programistycznym. Często też bazy danych tego typu używane są w trakcie testów integracyjnych. W trakcie takich testów możliwe jest testowanie właściwej integracji z bazą danych. Dostęp do tej bazy danych możliwy jest po dodaniu jednej linijki do konfiguracji Gradle compile group: 'org.hsqldb', name: 'hsqldb', version: '2.4.0'Jeśli chcesz dowiedzieć się czegoś więcej o samym Gradle zachęcam do przeczytania wprowadzenia do Gradle. JPA i ORM I tu wchodzą nam dwie wielkie kobyły ;). JPA czyli Java Persistence API i ORM czyli Object-Relational Mapping. JPA to specyfikacja, która została włączona do specyfikacji EJB (ang. Enterprise Java Beans). Specyfikacja ta określa mechanizmy, które pozwalają na “proste” zarządzanie zawartością bazy danych przez obiekty w Java. Innymi słowy instancje klas odpowiadają wierszom w bazie danych. Mapowanie zawartości bazy danych na obiekty Javy to “mapowanie obiektowo-relacyjne” - ORM. Najszerzej stosowaną implementacją JPA jest Hibernate. To właśnie tę implementację użyłem w Pogodynce. Aby uzyskać wsparcie Hibernate niezbędne są następujące zależności: compile group: 'org.hibernate', name: 'hibernate-entitymanager', version: '5.2.10.Final'compile group: 'org.hibernate', name: 'hibernate-core', version: '5.2.10.Final'ORM Nie wchodząc w szczegóły samego JPA i Hibernate opiszę co udało mi się osiągnąć. Przy pomocy odpowiednich adnotacji w kodzie Javy mapuję obiekty klasy TemperatureMeasurement na wiersze w tabeli temperature_measurements. Całość wymagała kilku adnotacji w kodzie oraz dodatkowej konfiguracji, która pozwoliła na mapowanie typu DateTime na odpowiedni typ w bazie danych. Jedyny obiekt modelu, który aktualnie jest dostępny wygląda następująco: @Entity@Table(name = \"temperature_measurements\",       indexes = @Index(name = \"idx_temperature_measurements_when_meaasured\",                        columnList = \"when_measured\"))public class TemperatureMeasurement {     @Id    @SequenceGenerator(name = \"measurements_sequence\", allocationSize = 5, sequenceName = \"temperature_measurements_seq\")    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"measurements_sequence\")    private Long id;     private BigDecimal temperature;     @Column(name = \"when_measured\")    private DateTime whenMeasured;     public TemperatureMeasurement() {    }     public TemperatureMeasurement(BigDecimal temperature, DateTime whenMeasured) {        this.temperature = temperature;        this.whenMeasured = whenMeasured    }     @NotNull    public BigDecimal getTemperature() {        return temperature;    }     @NotNull    public DateTime getWhenMeasured() {        return whenMeasured;    }}Warstwa dostępu do danych Warstwa DAO (ang. Data Access Object) jest automatycznie generowana. Są to obiekty pośredniczące zarządzane przez Spring. Interfejs DAO, którym posługuję się w aplikacji sprowadza się do kilku linijek: @Repositorypublic interface TemperatureMeasurementDAO extends CrudRepository&lt;TemperatureMeasurement, Long&gt; {}Taka “magia” dostępna jest dzięki użyciu Spring Data: compile group: 'org.springframework.data', name: 'spring-data-jpa', version: '1.11.3.RELEASEMagiczna konfiguracja Spring Całość konfiguracji to jeden nowy plik. Tworzy on odpowiednie obiekty, które wymagane są przez specyfikację JPA @Configuration@EnableTransactionManagement@EnableJpaRepositories(basePackages = \"pl.samouczekprogramisty.pogodynka.datavault.model\")public class JPAConfigration {     @Bean    public DataSource getDataSource() {        DriverManagerDataSource dataSource = new DriverManagerDataSource();        dataSource.setDriverClassName(\"org.hsqldb.jdbc.JDBCDriver\");        dataSource.setUrl(\"jdbc:hsqldb:mem:datavault_test\");        dataSource.setUsername(\"datavault_test\");        dataSource.setPassword(\"datavault_test\");        return dataSource;    }     @Bean    public LocalContainerEntityManagerFactoryBean entityManagerFactory() {        LocalContainerEntityManagerFactoryBean entityManager = new LocalContainerEntityManagerFactoryBean();        entityManager.setDataSource(getDataSource());        entityManager.setJpaVendorAdapter(new HibernateJpaVendorAdapter());        entityManager.setPackagesToScan(\"pl.samouczekprogramisty.pogodynka.datavault.model\");         Properties jpaProperties = new Properties();        jpaProperties.setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.HSQLDialect\");        jpaProperties.setProperty(\"hibernate.show_sql\", \"true\");        jpaProperties.setProperty(\"hibernate.format_sql\", \"true\");        jpaProperties.setProperty(\"hibernate.hbm2ddl.auto\", \"create-drop\");        jpaProperties.setProperty(\"jadira.usertype.autoRegisterUserTypes\", \"true\");         entityManager.setJpaProperties(jpaProperties);         return entityManager;    }     @Bean    public PlatformTransactionManager transactionManager(EntityManagerFactory entityManagerFactory) {        JpaTransactionManager transactionManager = new JpaTransactionManager();        transactionManager.setEntityManagerFactory(entityManagerFactory);         return transactionManager;    }     @Bean    public PersistenceExceptionTranslationPostProcessor exceptionTranslation() {        return new PersistenceExceptionTranslationPostProcessor();    }}Podsumowanie Dzisiaj mam “gotową” aplikację webową, która wystawia dwa adresy URL. Pozwalają one na utworzenie nowej instancji pomiaru temperatury i pobrania wszystkich istniejących pomiarów. Kolejnym krokiem będzie zaimplementowanie “logowania” użytkowników i wystawienia takiej aplikacji na świat. Następnie będę mógł zintegrować czujnik z tak działającą aplikacją. Po kilku dniach działania aplikacji będę miał wystarczająco dużo rzeczywistych pomiarów temperatury, które pozwolą mi na pracę nad interfejsem użytkownika. Jeśli chcesz zobaczyć aktualną wersję aplikacji możesz ją znaleźć na samouczkowym githubie. Trzymaj się i do następnego razu! ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pogodynka-jpa-i-spring-data/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/04/23_pogodynka_06_artykul.jpeg"},{
        "title": "Deskryptor wdrożenia w aplikacjach webowych",
        "excerpt":"Deskryptor wdrożenia Plik web.xml nazywany jest deskryptorem wdrożenia. W starszych wersjach specyfikacji serwletów tylko przy jego pomocy można było konfigurować aplikacje webowe. Aktualnie plik web.xml nie jest wymagany, praktycznie wszystkie elementy można skonfigurować przy pomocy adnotacji. Jednak nadal zdarzają się aplikacje gdzie taki plik jest wykorzystywany. W związku z tym dobrze jest wiedzieć o jego istnieniu. Oczywiście zawartością deskryptora wdrożenia są znaczniki XML, jeśli nie miałeś wcześniej styczności z tym formatem zapraszam do osobnego artykułu ze wstępem do formatu XML. Plik web.xml powinien znajdować się bezpośrednio w katalogu WEB-INF wewnątrz pliku war. Struktura przykładowego pliku war może wyglądać następująco: $ unzip -l build/libs/05_webxml-1.0-SNAPSHOT.war Archive:  build/libs/05_webxml-1.0-SNAPSHOT.war  Length      Date    Time    Name---------  ---------- -----   ----        0  2017-04-27 20:15   META-INF/       25  2017-04-27 20:12   META-INF/MANIFEST.MF        0  2017-04-27 20:15   WEB-INF/        0  2017-04-27 20:15   WEB-INF/classes/        0  2017-04-26 21:36   WEB-INF/classes/pl/        0  2017-04-26 21:36   WEB-INF/classes/pl/samouczekprogramisty/        0  2017-04-26 21:36   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/        0  2017-04-27 20:15   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/webxml/        0  2017-04-27 20:15   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/webxml/xml/     1073  2017-04-27 20:15   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/webxml/xml/XMLConfiguredListener.class     3045  2017-04-27 20:15   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/webxml/xml/XMLConfiguredServlet.class     1330  2017-04-27 20:15   WEB-INF/classes/pl/samouczekprogramisty/kursaplikacjewebowe/webxml/xml/XMLConfiguredFilter.class     1227  2017-04-26 21:40   WEB-INF/web.xml---------                     -------     6700                     13 filesStrukturę aplikacji webowej opisywałem szczegółowo w pierwszym artykule wprowadzającym. Szablon web.xml Plik web.xml informuje kontener serwletów o wersji specyfikacji serwletów. Dla każdej wersji specyfikacji plik ten różni się nagłówkiem. Dla wersji 3.1 szablon pliku wygląda następująco &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"         version=\"3.1\"&gt;    &lt;!-- tutaj są znaczniki do konfiguracji --&gt;&lt;/web-app&gt;Jak widzisz w głównym węzłem deskryptora wdrożenia jest &lt;web-app&gt;. Wewnątrz tego znacznika znajduje się właściwe elementy konfigurujące aplikację webową. W kolejnej części artykułu zobaczysz porównanie konfiguracji przy pomocy znaczników XML z konfiguracją zapisaną w postaci adnotacji. W obu przypadkach pokazywał będę prostą aplikację, która zawiera serwlet, obiekt nasłuchujący i filtr. Przykładowy deskryptor wdrożenia możesz zobaczyć na samouczkowym githubie. Zawiera on wszystkie elementy omówione poniżej. Konfiguracja serwletu Podstawowa konfiguracja serwletu sprowadza się do nadania mu nazwy i podpięcia go pod odpowiedni adres URL. Zobacz jak taki efekt można osiągnąć przy pomocy znaczników XML i adnotacji. Znaczniki XML &lt;servlet&gt;    &lt;servlet-name&gt;my-servlet&lt;/servlet-name&gt;    &lt;servlet-class&gt;pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredServlet&lt;/servlet-class&gt;&lt;/servlet&gt;&lt;servlet-mapping&gt;    &lt;servlet-name&gt;my-servlet&lt;/servlet-name&gt;    &lt;url-pattern&gt;/servlet-url-xml&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;Powyższy fragment xml zawiera kilka znaczników. Pierwszy z nich &lt;servlet&gt; informuje kontener serwletów o tym, ze w klasie pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredServlet znajduje się serwlet. Nadałem mu nazwę my-servlet. Następnie wewnątrz &lt;servlet-mapping&gt;, posługując się wcześniej nadaną nazwą podpinam serwlet pod adres URL /servlet-url-xml. Adnotacje @WebServlet(name = \"my-servlet\", urlPatterns = \"/servlet-url-annotations\")public class AnnotationConfiguredServlet extends HttpServletW przypadku adnotacji sprawa jest prostsza. Tutaj nie muszę podawać dokładnej nazwy klasy wraz z pakietem. Adnotacja znajduje się właśnie w nad tą klasą.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Konfiguracja filtra Aby skonfigurować podstawowy filtr należy nadać mu nazwę i podpiąć go pod serwlet czy adres URL. Poniżej możesz porównać oba sposoby konfiguracji. Znaczniki XML &lt;filter&gt;    &lt;filter-name&gt;my-filter&lt;/filter-name&gt;    &lt;filter-class&gt;pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredFilter&lt;/filter-class&gt;&lt;/filter&gt; &lt;filter-mapping&gt;    &lt;filter-name&gt;my-filter&lt;/filter-name&gt;    &lt;url-pattern&gt;/servlet-url-xml&lt;/url-pattern&gt;&lt;/filter-mapping&gt; &lt;filter-mapping&gt;    &lt;filter-name&gt;my-filter&lt;/filter-name&gt;    &lt;servlet-name&gt;my-servlet&lt;/servlet-name&gt;&lt;/filter-mapping&gt;Podobnie jak w przypadku serwletu pierwszy znacznik &lt;filter&gt; tworzy filtr o nazwie my-filter podpinając klasę pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredFilte. Kolejne dwie grupy znaczników &lt;filter-mapping&gt; posługują się nazwą filtra. Pierwsza używa &lt;url-pattern&gt; aby podpiąć filtr pod konkretny adres URL. Wewnątrz drugiego znacznika &lt;filter-mapping&gt; użyłem &lt;servlet-name&gt; aby podpiąć filtr pod konkretny serwlet. Adnotacje @WebFilter(filterName = \"my-filter\", servletNames = \"my-servlet\", urlPatterns = \"/servlet-url-annotations\")public class AnnotationConfiguredFilter implements FilterKonfiguracja obiektu nasłuchującego W tym przypadku sprawa jest prosta. Cała konfiguracja sprowadza się do poinformowania kontenera serwletów o istnieniu takiego obiektu. Znacznik XML &lt;listener&gt;    &lt;listener-class&gt;pl.samouczekprogramisty.kursaplikacjewebowe.webxml.xml.XMLConfiguredListener&lt;/listener-class&gt;&lt;/listener&gt;Adnotacje @WebListenerpublic class AnnotationConfiguredListener implements ServletRequestListenerDodatkowe informacje Kiedy plik web.xml jest niezbędny Są sytuacje w których plik web.xml jest niezbędny. W przypadku kiedy istotna jest kolejność wykonania filtrów, obiektów nasłuchujących czy przypisania serwletów do adresów URL plik web.xml jest niezbędny. Specyfikacja serwletów jasno mówi o tym, że bez tego pliku kolejność wywołania tych elementów nie jest jasno określona. Modułowość konfiguracji Konfigurację podobną do tej z pliku web.xml można zawrzeć w plikach web-fragment.xml. Taki plik może znajdować się w każdym pliku jar, który znajduje się wewnątrz pliku war (ponownie odsyłam do artykułu opisującego strukturę aplikacji webowej). Konkretnie w katalogu META-INF wewnątrz pliku jar. Wewnątrz pliku web-fragment.xml możemy użyć tych samych znaczników jak pliku web.xml. Różnicą jest tutaj znacznik główny. W tym przypadku jest to &lt;web-fragment&gt; a nie &lt;web-app&gt;. Ostatnie słowo ma web.xml Chociaż dla niektórych osób adnotacje czy pliki web-fragment.xml mogą być preferowanym wyborem to web.xml ma ostatnie słowo. Mam tu na myśli atrybut metadata-complete. Atrybut ten można ustawić na znaczniku &lt;web-app&gt;. Jeśli przyjmie on wartość true, wówczas adnotacje i pliki web-fragment.xml będą ignorowane. W takim przypadku cała konfiguracja aplikacji webowej musi znajdować się w pliku web.xml. &lt;web-app xmlns=\"http://xmlns.jcp.org/xml/ns/javaee\"         xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"         xsi:schemaLocation=\"http://xmlns.jcp.org/xml/ns/javaee         http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd\"         version=\"3.1\"         metadata-complete=”true”&gt;     &lt;!-- tutaj są znaczniki do konfiguracji --&gt; &lt;/web-app&gt;Przykładowe aplikacje Na potrzeby tego artykułu napisałem dwie proste aplikacje. Jedna z nich skonfigurowana jest wyłączni przy użyciu znaczników xml, druga tylko adnotacji. Zachęcam do zajrzenia do kodu, który umieściłem na githubie:   Aplikacja konfigurowana wyłącznie przy pomocy XML,  Aplikacja konfigurowana wyłącznie przy pomocy adnotacji.Podsumowanie Przedstawiłem tutaj wyłącznie podstawowe znaczniki stosowane wewnątrz pliku web.xml. Zależało mi na tym abyś sam mógł zobaczyć różnicę pomiędzy tymi podejściami. Nie oceniam, które z nich jest lepsze, które gorsze. Każde z nich ma swoje wady i zalety. Wybierz ten sposób, który bardziej Ci odpowiada i konsekwentnie się go trzymaj. Z jednej strony posiadanie całej konfiguracji w pliku xml jest wygodne. Jednak z drugiej strony w przypadku adnotacji edytując kod od razu masz informacje o konfiguracji. Ciekawy jestem Twojego zdania. Które podejście bardziej Ci odpowiada i dlaczego? ","categories": ["DSP2017","Kurs aplikacji webowych"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/deskryptor-wdrozenia-w-aplikacjach-webowych/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/04/27_deskryptor_wdrozenia_artykul.jpeg"},{
        "title": "Pogodynka - konfiguracja serwera",
        "excerpt":"Konfiguracja maszyny produkcyjnej Chociaż do konfiguracji produkcyjnej daleko, będę tutaj pisał o “serwerze produkcyjnym”. Mam tu na myśli VPS (ang. Virtual Private Server), na którym uruchomiona będzie baza danych oraz Tomcat. To właśnie do tej maszyny Malinka wysyłała będzie informacje o odczytach temperatury. Ta sama maszyna posłuży do uruchomienia aplikacji webowej pokazującej interfejs użytkownika. Namiastka produkcji Konfiguracja ta nijak nie przypomina “produkcji z prawdziwego zdarzenia”. Nie ma tu mowy o sensownym monitorowaniu czy zapewnieniu niezawodności. Mam świadomość tych niedociągnięć :). Jak na hobbystyczny projekt konfiguracja tego typu powinna być wystarczająco dobra. Oczywiście przy takiej konfiguracji nie zapewnię dostępności na poziomie pięciu dziewiątek (nawet, chyba dwóch nie dałbym rady ;)). Aby poprawić tę konfigurację musiałbym poświęcić na nią więcej czasu i zapłacić więcej za utrzymanie finalnego środowiska. “Budżetu” na Pogodynkę, nie chciałbym powiększać, więc zostanę przy aktualnych ustawieniach. Akceptuję te niedociągnięcia z racji tego, że projekt ten nie jest krytyczny. Zarządzanie konfiguracją Mógłbym skonfigurować maszynę ręcznie. Na pewno byłoby to szybsze niż zabawa, którą zaraz opiszę. Jednak tego typu podejście prowadzi do sytuacji, w której odtworzenie konfiguracji jest ciężkie. Chciałbym tego uniknąć. Konfiguracja maszyny produkcyjnej zarządzana jest przy pomocy Puppet’a. Całość trzymana jest w repozytorium razem z kodem. Dzięki takiemu podejściu wiem dokładnie co, jak i kiedy zostało zmienione. A co najważniejsze mogę tę konfigurację szybko odtworzyć. Czym jest Puppet Puppet to narzędzie, które pomaga zarządzać konfiguracją maszyn. Puppet używa tak zwanych manifestów, które określają konfigurację danej maszyny. Wewnątrz manifestów używany jest DSL (ang. Domain Specific Language), który ułatwia tę konfigurację. Przy pomocy tego narzędzia i odpowiednich manifestów możemy na przykład zainstalować bazę danych, odpowiednią wersję Javy czy Tomcat’a. Manifesty z konfiguracją pakowane są w tak zwane moduły. W moim przypadku używam na przykład modułów do instalacji Tomcat’a czy zarządzania regułami firewalla. Mogę śmiało powiedzieć, że konfiguracja większości standardowych rzeczy dostępna jest w odpowiednim module. Kod odpowiedzialny za konfigurację Aby niepotrzebnie nie komplikować sprawy uruchamiam Puppeta w trybie “samodzielnym”. Nie ma tutaj standardowej maszyny, z której pobierana jest konfiguracja (“puppet mastera”). Jest to uproszczenie, które w tym przypadku jest akceptowalne. Cały katalog modułów trzymam w repozytorium git. Zewnętrzne moduły puppeta dodałem do repozytorium jako submoduły git’a. $ git submodule status 3f6863ac4c97f834bebc811852452b073d202682 puppet/modules/apt (2.4.0) 5c4a9141d08a7b23dcada029d23b82590632d0f4 puppet/modules/concat (2.2.1) 23016934d23c5c2f3f3edbc2ec8279f8faac2457 puppet/modules/firewall (1.8.2) 5b01b42e2228d9c979f7fcbdfac5b926f25f5dea puppet/modules/postgresql (4.9.0) ec1ce78c1ec0c82d440cb5d1b98a065c858d3c0e puppet/modules/staging (0.4.1) 1ae06c50acc89be4dea28b6e85b5a23f479f584e puppet/modules/stdlib (4.16.0) e545ac740122c9a873aec66b24148a43dd65f9ef puppet/modules/tomcat (1.6.1)Dzięki takiemu podejściu zawsze (jak tylko github i repozytoria modułów są dostępne ;)) mam dostęp do całości konfiguracji. Konfiguracja przy pomocy Puppet’a Wykupiłem VPS w jednej z firm. Zainstalowałem tam obraz z Debianem Jessie. W tym miejscu zaczyna się zabawa ;). Instalacja Javy Zacznijmy od Javy. Instalacja Javy 8 na Debianie 8 nie jest trywialna :). Chodzi mi tu o Javę od Oracle. OpenJDK można zainstalować z “backports”. Po zabawie z kluczami do apt udało mi się Javę zainstalować: class pogodynka::java {  $package = \"oracle-java8-installer\"  $responsefile = \"/var/cache/debconf/${package}.preseed\"    file {    'java-apt-list':      path    =&gt; '/etc/apt/sources.list.d/webupd8team-java.list',      content =&gt; \"deb http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main\\ndeb-src http://ppa.launchpad.net/webupd8team/java/ubuntu xenial main\";        'java-apt-key':      path   =&gt; '/etc/apt/trusted.gpg.d/webupd8.gpg',      source =&gt; 'puppet:///modules/pogodynka/webupd8.gpg';      $responsefile:      ensure  =&gt; 'present',          content =&gt; \"${package} shared/accepted-oracle-license-v1-1 select true\";  }           package {           'oracle-java8-installer':      ensure       =&gt; 'latest',      responsefile =&gt; $responsefile,      require      =&gt; [File['java-apt-list'], File['java-apt-key'], Class['apt::update']];        'oracle-java8-set-default':      ensure  =&gt; 'latest',      require =&gt; Package['oracle-java8-installer'];  }}Tomcat Podobnie jak w przypadku firewalla użyłem istniejącego modułu. Cała konfiguracja sprowadza się do kilku linijek: $catalina_home = '/opt/tomcat8.5'$catalina_base = \"${catalina_home}/production\" tomcat::install {  '/opt/tomcat8.5':    source_url =&gt; 'http://mirror.23media.de/apache/tomcat/tomcat-8/v8.5.14/bin/apache-tomcat-8.5.14.tar.gz';} tomcat::instance {  'tomcat8.5-production':    catalina_home =&gt; $catalina_home,    catalina_base =&gt; $catalina_base;}Sam Tomcat uruchamiany jest z poziomu użytkownika tomcat. Z tego powodu nie mogę uruchomić go tak aby nasłuchiwał na domyślnym porcie HTTP. Tomcat słucha na 8080. Firewall Podobnie jak w przypadku Tomcat’a użyłem istniejącego modułu. Oczywiście nie chcę otwierać na świat serwera produkcyjnego. Sytuacja, w której na przykład baza danych była dostępna z zewnątrz jest zła. Domyślnie chcę mieć otwarty mały podzbiór portów. Oczywiście standardowy port 80 dla HTTP i 22 dla SSH potrzebuję, resztę trzeba wyciąć. To się musiało stać, w trakcie zabawy z konfiguracją firewall odciąłem sobie dostęp po SSH. Skończyło się to reinstalacją Debiana na nowo. Całe szczęście cała konfiguracja trzymana jest w repozytorium więc odtworzenie poprzedniego stanu sprowadziło się do kilku komend: wget https://raw.githubusercontent.com/SamouczekProgramisty/Pogodynka/master/puppet/bootstrap.shchmod +x bootstrap.sh./bootstrap.shPoza wycięciem portów za pomocą konfiguracji firewalla będę musiał zrobić przekierowanie ruchu z portu 80 na 8080. Ta część jeszcze przede mną ;). Podsumowanie Konfiguracja jeszcze nie jest gotowa. Jeśli chcesz zobaczyć jej aktualną wersję możesz rzucić okiem na samouczkowego githuba. Jeszcze męczę się z dopięciem niektórych elementów. W każdym razie postęp, mały bo mały, jest. Do końca projektu zostały jeszcze trzy tygodnie. Trzymaj za mnie kciuki ;). Do następnego razu! ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pogodynka-konfiguracja-serwera/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/04/30_konfiguracja_puppet_artykul.jpeg"},{
        "title": "`String` cache i `StringBuilder` w praktyce",
        "excerpt":"Literał znakowy Na początku powtórka podstaw. Literał znakowy to ciąg znaków otoczony cudzysłowami. Jest to instancja klasy String, jednak tworzona jest bez udziału słówka kluczowego new. Przykład poniżej pokazuje literał znakowy przypisany do zmiennej: String someLiteral = “some constant value”;Jak działa klasa String Instancje klasy String reprezentują łańcuchy znaków. Wewnętrznie znaki te przetrzymywane są w tablicy znaków. Tablica ta ma typ char[]. Implementacja klasy String chowa przed programistą mechanizmy operowania na tej tablicy. Instancje klasy String są niemutowalne. Oznacza to tyle, że po stworzeniu instancji nie ma możliwości jej modyfikacji. Kilka metod wymienionych poniżej zwraca nowe instancje, pozostawiając tę na której zostały wywołane bez zmian:   replace - podmienia znak w łańcuchu znaków,  substring - zwraca pewną część łańcucha znaków określoną indeksami,  toLowerCase - zamienia wielkie litery na małe w nowej instancji,  toUpperCase - zamienia łańcuch znaków na wielkie litery,  trim - zwraca nową instancję bez początkowych i końcowych białych znaków.Co jeśli String nie ma metody, której potrzebuję? Chociaż klasa String zawiera spory zestaw metod, nie jest to lista kompletna. Jeśli trafisz na taki przypadek nie próbuj wynaleźć koła na nowo. Lepiej rzuć okiem na istniejące biblioteki. Na przykład na commons-lang . Biblioteka ta zawiera klasę StringUtils, w której znajdziesz masę przydatnych metod operujących na łańcuchach znaków. Konkatenacja łańcuchów znaków Najprostszym sposobem otrzymania łańcucha znaków jaki nas interesuje jest złożenie go z wielu części. Służy do tego operator +. Operacja ta nazywana jest konkatenacją. System.out.println(\"some\" + \" \" + \"string\" + \" \" + \"literal\");W przypadku konkatenacji każdy z elementów konwertowany jest do typu String używając metody toString1: int x = 10;Object y = new Object();System.out.println(\"some\" + \" \" + x + \" \" + \"literal\" + \" \" + y);Używanie operatora + może być bardzo wygodne jednak czasami może prowadzić do zaskakujących (na początku) rezultatów. Proszę porównaj dwie poniższe linijki kodu: System.out.println(1 + 2 + \"test\"); // 3testSystem.out.println(\"test\" + 1 + 2); // test12Pierwsza z nich na początku doda dwie liczby uzyskując 3 a następnie dołączy do niej łańcuch znaków. Druga do łańcucha znaków dołączy dwie kolejne liczby. Dzieje się tak ponieważ operator + jest lewostronnie łączny. Oznacza to tyle, że w tym przypadku wyrażenie to wykonywane jest od lewej do prawej strony. W pierwszym przypadku do liczby 1 dodajemy liczbę 2, następnie “dodajemy” do niej łańcuch znaków. W drugim przypadku do łańcucha znakód dodajemy kolejno dwie liczby. Klasa String posiada także metodę concat, która działa w podobny sposób do operatora +2.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Wydajność a konkatenacja Wiesz już, że instancje klasy String są niemutowalne. Wszystkie metody znajdujące się w klasie String, modyfikują łańcuch znaków tak na prawdę tworzą jego nową instancję. Nie inaczej jest z konkatenacją. Proszę spójrz na przykład poniżej: String some = \"some\";String space = \" \";String random = \"random\";String string = \"string\"; String someString = some + space + random + space + string;Tak na prawdę, zanim powstałaby finalna instancja klasy String potrzebne byłoby aż trzy “tymczasowe” obiekty3. Dopiero piąty obiekt byłby tym, który mógłby być przypisany do zmiennej someString. Dlaczego aż cztery? Wynika to z niemutowalności instancji klasy String. Nie możemy, posługując się wyłącznie instancjami klasy String od razu stworzyć finalnej wersji. Tworzone są obiekty “pośrednie”:   “some “ (zwróć uwagę na spację na końcu),  “some random”,  “some random “ (ponownie ze spacją).Tworzenie takich nowych tymczasowych instancji nie jest wydajne. Można to zrobić lepiej. Z pomocą przychodzą klasy StringBuilder i StringBuffer4. Jak używać klasy StringBuilder Klasa StringBuilder podobnie jak String jest opakowaniem tablicy znaków typu char[]. StringBuilder jednak jest typem mutowalnym. Instancje tego typu w można konwertować do typu String używając metody toString. Najprosztszym sposobem utworzenia instancji klasy StringBuilder jest użycie konstruktora bezparametrowego. Następnie możesz modyfikować ten obiekt używając dostępnych metod. Bardzo przydatną metodą z tej klasy jest przeciążona metoda append. Pozwala ona na wydajne łączenie łańcuchów znaków. Proszę spójrz na przykład poniżej pokazujący sposób użycia klasy: public void compilerConcatenationFiddling() {    String some = \"some\";    String space = \" \";    String random = \"random\";    String string = \"string\";     StringBuilder someSttringBuilder = new StringBuilder();    someSttringBuilder.append(some);    someSttringBuilder.append(space);    someSttringBuilder.append(random);    someSttringBuilder.append(space);    someSttringBuilder.append(string);     String someString = someSttringBuilder.toString();}Różnica pomiędzy StringBuilder a StringBuffer Istnieje też inna implementacja tej samej funkcjonalności. Jest to klasa StringBuffer. Jeśli masz przed sobą rozmowę kwalifikacyjną dobrze jest znać różnicę między tymi klasami. Jest to jedno ze “sztampowych” pytań rekrutacyjnych ;). Główną różnicą jest to, że instancję klasy StringBuffer można bezpiecznie używać nawet w aplikacjach wielowątkowych. Instancje klasy StringBuilder nie powinny być współdzielone pomiędzy wątkami. Cecha ta ma jedną ważną konsekwencję. Ze względu na brak synchronizacji instancje klasy StringBuilder są nieznacznie szybsze od StringBuffer. Dodatkowo możesz zapoznać się też z klasą StringJoiner, która oferuje podobną funkcjonalność. Jest ona wykorzystywana na przykład podczas łączenia strumieni. Optymalizacja konkatenacji przez kompilator Mamy dwa elementy układanki. Klasę StringBuilder, która dużo lepiej się sprawdza przy pracy z łączeniem znaków. Konkatenację, która nie jest wydajnym sposobem łączenia łańcuchów znaków. Mamy też metodę append, którą już poznałeś. Jest ona odpowiednikiem + w konkatenacji. Nie można czegoś z tym zrobić? Oczywiście, że można! I to właśnie jest robione przez kompilator. Tak naprawdę, pisząc kod: String some = \"some\";String space = \" \";String random = \"random\";String string = \"string\"; String someString = some + space + random + space + string;Kompilator kompiluje go do postaci, która wygląda podobnie do fragmentu niżej: String some = \"some\";String space = \" \";String random = \"random\";String string = \"string\"; StringBuilder x = new StringBuilder();x.append(some);x.append(space);x.append(random);x.append(space);x.append(string); String someString = x.toString();Innymi słowy kompilator optymalizuje za nas kod. Czy ta optymalizacja zawsze działa? Niestety nie, są przypadki kiedy nawet taka optymalizacja nie daje rady. Proszę spójrz na przykład poniżej. Jest to pętla, która dołącza aktualny stan licznika do łańcucha znaków. String finalString = \"\";for (int counter = 0; counter &lt; 1000000; counter++) {    finalString = finalString + \" \" + counter;}Jak zoptymalizuje to kompilator? Będzie to kod podobny do tego: String finalString = \"\";for (int counter = 0; counter &lt; 1000000; counter++) {    StringBuilder x = new StringBuilder();    x.append(finalString);    x.append(\" \");    x.append(counter);    finalString = x.toString();}Niestety mimo optymalizacji wewnątrz pętli dalej musimy tworzyć blisko milion obiektów tymczasowych. To jest czasochłonne. Lepszym rozwiązaniem jest poniższy fragment kodu: StringBuilder finalStringBuilder = new StringBuilder();for (int counter = 0; counter &lt; 1000000; counter++) {    finalStringBuilder.append(\" \");    finalStringBuilder.append(counter);}String finalString = finalStringBuilder.toString();W tym przypadku sam tworzę instancję klasy StringBuilder i używam jej wewnątrz pętli. Literały i cache Specyfikacja języka Java narzuca pewne wymagania związane z optymalizacją pracy z łańcuchami znaków. Każdy łańcuch znaków, który jest literałem umieszczany jest w cache’u. Tutaj drobna dygresja. Cache to mechanizm, który pozwala na przetrzymywanie wartości jakiegoś typu. Przeważnie uzyskanie tej wartości jest czasochłonne. Założeniem tego mechanizmu jest pozwolenie na szybsze dotarcie do tych wartości w późniejszym czasie. Dodatkowo pozwala on na optymalizację zajmowanego miejsca. Elementy znajdujące się w cache’u przeważnie się nie powtarzają. Cache może być zrealizowany na wiele sposobów, najprostszą implementacją może być zwykła instancja HashMap. W bardziej zaawansowanych zastosowaniach używa się osobnych programów/baz danych, które zapewniają tę funkcjonalność, na przykład memcached. Oznacza to tyle, że poniższe dwie zmienne są referencjami na dokładnie ten sam obiekt na stercie. Dzieje się tak, ponieważ są one literałami o tej samej zawartości: Poniższe fragmenty kodu są testami jednostkowymi. Jeśli chcesz przeczytać więcej na ten temat zapraszam do arytkułu poświęconemu testom jednostkowym w Javie. Możesz też przeczytać kolejny artykuł poświęcony Test Driven Development. @Testpublic void twoLiterals() {    String someVariable = \"samouczek programisty\";    String otherVariable = \"samouczek programisty\";     assertEquals(someVariable, otherVariable);    assertSame(someVariable, otherVariable);}Pierwsze porównanie, sprawdza “zawartość” łańcucha znaków. Drugie porównuje adresy obiektów na stercie. W przypadku utworzenia nowej instancji przy pomocy wywołania konstruktora, zawsze tworzone są nowe obiekty. Proszę porównaj poprzedni fragment kodu z tym poniżej: @Testpublic void twoNewObjects() {    String someVariable = new String(\"samouczek programisty\");    String otherVariable = new String(\"samouczek programisty\");    assertEquals(someVariable, otherVariable);    assertNotSame(someVariable, otherVariable);}W tym przypadku mamy do czynienia z dwoma osobnymi obiektami. W tym przypadku adresy obiektów są różne. Metoda String.intern Istnieje sposób aby zachować wartość łańcucha znaków w cache (lub pobrać go z cache). Dzięki tej metodzie w cache’u możemy zachować nawet instancje utworzone przy pomocy konstruktora. Służy do tego metoda intern. Wywołanie tej metody zachowuje w cache’u dany łańcuch znaków i zwraca instancję, która jest w cache’u zachowana. Jeśli ten literał istnieje już w cache’u, będzie tam zachowany wyłącznie raz. Proszę spójrz na przykład poniżej @Testpublic void literalAndInternedObject() {    String someVariable = \"samouczek programisty\";    String otherVariable = new String(\"samouczek programisty\").intern();     assertEquals(someVariable, otherVariable);    assertSame(someVariable, otherVariable);}W tym przypadku oba porównania zwrócą wartość true. Dodatkowe materiały do nauki Poniżej przygotowałem dla Ciebie zestaw odnośników, które mogą pomóc w rozwijaniu wiedzy związanej z pracą z łańcuchami znaków:   Java Language Specification o konkatenacji,  dokumentacja klasy StringUtils,  dokumentacja klasy StringBuilder,  dokumentacja klasy StringBuffer,  dokumentacja klasy StringJoiner,  kod źródłowy przykładów użytych w artykule.Podsumowanie Po lekturze tego artykułu sporo wiesz o pracy z łańcuchami znaków. Poznałeś jedną z optymalizacji, które wprowadza kompilator. Umiesz odpowiedzieć na jedno ze sztampowych pytań rekrutacyjnych ;). Znasz sposób pracy z klasą StringBuilder. Dowiedziałeś się też o przydatnych metodach operujących na instancjach klasy String znajdujących się w bibliotece commons-lang. Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć żadnego postu polub stronę na facebooku i dopisz się do samouczkowego newslettera. Do następnego razu!             Nie jest to do końca prawda, na przykład w przypadku typów prymitywnych stosowany jest inny mechanizm, zależny od typu zmiennej. &#8617;               Istnieją oczywiście drobne różnice, na przykład zachowanie w odniesieniu do zmiennych o wartości null. &#8617;               Piszę “potrzebne byłby” ponieważ kompilator wprowadza tu pewne optymalizacje, o których przeczytasz niżej. &#8617;               Prawda jest taka, że kompilator Java w trakcie kompilacji wykrywa taką konkatenacją i zastępuje ją właśnie wywołaniem odpowiednich metod na instacji klasy StringBuilder. Więc w prostych przypadkach tragedii nie ma, gorzej jeśli w grę wchodzą pętle ;). &#8617;       ","categories": ["Kurs programowania Java","DSP2017"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/string-cache-i-stringbuilder-w-praktyce/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/05/06_string_cache_string_builder_artykul.jpeg"},{
        "title": "Pogodynka - konfiguracja bazy danych",
        "excerpt":"Niestety moje plany kontynuacji konfiguracji od początku tygodnia spełzły na niczym. Założyłem, że to co zostało to już “pikuś” i powinno pójść prosto… O tym, jak strasznie się myliłem przeczytasz poniżej ;). Na początku chciałbym zastrzec, że nie jestem administratorem, więc jeśli masz jakiekolwiek uwagi mogące poprawić ustawienie środowiska bardzo proszę o informację w komentarzu. Baza danych Jako produkcyjną bazę danych wybrałem PostgreSQL. W przypadku tej aplikacji silnik bazy danych nie ma większego znaczenia. Nie będzie to “hurtownia danych” z olbrzymim zbiorem a raczej kilka (jedna?) prostych tabel. W poprzednim tygodniu znalazłem moduł puppeta, który pomaga w konfiguracji instancji postgresql na serwerze. Ujarzmienie tego modułu trochę mi zajęło. Okazało się, że serwer bazy danych nie mógł poprawnie wystartować ponieważ w na serwerze, nie wszystkie informacje o lokalizacji były dostępne: root@debian:~# localeLANG=en_US.UTF-8LANGUAGE=LC_CTYPE=\"en_US.UTF-8\"LC_NUMERIC=pl_PL.UTF-8LC_TIME=pl_PL.UTF-8LC_COLLATE=\"en_US.UTF-8\"LC_MONETARY=pl_PL.UTF-8LC_MESSAGES=\"en_US.UTF-8\"LC_PAPER=pl_PL.UTF-8LC_NAME=pl_PL.UTF-8LC_ADDRESS=pl_PL.UTF-8LC_TELEPHONE=pl_PL.UTF-8LC_MEASUREMENT=pl_PL.UTF-8LC_IDENTIFICATION=pl_PL.UTF-8LC_ALL=Jak widać tutaj używane były dwie lokalizacje en_US.UTF-8 i pl_PL.UTF-8. W pliku /etc/locale.gen dostępna byłą tylko jedna z nich. Dodanie obu lokalizacji do tego pliku pozwoliło utworzyć klaster i uruchomić serwer bazy danych. Po zmianie zawartości tego pliku konfiguracyjnego niezbędne jest uruchomienie polecenia locale-gen. # grep -v '#' /etc/locale.genpl_PL.UTF-8 UTF-8en_US.UTF-8 UTF-8Firewall W poprzednim odcinku wspominałem o konfiguracji firewalla, niestety dalej nie udało mi się zrobić poprawnego przekierowania ruchu z portu 80 na port 8080. Muszę jeszcze nad tym popracować. Próbowałem znaleźć odpowiedź na to pytanie na StackOverflow, niestety z marnym rezultatem :(. Przechowywanie haseł Jednym z mechanizmów dostępnych w Puppecie jest hiera. Jest to swego rodzaju hierarchiczna konfiguracja dostępna dla manifestów puppeta. W moim przypadku nie używam hierarchii plików a jedynie jednego pliku passwords.yaml. Plik ten zawiera wszystkie hasła, które nie powinny być dostępne na gitubie ;). Na przykład zawarte jest tam hasło dla głównego użytkownika bazy danych. Dzięki takiemu podejściu mogę dzielić się z Tobą konfiguracją, zachowując jednocześnie odpowiedni poziom bezpieczeństwa1. Przykładowe użycie w manifeście wygląda następująco hiera(‘variable_name’)Wówczas puppet wyszukuje wartości zmiennej variable_name i wstawia ją w odpowiednie miejsce w manifeście. Przykładowe użycie możesz znaleźć w konfiguracji bazy danych. Same hasła są losowymi ciągami o długości 64 znaków generowanymi przy pomocy komendy pwgen. Podsumowanie Zostało coraz mniej czasu, deadline coraz bliżej a tu końca nie widać ;). Mam nadzieję, że w przyszłym tygodniu uda mi się już rozwiązać definitywnie problemy z konfiguracją. Na dzisiaj to tyle, trzymaj się i do następnego razu! ;)             Jak na moją wiedzę z tego zakresu ;). &#8617;       ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pogodynka-konfiguracja-bazy-danych/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/05/07_konfiguracja_puppet_artykul.jpeg"},{
        "title": "Formatter - formatowanie łańcuchów znaków",
        "excerpt":"Formatowanie Wyobraź sobie, że chcesz pokazać użytkownikowi pewne zestawienie. Dane tego typu wygodnie jest prezentować w formie tabelarycznej. Tak dochodzimy do problemu formatowania. W jaki sposób można taki format uzyskać? Problem ten można rozwiązać posługując się klasą Formatter. Instancje właśnie tej klasy użyte są w wielu innych miejscach. Na przykład:   PrintWriter.format Wewnątrz tej metody użyty jest Formatter. System.out to instancja klasy PrintWriter. Dzięki temu w bardzo wygodny sposób możesz formatować tekst wypisując go na konsoli używając metody System.out.format,  String.format statyczna metoda w klasie String, która pozwala na formatowanie łańcucha znaków. Jej implementacja także bazuje na klasie Formatter.Zasada działania formattera Formatter działa w oparciu o specjalny łańcuch znaków. Ten łańcuch opisuje sam format w jakim dane powinny być sformatowane. Może on wyglądać następująco: %2$08.3f %3$(,08.3f %sNie przeraź się tym przykładem, po przeczytaniu tego artykułu będziesz dokładnie wiedział co ten magiczny wzorek oznacza. Jest on celowo skomplikowany, żeby pokazać Ci możliwości klasy Formatter. Łańcuch formatujący Zacznijmy od prostego przykładu: Formatter formatter = new Formatter();formatter.format(\"Samouczek Programisty istnieje od %d roku. Wszystkie artykuły pisze %s.\", 2015, \"Marcin\");String formattedString = formatter.toString();System.out.println(formattedString);Po uruchomieniu tego fragmentu kodu na konsoli pokaże się: Samouczek Programisty istnieje od 2015. Wszystkie artykuły pisze Marcin.Powyższy fragment kodu to nic innego jak utworzenie nowej instancji klasy Formatter. Następnie na tej instancji wywołana jest metoda format. Jako pierwszy argument przyjmuje ona łańcuch formatujący. Następnie może przyjąć zmienną liczbę argumentów, które wykorzystywane są do uzupełniania formatu. W naszym przypadku łańcuchem formatującym jest Samouczek Programisty istnieje od %d roku. Wszystkie artykuły pisze %s.. Natomiast dwa parametry służące do uzupełniania formatu to literały 2015 i Marcin. Powyższy fragment można uprościć używając wcześniej wspomnianej metody PrintWriter.format: System.out.format(\"Samouczek Programisty istnieje od %d roku. Wszystkie artykuły pisze %s.%n\", 2015, \"Marcin\")W dalszej części artykułu posługiwał będę się tą uproszczoną wersją. Ważne jest żebyś miał jednak świadomość, że pod spodem używana jest instancji klasy Formatter.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Znaczniki konwersji Wcześniej użyty łańcuch formatujący to zwykły String, wewnątrz którego znajdują się sekwencje interpretowane w specjalny sposób. Sekwencje te zawsze mają format: %[indeks argumentu$][flagi][szerokość][.precyzja]konwersjaWszystkie elementy otoczone nawiasami [] są opcjonalne więc w najprostszej wersji znacznik konwersji może mieć format %konwersja. Zwróć jeszcze raz uwagę na łańcuch formatujący Samouczek Programisty istnieje od %d roku. Wszystkie artykuły pisze %s.Jak widzisz znajdują się w nim dwa znaczniki konwersji. Są to %d i %s. Odnoszą się one do kolejnych argumentów metody format. W naszym przypadku są to literały 2015 i Marcin. Znaczniki konwersji informują instancję klasy Formatter w jaki sposób dodatkowe parametry powinny być sformatowane. Występuje wiele znaczników konwersji, te najczęściej używane podsumowane są w tabeli poniżej:             Znacznik      Typ argumentu      Działanie                  %b      dowolny      interpretuje argument jako wartość logiczną              %s      dowolny      interpretuje argument jako łańcuch znaków              %d      liczba całkowita      interpretuje argument jako liczbę całkowitą              %o      liczba całkowita      interpretuje argument jako liczbę całkowitą zapisaną w systemie ósemkowym              %x      liczba całkowita      interpretuje argument jako liczbę całkowitą zapisaną w systemie szesnastkowym              %f      liczba zmiennoprzecinkowa      interpretuje argument jako liczbę zmiennoprzecinkową              %%      -      nie potrzebuje argumentu, jest to sposób na umieszczenie znaku % wewnątrz sformatowanego łańcucha znaków              %n      -      nie potrzebuje argumentu, jest to sposób na umieszczenie znaku nowej linii wewnątrz sformatowanego łańcucha znaków      Indeks argumentu Metoda format przyjmuje łańcuch formatujący i parametry, które służą do wypełnienia znaczników formatujących. Jeśli chciałbyś użyć, któregoś obiektu wiele razy możesz użyć indeksu argumentu. Indeksy mają także zastosowanie jeśli chciałbyś użyć argumentów w innej kolejności. Numeracja argumentów zaczyna się od 1. Proszę spójrz na przykład poniżej: System.out.format(\"[%2$s] [%1$s] [%1$s]\", \"pierwszy argument\", \"drugi argument\");Po uruchomieniu tego kodu na konsoli zostanie wyświetlony napis: [drugi argument] [pierwszy argument] [pierwszy argument]Argument z numerem 1 użyty jest dwa razy, argument 2. użyty jest jako pierwszy w łańcuchu formatującym. Szerokość Możesz także określić minimalną szerokość jaką powinien zająć argument. Domyślnie zostanie on wyrównany do prawej. Proszę spójrz na przykład poniżej: System.out.format(\"[%10s] [%3s]\", \"test\", \"test\");Pierwszy fragment będzie uzupełniony sześcioma spacjami. Dzieje się tak ponieważ test ma cztery znaki a minimalna szerokość to 10. Zauważ, że w drugiej części gdzie minimalna szerokość to 3 żadne dodatkowe spacje nie zostały dodane. [      test] [test]Precyzja Dodatkowo dla liczb zmiennoprzecinkowych możesz określić precyzję. Dodając ten modyfikator określasz ile liczb po przecinku powinno być wyświetlonych1. Jeśli precyzja zostanie pominięta użyta jest domyślna wartość - sześć miejsc po przecinku. Proszę spójrz na przykład poniżej: double x = 1.1234567890123;System.out.format(\"[%.10f] [%.3f] [%f]\", x, x, x);Na konsoli pokażą się trzy liczby. Pierwsza z nich zawiera 10 liczb po przecinku, druga 3 a ostatnia domyślne 6: [1.1234567890] [1.123] [1.123457]Flagi Flagi modyfikują zachowanie znaczników konwersji. Poniżej opiszę kilka dostępnych flag:   - element będzie wyrównany do lewej strony,  + liczba zawsze będzie zawierała znak (nawet jeśli jest dodatnia),  0 liczba będzie uzupełniona 0 do żądanej szerokości,  ( liczby ujemne nie będą prezentowane ze znakiem,  , użyj separatora do grupowania liczb. Separator ten zależy jest od lokalizacji.Jeden znacznik może zawierać kilka flag. Dodatkowo wszystkie opisane wcześniej elementy mogą być połączone ze sobą. Lokalizacja W uproszczeniu lokalizacja to zbiór reguł, które określają w jaki sposób w należy prezentować dany łańcuch znaków. Można powiedzieć, że jest to swego rodzaju tłumaczenie na reguły obowiązujące w danym kraju/regionie. To lokalizacja ma wpływ na to jak na przykład wyświetlane są na daty czy liczby. Do tej pory w całym artykule używałem metod, które używały domyślnej lokalizacji, możesz ją uzyskać odwołując się do metody Locale.getDefault. Formatter pozwala także na formatowanie łańcucha znaków używając innych ustawień lokalizacji. Proszę spójrz na przykład poniżej. Ta sama liczba prezentowana jest używając trzech różnych ustawień lokalizacji. Zwróć uwagę na to, że w każdym przypadku otrzymujemy różne wyniki: double someNumber = 12345.12;System.out.format(Locale.US, \"%,.2f%n\", someNumber);System.out.format(Locale.GERMAN, \"%,.2f%n\", someNumber);System.out.format(Locale.forLanguageTag(\"PL\"), \"%,.2f%n\", someNumber);12,345.1212.345,1212 345,12Wyniki różnią się separatorem dziesiętnym (. lub ,) i separatorem grup liczb (,, . lub ` `). Bardziej skomplikowany przykład Teraz masz już wystarczająco dużo informacji aby zrozumieć pierwszy przykład użyty na początku artykułu. Dla przypomnienia: %2$08.3f %3$(,08.3f %sRozkładając ten łańcuch formatujący na części widzisz trzy znaczniki formatujące:   %2$08.3f,  %3$(,08.3f,  %s.Rozkładając najbardziej skomplikowany z nich %3$(,08.3f na części pierwsze otrzymujemy:   %3$ odwołanie się do trzeciego argumentu,  ( otoczenie liczb ujemnych nawiasami (),  , użycie separatora grup liczb,  0 uzupełnienie liczby zerami,  8 ustawienie minimalnej szerokości wyświetlanej liczby na osiem znaków,  .3 wyświetlenie trzech miejsc dziesiętnych,  f konwersja liczby zmiennoprzecinkowej.Ćwiczenie do wykonania Plik CSV zawiera trzy kolumny oddzielone znakiem ,. Pierwsza kolumna zawiera imię, druga liczbę zmiennoprzecinkową trzecia dzień tygodnia. Twoim zadaniem jest wczytanie zawartości tego pliku i wyświetlenie jej w formie tabeli. Efekt, który chcesz uzyskać wygląda następująco: | Piotrek | 123.12  | poniedziałek || Tomek   | 321.30  | wtorek       || Marcin  | -123.12 | środa        || Wojtek  | -3.12   | czwartek     |Zachęcam Cię do rozwiązania zadania samodzielnie. Jeśli jednak będziesz miał problem z jego rozwiązaniem przygotowałem dla Ciebie przykładowe rozwiązanie. Dodatkowe materiały do nauki Artykuł ten to “skrót” dokumentacji dla klasy klasy Formatter. Jeśli chcesz dowiedzieć się czegoś więcej zachęcam do przeczytania dokumentacji tej klasy. Dodatkowo możesz także przejrzeć kod źródłowy wszystkich przykładów użytych w tym artykule. Podsumowanie W artykule przeczytałeś o formatowaniu łańcuchów znaków. Wiesz jak formatować liczby zmiennoprzecinkowe, poznałeś klasę Formatter wraz miejscami gdzie jest ona używana. Rozwiązując ćwiczenie wykorzystałeś całą wiedzę w praktyce. Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli masz jakieś pytania nie wahaj się zadać je w komentarzach. Jeśli nie chcesz pominąć kolejnych artykułów polub Samouczka na facebooku i dopisz się do newslettera. Do następnego razu.             Precyzję można także użyć na przykład wraz z %s, wtedy oznacza to maksymalną liczbę znaków do wyświetlenia. &#8617;       ","categories": ["Kurs programowania Java","DSP2017"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/formatter-formatowanie-lancuchow-znakow/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/05/12_formwatowanie_lancuchow_znakow_artykul.jpeg"},{
        "title": "Pogodynka - szkic interfejsu użytkownika",
        "excerpt":"Interfejs użytkownika Nadszedł czas na część, która sprawia mi najmniej frajdy. Mianowicie na pracę z interfejsem użytkownika. Odszedłem już od wprawy i nie śledzę do końca technologii/bibliotek związanych z fontendem. Dlatego też poszedłem tutaj po najmniejszej linii oporu. Mam świadomość, tego, że “dzisiejsze strony www robi się inaczej”, ale nie to jest celem tego projektu. W moim przypadku użyłem:   Highcharts - Rozbudowana biblioteka JavaScript do rysowania wykresów, świetnie nadaje się do mojego zastosowania. Licencja pozwala na darmowe użycie dla projektów niekomercyjnych,  Bootstrap - Ostylowanie strony, którego sam nie byłbym w stanie porządnie zrobić ;).Po dodaniu odpowiednich wpisów w DNS podstawową wersję strony możesz zobaczyć pod adresem http://pogodynka.pietraszek.pl. Będzie to też adres, pod którym dostępna będzie finalna wersja strony. Aktualnie strona to jedynie szkic, to co się zmieni to głównie kod JavaScript konfigurujący wykres aby pobierał dane z odpowiedniego miejsca. Aktualnie dane są na stałe wpisane w źródło strony, co nie jest oczywiście docelowym rozwiązaniem ;).         Pogodynka - interfejs użytkownika.  HTML i CSS znajdziesz na samouczkowym githubie. Sam wygląd strony do złudzenia przpomina jeden z przykładów ze strony Bootstrapa obcięty do moich potrzeb. Serwer WWW Tutaj wybór był prosty, zdecydowałem się na de facto standard obowiązujący w “branży”. Prosta instancja nginx serwująca statyczne strony HTML wydała się najprostszym rozwiązaniem. Podsumowanie Muszę jeszcze popracować nad spięciem wszystkich elementów w całość, został mi na to tydzień. Trzymajcie kciuki ;). Zostało też “kilka” brakujących funkcjonalności i finalne testy. Mówi się, że tego typu praca pochłania 80% czasu. Zobaczymy czy zasada 80/20 sprawdzi się i tym razem. Do następnego razu! ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pogodynka-szkic-interfejsu-uzytkownika/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/05/14_pogodynka_09_artykul.jpeg"},{
        "title": "Pogodynka - integracja",
        "excerpt":"Jak wspomniałem wyżej większość zmian związanych było z konfiguracją i integracją poszczególnych komponentów. Zacznę od serwera HTTP. nginx Jak wspomniałem w jednym z poprzednich raportów nie chcę rozdmuchiwać kosztów projektu. Nie chciałem też pisać warstwy widoku w oparciu o JSP. Mógłbym statyczne strony HTML zawrzeć w pliku WAR, jednak nie podoba mi się to rozwiązanie. Moim zdaniem nie jest to podejście, w którym teraz tworzy się nowe strony WWW. Przy jednym pliku WAR miałbym monolityczną aplikację. Przy podejściu, które zastosowałem mam osobną warstwę z interfejsem użytkownika i osobną, która serwuje dane. Aby obsłużyć taką konfigurację i używać wyłącznie jednej instancji VPS (ang. Virtual Private Server) użyłem serwera nginx. Na tej samej instancji uruchomiony jest serwer Tomcat. W związku z konfiguracją firewall’a na tej maszynie nie jest on jednak dostępny bezpośrednio. nginx skonfigurowałem jako “reverse proxy”. Sprowadza się to do tego, że część żądań przesyłana jest przez nginx to Tomcata. Pozostała część to serwowanie statycznych stron. W uproszczeniu konfiguracja ta podobna jest do tej pokazanej na diagramie poniżej:         Nginx - reverse proxy.  Interfejs użytkownika wykorzystywał będzie aplikację webową do pobrania informacji o dotychczasowych odczytach temperatury. PostgreSQL Baza danych, którą skonfigurowałem do pracy z projektem nie nadaje się na produkcję. Mowa tu o HyperSQL. Do produkcyjnego działania potrzebna jest baza z prawdziwego zdarzenia. I tak pojawił się PosgreSQL. Przy pomocy puppet’a skonfigurowałem serwer bazy danych, utworzyłem bazę i dodałem odpowiednich użytkowników. Użytkownik, którego używam w aplikacji ma uprawnienia tylko do części elementów. Konfigurację możesz zobaczyć na githubie. Dodatkowo sama baza danych zainstalowana jest na tym samym VPS co Tomcat. Dzięki temu nie ma potrzeby “otwierać” bazy danych na świat. Dostępna jest ona wyłącznie lokalnie. Zapewnia to sama konfiguracja PostgreSQL oraz reguł firewall’a. Raspberry PI Stwierdziłem, że skoro mam już Puppeta to wykorzystam go także po stronie Raspberry PI. Podzieliłem manifesty w ten sposób, że konfiguracja Malinki także jest jasno opisana. Całość znajduje się w pliku node_thermometer.pp. Dzięki takiemu podejściu mam spójny sposób na konfigurację wszystkich “serwerów” jakie używam. Dodatkowo nie muszę już manualnie zarządzać wpisami w crontab. Robi to za mnie puppet. Konfiguracja serwera Tomcat Aplikacje Datavault i Thermometer starałem się pisać w taki sposób aby móc udostępnić kod publicznie. Ma to pewne konsekwencje. Mianowicie pewne elementy takie jak hasła nie powinny być publicznie dostępne. Aby to obejść użyłem zmiennych środowiskowych. Używam takiej zmiennej na przykład aby pobrać hasło użytkownika bazy danych. Zmienne te są ustawione na serwerze za pomocą puppet’a. Ich wartość pobierana jest za pośrednictwem mechanizmu hiera (opisałem go w jednym z poprzednich artykułów opisujących projekt Pogodynka) więc nie są to dane dostępne publicznie. Zmiany w kodzie Jak wspomniałem zmian w kodzie Javy było niewiele. Można je podzielić na dwie części:   wspólne interfejsy,  uwierzytelnianie.Wspólne interfejsy Pogodynka składa się z trzech modułów: Datavault, Thermometer i Frontend. Thermometer wysyła dane do Datavault używając zapytania HTTP. Zapytanie to zawiera dane w formacie JSON. W aplikacji Thermometer wysyłałem dane sformatowane w trochę inny sposób niż było to oczekiwane przez Datavault. Jako konsekwencja Datavault zwracał odpowiedzi ze statusem 400 na każde żądanie wysłane z Thermometer. Uwspólnienie formatu rozwiązało problem. Uwierzytelnianie Chociaż dane z termometru są publicznie dostępne to powinny być dostępne wyłącznie do odczytu. Możesz to sprawdzić otwierając stronę pogodynki. Zależy mi na tym aby te dane były rzetelne. Sprowadza się to do tego, że tylko określeni użytkownicy powinni móc dodawać informacje o aktualnych odczytach. Nie chciałem zbytnio komplikować mechanizmu uwierzytelniania/autoryzacji więc poszedłem po najmniejszej linii oporu. Mianowicie przy żądaniu wysyłającym nowy pomiar sprawdzana jest zawartość pewnego nagłówka. Jeśli zawartość ta jest błędna żadne dane nie są dodawane do bazy. W odpowiedzi wysyłany jest kod 403. Ta tajna wartość nagłówka również przechowywana jest w zmiennej środowiskowej. Brakujące elementy Czujnik zewnętrzny Aktualnie całość działa w oparciu o czujnik wewnętrzny. Takie podejście raczej nie przejdzie próby deszczu ;). Kupiłem czujnik zewnętrzny, Mam nadzieję, że jutro już będzie uruchomiony.         Woododporny czujnik temperatury.  Interfejs użytkownika Chociaż szablon interfejsu użytkownika jest już dostępny, nie jest on prawidłowy. Aby miał on sens musi pobierać dane o temperaturach z Datavault. Właśnie na tej części skupię się w przeciągu najbliższych dni. Podsumowanie Integrację mogę uznać za ukończoną. Monitoring całości opisany w początkowych odcinkach także działa. Zostały ostatnie szlify. Myślę, że mam duże szanse ukończyć projekt w terminie. Konkurs “Daj się poznać” trwa do 31.05.2017 więc zostało jeszcze parę dni. Trzymajcie kciuki i do następnego razu! ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pogodynka-integracja/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/05/23_pogodynka_integracja_artykul.jpeg"},{
        "title": "Pogodynka - podsumowanie",
        "excerpt":"Jeśli chcesz przeczytać więcej na temat samego projektu i jego założeń zapraszam do przeczytania pozostałych artykułów opisujących projekt. Mistrz lutownicy ucieka Aby mieć sensowne odczyty temperatury musiałem użyć czujnika zewnętrznego. Jest on odporny na wilgoć więc nie powinno być problemu z odczytem temperatury w trakcie deszczu. Mistrzem lutownicy na pewno nie jestem, ale finalny efekt nie wyszedł najgorzej.         Lutowanie czunika temperatury.  Na zdjęciu możesz zobaczyć opornik przylutowany do czujnika temperatury. Profile Spring w aplikacji Datavault Aplikacja webowa, która odpowiada za zapis i odczyt historycznych wskazań czujnika temperatury działa w kilku środowiskach. Pierwszym z nich jest środowisko developerskie. Kolejnym “produkcyjne”, w którym aplikacja jest dostępna z internetu. Oba te środowiska różnią się między sobą. Jedną z różnic jest konfiguracja bazy danych. W związku z tym użyłem profili udostępnionych przez Springa. Profil wybierany jest na podstawie jednego z parametrów przekazywanych podczas uruchomienia wirtualnej maszyny Javy. Dzięki temu bez zmieniania kodu aplikacji mogę użyć tego samego pliku war w różnych środowiskach. Średnia dobowa temperatura Użytkownik, dla którego pisałem tę aplikację (mój ociec ;)), wspomniał o paru funkcjonalnościach, które byłby przydatne. Główną z nich jest możliwość udostępnienia średniej dobowej temperatury. W meteorologii temperatura ta jest średnią z odczytów z godzin 1, 7, 13 i 19. W przypadku Pogodynki malinka wysyła odczyty temperatury co godzinę. Oczywiście jest to pomiar z “drobnym poślizgiem”, na przykład z godziny 13:00:05 a nie 13:00:00. Średnią dobową obliczam na etapie pobierania danych z bazy danych używając następującego zapytania SQL:   SELECT day,         SUM(temperature) / COUNT(temperature) AS daily_average    FROM (SELECT DATE(when_measured) AS day,                 EXTRACT('hour' FROM when_measured) AS hour,                 temperature            FROM temperature_measurements           WHERE EXTRACT('hour' FROM when_measured) IN (1, 7, 13, 19)             AND EXTRACT('minute' FROM when_measured) &lt; 2) AS daily_tempsGROUP BY dayNastępnie wyniki tego zapytania udostępnione są w formie dokumentu JSON. Tak sformatowane dane są następnie wykorzystywane przez interfejs użytkownika. Interfejs użytkownika Kilka ostatnich dni poświęciłem na pracę nad interfejsem użytkownika. Całość sprowadzała się do eksperymentów z JavaScript i API biblioteki Highcharts. Właśnie tej biblioteki użyłem do pokazywania historycznych wykresów temperatury. Finalny efekt pracy wygląda następująco:         Pogodynka - interfejs użytkownika.  Podsumowanie projektu W trakcie pracy nad projektem udało mi się zrealizować większość początkowych założeń. Projekt udało mi się “dowieźć” w terminie. Trello, którego używałem do śledzenia zadań w projekcie pokazuje dokładnie w jakim etapie jestem etapie. Jest bardzo dobrze :). Chociaż całość mogę określić jako “udany projekt” mam świadomość pewnych niedociągnięć. Głównym z nich jest brak testów integracyjnych dla aplikacji Datavault. Podejrzewam, że znalazłbym kilka błędów po napisaniu odpowiedniego zestawu testów/ Muszę też powiedzieć, że zdecydowanie nie doszacowałem części związanej z integracją i konfiguracją. Praca nad modułami puppeta zajęła mi sporo czasu. Podsumowując całość w jednym zdaniu. Bardzo się cieszę, że Pogodynka zakończyła się sukcesem :). W przyszłości planuję realizację innych projektów tego typu. Może chciałbyś zobaczyć konkretny projekt realizowany w ten sposób? Daj znać w komentarzac, razem na pewno uda się nam wybrać coś ciekawego :). ","categories": ["DSP2017","Projekty","Pogodynka"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pogodynka-podsumowanie/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/05/28_pogodynka_podsumowanie_artykul.jpeg"},{
        "title": "Od zera do developera, czyli jak zostać programistą",
        "excerpt":"Nie ma dróg na skróty Napiszę to w pierwszym akapicie. Moim zdaniem jest to bardzo ważny punkt, który wielu pomija. Programowanie nie jest łatwe. Nauka programowania tym bardziej nie jest łatwa. Wymaga od Ciebie zaangażowania, często również sporo poświęcenia. Jeśli aktualnie pracujesz i chcesz zmienić swój profil jesteś w jeszcze cięższej sytuacji. Jak to mówią, “nikt nie powiedział, że będzie łatwo i słowa dotrzymał”. Z nauką programowania jest jak z nauką języków obcych. Są ludzie, którzy mają swego rodzaju dar i przychodzi im to łatwiej. Znakomita większość (w tym ja) musi spędzić mnóstwo czasu żeby przyswoić tę wiedzę. Jeśli liczysz na to, że kupisz kurs, przeczytasz dwie książki i zostaniesz programistą muszę wyprowadzić Cię z błędu. Tak nie będzie. Tylko Twoja ciężka praca może doprowadzić Cię do celu. Materiały w internecie mogą Ci w tym pomóc, nakierować na pewien tor. Na pewno nie zastąpią Twojej pracy. Ona po prostu jest niezbędna. Jeśli masz słomiany zapał (jak ja) to też nie jesteś na uprzywilejowanej pozycji. Będzie ciężko, ale będzie też mnóstwo satysfakcji jeśli osiągniesz cel, który sobie założyłeś. Jeśli nie masz zamiaru ciężko pracować żeby zostać programistą zamknij tę zakładkę przeglądarki. Jeśli tak jest to szkoda Twojego czasu, nie ma sensu czytać dalej. Full stack Java developer Określenie “programista” czy “developer” jest bardzo szerokie. Kryje w sobie mnóstwo technologii i ścieżek, które możesz wybrać. A może “programista Java”? Programista Java niestety także nie jest wystarczająco specyficzne. Skupię się zatem na profilu, który moim zdaniem aktualnie jest jednym z najczęściej poszukiwanych na rynku pracy “full stack Java developer”. Czym zajmuje się szablonowy “full stack Java devloper”? Jest to programista, który rozwija aplikacje webowe. Zajmuje się zarówno warstwą interfejsu użytkownika jak i kodem wykonywanym po stronie serwera. Dalsza część artykułu opisuje właśnie ten typ stanowiska wraz z zakresami wiedzy, które powinieneś opanować. Rzeczy, które opiszę poniżej dotyczą profilu idealnego kandydata. Jest tego dużo, jednak nie zrażaj się. Firmy bardzo często patrzą na potencjał nie na aktualny zestaw umiejętności. Wiedza ogólna Składnia języka Java Podstawą jest znajomość składni języka Java. Obsługa wyjątków, pętle, instrukcje warunkowe, adnotacje czy “lambdy” - wszystko co związane jest z samym językiem programowania. Wiedzę z tego zakresu możesz zdobyć przerabiając artykuły zebrane w ramach kursu języka Java.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Biblioteka standardowa Bez znajomości biblioteki standardowej nie będziesz mógł efektywnie pracować z kodem źródłowym. Znajomość kolekcji czy wyrażeń regularnych świetnie pasuje do tej kategorii. Dobrym sposobem na ćwiczenie tej umiejętności jest rozwiązywanie zadań. Sporo zadań z przykładowymi rozwiązaniami znajdziesz na blogu. Biblioteki narzędziowe Tutaj mam na myśli najczęściej używane biblioteki, które rozszerzają możliwości biblioteki standardowej na przykład Guava, Apache Commons czy Joda. Nie chodzi mi tu o zapamiętanie całego API dostępnego w tych bibliotekach, chodzi o samą świadomość ich istnienia i możliwości użycia w projektach. Jako przykład mogę podać Ci jeden z projektów, który realizowałem. Pogodynka także dostępna jest na githubie gdzie możesz przejrzeć kod źródłowy tego projektu. IDE Do efektywnej pracy z językiem Java niezbędne jest IDE. Czy to będzie Idea, Eclipse, Netbeans czy cokolwiek innego - nie ma to znaczenia. Istotne jest abyś swobodnie pracował z IDE. Znajomość skrótów klawiaturowych czy możliwości IDE są bardzo przydatne. Tę umiejętność także rozwiniesz przez praktykę. W większości IDE są wtyczki, które wspierają pracę ze skrótami klawiaturowymi. Pracując z Eclipse używałem wtyczki mousefeed. Teraz z Ideą bardzo często używam funkcjonalności Search Everywhere (Shift + Shift) lub Navigate to Action (Ctrl + Shift + A). System kontroli wersji System kontroli wersji to mechanizm ułatwiający pracę z kodem. W systemie tym zapisuje się historyczne wersje plików, dzięki temu w łatwy sposób możemy śledzić zmiany. System ten pomaga także przy pracy zespołowej nad jednym fragmentem kodu. Standardem w większości firm jest Git, zdarzają się też firmy, które używają SVN czy innych bardziej “egzotycznych” systemów. Proponowałbym zacząć do Git’a. Jeśli jesteś początkującym zachęcam do zajrzenia na jeden z interaktywnych kursów gita:   http://gitreal.codeschool.com,  https://try.github.io/levels/1/challenges/1.Testy jednostkowe Umiejętność pisania testów jednostkowych jest bardzo przydatna. Jeśli będziesz mógł się pochwalić znajomością bibliotek takich jak JUnit, Mockito czy Hamcrest będzie bardzo dobrze. Sam używam tej trójki przy pisaniu testów. Jeśli ta tematyka Cię interesuje napisałem artykuł wprowadzający do testów jednostkowych i metodyki TDD. Biblioteki, specyfikacje i technologie Interfejs użytkownika Aplikacje webowe posiadają interfejs użytkownika. W zależności od projektu, w którym będziesz pracował do jego tworzenia mogą wykorzystywane być różne technologie. Jest jednak pewien zestaw minimum, który zawsze powinieneś znać. Chodzi mi tu o podstawy HTML, CSS i JavaScript. Jako początkujący wystarczy, że znasz podstawy tych technologii. Im jesteś bardziej doświadczony poznasz kilka bibliotek JavaScript używanych przy pracy z interfejsem użytkownika. Osobiście bardzo zaniedbuję ten obszar. Sam musisz zobaczyć co Ci bardziej odpowiada :). Kod wykonywany na serwerze Pracując z aplikacjami webowymi w Javie będziesz miał styczność z servletami. Powinieneś poznać mechanizm ich działania wraz z ich ograniczeniami. Przechodząc przez serię artykułów na temat programowania webowego w Javie poznasz specyfikację serwletów. Spring MVC Spring MVC jest bardzo popularny. Używany jest w dużej liczbie projektów. Dokumentacja tylko do tej biblioteki to kilkaset stron tekstu. Nikt od początkującego nie będzie wymagał cudów. Jeśli będziesz potrafił stworzyć prostą aplikację webową opartą o kilka kontrolerów jesteś na dobrej drodze. Jako przykład może posłużyć Ci Pogodynka, którą realizowałem na blogu. Bazy danych Większość aplikacji webowych zapisuje dane w bazach danych. Powinieneś wiedzieć czym są relacyjne bazy danych. Takie rzeczy jak klucz główny, klucz obcy, indeks czy rodzaje złączeń nie powinny Cię zaskakiwać. Powinieneś także konstruować proste zapytania z użyciem GROUP BY, HAVING, ORDER BY i JOIN. ORM (ang. Object-Relational Mapping) Po Spring MVC mamy tu kolejnego mocnego gracza. Chodzi o Hibernate. Jest to de facto standard w branży. Także i tutaj dokumentacja to kilkaset stron. Moim zdaniem na początek umiejętność zmapowania relacji wiele do wielu powinna wystarczyć. Resztę przeczytasz w dokumentacji jak będziesz tego potrzebował. Programowanie to nie tylko technologia Język angielski Większość materiałów pomagających przy nauce programowania napisana jest w języku angielskim. Jeśli nie wiesz od czego zacząć podszlifuj angielski do poziomu gdzie czytanie dokumentacji technicznej nie jest problemem. Praca zespołowa Rzadko zdarzają się projekty, które możesz zrealizować samodzielnie. Szczególnie jeśli jesteś początkującym programistą. Programowanie to praca zespołowa. Musisz umieć pracować w zespole. Jak się tego nauczyć? Jak zwykle praktyka jest najlepsza, wcale nie trzeba ćwiczyć tej umiejętności w projekcie programistycznym. Równie dobrze można pracować zespołowo na aplikacją webową jak i innym projektem spoza działki IT. Przyjmowanie krytyki Programiści czasami potrafią być straszni. Część osób (w tym ja) ma problem z przyjmowaniem krytyki. Niestety jest to spora wada. Musisz koniecznie się tego oduczyć! Jeśli ktoś krytykuje Twoją pracę postaraj wyciągnąć od tej osoby jak najwięcej informacji. Szczególnie sposobu naprawienia danego błędu. Pamiętaj też, że krytykujące nie zawsze musi mieć rację. Niemniej jednak zawsze warto go wysłuchać aby poznać inny punkt widzenia. Sprzedaż No tak… W końcu nadchodzi czas na pierwszą rozmowę kwalifikacyjną. Rozmowa to nic innego jak sprzedawanie swojego czasu przyszłemu pracodawcy. Jeśli potrafisz ten czas sprzedać i pasujesz do zespołu dostaniesz pracę.W tym punkcie można też zawrzeć CV i jego przygotowanie. Tutaj odsyłam Cię do materiałów w internecie - są ludzie, którzy poradzą Ci jak to zrobić dużo lepiej ode mnie ;). Podsumowanie Jak wspomniałem na początku artykułu programowanie nie jest łatwe. Jego nauka także nie. Szczególnie, że materiału do opanowania jest sporo. W artykule tym starałem się zebrać dla Ciebie listę zagadnień, które są istotne w pracy jako “junior full-stack Java developer”. A może uważasz, że pominąłem coś istotnego? Daj znać w komentarzach co sądzisz o tej liście. Mam nadzieję, że artykuł przypadł Ci do gustu. Proszę podziel się nim ze swoimi znajomymi, może ktoś z nich zechce nauczyć się programowania? Jeśli nie chcesz pominąć kolejnych artykułów dopisz się do samouczkowego newsletera i polub stronę na facebooku. Do następnego razu! ","categories": ["Programowanie","Początkujący programista"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/od-zera-do-developera-czyli-jak-zostac-programista/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/07/09_od_zera_do_developera_artykul.jpeg"},{
        "title": "Jak dostać pierwszą pracę jako programista",
        "excerpt":"Na początku chciałbym zaznaczyć, że nie jestem profesjonalnym rekruterem. Mimo tego miałem przyjemność brać udział w wielu rekrutacjach weryfikując umiejętności kandydatów. Przed napisaniem tego artykułu rozmawiałem też z kilkoma kolegami, którzy także takie rozmowy przeprowadzali. Udało mi się też dotrzeć do kilku rekruterów z firm pośredniczących w zatrudnianiu programistów. Opinie przedstawione w tym artykule pochodzą z tych właśnie rozmów. Nie poddawaj się Na początku historia prawdziwa, żeby podnieść Cię na duchu ;). Otrzymanie pierwszej pracy wcale nie musi być łatwe. Dla mnie na pewno nie było. Sam wysłałem kilkadziesiąt (sic!) CV zanim dostałem się do mojej pierwszej pracy. Byłem wtedy na przełomie trzeciego i czwartego roku studiów. Moje CV wyglądało, delikatnie mówiąc, tragicznie. Teraz wiem, że wymagało wielu poprawek. Mimo tego, że wysyłałem je masowo odzew był znikomy. Nie przeszedłem też kilku rozmów, zanim udało mi się znaleźć pierwszą pracę. Nie jest to historia zmyślona na potrzeby artykułu. Tak rzeczywiście było. Brak odzewu i wysłanie tych kilkudziesięciu CV to prawda. Nie było mi łatwo znaleźć pierwszą pracę w branży, jednak od tamtej pory nie miałem z tym żadnego problemu. Dostać pracę bez komercyjnego doświadczenia może być trudno. Kilka wskazówek poniżej może Ci w tym pomóc. Nie strzelaj ze śrutówki Kiedyś usłyszałem ciekawy termin dotyczący masowego wysyłania ofert do kandydatów - “shotgun recruiting”. Shotgun recruiting jest jak spam. Nikt tego nie lubi. Historia, którą przytoczyłem na początku to nic innego jak shotgun recruiting w wykonaniu kandydata. Masowe wysyłanie tego samego CV do całej masy firm moim zdaniem jest błędem. Lepiej będzie jak przejrzysz dostępne oferty i dopasujesz swoje umiejętności do firmy, w której chcesz pracować. Znajdź firmę, na której Ci zależy. Dopracuj swoje CV w ten sposób aby odpowiadało wymaganiom stawianym w tej firmie. Rekruterzy sprawdzają czy miałeś już jakiekolwiek doświadczenie z technologiami wykorzystywanym w danym projekcie. Jeśli takiego doświadczenia nie masz to zacznij dziubać projekt, który te technologie wykorzystuje.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Nie ma idealnego kandydata Duża część ogłoszeń opisuje idealnego kandydata. Nie zrażaj się jeśli nie znasz części technologii wykorzystywanych w danym projekcie. Często pracodawca opisuje kogoś kto jest idealny dla danego stanowiska. Ideałów nie ma. Wszyscy jesteśmy ludźmi i mamy prawo nie wiedzieć wszystkiego. Ponadto jeśli pracodawca od początkującego programisty wymaga znajomości szeregu technologii jest oderwany od rzeczywistości. Zapomniał wół jak cielęciem był… Bądź aktywny W dużych miastach, gdzie rynek IT jest mocny programiści spotykają się dość często. Na tyle często, że jeśli chciałbyś chodzić na te wszystkie spotkania nie starczyłoby Ci czasu na nic innego ;). W trakcie takich spotkań przedstawiane są tematy związane z IT. Zacznij chodzić na spotkania programistów, słuchaj wykładów na tych spotkaniach. Zadawaj pytania i wdawaj się w dyskusje. Poszukaj już dzisiaj, może i w Twoim mieście są spotkania, które będą dla Ciebie interesujące? Na stronie www.meetup.com powinieneś znaleźć coś dla siebie. We Wrocławiu zdarzało mi się chodzić na spotkania programistów Javy, Rubiego czy Go. Musisz wiedzieć, że dużo takich spotkań to nic innego jak rekrutacja :). Z racji dużej konkurencji na rynku IT firmy organizują takie spotkania aby przyciągnąć do siebie programistów. Na tych spotkaniach możesz także poznać pracowników rekrutujących programistów. Niestety ostatnio na takich spotkaniach zjawiam się rzadziej, jeśli jednak potrzebujesz inspiracji możesz rzucić okiem na mój profil na meetupie. Znajdziesz tam kilka moim zdaniem ciekawych grup we Wrocławiu. Twoje nastawienie jest kluczowe Wspominałem wcześniej o byciu aktywnym w społeczności. Podobnie jest z aktywnością w miejscu pracy. Dużo się mówi o bycie proaktywnym. Powinieneś zawojować pracodawcę próbą wykazywania inicjatywy i głowy otwartej na nowe pomysły. Rekruterzy w trakcie rozmowy kwalifikacyjnej szukają takiej umiejętności. Często pracodawcy zatrudniają programistów mimo braku znajomości wymaganych technologii. Mówi się wtedy o tym, że widać w kimś potencjał. Ten potencjał to właśnie wykazywanie własnej inicjatywy. Pokaż w CV swoje zaangażowanie. Mogę tu posłużyć jako przykład, dostałem pracę jako programista Pythona w ogóle nie znając tego języka. Pracuję w tej firmie do dzisiaj (17.07.2017). Nie masz doświadczenia zawodowego? Trudno, pokaż, że potrafisz się w coś zaangażować. Zgłoś się jako wolontariusz na jakiejś konferencji organizowanej w Twoim mieście, zorganizuj meetup, cokolwiek :). Sam pomagałem przy organizacji jednej z edycji wroc_love.rb czy byłem wolontariuszem/wykładowcą na Devoxx4Kids we Wrocławiu. Oczywiście wymaga to Twojego czasu i zaangażowania. Wyznaję zasadę, że nie ma dróg na skróty, musisz zapracować na swoją pierwszą pracę :). Przygotuj Twoje CV pod pracodawcę Wątek ten przewijał się wcześniej, jednak wymaga osobnego akapitu. Znasz treść ogłoszenia pracodawcy. Twoje CV ma być ofertą, która zachęca do rozmowy z Tobą. Powinno pokrywać część (w idealnym świecie wszystkie) wymagań pracodawcy. Jeśli tak nie jest to zacznij pracować nad projektem, który wykorzysta wymagane technologie. Pokazanie efektów Twojej pracy na gotowym projekcie jest dużo lepsze niż “suche” wypisanie nazw technologii. Posługuj się przykładami Określenia w stylu “potrafię pracować zespołowo” czy “szybko się uczę” są słabe. Pokaż to na przykładzie. Lepiej jest jeśli napiszesz “potrafię pracować w zespole, w grupie zrealizowałem projekt X” albo “szybko się uczę, napisałem projekt Y w miesiąc wcześniej nie mając doświadczenia w tej technologii”. Rekruterzy przychylniej patrzą na osoby, które potrafią poprzeć swoje umiejętności przykładami. Dziub swój projekt Jest to niejako powiązane z posługiwaniem się przykładami i byciem aktywnym. Przez twoje działanie pokazujesz, że potrafisz dociągnąć coś do końca. Zaczynanie rzeczy jest proste, gorzej jest z ich ukończeniem, dowożeniem do końca ;). Poza tym dziubanie swojego projektu daje Ci coś co jest bardzo cenne. Daje Ci doświadczenie, którego pracodawca poszukuje. Jeśli to doświadczenie dotyczy technologii, które są ważne dla pracodawcy, tym lepiej. Nie kłam w CV Nie wymyślaj rzeczy niestworzonych. Twoje CV będzie zweryfikowane. Nawet jeśli uda Ci się przekonać pracodawcę na rozmowie, to kłamstwo ma krótkie nogi. W codziennej pracy stan Twojej wiedzy będzie widoczny jak na dłoni. Masz prawo nie wiedzieć wszystkiego, ale nie masz prawa pisać, że wiesz wszystko. Odrób zadanie domowe Jeśli Twoje CV zostało wybrane spośród pozostałych to jesteś na dobrej drodze. Nogę w drzwi już wsadziłeś ;). Teraz czas na odrobienie zadania domowego, jeśli nie zrobiłeś tego wcześniej. Dowiedz się z kim będziesz miał rozmowę kwalifikacyjną. Znajdź tę osobę w sieciach społecznościowych, poczytaj o niej na linkedin czy goldenline. Dobrze jest znać swojego „przeciwnika” ;). Dużo lepiej rozmawia się z kimś kogo “znamy”. Dowiedz się więcej o samej firmie, poznaj ich produkty i projekty. Najlepiej byłoby, gdyby udało Ci się porozmawiać z kimś pracującym w tej firmie. Wbrew pozorom programiści czasami lubią pomagać :). Jeśli jasno dasz do zrozumienia na czym Ci zależy jestem pewien, że uda Ci się znaleźć kogoś kto Ci pomoże. W ten sposób uzyskasz odpowiedzi na Twoje pytania. A może uda Ci się dowiedzieć czegoś więcej na temat samego procesu rekrutacji? Rozmowa kwalifikacyjna Prezentacja na rozmowach kwalifikacyjnych to też umiejętność. Jak każda inna wymaga ćwiczeń, żeby ją opanować. Innymi słowy kolejna rozmowa pójdzie Ci lepiej niż poprzednia. Na poprzedniej nauczyłeś się już kilku rzeczy, zdobyłeś jakieś doświadczenie w odbywaniu rozmów kwalifikacyjnych. Nie zrażaj się, jeśli nie uda Ci się przejść przez rozmowę kwalifikacyjną. Często jest tak, że fakt zatrudnienia to składowa kilku czynników. Może się zdarzyć, że nie będzie „chemii” pomiędzy Tobą a rekrutującym. To jest normalne. Jeśli zależy Ci na tej pracy zapytaj kiedy możesz podejść do rozmowy po raz kolejny. Jak przyjdzie na to czas w trakcie rozmowy zadawaj pytania. Rozmowa kwalifikacyjna jest źródłem wiedzy dla obu stron. Może się okazać, że podejście pracodawcy do pracownika może Ci nie odpowiadać. Może obowiązkowe wyjazdy służbowe nie będą Ci pasowały? Rozmowa kwalifikacyjna to czas kiedy powinieneś upewnić się, że dany pracodawca jest dla Ciebie. Kilka wskazówek od rekrutera Rozmawiając z rekruterami udało mi się wysupłać kilka szczegółów, które warto zawrzeć w CV. Niestety część z nich jest często pomijana. Opisywałem je w poprzednich akapitach jednak taka wypunktowana lista może być pomocna:   dodaj swoje prywatne projekty do CV, nie zapomnij o wpisaniu używanych technologii,  wspomnij o swoim zaangażowaniu w organizacji różnych wydarzeń,  jeśli uczestniczyłeś w konferencjach programistycznych możesz także dodać to do CV,  jeśli jesteś studentem to uzupełnij CV o projekty realizowane na uczelni.Podsumowanie Postaram się streścić cały artykuł w kilku punktach. Punkty te powinny Ci pomóc dobrze przygotować swoje pierwsze CV i dobrze podejść do rozmowy kwalifikacyjnej:   wybierz pracodawcę, u którego chcesz pracować,  dowiedz się czegoś więcej o tej firmie,  dostosuj swoje umiejętności do jego wymagań,  nikt nie wie wszystkiego, nie zrażaj się jeśli nie spełniasz części wymagań,  bądź aktywny w społeczności programistów,  dziub projekt po godzinach ;).Na koniec życzę Ci powodzenia, mam nadzieję, że uda Ci się zdobyć Twoją pierwszą pracę w IT. Będzie mi bardzo miło, jeśli pochwalisz się tym w komentarzu. W każdym razie trzymam za Ciebie kciuki! ;) Jeśli artykuł ten był dla Ciebie pomocny będę wdzięczny jeśli podzielisz sie nim ze swoimi znajomymi. Może im też pomoże przy znalezieniu pierwszej pracy w IT? Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę dopisz się do newslettera i polub samouczka na facebooku. Trzymaj się! ","categories": ["Początkujący programista"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/jak-dostac-pierwsza-prace-jako-programista/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/07/17_jak_dostac_prace_jako_programista_artykul.jpeg"},{
        "title": "Wyrażenia lambda w języku Java",
        "excerpt":"  Artykuł ten dotyczy bardziej zaawansowanego fragmentu składni języka Java. Z tego powodu aby móc w pełni skorzystać z artykułu warto zapoznać się z wcześniejszymi artykułami, które dotyczą:   klas anonimowych,  typów generycznych,  adnotacji.Czym jest wyrażenie lambda Dla uproszczenia można powiedzieć, że wyrażenie lambda jest metodą1. Metodą, którą możesz przypisać do zmiennej. Możesz ją także wywołać czy przekazać jako argument do innej metody. Wyrażenia lambda możesz także porównać do klas anonimowych2. Mają one jednak dużo bardziej czytelną i zwięzłą składnię. Na przykład wyrażenie lambda, które podnosi do kwadratu przekazaną liczbę wygląda następująco: x -&gt; x * xSkładnia wyrażeń lambda Wyrażenie lambda ma następującą składnię &lt;lista parametrów&gt; -&gt; &lt;ciało wyrażenia&gt;Lista parametrów Lista parametrów zawiera wszystkie parametry przekazane do “ciała” wyrażenia lambda. W szczególności lista ta może być pusta. Wyrażenie lambda poniżej nie przyjmuje żadnych argumentów, zwraca natomiast instancję klasy String: () -&gt; “some return value”Podawanie typów parametrów jest opcjonalne. Kompilator jest w stanie poznać te parametry z kontekstu w którym znajduje się dane wyrażenie lambda. Jeśli chcesz możesz je także podać: (Integer x, Long y) -&gt; System.out.println(x * y)Nawiasy otaczające listę parametrów są opcjonalne jeśli wyrażenie ma wyłącznie jeden parametr bez określonego typu3. Ciało wyrażenia lambda W ogromnej większości przypadków wyrażenia lambda zawierają jedną linijkę kodu: x -&gt; x * x() -&gt; “some return value”(Integer x, Long y) -&gt; System.out.println(x * y);Może się jednak zdarzyć, że Twoje wyrażenie lambda będzie zawierało więcej linii. W takim przypadku musisz otoczyć je nawiasami {} jak w przykładzie poniżej: x -&gt; {    if (x != null &amp;&amp; x % 2 == 0) {        return (long) x * x;    }    else {        return 123L;    }}Można sobie wyobrazić wyrażenie lambda, które nie przyjmuje żadnych parametrów i nie zwraca żadnych wartości. Najprostsza wersja takiego wyrażenia wygląda następująco: () -&gt; {}Od klasy anonimowej do wyrażenia lambda Wiesz już czym jest klasa anonimowa. Dla przypomnienia powiem, że jest to stworzenie jedynej instancji klasy w miejscu jej użycia. Wiesz już też jak wyglądają wyrażenia lambda. Teraz nadszedł czas na zamianę klasy anonimowej na wyrażenie lambda. Proszę spójrz na przykład poniżej: public interface Checker&lt;T&gt; {    boolean check(T object);} Checker&lt;Integer&gt; isOddAnonymous = new Checker&lt;Integer&gt;() {    @Override    public boolean check(Integer object) {        return object % 2 != 0;    }}; System.out.println(isOddAnonymous.check(123));System.out.println(isOddAnonymous.check(124));W przykładzie tym zdefiniowałem interfejs Checker, który posiada jedną metodę check. Metoda ta zwraca wartość logiczną na podstawie przekazanego argumentu. Fragment kodu robiący to samo jednak przy użyciu składni wyrażeń lambda wygląda następująco: Checker&lt;Integer&gt; isOddLambda = object -&gt; object % 2 != 0; System.out.println(isOddLambda.check(123));System.out.println(isOddLambda.check(124));Prawda, że ładniej :)? Dochodzimy teraz do momentu, w którym muszę Ci powiedzieć o typach w wyrażeniach lambda. Każde wyrażenie lambda jest instancją dowolnego interfejsu funkcyjnego. Jest to bardzo ważne, dlatego też musisz dokładnie wiedzieć czym jest interfejs funkcyjny.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Interfejs funkcyjny Interfejs funkcyjny to interfejs, który ma jedną abstrakcyjną metodę4. Wprowadzono adnotację @FunctionalInterface, którą możesz dodać do interfejsów tego typu. Adnotacja ta zapewnia, że kompilator upewni się, że dany interfejs jest interfejsem funkcyjnym. Jeśli nie, wówczas kompilacja się nie powiedzie. Przykładem interfejsu funkcyjnego może być zdefiniowany wcześniej interfejs Checker. @FunctionalInterfacepublic interface Checker&lt;T&gt; {    boolean check(T object);}Zawiera on wyłącznie jedną metodę check. Przykładowe interfejsy funkcyjne Twórcy języka Java przygotowali zestaw interfejsów funkcyjnych, które możesz implementować. W większości przypadków w zupełności wystarczy ich użycie. Część z nich znajduje się w pakiecie java.util.function. Najważniejsze z nich zebrałem poniżej:   Function&lt;T, R&gt; zawiera metodę apply, która przyjmuje instancję klasy T zwracając instancję klasy R,  Consumer&lt;T&gt; zawiera metodę accept, która przyjmuje instancję klasy T,  Predicate&lt;T&gt; zawiera metodę test, która przyjmuje instancję klasy T i zwraca flagę. Interfejs ten może posłużyć do zastąpienia interfejsu Checker,  Supplier&lt;T&gt; zawiera metodę get, która nie przyjmuje żadnych parametrów i zwraca instancję klasy T,  UnaryOperator&lt;T&gt; jest specyficznym przypadkiem interfejsu Function. W tym przypadku typ argumentu i typ zwracany są te same.Wyrażenia lambda zdefiniowane na początku artykułu można przypisać do tych właśnie interfejsów: UnaryOperator&lt;Integer&gt; square = x -&gt; x * x;Supplier&lt;String&gt; someString = () -&gt; \"some return value\";BiConsumer&lt;Integer, Long&gt; multiplier = (Integer x, Long y) -&gt; System.out.println(x * y);Function&lt;Integer, Long&gt; multiline = x -&gt; {    if (x != null &amp;&amp; x % 2 == 0) {        return (long) x * x;    }    else {        return 123L;    }};Zalety stosowania wyrażeń lambda Wyrażenia lambda są bardzo pomocne przy operacji na kolekcjach. Są niezastąpione także przy pracy ze strumieniami. Pozwalają także na pisanie w Javie w sposób “funkcyjny”5. Oczywistą zaletą wyrażeń lambda jest ich zwięzłość. Kod zajmuje o wiele mniej miejsca, staje się przez to bardziej czytelny. Odwoływanie się do metod Wraz z wyrażeniami lambda Java została rozbudowana o składnię pozwalającą na odwoływanie się do metod. Służy do tego ::. Dzięki temu wyrażeniu możemy przypisać metodę do zmiennej bez jej wywołania. Takie podejście pozwala na przekazanie tak wyłuskanej metody i wywołanie jej w zupełnie innym miejscu. Proszę spójrz na przykład poniżej: Object objectInstance = new Object();IntSupplier equalsMethodOnObject = objectInstance::hashCode;System.out.println(equalsMethodOnObject.getAsInt());W przykładzie tym tworzę nową instancję klasy Object. Następnie pobieram metodę hashCode z tego obiektu i przypisuję ją do typu IntSupplier. Jest to kolejny interfejs funkcyjny znajdujący się w standardowej bibliotece. Ostatnia linijka to wywołanie metody znajdującej się w tym interfejsie. Kod powyżej można porównać do: Object objectInstance = new Object();System.out.println(objectInstance.hashCode());W obu przypadkach tworzę nowy obiekt klasy Object i wywołują na nim metodę hashCode. Odwoływanie się do metod bez podania instancji Można także odwołać się do metody bez podania instancji, na której metoda powinna być wywołana. Wówczas ta instancja musi być przekazana jako pierwszy argument. Przykład poniżej powinien pomóc zrozumieć to zastosowanie: ToIntFunction&lt;Object&gt; hashCodeMethodOnClass = Object::hashCode;Object objectInstance = new Object();System.out.println(hashCodeMethodOnClass.applyAsInt(objectInstance));W odróżnieniu do poprzedniego przykładu tutaj na początku pobieram metodę. Tym razem metoda nie jest przypisana do instancji. W związku z tym wyrażenie lambda jest już innego typu. W takim przypadku zawsze pierwszym argumentem jest instancja na której metoda powinna być wywołana. W kolejnej linijce tworzę instancję klasy Object. Ostatnia linijka to wywołanie metody na tej instancji. Kod bez użycia odwołania do metody robiący dokładnie to samo wygląda trochę mniej skomplikowanie: Object objectInstance = new Object();System.out.println(objectInstance.hashCode());Odwoływanie się do konstruktora Notacja z :: może być także użyta do odwołania się do konstruktora. W tym przypadku należy użyć :: wraz ze słowem kluczowym new. Proszę spójrz na przykład poniżej: Supplier&lt;Object&gt; objectCreator = Object::new;System.out.println(objectCreator.get());W pierwszej linijce przykładu przypisuje konstruktor klasy Object do zmiennej objectCreator. Kolejna linijka to wywołanie konstruktora. To samo bez użycia referencji metody możesz uzyskać w dobrze Ci znany sposób: System.out.println(new Object());Przykład zastosowania wyrażeń lambda i odwołania do metody Załóżmy, że chcemy wypisać na konsoli liczby znajdujące się w kolekcji. Możemy to zrobić przy pomocy standardowej pętli, którą już znasz: List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4); for (Integer number : numbers) {    System.out.println(number);}To samo zadanie można także zrobić przy pomocy wyrażeń lambda: List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);Consumer&lt;Integer&gt; integerConsumer = n -&gt; System.out.println(n);numbers.forEach(integerConsumer);Pierwsza linijka to utworzenie listy z liczbami. Kolejna jest bardziej ciekawa, zawiera wyrażenie lambda, które konsumuje liczbę wypisując ją na konsoli. Ostatnia to wywołanie metody forEach wraz z wyrażeniem lambda. Wyrażenie to zostanie wywołane dla każdego elementu. Kod ten można jeszcze bardziej skrócić używając mechanizmu odwoływania się do metod: List&lt;Integer&gt; numbers = Arrays.asList(1, 2, 3, 4);numbers.forEach(System.out::println);Efekt działania wszystkich trzech fragmentów jest dokładnie taki sam. Różnią się między sobą sposobem rozwiązania danego problemu. Zadania Na koniec mam dla Ciebie kilka zadań, które pomogą przećwiczyć Ci wiedzę z tego artykułu.   Napisz program, który pobierze o użytkownika cztery łańcuchy znaków, które umieścisz w liście. Następnie posortuj tę listę używając metody sort. Użyj wyrażenia lambda, które posortuje łańcuchy znaków malejąco po długości.  Napisz program, który wywoła funkcję equals na instancji klasy Object używając mechanizmu odwoływania się do metody (przy pomocy ::).  Utwórz instancję klasy Human przy pomocy mechanizmu odwoływania się do konstruktora (przy pomocy ::).public class Human {     private int age;    private String name;     public Human(int age, String name) {        this.age = age;        this.name = name;    }     public int getAge() {        return age;    }     public String getName() {        return name;    }}Jeśli będziesz miał problem z rozwiązaniem zadań możesz rzucić okiem na przykładowe rozwiązania, które umieściłem na samouczkowym githubie. Dodatkowe materiały do nauki Przygotowałem dla Ciebie zestaw kilku linków z materiałami dodatkowymi:   Wprowadzenie do wyrażeń lambda na stronie Oracle,  Tutorial dotyczący wyrażeń lambda na stronie Oracle,  Opis interfejsów funkcyjnych w JLS,  Referencja do metody w JLS,  Wyrażenia lambda w JLS.Podsumowanie Wyrażenia lambda nie są proste. Mogą powodować sporo zakłopotania, szczególnie na początku. Jeśli jednak się do nich przyzwyczaisz pisanie kodu z ich udziałem będzie sprawiało Ci sporo frajdy :). Po pewnym czasie docenisz też zwięzłość wyrażeń lambda. Po przeczytaniu artykułu wiesz czym są wyrażenia lambda i jak je stosować. Znasz też mechanizm odwoływania się do metod. Przećwiczyłeś te mechanizmy rozwiązując przykładowe zadania. Nie zapomnij pochwalić się w komentarzu gdzie ostatnio użyłeś wyrażeń lambda :). Na koniec mam do Ciebie prośbę. Jeśli uważasz, że artykuł ten był dla Ciebie pomocny proszę podziel się nim ze swoimi znajomymi. Zależy mi na dotarciu do jak największej grupy czytelników a Ty możesz mi w tym pomóc. Jeśli nie chcesz pominąć żadnego nowego artykułu dopisz się do samouczkowego newslettera i polub samouczka na Facebooku. Do następnego razu!             Nie jest to do końca prawda, na przykład wyrażenie lambda nie wprowadza nowego zakresu zmiennych, ale takie uproszczenie pomoże zrozumieć działanie wyrażeń lambda. &#8617;               Podobnie jak przy poprzednim porównaniu, są różnice pomiędzy wyrażeniami lambda i klasami anonimowymi. Jednak na potrzeby tego wprowadzenia możemy je pominąć. &#8617;               Oczywiście w trakcie kompilacji typ jest znany, ale nie jest jawnie podany w kodzie źródłowym. &#8617;               Efektywnie abstrakcyjną, czyli dodanie do interfejsu np. metody equals, która jest w klasie Object nadal spełnia to wymaganie. &#8617;               Oczywiście Java nie jest językiem w pełni funkcyjnym, jednak taka namiastka jest przydatna. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/wyrazenia-lambda-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/07/26_wyrazenia_lambda_artykul.jpeg"},{
        "title": "Modyfikatory dostępu w języku Java",
        "excerpt":"    Artykuł ten wymaga podstawowej wiedzy na temat języka Java. Z tego powodu, aby móc w pełni z niego skorzystać, warto zapoznać się z wcześniejszymi artykułami:   obiekty, klasy i pakiety w języku Java,  dziedziczenie w języku Java.    UWAGA Artykuł ten nie zawiera informacji na temat modułów. Moduły zostały wprowadzone do języka Java wraz z wersją 9. Moduły, podobnie jak modyfikatory dostępu także mają wpływ na widoczność. Operują one na pakietach. W artykule tym zakładam, że każdy z pakietów jest eksportowany przez moduł, w którym się znajduje. Więcej na temat modułów przeczytasz w osobnym artykule. Czym są modyfikatory dostępu Modyfikatory dostępu to słowa kluczowe, które mają wpływ na widoczność elementu który poprzedzają. Są to słowa kluczowe public, protected i private. Brak jakiegokolwiek ze wspomnianych słów kluczowych także ma wpływ na dostępność danego elementu. Czasami brak modyfikatora dostępu określa się jako dostęp typu “package”.Modyfikatory dostępu mogą być stosowane na przykład przed definicją klasy, czy interfejsu. Możemy ich także używać przed polami klasy, metodami czy typami wewnętrznymi. Rodzaje modyfikatorów dostępu Modyfikator public Słowo kluczowe public jest modyfikatorem dostępu, który pozwala na najbardziej swobodny dostęp do elementu, który poprzedza. public może być używane przed definicjami klas, pól w klasach, metod czy typów wewnętrznych. Zakładając, że klasa poprzedzona jest public i element w tej klasie jest także public, jest on dostępny dla wszystkich1. Poniższy fragment kodu pokazuje kasę PublicVisitCounter. Klasa ta implementuje licznik odwiedzin. Założenie jest takie, że każdy użytkownik wywoła metodę increment. Dzięki takiej klasie można w łatwy sposób zliczyć liczbę wizyt na stronie: package pl.samouczekprogramisty.kursjava.accessmodifiers.public_keyword;public class PublicVisitCounter {    public int userCount = 0;    public void increment() {        userCount++;    }}Klasa dostępna jest dla wszystkich, ze względu na modyfikator public. Zawiera jedno pole userCount, metodę increment i domyślny konstruktor. Każdy z tych elementów ma dostęp typu public. Oznacza to tyle, że jest dostępny dla wszystkich. Ma to swoje konsekwencje. Wyobraźmy sobie klasę MaliciousUser, która informuje PublicVisitCounter o swojej wizycie na stronie: package pl.samouczekprogramisty.kursjava.accessmodifiers.public_keyword;public class MaliciousUser {    public void countMyVisit(PublicVisitCounter counter) {        counter.increment();        counter.userCount = -10;    }}Jak widzisz, dzięki modyfikatorowi public przed polem userCount instancja MaliciousUser ma dostęp do pola userCount. W takim przypadku możemy mówić o tym, że obiekt PublicVisitCounter udostępnia swój stan na zewnątrz. Nie jest to dobrą praktyką. Modyfikator protected Modyfikator protected ma znaczenie w przypadku dziedziczenia. Elementy poprzedzone tym modyfikatorem dostępu są udostępnione dla danej klasy i jej podklas. Dodatkowo elementy oznaczone modyfikatorem protected dostępne są dla innych klas w tym samym pakiecie. Modyfikatora protected nie można stosować przed klasami2. Proszę spójrz na przykład poniżej: package pl.samouczekprogramisty.kursjava.accessmodifiers.protected_keyword;public class Pen {    protected String color;    public Pen(String color) {        this.color = color;    }}package pl.samouczekprogramisty.kursjava.accessmodifiers.protected_keyword.different_package;public class BallPen extends Pen {    protected String manufacturer;    public BallPen(String color, String manufacturer) {        super(color);        this.manufacturer = manufacturer;    }    @Override    public String toString() {        return manufacturer + \" \" + color;    }}Klasa Pen posiada pole color, które poprzedzone jest słowem protected. Dzięki temu klasa BallPen ma dostęp do tego pola. Używa go w implementacji metody toString. Proszę zwróć uwagę na to, że obie klasy znajdują się w różnych pakietach. Mimo to słowo kluczowe protected pozwala na dostęp do pola color. Jak wspomniałem wcześniej ten modyfikator dostępu pozwala także na dostęp dla klas z tego samego pakietu. Ten przypadek pokazuje klasa poniżej: package pl.samouczekprogramisty.kursjava.accessmodifiers.protected_keyword;public class PenOwner {    private Pen pen;    public PenOwner(Pen pen) {        this.pen = pen;    }    @Override    public String toString() {        return \"Mam pioro w kolorze \" + pen.color;    }}W tym przypadku PenOwner ma dostęp do pola color ponieważ obie klasy znajdują się w tym samym pakiecie pl.samouczekprogramisty.kursjava.accessmodifiers.protected_keyword.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Brak modyfikatora dostępu Brak modyfikatora dostępu również ma znaczenie. W przypadku gdy pominiemy modyfikator dostępu wówczas dana klasa czy element jest dostępna wyłącznie wewnątrz tego samego pakietu. Jest to podzbiór uprawnień, które nadaje modyfikator protected. Proszę spójrz na przykład poniżej: package pl.samouczekprogramisty.kursjava.accessmodifiers.missing_keyword;public class Car {    public static final double FUEL_TANK_CAPACITY = 50.0;    double fuelLevel = 12.5;}package pl.samouczekprogramisty.kursjava.accessmodifiers.missing_keyword;public class FuelStation {    public void fillUp(Car car) {        double toFill = Car.FUEL_TANK_CAPACITY - car.fuelLevel;        System.out.println(\"Tankuje \" + toFill + \" litrow.\");        car.fuelLevel = Car.FUEL_TANK_CAPACITY;    }}Modyfikator private Słowo kluczowe private jest najbardziej restrykcyjnym modyfikatorem dostępu. Może być stosowane wyłącznie przed elementami klasy, w tym przed klasami wewnętrznymi. Oznacza on tyle, że dany element (klasa, metoda, czy pole) widoczny jest tylko i wyłącznie wewnątrz klasy. Proszę spójrz na zmodyfikowaną klasę licznika: package pl.samouczekprogramisty.kursjava.accessmodifiers.encapsulated;public class EncapsulatedVisitCounter {    private int userCount = 0;    public void increment() {        userCount++;    }    public int getUserCount() {        return userCount;    }}W tym przypadku pole userCount poprzedzone jest słowem kluczowym private. Dzięki niemu stan wewnętrzny klasy nie jest dostępny na zewnątrz. Tylko elementy wewnątrz definicji klasy mają dostęp do tego pola. Porównanie modyfikatorów dostępu Informacje na temat działania modyfikatorów dostępu można zebrać je w następującej tabeli:             Modyfikator      Klasa      Pakiet      Podklasa      Inni      Poprawny dla klas                  public      tak      tak      tak      tak      tak              protected      tak      tak      tak      nie      nie              brak modyfikatora      tak      tak      nie      nie      tak              private      tak      nie      nie      nie      nie      Enkapsulacja, czyli kiedy używać modyfikatorów dostępu Enkapsulacja (ang. encapsulation), czy inaczej hermetyzacja to sposób na ukrycie szczegółów implementacji klasy. Enkapsulacja to bardzo ważny element programowania obiektowego. Pozwala to na pełną kontrolę nad zachowaniem i stanem danego obiektu. Dobrą praktyką jest stosowanie najbardziej restrykcyjnych modyfikatorów dostępu. Sprowadza się to do użycia private dla wszystkich pól i metod, które powinny być używane “wewnątrz”. Pozostałe elementy, które stanowią interfejs komunikacji oznaczamy słowem kluczowym public. Brak modyfikatora dostępu czy protected mają znaczenie w przypadku bardziej złożonych relacji pomiędzy obiektami. Fragment kodu poniżej pokazuje licznik, który poprawnie ukrywa swój stan. Pozwala on na modyfikację czy dostęp do userCount wyłącznie poprzez publiczny interfejs - metody increment i getUserCount: package pl.samouczekprogramisty.kursjava.accessmodifiers.encapsulated;public class EncapsulatedVisitCounter {    private int userCount = 0;    public void increment() {        userCount++;    }    public int getUserCount() {        return userCount;    }}Dodatkowe informacje Modyfikatory dostępu a interfejsy i typy wyliczeniowe Chciałbym Cię uczulić na przypadek interfejsów. Brak modyfikatora dostępu w definicji interfejsu oznacza, że dana metoda ma modyfikator public. Proszę spójrz na przykład poniżej: @FunctionalInterfacepublic interface Supplier&lt;T&gt; {    T get();}Jest to interfejs Supplier dostępny w standardowej bibliotece języka Java. Jak widzisz przed metodą get nie ma żadnego modyfikatora. W przypadku interfejsów oznacza to, że dana funkcja jest dostępna publicznie. Innym przykładem są wartości typu wyliczeniowego. Poniższy przykład to typ wyliczeniowy AccessMode ze standardowej biblioteki. Jego wartości READ, WRITE i EXECUTE są dostępne publicznie mimo braku jakiegokolwiek modyfikatora dostępu: public enum AccessMode {    READ,    WRITE,    EXECUTE;}  Interfejs Supplier jest generyczny, często jest wykorzystywany wraz z wyrażeniami lambda. Jeśli chcesz przeczytać więcej na ten temat zapraszam do oddzielnych artykułów:   typy generyczne w języku Java,  wyrażenia lambda w języku Java,  typ wyliczeniowe w języku Java.Modyfikatory dostępu a dziedziczenie Dzięki mechanizmowi nadpisywania metod mamy możliwość nadpisywania modyfikatorów dostępu. Jest to możliwe w przypadku dziedziczenia. Jeśli dziedziczymy po innej klasie mamy możliwość rozszerzenia dostępu do danej metody. W praktyce mamy dwie metody, jedną w klasie bazowej i kolejną w klasie potomnej: public class Tree {    protected int height = 12;    protected void prune() {        if (height &gt; 15) {            height -= 1;        }    }    public void grow() {        height += 1;    }}public class Oak extends Tree {    @Override    public void prune() {        super.prune();    }}Aby uniemożliwić przedefiniowanie metody należy umieścić przed nią słowo kluczowe final. Modyfikatory dostępu a mechanizm refleksji Tylko i wyłącznie dla pełnego obrazu napiszę Ci o mechanizmie refleksji. W większości produkcyjnego kodu nie jest on używany. Pozwala on na dostęp do dowolnego elementu klasy pomijając modyfikator dostępu. Proszę spójrz na przykład poniżej: public class BankAccount {    private int balance = 100;    public int getBalance() {        return balance;    }}public class Thief {    public static void main(String[] args) throws NoSuchFieldException, IllegalAccessException {        BankAccount account = new BankAccount();        System.out.println(\"Stan konta: \" + account.getBalance());        Field balance = BankAccount.class.getDeclaredField(\"balance\");        balance.setAccessible(true);        balance.set(account, -5000);        System.out.println(\"Stan konta: \" + account.getBalance());    }}Dzięki mechanizmowi refleksji zmieniłem wartość pola prywatnego. Po uruchomieniu takiego programu na konsoli wyświetlą się dwie linijki: Stan konta: 100Stan konta: -5000Ogólna reguła brzmi - nie używaj mechanizmu refleksji w produkcyjnym kodzie. Chyba, że wiesz co robisz i rzeczywiście jest to potrzebne ;). Zadanie Napisz program, który będzie symulował działanie banku. Zaimplementuj następujące interfejsy: public interface Account {    void deposit(int amount);    void withdraw(int amount);}public interface BankTransfer {    void transfer(BankAccount from, BankAccount to, int amount);}Bank przeprowadzający operację przesyłu środków pobiera stałą opłatę 1zł od nadawcy przelewu. Jakich modyfikatorów dostępu użyjesz? Dlaczego akurat tych? Pamiętaj, że nie ma jednego rozwiązania tego zadania. Jest ich nieskończenie wiele, jedno z przykładowych rozwiązań znajdziesz na samouczkowym githubie. Dodatkowe materiały do nauki Przygotowałem dla Ciebie zestaw kilku linków z materiałami dodatkowymi:   fragment kursu na stronie Oracle opisujący modyfikatory dostępu,  artykuł na Wikipedii na temat hermetyzacji,  przykłady kodu użyte w artykule.Podsumowanie Modyfikatory dostępu w Javie są bardzo ważne. Po przeczytaniu artykułu wiesz czym do czego służą i jak ich używać. Wiesz czym jest hermetyzacja i dlaczego jest istotna. Dowiedziałeś się czegoś więcej mechanizmie refleksji i wiesz, że nie powinieneś go używać ;). Po rozwiązaniu zadania przećwiczyłeś wiedzę z artykułu w praktyce. Mam nadzieję, że artykuł był dla Ciebie pomocny. Jeśli tak to proszę podziel się z nim ze swoimi znajomymi. Jeśli nie chcesz pominąć żadnego artykułu w przyszłości proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu!             Jak wspomniałem we wstępie pomijam tutaj moduły, które mogą ograniczyć dostęp do elementów poprzedzonych słowem kluczowym public. &#8617;               Chyba, że są to klasy wewnętrzne. W takim przypadku modyfikator protected jest dozwolony. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/modyfikatory-dostepu-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/10/29_modyfikatory_dostepu_w_jezyku_java_artykul.jpg"},{
        "title": "Liczby zmiennoprzecinkowe",
        "excerpt":"Artykuł ten wymaga znajomości notacji binarnej. Jeśli jeszcze jej nie znasz koniecznie zapoznaj się z artykułem opisującym system binarny.   Artykuł ten ma Cię jedynie wprowadzić w tematykę związaną ze standardem IEEE754. Nie poruszam w nim kwestii związanych z arytmetyką, zaokrąglaniem czy wartościami specjalnymi. Celem tego artykułu jest wytłumaczenie dlaczego operacje na liczbach zmiennoprzecinkowych nie są dokładne. Jeśli szukasz bardziej szczegółowych informacji odsyłam do punktu “Dodatkowe materiały do nauki”. Niezbędne podstawy Odrobina matematyki Żeby móc mówić o liczbach zmiennoprzecinkowych należy zrozumieć czym są liczby wymierne. Liczba wymierna to liczba, którą można przedstawić w postaci ułamka zwykłego. Dla przypomnienia to ten ułamek z kreską poziomą, który ma licznik i mianownik. Przykładem ułamka zwykłego jest ½. Ułamki mają jeszcze postać dziesiętną. Przykładem ułamka dziesiętnego jest 0,5. Niektóre ułamki zwykłe nie mają skończonej reprezentacji jako ułamek dziesiętny. Na przykład ułamek ⅓ zapisany dziesiętnie ma postać 0,(3). Taka notacja oznacza, że ułamek dziesiętny ma rozwinięcie okresowe. Zawartość nawiasu powtarzana jest w nieskończoność 0,33333.... Okres ułamka może mieć kilka cyfr, na przykład 0,38(12). Taki okres rozwija się do ułamka 0,3812121212.... Liczby wymierne zapisywane binarnie Liczby wymierne można zapisać także binarnie. Algorytm na zamianę liczb całkowitych z postaci dziesiętnej na postać binarną opisałem w artykule na temat systemu binarnego. Do zamiany zostaje część po przecinku. Weźmy na przykład liczbę 0,25. Aby zapisać ją binarnie należy postępować zgodnie z algorytmem:   Zapisz 0,,  Pomnóż ułamek przez 2, jeśli wynik jest większy bądź równy 1 należy dopisać 1 w reprezentacji binarnej. W przeciwnym wypadku należy dopisać 0.  Jeśli wynik jest równy 1 jest to koniec algorytmu. Jeśli wynik jest mniejszy od 1 należy przejść do punktu drugiego. Jeśli wynik jest większy od 1 należy odjąć od niego 1 i przejść do punktu drugiego.Mam nadzieję, że przykład pozwoli Ci lepiej zrozumieć zasadę działania algorytmu. Zacznijmy od liczby 0,75.   Postać binarna 0,,  0,75 * 2 = 1,5. Wynik jest większy od 1 więc dopisuję 1. Postać binarna 0,1. Wynik jest większy od 1 więc odejmuję jedynkę: 1,5 - 1 = 0,5,  0,5 * 2 = 1. Wynik jest równy 1 więc dopisuję 1. Postać binarna 0,11. Wynik jest równy 1 więc to koniec algorytmu,  0,75 zapisane jako ułamek binarny to 0,11.Inny przykład, tym razem ułamek dziesiętny to 0,125:   Postać binarna 0,,  0,125 * 2 = 0,25. 0,25 &lt; 1 więc dopisuję 0. Postać binarna to 0,0,  0,25 * 2 = 0,5. 0,5 &lt; 1 więc dopisuję 0. Postać binarna to 0,00,  0,5 * 2 = 1. 1 == 1 więc dopisuję 1. Postać binarna to 0,001, koniec algorytmu,  0,125 zapisane jako ułamek binarny to 0,001.Nie wszystkie ułamki, które mają skończone rozwinięcie dziesiętne są skończone w postaci binarnej. Spójrz jak wygląda to w przypadku ułamka 0,1:   Postać binarna 0,,  0,1 * 2 = 0,2. 0,2 &lt; 1 więc dopisuję 0. Postać binarna to 0,0,  0,2 * 2 = 0,4. 0,4 &lt; 1 więc dopisuję 0. Postać binarna to 0,00,  0,4 * 2 = 0,8. 0,8 &lt; 1 więc dopisuję 0. Postać binarna to 0,000,  0,8 * 2 = 1,6. 1,6 &gt; 1 więc dopisuję 1 i odejmuję 1 od wyniku. Postać binarna to 0,0001,  0,6 * 2 = 1,2. 1,2 &gt; 1 więc dopisuję 1 i odejmuję 1 od wyniku. Postać binarna to 0,00011,  Ułamek 0,2 występował już w kroku 3. Jeśli liczba się powtarza mamy do czynienia z ułamkiem, który ma nieskończone rozwinięcie binarne. Postać binarna to 0,0(0011).Aby zapisać liczbę wymierną, która ma zarówno część całkowitą i ułamkową należy połączyć zapis części całkowitej i ułamkowej. Na przykład liczba 20,1 zapisana binarnie to 10100,0(0011). Jest to tak zwana stałoprzecinkowa reprezentacja liczby wymiernej. Notacja naukowa a liczby wymierne W matematyce poza standardowym zapisem liczb, który już znasz 10, 123,15 czy 0,00000827194 istnieje tak zwana notacja naukowa. Jest ona pomocna przy zapisywaniu bardzo dużych/małych liczb w stosunkowo zwięzłej formie. Na przykład liczbę 0,00000827194 można zapisać jako \\(8,27194 * 10^{-6}\\). Inna postać tej liczby to 8,27194e-6. W języku Java możesz zobaczyć jak dana liczba wygląda w postaci naukowej: System.out.println(String.format(\"%e\", 123.456));Po uruchomieniu powyższego kodu na konsoli pokaże się: 1.234560e+02  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Czym jest standard IEEE754 Standard IEEE754 jest standardem opisującym arytmetykę zmiennoprzecinkową. W dużym uproszczeniu można powiedzieć, że opisuje on sposób zapisywania liczby wymiernej w pamięci komputera. Standard ten może być implementowany już na poziomie sprzętowym. Oznacza to tyle, że procesor może mieć specjalną jednostkę odpowiedzialną za obliczenia zmiennoprzecinkowe. Standard ten opisuje kilka formatów zapisu liczb. Jednym z nich jest zapis pojedynczej precyzji gdzie do zapisania liczby używa się 32 bitów. Występuje też wersja z podwójną precyzją, gdzie używa się 64 bitów do zapisania liczby. W języku Java liczby typu float są liczbami zmiennoprzecinkowymi formacie pojedynczej precyzji. Liczby typu double to liczby zmiennoprzecinkowe zapisane na 64 bitach w formacie podwójnej precyzji. W dalszej części artykułu skupię się wyłącznie na liczbach zmiennoprzecinkowych zapisanych w formacie pojedynczej precyzji. Liczba zmiennoprzecinkowa Liczba zmiennoprzecinkowa to liczba wymierna zapisana w formacie IEEE754. Nazwa zmiennoprzecinkowa wynika z tego, że miejsce przecinka w liczbie zmienia swoje położenie. Spójrz na przykład poniżej: 1234,5671,234567e+3Obie te liczby są równe, jednak przecinek w drugiej z nich znajduje się w innym miejscu. Druga liczba zapisana jest w notacji naukowej. Części składowe liczby zmiennoprzecinkowej Każdą liczbę zmiennoprzecinkową zapisujemy w pamięci przy pomocy trzech składowych:   znaku,  wykładnika,  mantysy.        Liczba zmiennoprzecinkowa pojedynczej precyzji © Wikipedia  Wartość liczby zmiennoprzecinkowej zależy od wartości poszczególnych pól. Można ją zapisać przy pomocy wzoru: Wzór ten przypomina notację naukową. Znak Liczby mogą być dodanie, ujemne lub 0. Znak służy do określenia czy dana liczba jest dodania czy ujemna. Jeśli liczba jest dodatnia bit znaku zawiera 0. Wykładnik Wykładnik to liczba zapisana na ośmiu bitach. Używa się tu tak zwanego kodowania z nadmiarem. W tym przypadku nadmiar wynosi -127. Oznacza to, że od zakodowanej liczby należy odjąć liczbę 127 aby uzyskać zakodowaną wartość. Standardowo na ośmiu bitach możemy zapisać liczbę \\(2^8 -1 == 255\\). Używając kodowania z nadmiarem -127 na ośmiu bitach możemy zakodować liczby z zakresu [-127, 128]. Innymi słowy wykładnik w liczbie zmiennoprzecinkowej może być z zakresu -127 do 1281. Mantysa Mantysa zapisana jest na 23 bitach. Zawiera ona właściwą liczbę, która zostanie pomnożona przez wykładnik zgodnie ze wzorem podanym wyżej. Mantysa w większości przypadków ma postać znormalizowaną. Najłatwiej będzie mi to wytłumaczyć na przykładzie. Załóżmy, że mamy liczbę zapisaną binarnie 1011,1101. Znormalizowana postać tej liczby to \\(1,0111101 * 2^3\\). Jak widzisz przecinek przesunięty jest do pierwszej jedynki. Inny przykład to 0,0001010110001, która po normalizacji wygląda następująco \\(1,010110001 * 2^{-4}\\). W znormalizowanej mantysie pierwszą cyfrą jest zawsze 1. W związku z tym jest pomijana. Zatem mając liczbę 1,010110001 mantysa będzie miała wartość (spacje dla czytelności): 0101 1000 1000 0000 0000 000Część ułamkowa 010110001 została uzupełniona zerami aby zapełnić wszystkie 23 bity przeznaczone na mantysę. Zapis liczby zmiennoprzecinkowej Teraz masz już wszystkie informacje potrzebne do zapisania liczby zmiennoprzecinkowej. Zacznijmy od liczby 270,125. Liczba ta zapisana binarnie to 100001110,001. Po znormalizowaniu otrzymujemy W naszym przypadku po przecinku mamy 11 cyfr. Mantysę zapisujemy na 23. Brakujące miejsca uzupełniamy zerami. Więc mantysa będzie miała następującą postać (spacje dla czytelności): 0000 1110 0010 0000 0000 000Nasz wykładnik to 8. Wynika on z przesunięcia w związku z normalizacją mantysy. Pamiętając o sposobie kodowania wykładnika dodaję do niego 127. Kodując 135 binarnie uzyskuję (spacja dla czytelności): 1000 0111Nasza liczba jest dodania, więc bit znaku ma wartość 0. Zbierając te informacje razem mogę zapisać liczbę 270,125 w standardzie IEEE754. Zapis ten wygląda następująco (spacje dla czytelności): 0  1000 0111  0000 1110 0010 0000 0000 000Dlaczego 0,1 + 0,2 != 0,3 Standard IEEE754 bardzo ułatwił pracę z liczbami wymiernymi. Niestety ma on swoje wady. Jedną z nich jest to, że w pewnych przypadkach zapis liczby w tym formacie prowadzi do utracenia informacji. Dzieje się tak na przykład w przypadku gdy ułamek zapisany binarnie ma rozwinięcie okresowe. Przykładem takich ułamków są 0,1 czy 0,2. Proszę spójrz na przykłady poniżej. Używam tu kodu Javy, jednak właściwość ta jest prawdziwa także w innych językach programowania: System.out.println(String.format(\"%.17f\" , 0.1F));System.out.println(String.format(\"%.17f\" , 0.2F));System.out.println(String.format(\"%.17f\" , 0.3F));0.100000001490116120.200000002980232240.30000001192092896Jeśli chcesz wiedzieć czym jest magiczne \"%.17f\" zachęcam Cię do przeczytania artykułu na temat formatowania łańcuchów znaków w języku Java. Jak widzisz wprowadzone 0,1 trochę różni się od właściwej wartości zapisanej w pamięci komputera. Chociaż 0,1 + 0,2 == 0,3 to w pamięci komputera wygląda to trochę inaczej: 0.10000000149011612 + 0.20000000298023224 != 0.30000001192092896Rady praktyczne W związku z opisanymi problemami typy double czy float nie zawsze są dobrym wyborem. Na przykład pisząc aplikację do banku, która oblicza ratę kredytu na pewno nie powinieneś używać tych typów. Z pomocą przychodzi klasa BigDecimal. Jeśli zależy Ci na dokładnych obliczeniach w większości przypadków będzie to dobry wybór: System.out.println(new BigDecimal(\"0.1\"));Wyświetli oczekiwane 0.1Proszę zwróć uwagę na sposób tworzenia instancji BigDecimal. Używam tutaj konstruktora, który przyjmuje liczbę jako łańcuch znaków. Użycie klasy BigDecimal utworzonej na podstawie instancji float powtórzy błąd: System.out.println(new BigDecimal(0.1F));0.100000001490116119384765625Innym sposobem na pracę z liczbami wymiernymi jest użycie typów całkowitoliczbowych. Jest to możliwe w przypadku gdy wiesz ile miejsc po przecinku jest dla Ciebie ważne. Na przykład operacje pieniężne w większości przypadków potrzebują dwóch miejsc po przecinku. Zatem kwotę 125 złotych 68 groszy możemy zapisać jako 12568 i przechowywać w polu o typu int czy long. Przy pomocy dzielenia możemy uzyskać część całkowitoliczbową i część ułamkową: int money = 12568;System.out.println(\"zlotych: \" + money / 100);System.out.println(\"groszy: \" + money % 100);Dodatkowe materiały do nauki Jeśli chcesz spojrzeć na temat liczb zmiennoprzecinkowych z innej perspektywy możesz rzucić okiem na poniższe materiały:   artykuł na Wikipedii na temat liczb zmiennoprzecinkowych,  artykuł na Wikipedii na temat standardu IEEE754,  artykuł opisujący standard IEEE754,  treść najnowszej wersji standardu IEEE754 (wymaga wykupienia dostępu).Zadania do wykonania Do wykonania zadań mogą Ci się przydać następujące funkcje:   Integer.toBinaryString,  Long.toBinaryString,  Float.floatToRawIntBits.  Double.doubleToRawLongBits,Zadania do wykonania:   Napisz program, który pobierze od użytkownika liczbę wymierną. Następnie wypisze tę liczbę w postaci binarnej pokazując osobno znak, wykładnik i mantysę.  Uzupełnij program z punktu 1. w ten sposób, aby pokazywał błąd wynikający z zapisu liczb. Na przykład jeśli użytkownik wprowadzi liczbę 0,1 wówczas program powinien wyświetlić binarną reprezentację i błąd powstały w wyniku zapisu liczby w tym formacie,  Spróbuj rozszerzyć program w ten sposób aby wspierał liczby zmiennoprzecinkowe zapisane w formacie podwójnej precyzji (1 bit znaku, 11 bitów wykładnika i 52 bity mantysy).Zachęcam Cię do samodzielnego rozwiązania zadań, wtedy nauczysz się najwięcej. Jeśli jednak będziesz potrzebował pomocy możesz rzucić okiem na przykładowe rozwiązanie na githubie. Podsumowanie Po przeczytaniu artykułu wiesz już czym są liczby zmiennoprzecinkowe. Znasz podstawy standardu IEEE754. Wiesz dlaczego niektóre operacje na liczbach zmiennoprzecinkowych nie są dokładne. Wiesz także jak wykonywać dokładne operacje na liczbach wymiernych. Innymi słowy kawał wiedzy! :). Mam nadzieję, że artykuł przypadł Ci do gustu. Proszę podziel się nim ze swoimi znajomymi, którzy mogą być nim zainteresowani. Jeśli nie chcesz pominąć nowych artykułów polub Samouczka na Facebooku i dopisz się do samouczkowego newslettera. Do następnego razu!             Jak już wspomniałem wcześniej dotyczy to liczb zapisanych w formacie pojedynczej precyzji. &#8617;       ","categories": ["Programowanie","Wiedza ogólna"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/liczby-zmiennoprzecinkowe/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/11/06_liczby_zmiennoprzecinkowe_artykul.jpg"},{
        "title": "Podstawy złożoności obliczeniowej",
        "excerpt":"  Artykuł ten zawiera jedynie podstawy związane z zagadnieniem złożoności obliczeniowej. Bynajmniej nie wyczerpuje tematu. Teoria obliczeń to osobny dział informatyki. Jeśli chcesz go zgłębić zachęcam Cię do przejrzenia dodatkowych materiałów do nauki. Mam świadomość, że tłumaczenie złożoności obliczeniowej bez wspominania o maszynie Turinga to profanacja. Jednak dla zupełnie początkujących w temacie takie podejście wydaje mi się łatwiejsze. Teoria obliczeń Teoria obliczeń to dział informatyki. Jedną z gałęzi tego działu jest teoria złożoności obliczeniowej. W uproszczeniu można powiedzieć, że zajmuje się ona oszacowaniem wydajności czasowej i pamięciowej algorytmów. Teoria złożoności obliczeniowej bazuje na wielu modelach, które służą do łatwego porównywania algorytmów. Dlaczego używamy złożoności obliczeniowej Komputerów na świecie są miliony. Wiele z nich bardzo się od siebie różni. Mają różny procesor, inny moduł RAM. Część z nich używa bardziej wydajnych dysków, które pozwalają na szybszy dostęp do danych. Dla części z nich dane dostępne są na zdalnych maszynach, do których trzeba łączyć się przez sieć. Są też mega-komputery, maszyny o ogromnej mocy obliczeniowej, czy smartfony w kieszeniach. W związku z tą różnorodnością pojawia się potrzeba wspólnej miary. Miary, która jest niezależna od zmiennych czynników. Może ona pomóc zorientować się w wydajności danego algorytmu, przyporządkować go do zdefiniowanej klasy algorytmów. Tutaj w grę wkraczają modele, o których wspomniałem wcześniej. Modele te upraszczają zawiłości związane z różnorodnością sprzętu. Mamy zatem wspólną bazę - model. Dalej jednak pozostaje pytanie: w jaki sposób mierzyć wydajność poszczególnych algorytmów? Mierzenie czasu jest mało praktyczne. Na modelu nie możemy mierzyć czasu. Mierzenie czasu nie ma większego sensu na komputerze z powodu różnorodności sprzętu. Otrzymane wyniki nie byłby miarodajne w przypadku innego komputera. Mierzymy więc zatem liczbę operacji wykonanych na modelu. Następnie próbujemy znaleźć funkcję, która będzie opisywała liczbę operacji w zależności od wejścia algorytmu. Funkcje te możemy porównywać ze sobą. Przykład wyznaczania złożoności obliczeniowej Załóżmy że chcemy policzyć sumę elementów tablicy. Może nam w tym pomóc następujący algorytm: public int sum(int[] numbers) {    int sum = 0;    for (int number : numbers) {        sum += number;    }    return sum;}Ile mamy w nim operacji? int sum = 0;, przypisanie to jedna operacja. Następnie mamy pętlę for. Jej ciało zawiera jedną operację. Sama pętla wykona się dokładnie tyle razy ile jest elementów tablicy numbers. Liczbę tych elementów określmy jako n. Na końcu mamy instrukcję return sum;. Jest to ostatnia operacja. Dodając te operacje do siebie otrzymujemy wzór: Zatem złożoność naszego algorytmu opisana jest przez funkcję f(n) = n + 2. Tak dla przypomnienia ;). Funkcje możesz pamiętać z matematyki. Na przykład funkcja f(x) = ax^2 + bx + c opisuje parabolę. Złożoność obliczeniowa a funkcja Złożoność obliczeniową określamy jako funkcję danych wejściowych algorytmu. Wyznacza się ją jak opisałem w poprzednim punkcie - licząc operacje. O ile dla naukowców znalezienie dokładnej funkcji może być bardzo istotne, to w praktyce wystarczą jej oszacowania. Takie oszacowania to notacja Ο (dużego O), notacja Ω (omega) i notacja Θ (theta). Oszacowania rzędu złożoności funkcji Na tapetę bierzemy przykładową funkcję: Możemy założyć, że funkcja ta dokładnie opisuje złożoność obliczeniową jakiegoś algorytmu. Argument n to rozmiar danych wejściowych do algorytmu. Wykres1 tej funkcji wygląda następująco:         Wykres funkcji f(n) = n^3 - 6n^2 + 4n + 12  Notacja Ο (dużego O) Notacja ta zakłada, że istnieje funkcja g(n), dla której spełniona jest poniższa własność: Teraz przetłumaczę te matematyczne hieroglify :). Własność ta oznacza, że wynik funkcji g(n) pomnożony przez jakąś stałą c będzie większy bądź równy wynikowi funkcji f(n). Własność ta jest spełniona dla wszystkich n, które będą większe od n0. Jeszcze łatwiej wygląda to na wykresie:         Oszacowanie z góry, notacja Ο.  Powyższy wykres pokazuje dwie funkcje. Pierwszą, którą już znasz z poprzedniego wykresu. Druga to wykres funkcji g(n) = n^3. Jak widzisz od pewnego punktu zielona linia jest zawsze ponad czerwoną linią. To nic innego jak oszacowanie z góry. To właśnie jest notacja Ο. Zatem w naszym przypadku nasza funkcja f(n) ma złożoność Ο(n^3). W mojej dotychczasowej praktyce notacja Ο jest najczęściej spotykana do określania złożoności algorytmów. Notacja Ο jest oszacowaniem z góry. Zatem można powiedzieć, że jeśli algorytm ma złożoność Ο(n^2) to ma także złożoność Ο(n^3) czy nawet Ο(n!). Jednak Ο(n^2) może być najlepszym oszacowaniem złożoności danego algorytmu. Z racji tego, że jest to oszacowanie pomijamy w nim wszelkiego rodzaju stałe. Zatem Ο(2n + 123), Ο(2n) i Ο(n) to ta sama złożoność obliczeniowa. Stałe te i tak nie mają znaczenia przy odpowiednio dużych wartościach n.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Notacja Ω (omega) Notacja ta różni się od poprzedniej własnością, którą spełnia nowa funkcja: Własność ta oznacza, że wynik funkcji g(n) pomnożony przez jakąś stałą c będzie mniejszy bądź równy wynikowi funkcji f(n). Własność ta jest spełniona dla wszystkich n, które będą większe od n0. Ponownie wykres pomoże Ci to zrozumieć:         Oszacowanie z dołu, notacja Ω.  Na wykresie widoczne są dwie funkcje. Pierwszą znasz. Druga to wykres funkcji g(n) = n^2. “Ostatni” punkt przecięcia tych dwóch wykresów, to n02. Od tego miejsca wykres funkcji g(n) jest zawsze pod wykresem funkcji f(n). Możemy powiedzieć, że funkcja f(n) ma złożoność Ω(n^2). Notacja Θ (theta) Można powiedzieć, że notacja Θ to połączenie notacji Ο i Ω. W tym przypadku funkcja użyta do oszacowania musi spełniać zależność: Tłumacząc to na polski można powiedzieć, że wynik funkcji g(n) pomnożony przez stałą c1 będzie większy bądź równy wartości funkcji f(n). Jednocześnie będzie mniejszy bądź równy wartości funkcji f(n) jeśli pomnożymy go przez stałą c2. Ponownie wykres może pomóc to zrozumieć:         Dokładne oszacowanie rzędu, notacja Θ.  W naszym przypadku funkcję g(n) możemy opisać wzorem g(n) = (n-4)^3. Stałe mają odpowiednio wartości c1 = 5, c2 = 1. Wykres oznaczony kolorem niebieskim to wynik funkcji g(n) przemnożony przez stałą c1. Wykres oznaczony kolorem fioletowym to wynik funkcji g(n) przemnożony przez stałą c2. Jak wcześniej wspomniałem notacja Ο jest najczęściej spotykana. W dalszej części artykułu będę odnosił się tylko do tej notacji. Rząd złożoności obliczeniowej Tu także skupię się na przykładzie wzoru wałkowanego wcześniej: Jak wspomniałem wcześniej w praktyce nie potrzebujemy tak dokładnego wzoru wystarczy jedynie zgrubne oszacowanie, które uwzględnia najbardziej istotny element funkcji. Który element funkcji jest najbardziej istotny? Ten, który ma największy wpływ na ostateczny wynik funkcji. Jak to sprawdzić? Wystarczy pod n podstawić bardzo dużą liczbę i zobaczyć, który element będzie miał największą wartość. Na przykład:             Element      Wartość przy n = 1'000'000'000                  n^3      1’000’000’000’000’000’000’000’000’000              6n^2      6’000’000’000’000’000’000              4n      4’000’000’000              12      12      Jak widzisz, przy odpowiednio dużych wartościach n część “elementów równania” jest mniej istotna. W przypadku funkcji powyżej najszybciej rosnącym elementem jest n^3. Ma on największy wpływ na ostateczny wynik funkcji. Wiesz już z powyższych rozważań, że funkcja f(n) ma złożoność Ο(n^3). Jest to tak zwana złożoność wykładnicza, specyficzny przypadek złożoności wielomianowej. Istnieje kilka popularnych rzędów złożoności obliczeniowej. Ο(1) Złożoność stała, niezależna od liczby danych wejściowych. Mówimy, że problem o złożoności Ο(1) możemy rozwiązać w stałym czasie niezależnie od wielkości danych wejściowych. Przykład problemu, dla którego istnieje algorytm Ο(1):   Na wejściu programu jest tablica liczb o długości N. Liczby są posortowane rosnąco. Pomiędzy dwoma sąsiadującymi liczbami różnica jest stała. Znajdź sumę liczb w tablicy. Problem to nic innego jak obliczenie sumy ciągu arytmetycznego. Istnieje na to wzór, który można zaimplementować: public int sum(int[] numbers) {    if (numbers == null || numbers.length == 0) {        return 0;    }    return (numbers[0] + numbers[numbers.length - 1]) * numbers.length / 2;}W tym przypadku nie potrzebujemy iterować po elementach tablicy. Niezależnie od wielkości tablicy wejściowej możemy obliczyć sumę ciągu w stałym czasie. Ο(n) Złożoność liniowa. Jest to specyficzny przypadek złożoności wielomianowej. Czas rozwiązania problemu jest wprost proporcjonalny do wielkości danych wejściowych. Przykład problemu, dla którego istnieje algorytm Ο(n):   Na wejściu programu jest tablica liczb o długości N. Znajdź sumę wszystkich liczb w tablicy wejściowej. public int sum(int[] numbers) {    int sum = 0;    for (int number : numbers) {        sum += number;    }    return sum;}Aby znaleźć tę sumę należy sprawdzić wszystkie elementy tablicy. Musimy zatem odbyć N kroków. Ο(log(n)) Złożoność logarytmiczna, czas rozwiązania zależy od wyniku logarytmu3 z wielkości danych wejściowych. Przykład problemu, dla którego istnieje algorytm Ο(log(n)):   Na wejściu programu jest posortowana tablica liczb o długości N. Sprawdź czy liczba x istnieje w tablicy wejściowej. To popularny algorytm przeszukiwania binarnego. Jego nazwa pochodzi od tego, że przy każdej iteracji algorytmu dzielimy przeszukiwany zbiór na dwie równe4 części. Algorytmy, które dzielą w ten sposób problem na mniejsze problemy przeważnie są zależne od logarytmu wielkości danych wejściowych. public boolean binarySearch(int[] numbers, int number) {    int indexLow = 0;    int indexHigh = numbers.length - 1;    while (indexLow &lt;= indexHigh) {        int indexMiddle = indexLow + (indexHigh - indexLow) / 2;        if (number &lt; numbers[indexMiddle]) {            indexHigh = indexMiddle - 1;        }        else if (number &gt; numbers[indexMiddle]) {            indexLow = indexMiddle + 1;        }        else {            return true;        }    }    return false;}Ο(nlog(n)) Złożoność liniowo-logarytmiczna. Czas rozwiązania problemu jest wprost proporcjonalny do iloczynu wielkości danych wejściowych i ich logarytmu. Przykładem problemu dla którego istnieje algorytm o złożoności Ο(nlog(n)) jest:   Na wejściu programu jest tablica liczb. Zwróć tablicę, która będzie zawierała te same elementy, które są w tablicy wejściowej. Tablica wynikowa powinna być posortowana w porządku rosnącym. Powyższy problem to sortowanie. Jeden z ze standardowych problemów w informatyce. Algorytmem sortującym, który ma złożoność obliczeniową Ο(nlog(n)) jest sortowanie przez scalanie (ang. merge sort): public static int[] sort(int[] numbers) {    if (numbers.length &lt;= 1) {        return numbers;    }    int[] first = new int[numbers.length / 2];    int[] second = new int[numbers.length - first.length];    for (int i = 0; i &lt; first.length; i++) {        first[i] = numbers[i];    }    for (int i = 0; i &lt; second.length; i++) {        second[i] = numbers[first.length + i];    }    return merge(sort(first), sort(second));}private static int[] merge(int[] first, int[] second) {    int[] merged = new int[first.length + second.length];    for (int indexFirst = 0, indexSecond = 0, indexMerged = 0; indexMerged &lt; merged.length; indexMerged++) {        if (indexFirst &gt;= first.length) {            merged[indexMerged] = second[indexSecond++];        }        else if (indexSecond &gt;= second.length) {            merged[indexMerged] = first[indexFirst++];        }        else if (first[indexFirst] &lt;= second[indexSecond]) {            merged[indexMerged] = first[indexFirst++];        }        else {            merged[indexMerged] = second[indexSecond++];        }    }    return merged;}Algorytm dzieli tablicę na części do czasu aż każda z nich będzie miała długość 1. Następnie scala je ze sobą. Każde takie scalenie to koszt Ο(n). W związku z tym, że tablicę wejściową dzieliliśmy za każdym razem na pół takich scaleń mamy log(n). Zatem wynikowa złożoność algorytmu to Ο(nlog(n)). Jak widzisz obliczanie złożoności obliczeniowej bardziej skomplikowanych algorytmów nie jest takie łatwe. Ο(n^2) Złożoność kwadratowa. Jest to specyficzny przypadek złożoności wielomianowej. Przykładowy problem może być ten, który użyłem wyżej - posortowanie tablicy. Tym razem jednak algorytm jest mniej wydajny. Sortowanie bąbelkowe charakteryzuje się złożonością obliczeniową Ο(n^2): public int[] sort(int[] numbers) {    for (int i = 0; i &lt; numbers.length; i++) {        for (int j = 0; j &lt; numbers.length - 1; j++) {            if (numbers[j] &gt; numbers[j + 1]) {                int temp = numbers[j + 1];                numbers[j + 1] = numbers[j];                numbers[j] = temp;            }        }    }    return numbers;}Mamy tutaj dwie zagnieżdżone pętle. Każda z nich iteruje po n elementach. W związku z tym otrzymujemy złożoność Ο(n^2). Ο(n^x) Złożoność wielomianowa. Jak już wiesz złożoność liniowa i złożoność kwadratowa są specyficznymi przypadkami złożoności wielomianowej. Ze względu na częste występowanie wyszczególniłem je jako osobne rzędy złożoności. Przykłady problemów i rozwiązań znajdziesz w poprzednich punktach. Ο(x^n) Jest to złożoność wykładnicza, jej przykładem może być Ο(2^n). Problemem, który ma rozwiązanie o złożoności co najmniej Ο(2^n) jest:   Na wejściu programu jest tablica unikalnych liczb. Zwróć tablicę, która będzie zawierała wszystkie możliwe podzbiory elementów tablicy wejściowej. Wynika to z faktu, że wszystkich możliwych podzbiorów zbioru, który ma n elementów jest dokładnie 2^n. Poniższy algorytm ma złożoność Ο(log(n)2^n). public static int[][] powerSet(int[] numbers) {    int two_pow_n = 1 &lt;&lt; numbers.length;    int[][] powerSet = new int[two_pow_n][];    for (int subsetIndex = 0; subsetIndex &lt; two_pow_n; subsetIndex++) {        powerSet[subsetIndex] = pickNumbers(subsetIndex, numbers);    }    return powerSet;}private static int[] pickNumbers(int subsetIndex, int[] numbers) {    int howManyOnes = 0;    int temp = subsetIndex;    while (temp &gt; 0) {        if (temp % 2 == 1) {            howManyOnes++;        }        temp &gt;&gt;= 1;    }    int[] subset = new int[howManyOnes];    for (int charIndex = 0, lastElementIndex = 0; subsetIndex &gt; 0; charIndex++) {        if (subsetIndex % 2 == 1) {            subset[lastElementIndex++] = numbers[charIndex];        }        subsetIndex &gt;&gt;= 1;    }    return subset;}Wynika to z faktu, że pętla wewnątrz metody powerSet wywołana jest dokładnie 2^n razy. Natomiast wewnątrz metody pickNumbers są dwie pętle. Każda z nich ma złożoność Ο(log(n)). Zatem finalna złożoność algorytmu to Ο(log(n)2^n). Spróbuj uruchomić ten kod z tablicą wejściową z 30 elementami, życzę powodzenia ;). Ο(n!) Jest to złożoność typu silnia.  Dla przypomnienia silnia n, albo inaczej n! to iloczyn wszystkich liczb od 1 do n. Na przykład 3! = 1 * 2 * 3 = 6. Przykładem problemu, dla którego istnieje naiwny algorytm o tej złożoności to problem komiwojażera:   Na wejściu programu jest n miast oraz odległości pomiędzy każdą parą miast. Zakładając, że komiwojażer zaczyna z miasta A i ma dojść do miasta B jaką trasę powinien pokonać aby była ona najkrótsza? Nie silę się nawet na naiwny algorytm dla tego problemu, nie jest on możliwy do uruchomienia na dzisiejszych komputerach dla problemów odpowiednio dużych. Wyobraź sobie, skalę możliwych rozwiązań. 60! ~= 8,3 * 10^81. Szacowana liczba atomów wodoru w widzialnym wszechświecie to około 10^80. Przekładając to na problem wyżej. Możliwych dróg pomiędzy 60 miastami jest więcej niż atomów wodoru w widzialnym wszechświecie ;). Najlepszy, średni i najgorszy przypadek Ten sam algorytm może zachowywać się zupełnie inaczej w przypadku innych danych wejściowych. Nie mówię tu o wielkości problemu, wielkości danych wejściowych. A o instancji problemu. Jeśli algorytm jako dane wejściowe przyjmuje tablicę liczb to wielkością problemu może być 5 - tablica o długości 5. Natomiast instancji tego problemu jest nieskończenie wiele: [1, 2, 3, 4, 5], [-1, 2, -3, 4, -5] czy [5, 4, 3, 2, 1]. Algorytm może mieć różną złożoność obliczeniową określoną w notacji Ο w zależności od instancji problemu. Są także algorytmy, których złożoność obliczeniowa jest niezależna od instancji problemu. W zależności od wymagań w wyborze algorytmu bierze się pod uwagę złożoność odpowiedniego przypadku. Dodatkowe materiały do nauki Informacji na temat teorii obliczeń i złożoności obliczeniowej w internecie jest sporo. Jednak dość ciężko jest znaleźć jakiekolwiek informacje, które są na początkującym poziomie. Niemniej jednak poniżej starałem się zebrać materiały, które mogą być interesujące:   Wykład dotyczący złożoności obliczeniowej na Uniwersytecie Warszawskim,  Kilka krótkich artykułów opisujących podstawy teorii obliczeń,  Computational Complexity: A Modern Approach, szkic książki o złożoności obliczeniowej. Jej ostateczna wersja dostępna jest na Amazonie5,  Artykuł na temat złożoności obliczeniowej z uniwersytetu Stanford,  Sekcja Wolfram Alpha poświęcona złożoności obliczeniowej,  Artykuł na Wikipedii na temat funkcji służących do szacowania,  Artykuł o złożoności obliczeniowej na Codility6,  Fragmenty kodu użyte w tym artykule.Podsumowanie Jeśli zrozumiałeś ten artykuł możesz śmiało powiedzieć, że wiesz czym jest złożoność obliczeniowa. Wiesz jak ją szacować, znasz przykłady algorytmów z najczęściej spotykanych rzędów złożoności obliczeniowej. Znasz kilka notacji do określania złożoności. Dowiedziałeś się też ile jest atomów wodoru we wszechświecie ;). W każdym razie masz za sobą spory kawałek lektury i sporo wiedzy. Na koniec mam do Ciebie prośbę. Proszę podziel się tym artykułem ze swoimi znajomymi, sporo się nad nim napracowałem. Mam nadzieję, że będzie mógł pomóc jak największej grupie osób. Jeśli nie chcesz ominąć kolejnych artykułów w przyszłości polub Samouczka na Facebooku i zapisz się do newslettera. Do następnego razu!             Wykresy użyte w tym artykule stworzyłem przy pomocy graphsketch. &#8617;               To oczywiście kolejne uproszczenie, punkt to para dwóch liczb. n0 jest jedną z nich - tą na osi poziomej. Dasz radę wyznaczyć drugą współrzędną? ;) &#8617;               Podstawą logarytmu przeważnie jest 2. Zdarzają się także algorytmy, w których logarytm ma inną podstawę. &#8617;               Oczywiście, w przypadku tablicy o nieparzystej długości jedna z części nie będzie “równiejsza” od drugiej ;). &#8617;               To jest link afiliacyjny. Oznacza to tyle, że jeśli kupisz ten produkt pomożesz mi w dalszym prowadzeniu bloga. Nie jest to związane z żadnymi dodatkowymi kosztami dla Ciebie. Dziękuję! :) &#8617;               Wielkie dzięki dla Marka za podesłanie linka do tego artykułu. &#8617;       ","categories": ["Programowanie","Wiedza ogólna"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/podstawy-zlozonosci-obliczeniowej/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/11/13_zlozonosc_obliczeniowa_artykul.jpg"},{
        "title": "REST web service z Java EE część 1",
        "excerpt":"  To jest jeden z artykułów w ramach darmowego kursu programowania aplikacji webowych w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. W kursie tym zakładam, że znasz język Java. Możesz go poznać w osobnym kursie programowania w języku Java. Do budowania wszystkich projetków używam Gradle, przeczytasz o nim więcej w osobnym artykule. Słownik pojęć Na początku postaram się wytłumaczyć pojęcia, które będą używane w dalszej części artykułu. Czym jest web service Wyobraź sobie obiekt. Obiekt ma zestaw metod. W normalnych warunkach metody na tym obiekcie możemy wywoływać wyłącznie w tym samym programie, w ramach tej samej wirtualnej maszyny Java. W uproszczeniu web service1 to mechanizm umożliwiający wywołanie jakiejś funkcjonalności za pośrednictwem internetu. Istnieje kilka podejść do tworzenia web service’ów. Jednym z nich jest tak zwany REST. Czym jest REST REST to rozwinięcie Representational State Transfer. REST to zbiór praktyk, które określają w jaki sposób powinniśmy implementować web service’y. REST kręci się wokół tak zwanych encji (ang. resource). Encja to obiekt, który reprezentuje byt w aplikacji. Może to być na przykład obiekt reprezentujący rezerwację stolika, użytkownika aplikacji czy kredyt w banku. Operacje na encjach wykonuje się za pomocą zapytań HTTP. Do encji dobieramy się używając odpowiednich typów zapytań. Typy zapytań określone są przez czasowniki HTTP: GET, POST, PUT i DELETE. Czasowniki te wraz z adresem URL definiują dokładnie jaką operację chcemy wykonać na danej encji.             Czasownik      Przykład      Znaczenie                  GET      GET /rezerwacja/123      Pobranie rezerwacji o identyfikatorze 123              PUT      PUT /rezerwacja/123      Edycja rezerwacji o identyfikatorze 123              POST      POST /rezerwacja      Utworzenie nowej rezerwacji              DELETE      DELETE /rezerwacja/123      Usunięcie rezerwacji o identyfikatorze 123      Zanim powstał REST, web service’y w języku Java tworzono w oparciu o SOAP (ang. Simple Object Access Protocol). SOAP w porównaniu do REST jest dużo bardziej złożony. SOAP oparty jest o XML’a i jest dość rozwlekłym protokołem. Moim zdaniem REST zdobył dużą przewagę właśnie swoją prostotą w porównaniu do SOAP. REST jest de facto standardem jeśli chodzi o tworzenie web service’ów w większości aplikacji webowych. Wysłane zapytanie informuje także web service o preferowanej formie odpowiedzi. Dzieje się to zazwyczaj przy pomocy nagłówków HTTP. Na przykład nagłówek zapytania Accept: application/json informuje web service, że klient oczekuje odpowiedzi w formacie JSON. Jest to tylko krótkie wprowadzenie, jeśli chcesz dowiedzieć się więcej na temat REST odsyłam Cię do materiałów dodatkowych. PUT czy POST? W tabeli wyżej wspomniałem o tym, że to zapytania typu POST powinny tworzyć nową instancję a zapytania typu PUT powinny ją edytować. Dla pełni informacji muszę Ci powiedzieć, że z tego co wiem, nie jest to nigdzie ustandaryzowane. Spotkasz się zarówno z takim podejściem jak w tabeli wyżej jak i odwrotnym, w którym to zapytania typu POST służą do edycji encji. Czym jest Java EE W jednym zdaniu. Java EE to platforma, która oparta jest na zbiorze specyfikacji. Technologie opisane w tych specyfikacjach są używane głównie do tworzenia aplikacji webowych.         Logo Java EE  Teraz należy Ci się rozwinięcie. Język Java już znasz. Java wraz z zestawem biblioteki standardowej to Java SE (ang. Standard Edition). Istnieje również taki twór jak Java EE (ang. Enterprise Edition). Jak napisałem wyżej Java EE to nic innego jak zbiór różnych specyfikacji. Można powiedzieć, że Java EE rozbudowuje możliwości Java SE. Oczywiście podstawą tutaj jest język programowania Java. Java EE w wersji 8 została opublikowana 31 sierpnia 2017 roku. Java EE w wersji 8 to 41 osobnych specyfikacji! Jedną ze specyfikacji jest Java Servlets. Opisywałem ją w poprzednich artykułach w ramach kursu. Java Servlets jest specyfikacją, którą można używać w kontenerach serwletów. Niestety nie wszystkie ze wspomnianych 41 specyfikacji można używać w kontenerze serwletów. Java API for RESTful Web Services (w skrócie JAX-RS) jest tu dobrym przykładem. Aby móc używać tej technologii potrzebujemy kontenera aplikacji.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Kontener aplikacji a kontener serwletów Apache Tomcat, którego używałem do tej pory w ramach kursu jest kontenerem serwletów. Umożliwia on uruchamianie aplikacji webowych, które używają podzbioru specyfikacji Java EE (na przykład specyfikacji serwletów). Pisanie web service’ów w oparciu o JAX-RS wymaga kontenera aplikacji. Jednym z kontenerów aplikacji jest Apache TomEE. Instalacja kontenera aplikacji Jest wiele kontenerów aplikacji. W tym kursie będę używał Apache TomEE. Jest to jeden z darmowych kontenerów. Aby go zainstalować pobierz TomEE PluME i rozpakuj plik ZIP do dowolnego folderu. To tyle, instalację kontenera aplikacji masz już za sobą. Ważne jest, żebyś pobrał wersję TomEE PluME, lub TomEE+. Te wersje wspierają specyfikację JAX-RS.         Pobieranie TomEE Plume  Web service z JAX-RS build.gradle Nadszedł czas na to, żeby utworzyć swój pierwszy web service. Do budowania aplikacji użyłem Gradle. Plik build.gradle wygląda następująco: apply plugin: 'java'apply plugin: 'idea'apply plugin: 'maven'apply plugin: 'war'apply from: 'https://raw.github.com/akhikhl/gretty/master/pluginScripts/gretty.plugin'repositories {    mavenCentral()}sourceCompatibility = 1.8group = 'pl.samouczekprogramisty.kursaplikacjewebowe'version = '1.0-SNAPSHOT'dependencies {    providedCompile group: 'javax.servlet', name: 'javax.servlet-api', version: '3.1.0'    providedCompile group: 'javax.ws.rs', name: 'javax.ws.rs-api', version: '2.1'    testCompile group: 'junit', name: 'junit', version: '4.12'    testCompile group: 'org.hamcrest', name: 'hamcrest-all', version: '1.3'    testCompile group: 'org.mockito', name: 'mockito-all', version: '1.10.19'}task explodedWar(type: Copy) {    into \"$buildDir/explodedWar\"    with war}war.dependsOn explodedWarNajbardziej istotnym fragmentem jest providedCompile group: 'javax.ws.rs', name: 'javax.ws.rs-api', version: '2.1'2. Jest to zależność, która zawiera klasy określone przez specyfikację JAX-RS. providedCompile mówi Gradle o tym, że zależność jest wymagana przez aplikację wyłącznie w trakcie kompilacji. Nie zostanie umieszczona w wynikowymi pliku war. Nie jest ona tam potrzebna ponieważ jest dostępna na classpath kontenera aplikacji. Pierwszy web service Utwórz klasę, która będzie odpowiedzialna za encję Reservation. Może to być na przykład ReservationWebservice: package pl.samouczekprogramisty.kursaplikacjewebowe.rest;import javax.ws.rs.GET;import javax.ws.rs.Path;import javax.ws.rs.core.Response;@Path(\"/reservation\")public class ReservationWebservice {    @GET    public Response listReservations() {        return Response.ok(\"Oto wszystkie rezerwacje :)\").build();    }}Jest to standardowa klasa Javy, tak zwane POJO (ang. Plain Old Java Object). Zawiera ona jedną metodą, listReservations. Dodatkowo znajdują się w niej dwie adnotacje: @Path i @GET. Metoda ta zwraca instancję obiektu Response. Ta kombinacja to Twój pierwszy web service. Adnotacja @Path informuje JAX-RS o tym pod jakim URL dana klasa/metoda powinna odpowiadać. Adnotacja @GET mówi o tym jaki czasownik HTTP jest obsługiwany przez daną metodę. Następnie zbuduj aplikację używając polecenia: gradle warPo jego wykonaniu w katalogu build/libs projektu powinien znaleźć się plik war. Przekopiuj go do katalogu webapps w miejscu gdzie zainstalowałeś TomEE. W moim przypadku wygląda to następująco: cp /home/mapi/KursAplikacjeWebowe/06_rest_endpoint/build/libs/06_rest_endpoint-1.0-SNAPSHOT.war /home/mapi/opt/apache-tomee/webapps/rest.warZauważ, że w trakcie kopiowania zmieniłem nazwę pliku war z 06_rest_endpoint-1.0-SNAPSHOT.war na rest.war. Zrobiłem tak, ponieważ TomEE, podobnie jak Tomcat używa nazwy pliku war jako fragmentu adresu URI aplikacji. Szybciej napiszę rest niż 06_rest_endpoint-1.0-SNAPSHOT. Po przekopiowaniu pliku war uruchom serwer TomEE. Możesz to zrobić przy pomocy pliku catalina.sh3: /home/mapi/opt/apache-tomee/bin/catalina.sh runJeśli zrobiłeś wszystko zgodnie z powyższą instrukcją masz swój pierwszy działający web service. Gratulacje ;). Aby móc zobaczyć go w działaniu odwiedź stronę: http://localhost:8080/rest/reservation. Powinieneś zobaczyć napis Oto Wszystkie rezerwacje :). Jak działa web service z użyciem JAX-RS Skoro napisałeś już swój pierwszy web service warto zrozumieć co dzieje się pod spodem. Nie ma tam żadnej magii. Jedynie trochę pracy po stronie kontenera aplikacji. Otóż w naszym przypadku specyfikacja JAX-RS wymaga od kontenera aplikacji utworzenia specjalnego serwletu. Serlwet ten ma za zadanie obsługiwać wszystkie żądania, które wysyłane są do naszej aplikacji. Kontener aplikacji musi przeskanować wszystkie klasy w naszej aplikacji pod kątem adnotacji JAX-RS. Jeśli znajdzie te adnotacje w klasach zapamiętuje je. Następnie używa tych klas do obsługi żądań wysyłanych przez klienty4. Więc w tym przypadku, wysłanie żądania na adres http://localhost:8080/rest/reservation spowoduje wywołanie tego serwletu. Następnie serwlet stworzy instancję klasy ReservationWebservice. Na tej instancji wywoła metodę listReservations. Wartość zwrócona przez tę metodę zostanie użyta do przygotowania odpowiedzi dla klienta. REST bez użycia JAX-RS Jak widzisz z powyższego opisu JAX-RS jest jedynie nakładką na mechanizm serwletów. Jeśli czytałeś poprzednie artykuły w ramach kursu to wiesz, że serwlety są sercem ogromnej większości aplikacji webowych napisanych w Javie. Skoro jest to nakładka, to można tę samą funkcjonalność uzyskać bez niej. Innymi słowy można pisać REST’owe web service’y bez użycia JAX-RS, używając standardowego kontenera serwletów. Jednak JAX-RS sporo upraszcza, pozwala programiście używać wyższego poziomu abstrakcji. Nie musisz pamiętać o doGet czy innych metodach z API serwletów. Pozostałe metody web service’u Metody te to jedynie szablony, które mają pokazać Ci przykład użycia adnotacji udostępnionych przez JAX-RS. Pobieranie encji. Metoda GET Poprzednia metoda listReservations odpowiadała na żądanie do ścieżki /reservation i zwracała (teoretycznie) wszystkie rezerwacje. Tym razem chcemy zwrócić pojedynczą rezerwację. Proszę spójrz na przykład poniżej: @GET@Path(\"{id}\")public Response getReservation(@PathParam(\"id\") Integer id) {    return Response.ok(\"Oto rezerwacja o identyfikatorze \" + id + \" :)\").build();}Jak widzisz w tym przypadku metoda getReservation dekorowana jest adnotacją @Path. Metoda ta zostanie wywołana do obsłużenia zapytania wysłanego pod adres /reservation/{id}. Składnia {id} użyta jest do przechwytywania części adresu URL. Dzięki tej składni i użyciu adnotacji @PathParam część tej ścieżki zostanie przekazana w trakcie wywołania metody getReservation. Na przykład zapytanie GET /reservation/123 spowoduje wywołanie tej metody z argumentem id o wartości 123. Edycja encji. Metoda PUT @PUT@Path(\"{id}\")public Response updateReservation(@PathParam(\"id\") Integer id) {    return Response.ok(\"Zmodyfikowaliśmy rezerwację o numerze \" + id + \" :)\").build();}W tym przypadku nowa jest dla Ciebie jedynie adnotacja @PUT. Informuje ona kontener aplikacji o tym, że metoda updateReservation powinna być wywołana jeśli klient wyśle zapytanie PUT /reservation/{id}. Usuwanie encji. Metoda ‘DELETE` @DELETE@Path(\"{id}\")public Response deleteReservation(@PathParam(\"id\") Integer id) {    return Response.ok(\"Usunęliśmy rezerwację o numerze \" + id + \" :)\").build();}Dodawanie encji. Metoda ‘POST` @POSTpublic Response createReservation() {    return Response.ok(\"Rezerwacja została utworzona!\").build();}Testowanie zapytań typu PUT, DELETE Do przetestowania zapytań typu PUT czy DELETE w przeglądarce potrzebujesz odrobiny HTML’a i kodu w języku JavaScript. Przygotowałem dla Ciebie prostą stronę, która może Ci w tym pomóc. Jeśli Twoja instancja TomEE będzie uruchomiona i aplikacja będzie zainstalowana, to po odpowiednim wypełnieniu pól zostanie wysłane żądanie. Słów kilka o CORS CORS (ang. Cross-Origin Resource Sharing) jest mechanizmem używanym przez przeglądarki. Polega on na dodawaniu odpowiednich nagłówków do odpowiedzi serwera. Zawartość tych nagłówków informuje przeglądarkę czy może używać wyników tego zapytania. Mechanizm ten użyty jest do podniesienia bezpieczeństwa używania stron internetowych. Na chwilę obecną musisz wiedzieć, że aby móc używać strony do testowania Twój web service musi dodawać odpowiednie nagłówki do odpowiedzi. Innymi słowy zamiast wysyłać prostą odpowiedź: Response.    ok(\"Usunęliśmy rezerwację o numerze \" + id + \" :)\").    build();Musiałbyś dodać zestaw nagłówków: Response.    ok(\"Usunęliśmy rezerwację o numerze \" + id + \" :)\").    header(\"Access-Control-Allow-Origin\", \"*\")    header(\"Access-Control-Allow-Headers\", \"Content-Type\")    header(\"Access-Control-Allow-Methods\", \"DELETE\")    build();Jest to wymagane dla każdego zapytania, które będzie uruchamiane ze strony do testowania. Jest to spowodowane tym, że adres URL źródła zapytania jest inny niż adres URL web service’u5. W związku z tym, że trzeba to umieścić w wielu miejscach JAX-RS przychodzi z pomocą. Adnotacja @Provider Więcej o tej adnotacji przeczytasz w drugiej części artykułu. Dzisiaj opiszę jedynie część jej możliwości. JAX-RS udostępnia adnotację @Provider. Służy ona do oznaczenia komponentów, które powinny być automatycznie odkryte przez kontener aplikacji. Tą adnotacją oznacza się klasy, które są odpowiedzialne za przekrojowe zadania (ang. cross-cutting) związane z aplikacją. Przykładem takiego przekrojowego zadania może być automatyczne dodawanie nagłówków do każdej odpowiedzi. Ta funkcjonalność pozwala na łatwą implementację wymagań narzucanych przez CORS: @Providerpublic class CORSFilter implements ContainerResponseFilter {    @Override    public void filter(ContainerRequestContext requestContext, ContainerResponseContext responseContext) throws IOException {        MultivaluedMap&lt;String, Object&gt; headers = responseContext.getHeaders();        if (!headers.containsKey(\"Access-Control-Allow-Origin\")) {            headers.add(\"Access-Control-Allow-Origin\", \"*\");        }        if (!headers.containsKey(\"Access-Control-Allow-Headers\")) {            headers.add(\"Access-Control-Allow-Headers\", \"Content-Type\");        }        if (!headers.containsKey(\"Access-Control-Allow-Methods\")) {            headers.add(\"Access-Control-Allow-Methods\", \"GET, PUT, POST, DELETE\");        }    }}Klasa CORSFilter implementuje interfejs ContainerResponseFilter. Interfejs ten zawiera metodę filter, która pozwala między innymi na dodanie nagłówków do każdej odpowiedzi. Dodatkowe materiały do nauki Jest tego sporo, głównie w języku angielskim:   Przykłady kodu użyte w artykule,  Tutorial dotyczący JAX-RS przygotowany przez Oracle,  Praca doktorska Roy’a Fielding’a, gdzie po raz pierwszy użyto określenia REST,  Rozdział w wyżej wspomnianej pracy na temat REST,  REST API Tutorial,  Artykuł o REST na anglojęzycznej wersji Wikipedii,  Specyfikacja JAX-RS 2.1,  Dokumentacja API JAX-RS,  Artykuł na stronie Mozilli o CORS,  Artykuł na temat dojrzałości architektury REST,Podsumowanie Dzisiaj udało Ci się zdobyć sporo wiedzy. Dowiedziałeś się czym jest REST. Co składa się na platformę Java EE. Poznałeś część funkcjonalności jednej ze specyfikacji znajdującej się pod parasolem Java EE. Zainstalowałeś kontener aplikacji, no i przede wszystkim napisałeś swój pierwszy web service przy pomocy JAX-RS. W kolejnym artykule z tej serii zajmę się implementacją bardziej użytecznego web service’u. Jeśli nie chcesz pominąć kolejnych artykułów na blogu dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu!             Zawsze staram się tłumaczyć angielskie terminy. Jednak w tym przypadku poddałem się. Jak przetłumaczyć web service? Usługa sieciowa? Serwis internetowy? Takie tłumaczenie wprowadzałoby więcej zamieszania niż pożytku. Zostanie więc web service, jeśli masz jakiś pomysł jak to przetłumaczyć daj znać ;). &#8617;               W rzeczywistości mimo, że importuję tu API w wersji 2.1 serwer TomEE, którego używam (7.0.4) wspiera wersję 2.0. &#8617;               Jeśli pracujesz w systemie Windows wówczas plik ten nazywa się catalina.bat. &#8617;               Oczywiście jest to uproszczenie. W praktyce proces jest trochę bardziej rozbudowany. Proces ten opisany jest w sekcji 3.7 specyfikacji “Matching Requests to Resource Methods”. Domyślnie nowa instancja klasy obsługującej zapytanie tworzona jest dla każdego zapytania. W większości przypadków nie jest to zachowanie, które chcesz zostawić na produkcyjnym środowisku. &#8617;               W tym przypadku porównywany jest protokół (np. http), domena (np. www.samouczekprogramisty.pl) i port (np. 8080). &#8617;       ","categories": ["Kurs aplikacji webowych"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/rest-web-service-z-java-ee-czesc-1/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/11/20_rest_web_service_artykul.jpg"},{
        "title": "SOLID czyli dobre praktyki w programowaniu obiektowym",
        "excerpt":"Artykuł ten zakłada, że znasz już podstawy języka programowania. Najlepiej gdybyś miał już za sobą drobny projekt, na przykład prosty kalkulator. Abyś mógł wynieść coś z tego artykułu musisz wiedzieć czym są interfejsy i dziedziczenie. Przydatne mogą być też pozostałe artykuły z kursu programowania w języku Java. Czym jest SOLID S.O.L.I.D. to akronim, który wymyślił Robert C. Martin. Uncle Bob (taki ma pseudonim) jest programistą. Ma sporo doświadczenia, przez wielu uważany jest za swego rodzaju autorytet. Akronim ten zbiera zestaw wytycznych. Wytyczne te stosuje się podczas pisania programów w sposób obiektowy. Samo słówko solid można przetłumaczyć jako solidny, konkretny, mocny. Ta gra słów pewnie też miała spore znaczenie dla popularności samego akronimu. Poniżej na przykładach postaram się wyjaśnić poszczególne literki. S jak Samodzielny S pochodzi od Single Responsibility Principle. W oryginalnym wydaniu autor mówi o tym, że klasa powinna mieć wyłącznie jeden powód do zmiany. Wytyczna ta sprowadza się do tego, że dana klasa powinna mieć jeden główny cel. Jedną główną odpowiedzialność. Jedną funkcjonalność, którą realizuje. Klasy, które implementują wyłącznie jedną odpowiedzialność nie są bezpośrednio związane (ang. coupled) z inną funkcjonalnością. Moim zdaniem, w większości przypadków łatwiej jest zrozumieć taki kod, który jest odpowiedzialny za jedną rzecz. Twoje klasy powinny mieć motto: rób jedną rzecz, rób tę rzecz dobrze1. Przykład W praktyce możesz pomyśleć o klasie, która przechowuje szczegóły umowy. Taką umowę czasami trzeba wydrukować. Niezbędne jest też obliczenie miesięcznej kwoty abonamentu. W przypadku upakowania tych dwóch odpowiedzialności do jednej klasy może ona wyglądać następująco: public class Contract {    private final Date start;    private final Date end;    public Contract(Date start, Date end) {        this.start = start;        this.end = end;    }    public BigDecimal getMonthlySubscriptionFee() {        // compute based on end and start        return BigDecimal.ONE;    }    public byte[] formatAsPDF() {        return \"...\".getBytes();    }}Ewidentnie w tym przypadku mamy kilka powodów do zmiany. Jeśli zmieni się wymaganie dotyczące wydruków, czy sposobu obliczania abonamentu musimy zmienić klasę Contract. Literka S w SOLID zachęca do rozdzielenia tych zagadnień: public class Contract {    private final Date start;    private final Date end;    public Contract(Date start, Date end) {        this.start = start;        this.end = end;    }    public Date getStart() {        return start;    }    public Date getEnd() {        return end;    }    public BigDecimal getMonthlySubscriptionFee() {        // compute based on end and start        return BigDecimal.ONE;    }}public class PDFFormatter {    private final Contract contract;    public PDFFormatter(Contract contract) {        this.contract = contract;    }    public byte[] format() {        return \"...\".getBytes();    }}  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. O jak Otwarty O pochodzi od Open/Closed Principle. W tym miejscu Uncle Bob zwraca uwagę na to aby kod, który tworzymy był “możliwy do rozszerzania i zamknięty na modyfikacje”. Sprowadza się do do świadomego użycia kompozycji, dziedziczenia czy modyfikatorów dostępu. Przykład Załóżmy, że firma poza umową chce też wydrukować ulotki. Drukarnia przyjmuje dokumenty w formacie PDF więc i ulotkę trzeba zapisać w tym właśnie formacie. Klasy Contract i PDFFormatter nie różnią się od poprzedniego przykładu. Aby zrealizować to wymaganie można utworzyć dwie nowe klasy: public class Leaflet {    private final String title;    private final String location;    public Leaflet(String title, String location) {        this.title = title;        this.location = location;    }    public String getTitle() {        return title;    }    public String getLocation() {        return location;    }}public class LeafletPDFFormatter {    private final Leaflet leaflet;    public LeafletPDFFormatter(Leaflet leaflet) {        this.leaflet = leaflet;    }    public byte[] format() {        return \"...\".getBytes();    }}Klasa LeafletPDFFormatter jest praktycznie taka sama jak klasa PDFFormatter. W tym przypadku klasa PDFFormatter nie spełnia wytycznych Open/Closed Principle. Nie można rozszerzyć jej funkcjonalności bez zmiany jej kodu źródłowego. Proszę spójrz na przykład poniżej: public class PDFMetadata {    public final List&lt;String&gt; metadata;    public PDFMetadata(String... metadata) {        this.metadata = Arrays.asList(metadata);    }    public List&lt;String&gt; getMetadata() {        return Collections.unmodifiableList(metadata);    }}public class Leaflet {    // ...    public PDFMetadata getPDFMetadata() {        return new PDFMetadata(title, location);    }}public class Contract {    // ...    public PDFMetadata getPDFMetadata() {        return new PDFMetadata(start.toString(), end.toString());    }}public class PDFFormatter {    private final PDFMetadata metadata;    public PDFFormatter(PDFMetadata metadata) {        this.metadata = metadata;    }    public byte[] format() {        return metadata.toString().getBytes();    }}W tym przypadku wprowadziłem klasę PDFMetadata. Zawiera ona dane niezbędne do przygotowania wydruku PDF. Zarówno klasa Leaflet jak i Contract zwracają taką reprezentację. Dzięki temu klasa PDFFormatter może utworzyć wydruk dla każdej z nich. Zauważ, ze teraz klasa PDFFormatter jest otwarta na rozszerzenie. Jeśli Twoja nowa klasa będzie zwracała instancję PDFMetadata będzie można ją przekonwertować do formatu PDF. L jak Liskov Barbara L pochodzi od Liskov Substitution Principle. W przypadku tej wytycznej Twój kod powinien współpracować poprawnie z klasą, jak i wszystkimi jej podklasami. Innymi słowy jeśli zależysz od jakiegoś interfejsu to wszystkie jego implementacje powinny poprawnie działać z Twoją klasą/metodą. Stosowanie się do tej zasady pozwala na dostarczenie alternatywnej implementacji danej funkcjonalności bez zmiany Twojego kodu. Przykład W tym przypadku świetnym przykładem są kolekcje w języku Java: public class SubstitutionExample {    public static void main(String[] args) {        List&lt;String&gt; someList = new ArrayList&lt;&gt;();        Set&lt;String&gt; someSet = new HashSet&lt;&gt;();        Queue&lt;String&gt; someQueue = new PriorityQueue&lt;&gt;();        SubstitutionExample example = new SubstitutionExample();        example.doSomethingWithElements(someList);        example.doSomethingWithElements(someSet);        example.doSomethingWithElements(someQueue);    }    public void doSomethingWithElements(Collection&lt;String&gt; someCollection) {        for (String element : someCollection) {            System.out.println(\"element: \" + element);        }    }}Metoda doSomethingWithElements zrobi dokładnie to samo bez wiedzy o tym z jakim podtypem ma do czynienia. Niezależnie od tego czy będzie to ArrayList czy PriorityQueue metoda zadziała poprawnie. I jak Interfejsy I pochodzi od Interface Segregation Principle. Wytyczna ta mówi o tym, abyś rozdzielał interfejs klasy. Interfejs ten powinien być odpowiednio zdefiniowany. Chodzi tu o aby inny fragment kodu, który używa Twojej klasy używał wyłącznie podzbioru metod, który jest w tamtym przypadku istotny. W oryginale wytyczna ta mówi o tym, ze klienty nie powinny być zmuszane do wprowadzania zależności od interfejsów, których nie używają. Jeśli będziesz stosował się do tej wytycznej to zmiany Twoich klas powinny być łatwiejsze do przeprowadzenia. Dzięki jasno zdefiniowanym interfejsom ryzyko zmiany klas, które używają tych interfejsów będzie mniejsze. Przykład Załóżmy, ze w swoim interfejsie masz 3 metody: public interface ObjectFormatter {    byte[] toPDF(Object someObject);    String toXML(Object someObject);    String toJSON(Object someObject);}Interfejs ten jest używany w trzydziestu innych projektach. W każdym przypadku używa wyłącznie jednej z tych trzech metod. Niestety z jakiegoś powodu musisz zmienić ten interfejs. W konsekwencji każdy z tych projektów musi wprowadzić jakieś zmiany. W praktyce rozdzielenie tego interfejsu na trzy oddzielne może mieć sens: public interface PDFFormatter {    byte[] toPDF(Object someObject);}public interface XMLFormatter {    String toXML(Object someObject);}public interface JSONFormatter {    String toJSON(Object someObject);}W takim przypadku zmiana jednej z tych metod nie pociąga za sobą zmian w każdym z 30 wspomnianych projektów. D jak oDwrócenie zależności D pochodzi od Dependency Inversion Principle. Wytyczna ta mówi, że wysokopoziomowe klasy nie powinny zleżeć od niskopoziomowych detali. Zależność ta powinna być odwrócona poprzez wprowadzenie dodatkowych elementów. Mówi się tu o dodatkowych warstwach abstrakcji, które pozwalają na zmianę kierunku takiej zależności. Osobiście ciężko było mi tę zasadę zrozumieć bez dobrego przykładu. Mam nadzieję, że ten przytoczony poniżej trochę Ci to ułatwi. Przykład Przykład poniżej pokazuje klasę PageCrawler. Klasa ta ma powinna zwrócić odnośniki znajdujące się na stronie. Poza tym, że widzisz tu pogwałcenie zasady Single Responsibility Principle to jeszcze  Dependency Inversion Principle także nie jest spełnione. Klasa PageCrawler zleży od niskopoziomowych detali związanych z obsługą protokołu HTTP i parsowaniem HTML. Zależność ta powinna być odwrócona: public class PageCrawler {    public List&lt;String&gt; findLinks(String url) throws IOException {        HttpURLConnection connection = makeRequest(url);        validateResponse(connection);        String content = getResponse(connection);        return parseLinks(content);    }    private List&lt;String&gt; parseLinks(String content) {        return Collections.emptyList(); // do some magic with content    }    private String getResponse(HttpURLConnection connection) throws IOException {        return connection.getContent().toString();    }    private HttpURLConnection makeRequest(String url) {        return null; //    }    private void validateResponse(HttpURLConnection connection) throws IOException {        if (connection.getResponseCode() != 200) {            throw new IllegalStateException(\"Wrong response code!\");        }        if (connection.getContentLength() &lt; 100) {            throw new IllegalStateException(\"Too small response!\");        }    }}Poniższy przykład pokazuje wprowadzenie dwóch dodatkowych elementów. Są to odpowiednio HTTPFetcher i HTMLTokenizer. Klasy te odpowiedzialne są za ukrycie niskopoziomowych detali wymaganych przez PageCrawler. W tym przypadku PageCrawler zależy od tych dwóch klas. Odwróciłem więc zależność, teraz już wysokopoziomowa klasa (PageCrawler) nie zależy od niskopoziomowych detali (protokół HTTP czy parsowanie HTML). public class HTTPFetcher {    public String fetch(String url) throws IOException {        return \"HTTP request details goes here\";    }}public class HTMLTokenizer {    public List&lt;String&gt; tokenize(String response) {        return Collections.emptyList(); // details about HTML handling goes here    }}public class PageCrawler {    private final HTTPFetcher fetcher;    private final HTMLTokenizer tokenizer;    public PageCrawler(HTTPFetcher fetcher, HTMLTokenizer tokenizer) {        this.fetcher = fetcher;        this.tokenizer = tokenizer;    }    public List&lt;String&gt; findLinks(String url) throws IOException {        String response = fetcher.fetch(url);        List&lt;String&gt; tokens = tokenizer.tokenize(response);        return findLinks(tokens);    }    private List&lt;String&gt; findLinks(List&lt;String&gt; tokens) {        return tokens; // pick only links here    }}Nie rób nic na ślepo Z mojego doświadczenia wynika to, że nie można na ślepo stosować się do wszystkich reguł. Mogą zdarzyć się sytuacje, w których w swojej codziennej pracy znajdziesz przypadek gdzie złamanie wytycznych SOLID ma sens. Możliwe, że czasami napisanie klasy, która ma dziesięć różnych zakresów odpowiedzialności jest dobre. Możliwe, że to dopiero przyczółek do dalszej pracy nad kodem. Postaraj się zrozumieć poszczególne wytyczne. Zacznij je rozważnie stosować dopiero po pełnym ich zrozumieniu. Robienie czegoś na ślepo tylko dlatego, że przeczytało się o tym w dowolnym miejscu moim zdaniem mija się z celem. Zastanów się nad SOLID, zrozum i dopiero wtedy zacznij stosować. Oczywiście tylko w przypadkach gdzie ma to sens :). Istotna jest także sama świadomość istnienia takich wytycznych. Prawdą jest, że nie wszyscy programiści są ich świadomi. Dodatkowe materiały do nauki Z racji tego, że akronim ten jest powszechnie używany znajdziesz sporo informacji na jego temat w internecie. Poniżej zebrałem materiały źródłowe:   SOLID opisany przez Robert’a C. Martin’a,  Single Responsibility Principle,  Open-Closed Principle,  Liskov Substitution Principle,  Interface Segregation Principle,  Dependency Inversion Principle.Dodatkowo poniżej mam dla Ciebie książkę autorstwa twórcy akronimu S.O.L.I.D. Moim zdaniem jest to jedna z obowiązkowych pozycji na liście lektur każdego programisty:   The Clean Code2,  Przykłady użyte w treści artykułu.Podsumowanie Dzisiejszy artykuł był mocno teoretyczny. Przeczytałeś nim o akronimie SOLID. Na przykładach zobaczyłeś jak wyglądają poszczególne składowe tego akronimu. Mam nadzieję, że zachęci Cię to do pisania solidnego kodu ;). Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku w przyszłości proszę dopisz się do newslettera i polub Samouczka na Facebooku. Jeśli będziesz miał jakiekolwiek pytania czy wątpliwości proszę zadaj je w komentarzu, postaram się pomóc. Do następnego razu :).             Wszystkie te reguły podlegają oczywiście dyskusji. W praktyce często ciężko jest zdefiniować czym ta “jedna” rzecz jest. &#8617;               To jest link afiliacyjny. Oznacza to tyle, że jeśli kupisz ten produkt z tego odnośnika pomożesz mi w dalszym prowadzeniu bloga. Nie jest to związane z żadnymi dodatkowymi kosztami dla Ciebie. Dziękuję! :) &#8617;       ","categories": ["Wiedza ogólna","Programista rzemieślnik"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/solid-czyli-dobre-praktyki-w-programowaniu-obiektowym/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/11/27_solid_dobre_praktyki_w_programowaniu_obiektowym_artykul.jpg"},{
        "title": "Walidacja obiektów w języku Java",
        "excerpt":"  Artykuł ten zakłada, że znasz już podstawy języka Java. Abyś mógł wynieść coś z tego artykułu musisz wiedzieć czym są adnotacje. Przydatne mogą być też pozostałe artykuły z kursu programowania w języku Java, szczególnie te dotyczące:   interfejsów,  typów wyliczeniowych (enumów),  wyjątków.Przy budowaniu projektu może pomóc też znajomość Gradle. Specyfikacja Bean Validation Specyfikacja Bean Validation ewoluuje. Wszystko zaczęło się od specyfikacji w wersji 1.0 wydanej w 2009 roku. Najnowsza wersja tej specyfikacji to 2.0. Jest ona częścią Java Enterprise Edition 8. Dodatkowo implementacji tej specyfikacji można używać w Java SE. Walidacja odbywa się w oparciu o reguły (ang. constraint), które stwierdzają, czy dany element jest poprawny. Specyfikacja pozwala na przypisywanie reguł do poszczególnych elementów za pomocą adnotacji i XML1. W dalszej części artykułu opisuję wyłącznie walidację opartą o adnotacje. Dla uproszczenia skupię się jedynie na zastosowaniu walidacji w Java SE. Proszę spójrz na przykładową klasę z adnotacjami do walidacji: public class PaidAccount {    @NotBlank    @Size(min=3)    private String owner;    @Future    private Date validUntil;    public PaidAccount(@NotNull @Size(min = 3) String owner, @Future Date validUntil) {        this.owner = owner;        this.validUntil = validUntil;    }    public String getOwner() {        return owner;    }    public Date getValidUntil() {        return validUntil;    }}W ramach specyfikacji udostępniony jest standardowy zestaw reguł. Na przykład “element nie może mieć wartości null” (@NotNull), “element musi mieć minimum X znaków” (@Size(min=X)), “element musi być datą w przyszłości” (@Future) itd. Przykład powyżej używa właśnie tych standardowych adnotacji. Zwróć uwagę, że do jednego elementu można przypisać wiele adnotacji. Na przykład atrybut owner posiada adnotacje @NotBlank i @Size. Implementacja specyfikacji Sama specyfikacja to nie wszystko. Dostarcza ona jedynie API. Zestaw interfejsów, adnotacji, typów wyliczeniowych i wyjątków. Potrzebna jest jeszcze konkretna implementacja tej specyfikacji. W artykule tym będę używał Hibernate Validator w wersji 6.0.5. Jest to implementacja referencyjna dla specyfikacji Bean Validation w wersji 2.0. Do projektu mogę ją dodać przez następujący fragment w pliku build.gradle: dependencies {    compile group: 'org.hibernate.validator', name: 'hibernate-validator', version: '6.0.5.Final'    compile group: 'org.glassfish', name: 'javax.el', version: '3.0.1-b08'}Druga zależność jest wymagana, ponieważ EL (Expression Language) wykorzystywany jest do formatowania komunikatów błędów. Wymagania dotyczące walidacji Atrybuty, których poprawność będzie sprawdzana, muszą być atrybutami w kontekście specyfikacji Java Beans. Innymi słowy dla każdego z sprawdzanych atrybutów powinna być zaimplementowana metoda dostępowa. Tak zwany “getter”. W poprzednim fragmencie kodu są to metody getOwner i getValidUntil. Adnotacja dotyczące walidacji można stosować do:   atrybutów,  parametrów metody czy konstruktora, na przykład public PaidAccount(@NotNull owner),  elementów wewnątrz kolekcji, na przykład List&lt;@NotBlank String&gt; users,  wartości zwracanej metody,  klas.W przypadku wartości zwracanej metody odpowiednią adnotację przypisuje się do metody dostępowej (gettera). Proszę spójrz na przykład poniżej: @Futurepublic Date getValidUntil() {    return validUntil;}Adnotacje przypisane do klas używane są wtedy, gdy do stwierdzenia czy dany obiekt jest poprawny potrzebujemy dostępu do wielu atrybutów: @ZipCodeCityCoherentpublic class Address {    @NotEmpty    private String zipCode;    @NotEmpty    private String postOfficeCity;    @NotEmpty    private String street;    @NotEmpty    private String number;    public Address(@NotEmpty String zipCode, @NotEmpty String postOfficeCity, @NotEmpty String street, @NotEmpty String number) {        this.zipCode = zipCode;        this.postOfficeCity = postOfficeCity;        this.street = street;        this.number = number;    }    public String getZipCode() {        return zipCode;    }    public String getPostOfficeCity() {        return postOfficeCity;    }    public String getStreet() {        return street;    }    public String getNumber() {        return number;    }}W przykładzie powyżej użyłem własnej adnotacji @ZipCodeCityCoherent. Adnotacja ta pozwala na sprawdzenie czy kod pocztowy i miasto są spójne. O tym jak tworzyć swoje własne adnotacje do walidacji przeczytasz w dalszej części artykułu.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dlaczego używa się walidacji Odpowiedź jest prosta ;). Walidacji używa się, aby mieć pewność, że dany obiekt wypełniony jest poprawnymi danymi. Takie podejście pozwala na stosowanie praktyki “Psuj się szybko, psuj się często” (ang. Fail fast, fail often). Można powiedzieć, że programy napisane przy takim założeniu szybko raportują błędy. Dzięki temu łatwiej jest znaleźć potencjalny błąd - informacja o błędzie pochodzi z miejsca jego wystąpienia, a nie z odległego miejsca w systemie. Nigdy nie ufaj danym pochodzącym od użytkownika Twojego kodu. Niezależnie czy jest to człowiek czy maszyna. Dane wejściowe trzeba walidować. Zawsze. Zdarza się, że brak przecinka kosztuje kilka ładnych milionów dolarów. Walidacja danych nie gwarantuje wyeliminowania wszystkich błędów. Pozwala jednak odsiać znaczną ich część. Dodatkowo walidacja jest czymś powtarzalnym. Mam tu na myśli to, że sposoby walidacji są podobne. Często chcemy sprawdzić czy pole jest wypełnione, czy jest liczbą z odpowiedniego zakresu, czy jest adresem e-mail, itd. Używanie gotowych mechanizmów walidacji pozwala na uniknięcie tej powtarzalnej części pracy. Jak działa walidacja Walidacja to nic innego jak szereg reguł, ograniczeń. Tylko poprawne dane spełniają te ograniczenia. Nakładanie ograniczeń na dane sprowadza się do użycia odpowiednich adnotacji. Instancja klasy klasy, którą sprawdzamy, przekazywana jest do tak zwanego walidatora. Walidator interpretuje adnotacje i uruchamia poszczególne reguły walidacji. Walidacja, bez jasno określonej kolejności polega na:   sprawdzeniu wszystkich “osiągalnych” atrybutów danej instancji,  sprawdzeniu wszystkich metod dostępowych danej instancji (getterów),  sprawdzeniu reguł przypisanych do klasy (adnotacje klasy).Walidacja uruchamiana jest kaskadowo. Proszę spójrz na przykład poniżej: public class MembershipBonus {    @Valid    private PaidAccount userAccount;    @NotEmpty    private String bonusName;    public MembershipBonus(@Valid PaidAccount userAccount, @NotEmpty String bonusName) {        this.userAccount = userAccount;        this.bonusName = bonusName;    }    public PaidAccount getUserAccount() {        return userAccount;    }    public String getBonusName() {        return bonusName;    }}W przykładzie tym użyta jest adnotacja @Valid. Zwraca ona uwagę na to, że instancja klasy PaidAccount także musi być sprawdzona pod kątem poprawności. To czy PaidAccount jest poprawne czy nie określone jest przez adnotacje wewnątrz tej klasy. Sprawdzenie reguł odbywa się poprzez uruchomienie metody validate na instancji klasy implementującej interfejs Validator. Biblioteka, która implementuje specyfikację Bean Validation dosttarcza odpowiednią klasę. Kiedy używamy automatycznej walidacji Do tej pory z użyciem specyfikacji Bean Validation spotkałem się głównie w aplikacjach webowych, bądź takich które używają bazy danych. Specyfikacja nie ogranicza użycia tego mechanizmu tylko do tych zastosowań. Aplikacje webowe Wszystkie dane pochodzące od użytkownika muszą zostać sprawdzone. Użytkownicy Twojej aplikacji mogą wpisać cuda w formularzu, nie można tym danym do końca ufać. Zatem wszystkie dane przychodzące do aplikacji webowej w formie zapytań HTTP są bardzo często walidowane przy użyciu Bean Validation. Obiekty w bazie danych Mimo tego, że baza danych bardzo często pozwala na podstawową walidację przechowywanych danych, nie jest ona wystarczająca. Dodatkowo, poza walidacją przeprowadzaną przez samą bazę danych, używa się Bean Validation. Jest to istotne ponieważ część reguł nie da się wymusić używając wyłącznie mechanizmów bazodanowych. Poza tym szybciej można sprawdzić poprawność danych w kodzie. Wynika to głównie z faktu, że wysłanie zapytania do bazy danych raczej nie jest szybsze niż walidacja przeprowadzona w kodzie. Najczęściej używane reguły Jak już wspomniałem specyfikacja zawiera adnotacje określające najczęściej używane reguły walidacji. Część z nich zebrałem dla Ciebie poniżej:   @NotNull - dany element nie może mieć wartości null,  @NotBlank - dany element nie może mieć wartości null i musi zawierać co najmniej jeden znak (nie może to być spacja, tabulator etc.),  @NotEmpty - dany element nie może mieć wartości null i musi zawierać co najmniej jeden znak,  @Min(X) - dany element musi być liczbą i jego wartość musi być większa bądź równa X,  @Max(X) - dany element musi być liczbą i jego wartość musi być mniejsza bądź równa X,  @Email - dane element musi zawierać poprawny adres e-mail,  @Pattern(regexp=X) - dany element musi pasować do wyrażenia regularnego X.  @Size(min=X, max=Y) - dany element musi mieć rozmiar określony przez elementy adnotacji min i max. Obie wartości są opcjonalne.Oczywiście lista reguł zapewniona przez specyfikację nie jest kompletna. Specyfikacja pozwala na rozszerzanie listy dostępnych reguł. Java SE i walidacja Skoro już wiesz czym jest walidacja, to najwyższy czas sprawdzić ją w praktyce. Przykład poniżej pokazuje sposób uruchomienia walidacji w aplikacji Java SE public class ValidationExample {    private final Validator validator;    public ValidationExample() {        ValidatorFactory validationFactory = Validation.buildDefaultValidatorFactory();        validator = validationFactory.getValidator();    }    public static void main(String[] args) {        ValidationExample example = new ValidationExample();        example.showSimpleValidation();    }    private void showSimpleValidation() {        PaidAccount account = new PaidAccount(\"mp\", Calendar.getInstance().getTime());        Set&lt;ConstraintViolation&lt;PaidAccount&gt;&gt; validationErrors = validator.validate(account);        for (ConstraintViolation&lt;PaidAccount&gt; validationError : validationErrors) {            System.out.println(validationError.getPropertyPath().toString() + \" \" + validationError.getMessage());        }    }}Po uruchomieniu tego programu na konsoli pokażą się następujące komunikaty błędów: validUntil must be a future dateowner size must be between 3 and 2147483647Formatowanie komunikatu błędu Jak widzisz komunikaty błędów nie są po polsku. Wynika to z tego, że domyślne komunikaty dostarczone przez Hibernate Validator są w języku angielskim. Niestety biblioteka aktualnie nie zawiera polskich komunikatów. Możesz to zmienić. Komunikaty błędów zaszyte w kodzie Sposób ten nie jest zalecany! Generalnie niezbyt dobrą praktyką jest umieszczanie tekstu w kodzie źródłowym programu. Doskonale do tego nadają się za to pliki properties, które opisałem poniżej. Modyfikując nieznacznie klasę z adnotacjami możemy wymusić inne komunikaty błędów: @NotNull(message=\"nie może być puste\")@Size(min=3, message=\"musi być dłuższe niż {min}\")private String owner;@Future(message=\"musi być w przyszłości\")private Date validUntil;Po takiej modyfikacji na konsoli pokażą się następujące komunikaty błędów: validUntil musi być w przyszłościowner musi być dłuższe niż 3Komunikaty błędów w plikach properties Pliki z rozszerzeniem properties to pliki tekstowe. Zawierają one zbiór wierszy w postaci klucz=wartość. Pliki te nadają się do przechowywania komunikatów błędów. Domyślna implementacja w kodzie ma zaszyty wyłącznie klucz komunikatu błędu. Na przykład: public @interface Size {    String message() default \"{javax.validation.constraints.Size.message}\";    //...}Przyjęło się, że klucz ma postać &lt;pakiet&gt;.&lt;nazwa_klasy&gt;.&lt;nazwa_atrybutu&gt;. W powyższym przykładzie jest to javax.validation.constraints.Size.message. Następnie klucz ten wraz z wartością umieszcza się w pliku ValidationMessages.properties. Plik ten jest odczytywany przez implementację Bean Validation. Znalezione tam wartości użyte są do budowania komunikatów błędów. Plik ValidationMessages.properties umieść w katalogu projektu src/main/resources: javax.validation.constraints.Size.message=musi być dłuższe niż {min}javax.validation.constraints.NotNull.message=nie może być pustejavax.validation.constraints.Future.message=musi być w przyszłości  Niestety pliki properties do wersji 8 języka są “dziwne”. Mam tu na myśli to, że domyślnym kodowaniem z jakim są one czytane jest ISO-8859-1. W związku z tym możesz zobaczyć na konsoli: validUntil musi byÄ w przyszÅoÅciowner musi byÄ dÅuÅ¼sze niÅ¼ 3Te magiczne znaczki to nic innego ja próba interpretowania pliku properties zapisanego przy pomocy kodowania UTF-8 przez Javę stosując kodowanie ISO-8859-1. IntelliJ Idea pozwala na ustawienie kodowania plików properties. Możesz to zrobić w menu File -&gt; Settings -&gt; Editor -&gt; File encodings. Istotne jest abyś ustawił ich kodowanie na ISO-8859-1 i zaznaczył opcję “Transparent native-to-ascii conversion”. Przy takim ustawieniu możesz tworzyć pliki properties w normalny sposób. IntelliJ pod spodem zrobi za Ciebie odpowiednią konwersję znaków. Na przykład powyższy plik properties przerobiony przez IntelliJ wygląda następująco: javax.validation.constraints.Size.message=musi by\\u0107 d\\u0142u\\u017Csze ni\\u017C {min}javax.validation.constraints.NotNull.message=nie mo\\u017Ce by\\u0107 pustejavax.validation.constraints.Future.message=musi by\\u0107 w przysz\\u0142o\\u015BciJava 9 rozwiązuje ten problem przez ustawienie domyślnego kodowania na UTF-8 co dużo lepiej odpowiada obecnym standardom. Szablon formatów błędu Celem tego artykułu nie jest wyjaśnianie Expression Language, ma on dużo większe możliwości. Ten podpunkt ma Ci tylko pomóc zrozumieć użycie EL w komunikatach błędów. Zauważyłeś użycie {min} wewnątrz komunikatu błędu? To właśnie język EL. To właśnie ten element, który zmusił mnie do dodania dodatkowej zależności w pliku build.gradle. Składnia {zmienna} pozwala na odwołanie się do elementu adnotacji. W naszym przypadku jest to element min. W wynikowym komunikacie błędu znalazła się wartość 3 - wartość elementu min. Te same szablony użyte są do odwołania się do wartości komunikatu błędu z plików properties. Własna adnotacja do walidacji Specyfikacja Bean Validation zezwala na tworzenie własnych reguł walidacji. Dzięki temu mechanizm ten jest łatwo rozszerzalny. Utworzenie własnej reguły przeważnie sprowadza się do utworzenia adnotacji i implementacji klasy sprawdzającej. Implementacja adnotacji Poniższy przykład pokazuje adnotację, którą użyłem w jednym z powyższych fragmentów kodu. Służy ona do sprawdzenia czy atrybut klasy zawierający kod pocztowy pasuje do atrybutu zawierającego miasto: @Target(TYPE)@Retention(RUNTIME)@Constraint(validatedBy = ZipCodeCityCoherentValidator.class)public @interface ZipCodeCityCoherent {    String message() default \"{pl.samouczekprogramisty.misc.validation.ZipCodeCityCoherent.message}\";    Class&lt;?&gt;[] groups() default {};    Class&lt;? extends Payload&gt;[] payload() default {};}Adnotacja ta może być przypisana wyłącznie do klasy @Target(TYPE). @Retention(RUNTIME) określa, że informacja o adnotacji ma być widoczna w trakcie uruchomienia programu. Dodanie do naszej adnotacji @Constraint(validatedBy = ZipCodeCityCoherentValidator.class) sprawia, że jest ona “widoczna” przez Bean Validation. W tym miejscu określiłem też klasę, która będzie wywołana aby przeprowadzić właściwą walidację. W tym przypadku jest to klasa ZipCodeCityCoherentValidator. Ciało adnotacji zawiera trzy elementy. Są to odpowiednio message, groups i payload. Komunikat błędu jest przechowywany w elemencie message. W tym przypadku jest to odwołanie do zawartości pliku properties: pl.samouczekprogramisty.misc.validation.ZipCodeCityCoherent.message=miasto nie pasuje do kodu pocztowegoElementy groups i payload są wymagane. Ich zastosowanie pominę, artykuł i tak jest wystarczająco długi ;). Skoro mamy już adnotację nadszedł czas na implementację klasy sprawdzającej. Implementacja klasy sprawdzającej Każda klasa sprawdzająca powinien implementować interfejs ConstraintValidator. W momencie walidowania danego elementu zostaje wywołana metoda isValid. To implementacja tej metody będzie decydowała o tym czy dany element jest poprawny. public class ZipCodeCityCoherentValidator implements ConstraintValidator&lt;ZipCodeCityCoherent, Address&gt; {\t@Override\tpublic boolean isValid(Address address, ConstraintValidatorContext context) {\t\treturn \"00-000\".equals(address.getZipCode()) &amp;&amp; \"Warszawa\".equals(address.getPostOfficeCity());\t}}W powyższym przykładzie implementacja jest strasznie naiwna, masz pomysł jak obsłużyć więcej kombinacji miast/kodów pocztowych? Zadanie do wykonania Napisz program, który pobierze od użytkownika następujące dane:   imię,  datę urodzenia w formacie YYYY-MM-dd mm:hh,  adres e-mail.Utwórz klasę grupującą te dane. Upewnij się, że są one poprawne używając adnotacji dostępnych w specyfikacji Bean Validation bądź własnych:   imię powinno mieć długość co najmniej 3 liter,  imię powinno zaczynać się od wielkiej litery,  imię powinno składać się wyłącznie z liter,  data urodzenia powinna być w przeszłości,  użytkownik powinien mieć co najmniej 4 lata.Materiały dodatkowe   Specyfikacja Bean Validation 2.0,  Artykuł na temat Fail fast, fail often,  Biblioteka rozszerzająca standardowy zestaw reguł,  Fragment tutoriala dla Java EE 7 opisujący walidację,  Strona projektu Hibernate Validator,  Kod źródłowy przykładów użytych w artykule.Podsumowanie Po lekturze artykułu wiesz już czym jest walidacja. Masz świadomość dlaczego jest ona istotna. Potrafisz użyć walidacji w swojej aplikacji używając dostępnych reguł walidacji. Umiesz też zaimplementować swoje własne reguły. Ćwiczenie, które wykonałeś pozwoliło Ci sprawdzić tę wiedzę w praktyce. Gratulacje! ;) Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku proszę dopisz się do samouczkowego newslettera i polub stronę na Facebooku. Jeśli cokolwiek nie będzie dla Ciebie jasne zadaj pytanie w komentarzu, postaram się pomóc. Do następnego razu!             Jeśli chcesz przeczytać więcej o XML zapraszam do osobnego artykułu na blogu. &#8617;       ","categories": ["Kurs aplikacji webowych"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/walidacja-obiektow-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/12/04_walidacja_obiektow_w_jezyku_java_artykul.jpg"},{
        "title": "Samouczek na rozmowie - znajdź brakujący element",
        "excerpt":"  To jest artykuł z serii “Samouczek na rozmowie”. W ramach tej serii staram się, między innymi, rozwiązywać zadania. Zadania te często zdarzają się na rozmowach kwalifikacyjnych. W trakcie rozwiązywania takich zadań umiejętność szacowania złożoności obliczeniowej jest niezwykle ważna. Przyda się też umiejętność pisania testów jednostkowych. Dzięki nim bardzo łatwo przetestujesz działanie algorytmu.   Podstawy złożoności obliczeniowej,  Test Driven Development na przykładzie,  Testy jednostkowe z JUnit,Podstawą jest oczywiście znajomość języka programowania, ja używał będę Javy jednak możesz użyć dowolnego języka programowania. W opisie problemu będę używał “pseudo kodu”. Przykładowe rozwiązania będą w języku Java.   Kurs programowania w języku Java.Kilka wskazówek dotyczących rozwiązywania zadań Akurat to zadanie miałem sam na rozmowie kwalifikacyjnej. Rozmowa przeprowadzana na stanowisko starszego programisty. Sam problem nie jest dość trudny. Zauważyłem, że jest to częsta praktyka. Problemy do rozwiązania na rozmowach kwalifikacyjnych przeważnie służą tylko do tego, żeby zweryfikować czy kandydat zna składnię danego języka. Dodatkowo zadania tego typu sprawdzają umiejętność analizowania problemu i szukania rozwiązania. Na rozmowie rozwiązałem ten problem algorytmem o najlepszej złożoności czasowej, jednak nie był on optymalny pod kątem użycia pamięci. Mimo tego, że moje rozwiązanie nie było idealne dostałem ofertę pracy. Tutaj chcę Ci pokazać, że nawet jeśli nie rozwiążesz problemu w idealny sposób a będziesz sensownie kombinował, uda się. Zacznij od najprostszego rozwiązania. Zacznij od czegokolwiek i później głośno zastanawiaj się nad minusami Twojego rozwiązania. Prowadzący rozmowę widząc Twoje zaangażowanie często pomogą i nakierują Cię na lepsze rozwiązanie problemu. Zadanie do wykonania Napisz funkcję findMissing, która jako argument przyjmuje tablicę N liczb całkowitych z zakresu od 0 do N. W tablicy wszystkie elementy są unikalne. Liczb z zakresu &lt;0, N&gt;, jest N + 1. Tablica ma długość N. W tablicy brakuje jednego elementu z zakresu. Funkcja findMissing powinna zwrócić brakujący element: tablica = [0, 2, 1, 4]findMissing(tablica) == 3W przykładzie wejściem jest tablica, która ma 4 elementy. Brakuje w niej liczby 3, i właśnie taką liczbę zwraca funkcja findMissing. Najprostsze rozwiązanie problemu Zacznę od najprostszego rozwiązania problemu. Na wejściu mamy tablicę1, w której brakuje jednego elementu z zakresu &lt;0, N&gt;. Żeby znaleźć brakujący element można sprawdzić czy każdy z elementów występuje w tablicy. Pierwsza iteracja sprawdzi czy w tablicy występuje 0, kolejna 1 i tak dalej aż dojdziemy do N. Proszę spójrz na przykładowe rozwiązanie: private static int naiveFindMissing(int... array) {    int missing = 0;    boolean elementFound;    for (int elementToFind = 0; elementToFind &lt;= array.length; elementToFind++) {        elementFound = false;        for (int elementInArray : array) {            if (elementToFind == elementInArray) {                elementFound = true;                break;            }        }        if (!elementFound) {            missing = elementToFind;            break;        }    }    return  missing;}Złożoność obliczeniowa Ten algorytm działa i znajduje brakujący element. Aby znaleźć brakujący element algorytm używa zagnieżdżonych pętli. Ilość iteracji w każdej z nich zależna jest od liczby elementów. Złożoność obliczeniowa tego algorytmu to Ο(n^2) Złożoność pamięciowa Algorytm ten używa stałej liczby zmiennych, jest ona niezależna od wielkości danych wejściowych. W związku z tym złożoność pamięciowa tego algorytmu jest stała, wynosi ona Ο(1). Pamięciożerne rozwiązanie Teraz spróbuję ugryźć problem z innej strony. Z opisu problemu wiem, że brakuje jednej liczby z zakresu &lt;0, N&gt;. Pomysł jest taki, aby stworzyć tablicę wartości logicznych (flag), które będą wskazywały czy dany element znajduje się w tablicy. Iterując po elementach tablicy wejściowej można oznaczać każdą z flag. Następnie iterując po tablicy z flagami można znaleźć tę, która ma wartość false. To ona będzie wskazywała brakujący element: private static int memoryGreedyFindMissing(int... array) {    boolean[] foundElements = new boolean[array.length + 1];    for (int element : array) {        foundElements[element] = true;    }    for (int index = 0; index &lt; foundElements.length; index++) {        if (!foundElements[index]) {            return index;        }    }    throw new IllegalStateException(\"At least one flag should be equal false!\");}Złożoność obliczeniowa Algorytm wymaga przejścia przez wszystkie elementy tablicy wejściowej. Dodatkowo iterujemy po tablicy flag. Rozmiar tej tablicy jest także zależy od wielkości danych wejściowych. Uzyskujemy zatem lepszą złożoność obliczeniową niż w poprzednim przypadku Ο(2n) = Ο(n). Złożoność pamięciowa Aby algorytm działał konieczna jest inicjalizacja tablicy z flagami. Jej rozmiar zależny jest od wielkości danych wejściowych. W związku z tym algorytm ten ma złożoność pamięciową Ο(n). Zatem kosztem pamięci udało mi się poprawić wydajność algorytmu. W większości przypadków taka zmiana jest akceptowalna, jednak problem ten można rozwiązać jeszcze wydajniej. Optymalne rozwiązanie Z opisu zadania wiesz, że szukamy brakującej liczby z zakresu &lt;0, N&gt;. Liczby 0, 1, 2, …, N to ciąg arytmetyczny. Istnieje wzór, który pozwala na obliczenie sumy elementów ciągu arytmetycznego: Załóżmy, że tablica wejściowa ma 100. Wiemy zatem, że szukamy liczby z zakresu 0 do 100. Liczb w tym zakresie jest 101, pierwszy element ma wartość 0 a różnica pomiędzy elementami wynosi 1. Podstawiając te wartości pod wzór otrzymujemy sumę elementów: Skoro znamy oczekiwaną sumę możemy zsumować zawartość przekazanej tablicy i odjąć tę wartość od oczekiwanej sumy. Wynik odejmowania to brakujący element: private static int optimalFindMissing(int... array) {    int expectedSum = (array.length + 1) * array.length / 2;    int actualSum = 0;    for (int element : array) {        actualSum += element;    }    return expectedSum - actualSum;}Złożoność obliczeniowa W tym przypadku w rozwiązaniu jest wyłącznie jedna pętla o złożoności Ο(n). Obliczenie sumy elementów ma złożoność Ο(1). Więc finalnie złożoność obliczeniowa tego algorytmu to Ο(n). Złożoność pamięciowa Algorytm ten wymaga stałej liczby zmiennych. Liczba ta nie jest zależna od wielkości danych wejściowych. Zatem złożoność pamięciowa tego algorytmu to Ο(1). Wyślij mi swoje zadanie Jeśli chcesz abym spróbował omówić zadanie, na które Ty trafiłeś daj znać. Zastrzegam jednak, że nie jestem alfą i omegą. Potrafię sobie wyobrazić problemy, na które nie znajdę najlepszego rozwiązania. Niemniej jednak postaram się rozwiązać to zadanie w najlepszy znany mi sposób. Zadania możesz wysłać na mój adres e-mail marcin [małpka] samouczekprogramisty.pl. Często firmy zastrzegają sobie to, żeby nie rozpowszechniać zadań, które były na rozmowie kwalifikacyjnej. Jeśli tak było w Twoim przypadku proszę uszanuj wolę danej firmy i nie przesyłaj mi takiego zadania. Podsumowanie Po przeczytaniu artykułu znasz trzy sposoby rozwiązania zadanego problemu. Znasz złożoność pamięciową i obliczeniową każdego z rozwiązań. Jesteś o jedno zadanie lepiej przygotowany do rozmowy kwalifikacyjnej ;). Przykładowe rozwiązania, przedstawione w artykule znajdziesz na samouczkowym githubie. Kod zawiera także testy jednostkowe, których użyłem do weryfikacji poprawności działania algorytmów. Jeśli nie chcesz pominąć kolejnych artykułów z tej serii dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Jak zwykle, jeśli masz jakiekolwiek pytania proszę zadaj je w komentarzach. Postaram się pomóc ;). Do następnego razu!             Właściwie jest to argument, który akceptuje zmienną liczbę argumentów. Taka sygnatura metody pozwala także na przekazanie tablicy. &#8617;       ","categories": ["Samouczek na rozmowie","Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/samouczek-na-rozmowie-znajdz-brakujacy-element/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2017/12/10_rozmowa_kwalifikacyjna_brakujacy_element_zadanie_artykul.jpg"},{
        "title": "Struktury danych - lista wiązana",
        "excerpt":"Struktury danych Lista wiązana to struktura danych. Struktury danych opisują sposób przechowywania danych w pamięci komputera. Przykładową strukturą danych jest tablica. Każda struktura danych ma charakterystyczne dla siebie właściwości. Na przykład dodanie elementu na początek tablicy ma złożoność obliczeniową Ο(n). Ta sama operacja dla listy wiązanej ma złożoność Ο(1)1. Te właściwości sprawiają, że użycie konkretnej struktury może uprościć rozwiązanie niektórych problemów. Możemy powiedzieć, że czasami lepiej jest użyć tablicy a w innym przypadku lista wiązana jest lepszym rozwiązaniem. Wszystko zależy od problemu, który próbujemy rozwiązać. Strukturę danych dopasowuje się do problemu. Klasyczną pozycją jeśli chodzi o powiązanie algorytmów i struktur danych jest książka autorstwa Niklausa Wirtha Algorytmy + struktury danych = programy. Struktury danych w językach programowania Struktura danych jest niezależna od języka programowania. Można ją zaimplementować w różnych językach. Na przykład tablica jest uniwersalną strukturą, która istnieje w każdym znanym mi języku programowani. Podobnie sytuacja wygląda z listą wiązaną. Przeważnie w standardowej bibliotece danego języka znajdzie się już gotowa implementacja tej struktury danych. W języku Java implementacją dwukierunkowej listy wiązanej jest klasa LinkedList. O tym czym jest dwukierunkowa lista wiązana przeczytasz w jednym z akapitów poniżej. Skoro zatem mamy gotowe implementacje to po co pisać kolejną? Jedynym powodem jest nauka i zrozumienie zasady działania danej struktury danych. Jeśli dany język dostarcza implementacji danej struktury najlepszym sposobem będzie jej użycie. Nie wymyślaj koła na nowo :). Struktury danych dostępne w standardowej bibliotece będą na pewno lepiej zaimplementowane niż własna wersja. Dodatkowo będę przetestowane przez dużo większą liczbę programistów. Jak działa lista wiązana Lista wiązana to struktura, która składa się z węzłów. Każdy z węzłów zawiera element, który przechowuje. Dodatkowo posiada także odnośniki do innych elementów. W ten sposób powstaje łańcuch powiązanych ze sobą węzłów. To ile odnośników przechowuje węzeł określa czy lista jest jedno, czy dwukierunkowa. W dalszej części artykułu te odnośniki do sąsiednich elementów będę nazywał wskaźnikami. Lista jednokierunkowa posiada wyłącznie wskaźnik do jednego elementu. Lista dwukierunkowa posiada dwa wskaźniki, do obu sąsiadujących elementów. Obrazki poniżej prezentują przykładowe listy z trzema elementami. Prostokąty to węzły, strzałki pokazują powiązania pomiędzy węzłami.         Lista jednokierunkowa.          Lista dwukierunkowa.  Lista wiązana jest strukturą, w której kolejność elementów ma znaczenie. Każdy z elementów ma swój numer, indeks, który zwyczajowo zaczyna się liczyć od 0. Jeśli lista jest pusta wskaźnik na pierwszy/ostatni węzeł jest pusty (w przypadku Javy ma wartość null). Wskaźniki na następny/poprzedni węzeł w ostatnim/pierwszym węźle w liście są puste. Lista jednokierunkowa Jak już wiesz lista to powiązane ze sobą węzły. Przykładowa implementacja takiego węzła może wyglądać następująco: private static class Node&lt;E&gt; {    private E element;    private Node&lt;E&gt; next;    Node(E element) {        this.element = element;    }}Klasa ta posiada element, atrybut ten przechowuje wartość z danego węzła. Każdy węzeł zawiera również wskaźnik do kolejnego węzła w liście. Kolejny węzeł przechowywany jest w atrybucie next. Listę jednokierunkową w tym przypadku można przedstawić jako klasę, która zawiera informację o początku listy. W przykładzie poniżej pierwszy element z listy przechowywany jest w atrybucie first. public class SingleLinkedList&lt;E&gt; {    private Node&lt;E&gt; first;    private static class Node&lt;E&gt; {        private E element;        private Node&lt;E&gt; next;        Node(E element) {            this.element = element;        }    }}Sprawdzanie czy lista jest pusta Mając taką klasę w prosty sposób możemy sprawdzić czy lista zawiera jakiekolwiek elementy. Wystarczy sprawdzić czy pierwszy element istnieje: public boolean isEmpty() {    return first == null;}Złożoność obliczeniowa tej operacji to Ο(1). Sprawdzanie rozmiaru listy Kolejną podstawową operacją jest sprawdzanie rozmiaru listy. Poniżej pokazuję naiwną implementację tej operacji: public int size() {    int size = 0;    Node&lt;E&gt; currentNode = first;    while (currentNode != null) {        size++;        currentNode = currentNode.next;    }    return size;}Przechodząc po wszystkich elementach listy otrzymuję złożoność Ο(n)2.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Pobieranie elementu z listy Wspomniałem wyżej, że lista wiązana jest strukturą, w której kolejność elementów jest istotna. Każdy z elementów ma swój indeks, podobnie jak w tablicy. Przydałaby się w takim razie metoda, która pozwoli pobrać element znajdujący się pod danym indeksem: public E get(int index) {    if (isEmpty() || index &lt; 0) {        throw new IndexOutOfBoundsException(\"Index \" + index);    }    Node&lt;E&gt; currentNode = first;    int currentIndex = index;    while (currentIndex &gt; 0) {        if (currentNode == null) {            throw new IndexOutOfBoundsException(\"Index \" + index);        }        currentNode = currentNode.next;        currentIndex--;    }    return currentNode.element;}Pierwszy warunek sprawdza czy index ma szanse być poprawny. Następnie przechodząc przez kolejne elementy listy, zaczynając od początku dochodzę do elementu znajdującego się pod żądanym indeksem. W związku z tym, że pętla while zależna jest od liczby elementów znajdujących się w liście złożoność tej operacji to Ο(n). Dodawanie elementu do listy Dodawanie nowego elementu do listy wiązanej zależy od tego gdzie chcemy taki element dodać. Rysunek poniżej pokazuje przykład dodawania elementu pomiędzy istniejącymi węzłami:         Dodawanie węzła do listy jednokierunkowej.  W takim przypadku należy w odpowiedni sposób przepiąć wskaźnik na kolejny element. Więc aby dodać element pod indeksem N potrzebuję dostęp do elementu pod indeksem N - 1. Metoda pomocnicza pozwala w łatwy sposób dostać się do obu węzłów: private static class NodePair&lt;E&gt; {    private final Node&lt;E&gt; previous;    private final Node&lt;E&gt; current;    private NodePair(Node&lt;E&gt; previous, Node&lt;E&gt; current) {        this.previous = previous;        this.current = current;    }}private NodePair&lt;E&gt; getNodeWithPrevious(int index) {    if (isEmpty() || index &lt; 0) {        throw new IndexOutOfBoundsException(\"Index \" + index);    }    Node&lt;E&gt; previousNode = null;    Node&lt;E&gt; currentNode = first;    int currentIndex = index;    while (currentIndex &gt; 0) {        if (currentNode == null) {            throw new IndexOutOfBoundsException(\"Index \" + index);        }        previousNode = currentNode;        currentNode = currentNode.next;        currentIndex--;    }    return new NodePair&lt;&gt;(previousNode, currentNode);}Mając już metodę pomocniczą mogę zaimplementować dodawanie elementów do listy. Proszę spójrz na przykładową implementację poniżej: public boolean add(int index, E element) {    if (first == null &amp;&amp; index == 0) {        first = new Node&lt;&gt;(element);        return true;    }    NodePair&lt;E&gt; pair = getNodeWithPrevious(index);    Node&lt;E&gt; previousNode = pair.previous;    Node&lt;E&gt; nodeAtIndex = pair.current;    // adding at the beginning of the list    if (previousNode == null) {        first = new Node&lt;&gt;(element);        first.next = nodeAtIndex;        return true;    }    Node&lt;E&gt; newNode = new Node&lt;&gt;(element);    newNode.next = nodeAtIndex;    previousNode.next = newNode;    return true;}Pierwszy blok if obsługuje dodanie elementu do pustej listy. W tym przypadku po prostu tworzę nową instancję klasy Node i ustawiam ją jako atrybut first. Kolejny blok if obsługuje dodanie elementu na początku listy. W tym przypadku atrybut first musi być zmieniony. Resztę przypadków obsługują ostatnie linijki metody. W przypadku tej implementacji dodanie elementu na początku listy ma złożoność Ο(1). Dodanie nowego elementu w innym miejscu to operacja o złożoności Ο(n). Usuwanie elementu z listy W przypadku usuwania elementu z listy również trzeba manipulować wskaźnikiem na kolejny element. Operację usuwanie pokazałem na rysunku poniżej:         Usuwanie węzła z listy jednokierunkowej.  Także i tutaj pomocna jest metoda getNodeWithPrevious. public E remove(int index) {    NodePair&lt;E&gt; pair = getNodeWithPrevious(index);    Node&lt;E&gt; previousNode = pair.previous;    Node&lt;E&gt; nodeToRemove = pair.current;    E removedElement = nodeToRemove.element;    // removing first node    if (previousNode == null) {        first = nodeToRemove.next;        return removedElement;    }    previousNode.next = nodeToRemove.next;    return removedElement;}Blok if obsługuje usunięcie pierwszego elementu z listy. W tym przypadku należy zmienić wartość atrybutu first. W przypadku tej implementacji usunięcie elementu z początku listy ma złożoność Ο(1). Usunięcie elementu z innego miejsca to operacja o złożoności Ο(n). Dwukierunkowa lista wiązana Dwukierunkowa lista wiązana od listy jednokierunkowej różni się tym, że każdy z węzłów zawiera wskaźnik na poprzedni i następny element. Sama lista zawiera też atrybuty wskazujące pierwszy i ostatni węzeł w liście: public class DoubleLinkedList&lt;E&gt; {    private Node&lt;E&gt; first;    private Node&lt;E&gt; last;    private static class Node&lt;E&gt; {        private E element;        private Node&lt;E&gt; next;        private Node&lt;E&gt; previous;        Node(E element) {            this.element = element;        }    }}Sprawdzanie czy lista jest pusta Podobnie jak w przypadku listy jednokierunkowej, sprawdzenie czy lista ma pierwszy węzeł wystarczy: public boolean isEmpty() {    return first == null;}Sprawdzanie rozmiaru listy public int size() {    int size = 0;    Node&lt;E&gt; currentNode = first;    while (currentNode != null) {        size++;        currentNode = currentNode.next;    }    return size;}Także tutaj naiwna implementacja polega na każdorazowym zliczaniu wszystkich elementów listy. Pobieranie elementu z listy Implementacja tej metody polega na przechodzeniu po wszystkich elementach od początku do żądanego indeksu. Także tutaj implementacja ta nie różni się znacznie od listy jednokierunkowej: public E get(int index) {    return getNode(index).element;}private Node&lt;E&gt; getNode(int index) {    if (isEmpty() || index &lt; 0) {        throw new IndexOutOfBoundsException(\"Index \" + index);    }    Node&lt;E&gt; currentNode = first;    int currentIndex = index;    while (currentIndex &gt; 0) {        if (currentNode == null) {            throw new IndexOutOfBoundsException(\"Index \" + index);        }        currentNode = currentNode.next;        currentIndex--;    }    return currentNode;}Dodawanie elementu do listy W przypadku listy dwukierunkowej węzły zawierają dwa wskaźniki. Operacje modyfikujące taką listę wymagają przepięcia każdego z tych wskaźników. Rysunek poniżej pokazuje przykładowe usunięcie elementu znajdującego się w środku listy:         Dodawanie nowego węzła do listy dwukierunkowej.  Implementacja tej metody musi obsłużyć dodawanie elementu do pustej listy, dodawanie elementu na koniec i początek listy jak i dodawanie element pomiędzy istniejące węzły: public boolean add(int index, E element) {    if (first == null &amp;&amp; index == 0) {        first = new Node&lt;&gt;(element);        last = first;        return true;    }    Node&lt;E&gt; nodeAtIndex = getNode(index);    // adding at the end of the list    if (nodeAtIndex == null) {        Node&lt;E&gt; previousLast = last;        last = new Node&lt;&gt;(element);        last.previous = previousLast;        previousLast.next = last;        return true;    }    // adding at the beginning of the list    if (nodeAtIndex.previous == null) {        Node&lt;E&gt; previousFirst = first;        first = new Node&lt;&gt;(element);        first.next = previousFirst;        previousFirst.previous = first;        return true;    }    Node&lt;E&gt; newNode = new Node&lt;&gt;(element);    Node&lt;E&gt; previous = nodeAtIndex.previous;    previous.next = newNode;    newNode.previous = previous;    newNode.next = nodeAtIndex;    nodeAtIndex.previous = newNode;    return true;}Usuwanie elementu z listy W tym przypadku także należy zmodyfikować wiele wskaźników. Rysunek poniżej pokazuje jak ta operacja wygląda:         Usuwanie węzła z listy dwukierunkowej.  Należy w odpowiedni sposób obsłużyć usuwanie pierwszego i ostatniego elementu. Odpowiednio pierwszy i drugi blok if obsługują te przypadki: public E remove(int index) {    Node&lt;E&gt; nodeToRemove = getNode(index);    Node&lt;E&gt; previousNode = nodeToRemove.previous;    Node&lt;E&gt; nextNode = nodeToRemove.next;    E removedElement = nodeToRemove.element;    // removing first node    if (previousNode == null) {        if (nextNode == null) {            first = null;            last = null;        }        else {            first = nextNode;            nextNode.previous = null;        }        return removedElement;    }    // removing last node    if (nextNode == null) {        last = previousNode;        previousNode.next = null;        return removedElement;    }    previousNode.next = nextNode;    nextNode.previous = previousNode;    return removedElement;}Porównanie złożoności obliczeniowych Poniższa tabela zawiera zestawienie złożoności obliczeniowych podstawowych operacji dla listy wiązanej i tablicy.             Operacja      Tablica      Lista wiązana                  pobieranie liczby elementów      Ο(1)      Ο(1)              dodawanie elementu na końcu/początku      Ο(n)      Ο(1)              dodawanie elementu      Ο(n)      Ο(n)              usuwanie elementu na końcu/początku      Ο(n)      Ο(1)              usuwanie elementu      Ο(n)      Ο(n)              pobieranie elementu z końca/początku      Ο(1)      Ο(1)              pobieranie elementu      Ο(1)      Ο(n)      Jak widzisz w niektórych przypadkach używając listy wiązanej można uzyskać lepszą złożoność obliczeniową niż w przypadku tablicy. Najczęściej zadawane pytania Czym różni się lista wiązana od tablicy Lista wiązana to struktura, która przetrzymuje elementy rozrzucone w pamięci. Tablica potrzebuje jednolitego obszaru w pamięci komputera. Ponadto tablica ma inne złożoności obliczeniowe niż lista wiązana dla podstawowych operacji pobierania, dodawania czy usuwania elementów. Kiedy używać listy wiązanej Na początku mojej przygody z programowaniem mówiono mi, że listy powinno używać się w momencie kiedy nie chcemy zajmować spójnego bloku w pamięci. Nie wydaje mi się, żeby ten argument był nadal bardzo istotny. Dalej jednak ważne są złożoności obliczeniowe zebrane w tabelce wyżej. Jeśli często dodajesz/usuwasz elementy z początku/końca kolekcji i nie potrzebujesz dostępu do innych elementów niż pierwszy/ostatni to lista wiązana jest lepszym wyborem niż tablica. Czy można odwrócić listę wiązaną W przypadku listy dwukierunkowej jest to proste. Wystarczy przechodzić po liście od ostatniego elementu do początku. Operacja ta ma złożoność Ο(n). W przypadku listy jednokierunkowej jest to trudniejsze. Dla listy jednokierunkowej operacja odwrócenia ma złożoność Ο(n^2) Co się dzieje z pominiętymi elementami W przykładowej implementacji powyżej mogłeś zwrócić uwagę na to, że przepinam wskaźniki na inne elementy. Przez taką manipulację możemy “gubić” instancje klasy Node. Takie instancje nadal zajmują miejsce na stercie. W przypadku Javy z pomocą przychodzi mechanizm “zbierania śmieci” (ang. garbage collection), który wykrywa takie obiekty i usuwa je z pamięci. Dodatkowe materiały do nauki Jeśli chcesz spojrzeć na temat z innego punktu widzenia zachęcam Cię do przeczytania materiałów, które zebrałem poniżej:   Artykuł o liście wiązanej na Wikipedii,  Artykuł na temat list na Wikibooks,  Materiały dotyczące list przygotowane przez Jerzego Wałaszka,  Kod źródłowy przykładów użytych w artykule,  Implementacja dwukierunkowej listy wiązanej z OpenJDK.Zadania do wykonania Skoro już wiesz jak działa lista wiązana nadszedł czas na Twoją implementację. Przygotowałem dla Ciebie dwa zadania do wykonania:   Zmodyfikuj klasę SingleLinkedList w taki sposób aby dodawanie elementów na koniec listy miało złożoność Ο(1).  Dodaj metodę reversed do klas SingleLinkedList i DoubleLinkedList. Metoda ta powinna zwrócić nową instancję klasy, w której węzły będą w odwróconej kolejności.  Zmodyfikuj klasy SingleLinkedList i DoubleLinkedList w taki sposób aby pobieranie rozmiaru listy miało złożoność Ο(1).Kod źródłowy klas SingleLinkedList i DoubleLinkedList znajdziesz na samouczkowym githubie. Na Githubie znajdziesz też testy jednostkowe, pamiętaj o tym żeby sprawdzić czy Twój kod działa poprawnie. Testy powinny Ci w tym pomóc. Podsumowanie Po przeczytaniu tego artykułu dokładnie wiesz czym są struktury danych. Poznałeś jednokierunkowe i dwukierunkowe listy wiązane. Zrozumiałeś działanie list na podstawie przykładowej implementacji. Rozwiązując zadania utrwaliłeś swoją wiedzę na temat list. Dobra robota :)! Jeśli masz jakiekolwiek pytania czy uwagi proszę daj znać w komentarzu, postaram się pomóc. Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Proszę Cię też o podzielenie się linkiem ze znajomymi, może im także przyda się wiedza zgromadzona w tym artykule.             Oczywiście zależy to od implementacji listy. W przypadku listy wiązanej otrzymanie takiej złożoności nie jest problemem. &#8617;               Metodę tę można zaimplementować uzyskując złożoność Ο(1), to będzie Twoim zadaniem na koniec artykułu ;). Uzyskanie takiej złożoności wymaga zmian we wszystkich metodach modyfikujących zawartość listy. &#8617;       ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/struktury-danych-lista-wiazana/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/01/02_struktury_danych_lista_wiazana_artykul.jpg"},{
        "title": "Struktury danych - tablica asocjacyjna",
        "excerpt":"  Artykuł ten opisuje strukturę danych określaną jako tablica asocjacyjna. Tę strukturę nazywa się też słownikiem czy mapą. Sama struktura występuje w wielu językach programowania. Zasada działania tej struktury jest niezależnie od języka programowania. Przykładową implementację przygotowałem w Javie. Aby wynieść jak najwięcej z tego artykułu powinieneś wiedzieć czym są metody hashCode i equals. Powinieneś też znać kontrakt pomiędzy metodami equals i hashCode. Do zrozumienia przykładowej implementacji niezbędna będzie też wiedza o typach generycznych. Może przydać się też wiedza na temat szacowania złożoności obliczeniowej. Czym jest tablica asocjacyjna Tablica asocjacyjna to struktura, która pozwala na przechowywanie par. Każda para zawiera klucz i wartość. Dzięki kluczowi jesteś w stanie w prosty sposób znaleźć wartość skojarzoną z danym kluczem. Klucz jest unikalny w ramach całej tablicy asocjacyjnej. Przykładem tablicy asocjacyjnej może być zwykły słownik wyrazów obcych. Na przykład słownik polsko-angielski. Kluczami w tym przypadku są słowa po polsku, wartościami ich angielskie odpowiedniki. Istnieje wiele możliwych sposobów na zaimplementowanie tej struktury danych. Jednym z nich jest tablica asocjacyjna oparta o funkcję skrótu. Założeniem tej implementacji jest uzyskanie bardzo dobrych czasów dostępu do danych. Dodawanie nowych elementów do mapy także powinno być szybkie. Czym jest funkcja skrótu Funkcja skrótu to funkcja, która z wartości może wyprodukować klucz. Klucz ten jest zawsze ten sam dla danej wartości. Przykładem funkcji skrótu w języku Java jest funkcja hashCode. Funkcja ta zwyczaj zwraca liczbę typu int. Jest ona bardzo ważna dla wydajnego działania tej implementacji mapy. Powinna ona zwracać wartości, które są dobrze rozdystrybuowane. Innymi słowy, funkcja skrótu, która zawsze zwraca wartość 1 nie jest najlepszym pomysłem. Zwracane wartości powinny być równomiernie rozrzucone po wszystkich liczbach. W dalszej części artykułu przeczytasz o tym dlaczego jest to ważne. Wspomniałem już wyżej, że tablicę asocjacyjną nazywa się także słownikiem czy mapą. Od teraz będę posługiwał się określeniem mapa. Jak działa HashMap Fragmenty kodu, które prezentuję poniżej pochodzą z uproszczonej implementacji mapy. Nie zmieniają one zasady działania tej implementacji. Te uproszczenia mają pomóc Ci zrozumieć sposób działania tej struktury danych. Mapa to zestaw par, par kluczy i wartości. Do reprezentacji takiej pary potrzebna jest osobna klasa. Może ona wyglądać następująco: private static class Entry&lt;K, V&gt; {    private final K key;    private V value;    Entry(K key, V value) {        this.key = key;        this.value = value;    }}Sama klasa mapy powinna przechowywać te pary. Dobrym sposobem może być użycie tablicy: public class SimpleHashMap&lt;K, V&gt; {    private Entry&lt;K, V&gt;[] table;}Tylko jak duża powinna być ta tablica? Ile elementów chcemy przechowywać w mapie? Uniwersalna implementacja nie może tego założyć. Zakłada więc rozsądne wartości domyślne: public class SimpleHashMap&lt;K, V&gt; {    private static final int INITIAL_CAPACITY = 4;    private Entry&lt;K, V&gt;[] table;    public SimpleHashMap() {        table = new Entry[INITIAL_CAPACITY];    }}        Tablica z dwiema parami  Co jeśli chcemy wrzucić do mapy więcej niż 4 wartości? Implementacja ta zakłada, że tablica ta zostanie rozszerzona. Jak? Opiszę to niżej. Teraz proszę skup się na zmiennej table. Zmienna table przechowuje instancje klasy Entry&lt;K, V&gt;, czyli pary klucz-wartość. Aby ta struktura pozwalała na szybkie wstawianie/dostęp do elementów musi być prosty sposób na zmapowanie klucza na indeks w tej tablicy. Dochodzimy tu do zastosowania funkcji skrótu. Zastosowanie funkcji skrótu Funkcja skrótu pozwala na zmapowanie klucza na indeks w tablicy wspomnianej wyżej. Wartość zwrócona przez metodę hashCode (funkcję skrótu) musi zostać dopasowana do wielkości tablicy. Najprostszym sposobem jest użycie reszty z dzielenia: private int hash(K key) {    if (key == null) {        return 0;    }    int hash = key.hashCode() % table.length;    return hash &lt; 0 ? hash * -1 : hash;}Zakładając, że nasza tablica ma wielkość 4 mapowanie wartości hashCode na indeks tablicy wygląda następująco:             Wartość hashCode      Indeks w tablicy                  1      1              3      3              6      2              -4      0              -5      1              17      1      Funkcja skrótu dzieli całą możliwy zakres liczb na przedziały. Przedziały te nazywa się wiadrami (ang. bucket). Dzięki temu, aby znaleźć interesujący nas element na podstawie klucza, musimy przejrzeć tylko jeden przedział. Podział na przedziały ma istotny wpływ na wydajność pracy na mapie. Powtarzające się indeksy A co jeśli pod danym indeksem występuje już element? Co jeśli dodamy dwa różne klucze, których funkcja hashCode zwróci tę samą wartość? Jeśli klucze są równe (czyli equals potwierdza, że obiekty są sobie równe) wtedy należy nadpisać wartość. Jeśli jednak hashCode jest ten sam a equals mówi, że obiekty są różne mamy problem ;). Z tego właśnie powodu w tablicy nie trzymamy par. Trzymamy kolekcję par: public class SimpleHashMap&lt;K, V&gt; {    private static final int INITIAL_CAPACITY = 4;    private List&lt;Entry&lt;K, V&gt;&gt;[] table;}Dlatego właśnie zmienna table jest tablicą list wiązanych zawierających pary elementów.         Tablica z trzema parami    Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Lepsza wydajność dostępu do danych Jednak nawet takie zachowanie nie rozwiązuje problemu. Pamiętasz domyślną wielkość tablicy? W przykładzie powyżej było to 4. Oznacza to tyle, że wszystkie możliwe wartości hashCode podzielone są na 4 przedziały. Jeśli w naszej mapie będzie odpowiednio dużo elementów znacząco wydłuży to czas pobierania elementu po kluczu. Poniższy rysunek pokazuje sytuację, w której aż 8 par trafiło do pierwszego przedziału.         Zbyt dużo par w jednym przedziale  Przy takim rozłożeniu par może wystąpić sytuacja, w której będziemy musieli przejrzeć wszystkie aby znaleźć właściwą. Dlatego właśnie tablica ta jest automatycznie rozszerzana. Powstaje kolejne pytanie. Kiedy należy taką tablicę powiększyć? Tutaj też wprowadza się pewne wartości domyślne. Możemy powiedzieć o czymś co nazywa się współczynnikiem wypełnienia (ang. load factor). Jeśli nasza tablica jest wypełniona w dość dużym stopniu i liczba elementów przechowywanych w mapie przekroczy pewien próg należy rozszerzyć naszą tablicę. public class SimpleHashMap&lt;K, V&gt; {    private static final float LOAD_FACTOR = 0.75F;    private static final int INITIAL_CAPACITY = 4;    private int size;    private int threshold;    private List&lt;Entry&lt;K, V&gt;&gt;[] table;    public SimpleHashMap() {        table = new List[INITIAL_CAPACITY];        threshold = (int) (INITIAL_CAPACITY * LOAD_FACTOR);    }}Fragment kodu powyżej zakłada, że współczynnik wypełnienia ma wartość 0.75. Zatem próg, po którym tablica przechowująca pary zostanie rozszerzona wynosi 0.75 * 4 == 3. Innymi słowy, jeśli włożymy do mapy 3 pary, to pierwotna tablica o wielkości 4 zostanie powiększona. Powiększenie tablicy przechowującej pary Dobrym sposobem na powiększenie wielkości tablicy jest podwojenie jej rozmiaru. Zauważ, że w przypadku powiększenia wielkości tablicy należy od nowa przyporządkować poszczególne klucze do nowych indeksów w tablicy. Funkcja poniżej podwaja wielkość tablicy table i przepisuje pary w odpowiednie miejsca w nowej tablicy: private void resize() {    if (table.length == Integer.MAX_VALUE) {        return;    }    List&lt;Entry&lt;K, V&gt;&gt;[] oldTable = table;    table = new List[table.length * 2];    threshold = (int) (table.length * LOAD_FACTOR);    for (List&lt;Entry&lt;K, V&gt;&gt; bucket : oldTable) {        if (bucket == null) {            continue;        }        for (Entry&lt;K, V&gt; entry : bucket) {            int hash = hash(entry.key);            if(table[hash] == null) {                table[hash] = new LinkedList&lt;&gt;();            }            List&lt;Entry&lt;K, V&gt;&gt; newBucket = table[hash];            newBucket.add(entry);        }    }}Ilustracja poniżej pokazuje jak po takiej operacji para K: 12, V: \"X\" znalazła się pod zupełnie innym indeksem. Dzieje się tak ponieważ funkcja hash bierze pod uwagę nową wielkość tablicy. W sytuacji gdy tablica miała rozmiar 4 wówczas 12 % 4 == 3. Po rozszerzeniu ta sama wartość klucza ląduje w innym miejscu w tabeli: 12 % 8 == 4.         Powiększenie tablicy  Standardowe operacje Standardowymi operacjami dostępnymi w mapie są:   dodanie pary klucz, wartość,  pobranie wartości na podstawie klucze,  usunięcie pary klucz, wartość,  sprawdzenie czy dany klucz istnieje,  pobranie rozmiaru mapy.Po wprowadzeniu powyżej mogę pokazać Ci przykładową implementację tych operacji. Dodanie pary do mapy Dodanie pary do mapy może skutkować utworzeniem nowej pary lub nadpisaniem istniejącej już wartości. Proszę spójrz na przykład poniżej: public V put(K key, V value) {    int hash = hash(key);    if (table[hash] == null) {        table[hash] = new LinkedList&lt;&gt;();    }    V oldValue = null;    boolean keyExist = false;    List&lt;Entry&lt;K, V&gt;&gt; bucket = table[hash];    for (Entry&lt;K, V&gt; entry : bucket) {        if (keysEqual(key, entry.key)) {            oldValue = entry.value;            entry.value = value;            keyExist = true;            break;        }    }    if (!keyExist) {        bucket.add(new Entry&lt;&gt;(key, value));        size++;    }    if (size == threshold) {        resize();    }    return oldValue;}Funkcja ta pobiera wiadro do którego dana para powinna zostać dodana. Następnie iteruje po wszystkich elementach w tym wiadrze, aby sprawdzić czy dany klucz już istnieje. Jeśli klucz istnieje wartość zostaje nadpisana. W przeciwnym wypadku na koniec przedziału zostaje dodana nowa para klucz/wartość. Teraz widzisz dlaczego porządna funkcja skrótu jest istotna. Jeśli do jednego przedziału trafia dużo elementów to złożoność obliczeniowa takiej operacji wynosi Ο(n). Jeśli natomiast w danym przedziale nie ma innych par klucz wartość wówczas złożoność tej operacji wynosi Ο(1). Pobieranie wartości z mapy Pobieranie elementów z mapy sprowadza się do sprawdzenia czy klucz występuje w tablicy. Funkcja skrótu służy do wskazania przedziału, w którym należy szukać instancji klucza. Przykładowa implementacja niżej pozwala na pobranie wartości z mapy: public V get(K key) {    int hash = hash(key);    List&lt;Entry&lt;K, V&gt;&gt; bucket = table[hash];    if (bucket != null) {        for (Entry&lt;K, V&gt; entry : bucket) {            if (keysEqual(key, entry.key)) {                return entry.value;            }        }    }    return null;}Złożoność obliczeniowa wygląda podobnie jak w przypadku dodawania pary do mapy. Jeśli pary są źle rozdystrybuowane, jeśli wszystkie są w jednym przedziale otrzymujemy złożoność Ο(n). Jeśli natomiast w danym przedziale nie ma innych par klucz wartość wówczas złożoność tej operacji wynosi Ο(1). Usuwanie wartości z mapy Usuwanie wartości wygląda podobnie do pobierania. W tym przypadku dodatkowo zmniejszana jest wartość atrybutu size przechowującego liczbę par w mapie. public V remove(K key) {    List&lt;Entry&lt;K, V&gt;&gt; bucket = table[hash(key)];    if (bucket == null) {        return null;    }    Iterator&lt;Entry&lt;K, V&gt;&gt; bucketIterator = bucket.iterator();    V oldValue = null;    while (bucketIterator.hasNext()) {        Entry&lt;K, V&gt; entry = bucketIterator.next();        if (keysEqual(key, entry.key)) {            oldValue = entry.value;            bucketIterator.remove();            size--;            break;        }    }    if (bucket.isEmpty()) {        table[hash(key)] = null;    }    return oldValue;}Zwróć uwagę na to, że w przypadku usuwania elementów nie zmniejszam wielkości tablicy z parami - table zostaje bez zmian. Złożoność obliczeniowa nie różni się od operacji dodawania/pobierania elementów. W zależności od funkcji skrótu i rozłożenia elementów wynosi ona Ο(n) lub Ο(1). Sprawdzanie rozmiaru mapy Wszystkie metody modyfikujące zawartość mapy manipulują także atrybutem size. Atrybut ten przechowuje aktualną liczbę elementów. public boolean isEmpty() {    return size == 0;}public int size() {    return size;}Kontrakt hashCode i equals W artykule opisującym porównywanie obiektów opisałem dokładnie kontrakt pomiędzy tymi metodami. Tutaj na przykładzie wyjaśnię Ci dlaczego jest on tak istotny. Dla przypomnienia, kontrakt ten sprowadza się do trzech reguł:   Jeśli X.equals(Y) == true wówczas wymagane jest aby X.hashCode() == Y.hashCode(),  Kilkukrotne wywołanie metody hashCode na tym samym obiekcie, który nie był modyfikowany pomiędzy wywołaniami musi zwrócić tę samą wartość,  Jeśli X.hashCode() == Y.hashCode() to nie jest wymagane aby X.equals(Y) == true.Wyobraź sobie sytuację, w której mamy dwa obiekty. X i Y. Załóżmy, że obiekty te są sobie równe, czyli X.equals(Y) == true. W tej sytuacji metoda hashCode powinna zwrócić tę samą wartość dla obu obiektów. Implementacja jest jednak błędna: X.hashCode() == 4 i Y.hashCode() == 5. Jeśli użyłbyś obiektów X i Y jako kluczy w mapie wówczas trafiłyby one do różnych przedziałów. Prowadziłoby to złamania założeń mapy. Pamiętaj, że w mapie wszystkie klucze powinny być unikalne. Błędna implementacja hashCode doprowadziłaby do złamania tej reguły. Jak działa HashMap Oczywiście HashMap z biblioteki standardowej jest dużo lepszą implementacją niż ta przedstawiona w artykule ;). Poza tym, że jest lepiej przetestowana i posiada dużo więcej przydatnych metod to zawiera także sporo usprawnień, które polepszają jej wydajność. Dedykowana implementacja kolekcji Wewnątrz HashMap używa dedykowanej implementacji kolekcji. Nie jest to zwykła lista LinkedList jak w mojej implementacji. Ta kolekcja zmienia swoje właściwości w zależności od liczby elementów znajdujących się w danym przedziale. Standardowo jest to lista wiązana. Jeśli jednak w danym przedziale znajduje się więcej niż 8 elementów wówczas zmienia się w strukturę zwaną drzewem. Struktura ta pozwala na lepsze wyszukiwanie elementów. Dzięki temu pesymistyczna złożoność obliczeniowa spada z Ο(n) do Ο(log(n)) dla operacji takich jak pobieranie, dodawanie czy usuwanie elementów1.         HashMap z drzewem jako kolekcją do przechowywania par  Porównanie złożoności obliczeniowych Poniższa tabela zawiera zestawienie złożoności obliczeniowych podstawowych operacji dla mapy:             Operacja      Mapa (dobra funkcja skrótu)      Mapa (zła funkcja skrótu)                  dodawanie pary klucz/wartość      Ο(1)      Ο(1)              usuwanie wartości z klucza      Ο(1)      Ο(n) lub Ο(log(n))              pobieranie wartości dla klucza      Ο(1)      Ο(n) lub Ο(log(n))      Oczywiście należy brać poprawkę na złożoność obliczeniową dodawania elementów do mapy. Należy pamiętać o tym, że niektóre operacje dodawania kończą się powiększeniem tablicy przechowującej pary. Wówczas złożoność obliczeniowa tej operacji spada do Ο(n). Najczęściej zadawane pytania Czy mogę modyfikować klucze Krótka, zwięzła odpowiedź: nie. Klucze powinny być instancjami klas, które są niemutowalne. Załóżmy, że modyfikacja klucza zmieniłaby wartość zwracaną przez metodę hashCode. Zastanów się, co by się stało gdybyś zmodyfikował instancję klasy, która już jest użyta jako klucz? Czy pary w mapie są posortowane Implementacja przedstawiona w tym artykule, czy HashMap nie przechowują elementów w żadnym porządku. Istnieją jednak implementacje, które pozwalają na przykład na przechowywanie elementów w porządku alfabetycznym kluczy (TreeMap) czy według kolejności ich dodawania (LinkedHashMap). Kiedy używać mapy Jeśli w programie potrzebujesz przechować strukturę podobną do słownika to mapa jest właśnie tym typem, którego chcesz użyć. Mapy pozwalają na uniknięcie rozbudowanych bloków switch. Użycie ich w taki sposób moim zdaniem poprawia czytelność kodu. Czy mapa może mieć klucz/wartość null To zależy od implementacji. Interfejs Map daje taką możliwość. HashMap czy moja implementacja pozwalają przechowywać zarówno klucze i wartości null. Oczywiście tylko jeden klucz może mieć wartość null. Dodatkowe materiały do nauki Jeśli chcesz spojrzeć na temat z innego punktu widzenia zachęcam Cię do przeczytania materiałów, które zebrałem poniżej. Szczególnie polecam przejrzenie kodu źródłowego implementacji dostarczonej w SDK:   Artykuł o tablicy asocjacyjnej na Wikipedii,  Kod źródłowy przykładów użytych w artykule,  Implementacja HashMap z OpenJDK.Zadania do wykonania Dodaj do Klasy SimpleHashMap kilka metod występujących w interfejsie Map:   Dodaj metodę containsKey. Metoda powinna zwrócić true jeśli dany klucz istnieje w mapie.  Dodaj metodę containsValue. Metoda powinna zwrócić true jeśli dany wartość istnieje w mapie.  Jaka jest złożoność obliczeniowa Twojej implementacji metod containsKey i containsValue?Kod źródłowy klasy SimpleHashMap. Pamiętaj o dodaniu testów jednostkowych, potwierdzających, że Twoja implementacja działa poprawnie. Podsumowanie Poznałeś właśnie zasadę działania mapy. Z praktycznej strony poznałeś kontrakt pomiędzy metodami equals i hashCode. Zapoznałeś się z przykładową implementacją mapy. Po rozwiązaniu zadań utrwaliłeś wiedzę z tego zakresu. Powiem Ci w tajemnicy, że o tym jak działa HashMap często pyta się na rozmowach rekrutacyjnych ;). Jesteś zatem o jedno pytanie bliżej otrzymania pracy ;). Jeśli masz jakiekolwiek pytania czy uwagi proszę daj znać w komentarzu, postaram się pomóc. Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Proszę Cię też o podzielenie się linkiem ze znajomymi, może im także przyda się wiedza zgromadzona w tym artykule.             Delikatnie pomijam tu pesymistyczną złożoność obliczeniową dla drzewa. &#8617;       ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/struktury-danych-tablica-asocjacyjna/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/01/08_struktury_danych_tablica_asocjacyjna_artykul.jpg"},{
        "title": "REST web service z Java EE część 2",
        "excerpt":"  To jest jeden z artykułów w ramach darmowego kursu programowania aplikacji webowych w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. W kursie tym zakładam, że znasz język Java. Możesz go poznać w osobnym kursie programowania w języku Java. Do budowania wszystkich projetków używam Gradle, przeczytasz o nim więcej w osobnym artykule. REST Webservice w Java EE 8 Tematykę REST omówiłem dokładnie w poprzednim artykule. W tym pokażę przykładową implementację webservice’u używającego wyłącznie technologii opisanych w ramach specyfikacji Java EE 8. Przykładowa aplikacja będzie używała implementacji następujących specyfikacji:   JAX-RS: Java API for RESTful Web Services 2.1,  JSON-B: JavaTM API for JSON Binding 1.0  Java API for JSON Processing 1.1  Context and Dependency Injection for Java 2.0  Java TM Servlet Specification 3.1W artykule tym rozszerzę przykładowy webservice do zarządzania rezerwacjami. Będzie on posiadał pięć metod odpowiedzialnych odpowiednio za:   pobieranie listy rezerwacji,  pobieranie konkretnej rezerwacji,  tworzenie nowej rezerwacji,  edycja rezerwacji,  usunięcie rezerwacji.Serwer aplikacji dla JavaEE 8 W poprzednim artykule posłużyłem się kontenerem aplikacji TomEE. Niestety aktualnie kontener ten nie wspiera JEE 8. W związku z tym w tym artykule bazuję na serwerze Glassfish 5. Instalacja serwera aplikacji Glassfish Podobnie jak w przypadku serwera TomEE instalacja nie jest skomplikowana. W tym przypadku należy pobrać najnowszą wersję serwera Glassfish. Następnie należy rozpakować ściągnięty plik do dowolnego folderu. W moim przypadku jest to /home/mapi/opt/glassfish5. Nie wchodząc zbytnio w szczegóły działania serwera Glassfish musisz wiedzieć o programie asadmin, który pomaga w administracji serwerem. Program ten znajduje się w katalogu bin. Podstawowe komendy do zarządzania serwerem Aby uruchomić serwer musisz wywołać polecenie asadmin start-domain. Mając działający serwer aplikacji możesz przejść do następnego kroku. Możesz pobrać listę aplikacji, które są aktualnie zainstalowane na serwerze przy pomocy polecenia asadmin list-applications. Zainstalować aplikację możesz przy pomocy polecenia asadmin deploy --contextroot / build/libs/07_rest_crud-1.0-SNAPSHOT.war. Ścieżka na końcu odpowiada plikowi war z aplikacją webową. Jeśli chcesz usunąć zainstalowaną aplikację uruchom asadmin undeploy 07_rest_crud-1.0-SNAPSHOT. Nazwę aplikacji do usunięcia możesz uzyskać wcześniej wspomniane polecenie asadmin list-applications. Wstrzykiwanie zależności Wstrzykiwanie zależności (ang. dependency injection) pozwala na oddelegowanie zarządzanie zależnościami do kontenera. Dzięki takiemu podejściu programista nie musi samemu tworzyć instancji obiektów, robi to za niego kontener aplikacji. Kontener aplikacji zarządza cyklem życia takich instancji. To kontener wywołuje konstruktor i kontener utrzymuje referencje do tych obiektów. Także kontener ustawia atrybuty jeśli odpowiadają one instancjom, którymi zarządza. Takie podejście do zarządzania obiektami znacząco upraszcza aplikacje. Pozwala też tworzyć kod, który można w łatwiejszy sposób przetestować przy pomocy testów jednostkowych. Wstrzykiwanie zależności to funkcjonalność, dzięki której Spring stał się tak popularny. W początkowych fazach istnienia biblioteki Spring jej możliwości sprowadzały się do przyjaznego zarządzania zależnościami. Proszę spójrz na przykład: public class ReservationWebservice {    @Inject    private ReservationDAO dao;}@ApplicationScopedpublic class ReservationDAO {}Fragment kodu powyżej używa mechanizmu wstrzykiwania zależności. Klasa ReservationWebservice potrzebuje instancji klasy ReservationDAO1. Atrybut dao może zostać wstrzyknięty dzięki mechanizmowi DI (ang. Dependency Injection). Adnotacja @Inject informuje kontener o tym, że ten atrybut powinien zostać wstrzyknięty. Klasa ReservationDAO poprzedzona jest adnotacją @ApplicationScoped. Adnotacja ta informuje kontener o tym, że instancja tej klasy powinna być możliwa do wstrzyknięcia. Instancja będzie dostępna w kontekście aplikacji. Oznacza to tyle, że kontener utworzy wyłącznie jedną instancję tej klasy w trakcie działania aplikacji2.     Mechanizm wstrzykiwania zależności powinien być domyślnie dostępny jak tylko kontener wykryje klasy, które powinien wstrzykiwać. Niestety jednak nie udało mi się zmusić do tego Glassfisha 5. Obszedłem to poprzez dodanie pustego pliku beans.xml, który także włącza ten mechanizm. Model - rezerwacja Rezerwacje, którymi zarządza webservice są reprezentowane przez osobną klasę Reservation: public class Reservation {    @NotEmpty    private String name;    @NotNull    @Positive    private Integer tableNumber;    @FutureOrPresent    @NotNull    private LocalDateTime start;    @Future    @NotNull    private LocalDateTime end;    // getters/setters}Klasa ta zawiera atrybuty opisujące rezerwację takie jak nazwisko rezerwującego, numer stolika czy początek i koniec rezerwacji. Rezerwacja jest prawidłowa wyłącznie jeśli atrybuty uzupełnione są poprawnymi danymi. Poprawność instancji klasy Reservation zapewniona jest przez mechanizm walidacji. Walidacja Walidacja obiektów dostarczona jest przez implementację specyfikacji Bean Validation. Każdy kontener aplikacji, który jest kompatybilny z Java EE 8 (jak Glassfish 5 wspomniany wyżej), musi dostarczać implementację tej specyfikacji. Samą walidację obiektów omówiłem bardziej szczegółowo w osobnym artykule. Tutaj widzisz jej użycie w kontekście aplikacji webowej. Instancja walidatora tworzona jest przez kontener automatycznie. Kontener także wywołuje mechanizm walidacji. Mechanizm ten wywoływany jest za każdym razem w metodach obsługujących podstawowe operacje. Przykład poniżej pokazuje użycie adnotacji @Valid w metodzie odpowiedzialnej za tworzenie nowej instancji rezerwacji. @POSTpublic Response createReservation(@Valid Reservation reservation) {    //...}Kontener na podstawie zapytania wysłanego przez użytkownika tworzy instancję klasy Reservation, następnie sprawdza czy instancja ta jest poprawna. Jeśli dane przesłane przez użytkownika są poprawne wówczas wywołuje ciało metody. Jeśli dane nie pozwolą na utworzenie poprawnej instancji wówczas zostanie rzucony wyjątekValidationException. W akapicie opisującym instancje oznaczone adnotacją @Provider opiszę ten mechanizm dokładniej.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Dostęp do danych W normalnej wersji aplikacji dane zapisywane są w dedykowanej bazie danych3. Na potrzeby tej aplikacji symuluję bazę danych przy pomocy mapy przechowywanej w pamięci. Oczywistym minusem jest to, że dane nie są zachowywane po wyłączeniu aplikacji. Na potrzeby tego artykułu taki mechanizm jest wystarczający: @ApplicationScopedpublic class ReservationDAO {    private final Map&lt;Integer, Reservation&gt; reservations = Collections.synchronizedMap(new TreeMap&lt;&gt;());;    private final AtomicInteger lastId = new AtomicInteger(0);    public Collection&lt;Reservation&gt; getAll() {        return reservations.values();    }    public Reservation getById(Integer id) {        return reservations.get(id);    }    public Reservation updateReservation(Integer id, Reservation reservation) {        return reservations.put(id, reservation);    }    public Reservation deleteReservation(Integer id) {        return reservations.remove(id);    }    public int createReservation(Reservation reservation) {        int id = lastId.getAndIncrement();        reservations.put(id, reservation);        return id;    }}Klasa ReservationDAO pozwala na łatwy dostęp do instancji klasy Reservation przechowywanych w pamięci. Pozwala na utworzenie, pobranie, usunięcie i edycję rezerwacji. Jak wspomniałem wyżej w akapicie opisującym wstrzykiwanie zależności, instancja klasy ReservationDAO jest zarządzana przez kontener aplikacji. W ramach całej aplikacji zostanie utworzona wyłącznie jedna instancja tej klasy. Ta instancja będzie wykorzystywana przez klasę obsługującą żądania wysyłane przez użytkownika. Aplikacja @ApplicationPath(\"/rest\")public class RegistrationApplication extends Application {}Adnotacja @ApplicationPath informuje kontener aplikacji o początkowym członie adresu URL pod jakim działa dana aplikacja. W przykładzie wyżej informuję kontener o tym, że adresy URL dla wszystkich webservice’ów w tej aplikacji poprzedzone są /rest. Adnotacja ta może zostać dodana wyłącznie do instancji klasy Application. Klasa ta dostarcza dodatkowych metadanych o aplikacji. W moim przypadku jedyną wymaganą informacją dodatkową jest ta dostarczona przez adnotację. Webservice Teraz znasz komponenty, które są wykorzystywane przez webservice. Nadszedł czas na klasę obsługują żądania użytkownika: @Path(\"/reservation\")@Produces(MediaType.APPLICATION_JSON)@Consumes(MediaType.APPLICATION_JSON)public class ReservationWebservice {    @Inject    private ReservationDAO dao;}Adnotację @Path znasz z poprzedniej części artykułu. Określa ona ścieżkę, która obsługiwana jest przez daną klasę. Nowe są dla Ciebie adnotacje @Consumes i @Produces. Odpowiadają one odpowiednio za określenie typu danych konsumowanych i produkowanych przez webservice. W tym przypadku są to dane w formacie JSON. Jeśli użytkownik wyśle zapytanie zawierające dane w innym formacie wówczas kontener automatycznie odpowie zwracając kod 415. Kod ten informuje klienty o tym, że format danych nie jest wspierany. Wewnątrz klasy widzisz atrybut, który zostanie wstrzyknięty przez kontener aplikacji. Jest to instancja klasy ReservationDAO pozwalająca na dostęp do aktualnie dostępnych rezerwacji. Zgodnie ze specyfikacją JAX-RS dla każdego żądania przychodzącego od użytkownika zostanie utworzona nowa instancja klasy ReservationWebservice. Po raz kolejny to kontener aplikacji zajmuje się tworzeniem tych instancji. Pobranie listy rezerwacji Kod odpowiedzialny za pobranie wszystkich rezerwacji nie jest zbyt skomplikowany: @GETpublic Response listReservations() {    return Response.ok(dao.getAll()).build();}Metoda listReservations poprzedzona jest adnotacją @GET. Nie zawiera dodatkowej adnotacji @Path, więc wszystkie żądania wysłane pod adres GET /rest/reservation zostaną obsłużone przez tę metodę. Do sprawdzenia jej działania możesz użyć programu curl curl -H \"Content-Type: application/json\" http://localhost:8080/rest/reservation-H \"Content-Type: application/json\" dodaje nagłówek do żądania. Określa on format zawartości zapytania. To właśnie ten nagłówek sprawdzany jest przez adnotację @Consumes. Wewnątrz metody buduję odpowiedź. Ciałem tej odpowiedzi jest lista rezerwacji zwrócona przez dao. Dzięki adnotacji @Produces JAX-RS wymusza format odpowiedzi. W moim przypadku jest to JSON. Kontener automatycznie przekonwertuje instancję klasy Reservation do formatu JSON. Dzieje się to dzięki implementacji specyfikacji JSON-B i JSON-P. Pobieranie pojedynczej rezerwacji Pobieranie pojedynczej rezerwacji również bazuje na atrybucie dao: @GET@Path(\"{id}\")public Response getReservation(@PathParam(\"id\") @Min(0) Integer id) {    Reservation reservation = dao.getById(id);    if (reservation != null) {        return Response.ok(reservation).build();    }    return Response.status(Response.Status.NOT_FOUND).build();}Dodatkowa adnotacja @Path rozszerza tę umieszczoną nad klasą ReservationWebservice. W wyniku tego metoda getReservation obsługuje wszystkie żądania wysłane przez klienty na adres GET /reservation/{id}. id jest identyfikatorem rezerwacji pobieranym z adresu URL dzięki adnotacji @PathParam. Zwróć także uwagę na użycie adnotacji @Min. Adnotacja ta uruchomi mechanizm walidacji dla parametru id. Mechanizm ten sprawdzi czy liczba przekazana w adresie ma wartość większą, bądź równą 0. Jeśli wartość parametru jest niepoprawna zostanie rzucony wyjątek. Wewnątrz ciała metody odwołuję się do atrybutu dao pobierając rezerwację na podstawie identyfikatora pobranego od użytkownika. dao zwróci wartość null jeśli rezerwacja o danym identyfikatorze nie zostanie odnaleziona. W takim przypadku klient uzyska odpowiedź z kodem 404 informującą o braku szukanego elementu. Jeśli dao znajdzie rezerwację o zadanym identyfikatorze, wówczas zostanie ona przekazana w odpowiedzi. Także tutaj zostanie ona przekształcona do formatu JSON. Także w tym przypadku curl może pomóc w wysłaniu zapytania: curl -H \"Content-Type: application/json\" http://localhost:8080/rest/reservation/0 Usuwanie rezerwacji Usuwanie rezerwacji niewiele różni się od pobierania pojedynczej wartości: @DELETE@Path(\"{id}\")public Response deleteReservation(@PathParam(\"id\") @Min(0) Integer id) {    Reservation reservation = dao.deleteReservation(id);    if (reservation != null) {        return Response.ok(reservation).build();    }    return Response.status(Response.Status.NOT_FOUND).build();}W tym przypadku kombinacja adnotacji @DELETE i @Path wskazuje, że metoda ta zostanie wywołana w przypadku wysłania żądania na adres DELETE /reservation/{id}. Podobnie jak w przypadku pobierania rezerwacji mechanizm walidacja sprawdza poprawność przekazanego parametru id. W przypadku tej metody dao użyte jest do usunięcia rezerwacji o podanym identyfikatorze. Przykładowe wywołanie curl usuwające rezerwację o identyfikatorze 0: curl -H \"Content-Type: application/json\" http://localhost:8080/rest/reservation/0 -X DELETEUtworzenie rezerwacji Podczas tworzenia rezerwacji webservice wymusza poprawność danych przekazanych przez użytkownika. To adnotacja @Valid wymusza sprawdzenie poprawności danych: @POSTpublic Response createReservation(@Valid Reservation reservation) {    int newId = dao.createReservation(reservation);    URI location;    try {        location = new URI(\"reservation/\" + newId);    } catch (URISyntaxException e) {        throw new RuntimeException(e);    }    return Response.created(location).build();}Jeśli wszystkie wymagania określone w klasie Reservation zostaną spełnione zostanie wywołana metoda createReservation. W przeciwnym wypadku zostanie rzucony wyjątek ValidationException. W ciele metody createReservation wywołuję dao.createReservation. To wywołanie zapisuje nową rezerwację w bazie danych. W wyniku wywołania tej metody zwrócony jest nowy identyfikator dla tej rezerwacji. Pomaga on w utworzeniu adresu URL, który zostaje zwrócony w odpowiedzi. Także i tutaj curl może zostać użyty do wysłania zapytania. Tym razem w ciele zapytania muszę przesłać dane w formacie JSON, które reprezentują nową rezerwację. Przykładowe zapytanie może wyglądać następująco: curl -H \"Content-Type: application/json\" http://localhost:8080/rest/reservation -X POST -d '{\"start\": \"2018-01-22T20:00\", \"tableNumber\": 1, \"name\": \"Marcin\", \"end\": \"2018-01-22T21:20\"}'Parametr -d służy do przekazania zawartości zapytania. W tym przypadku jest to JSON, który reprezentuje dane potrzebne do utworzenia instancji klasy Reservation. {    \"name\": \"Marcin\",    \"tableNumber\": 1,    \"start\": \"2018-01-22T20:00\",    \"end\": \"2018-01-22T21:20\"}W przykładzie powyżej instancja reprezentowana jest przez mapę. Kluczami są nazwy atrybutów, na przykład name czy start. Atrybuty klasy zostaną uzupełnione wartościami przekazanymi w mapie. Oczywiście format wartości musi być odpowiedni. Automatyczna transformacja pomiędzy formatem JSON a klasą Java możliwa jest dzięki specyfikacjom JSON-B i JSON-P. Modyfikacja rezerwacji Modyfikacja rezerwacji nie zawiera nowych mechanizmów. Jest dość podobna do tworzenia nowej instancji: @PUT@Path(\"{id}\")public Response updateReservation(@PathParam(\"id\") @Min(0) Integer id, @Valid Reservation reservation) {    boolean hasReservation = dao.getById(id) != null;    if (hasReservation) {        dao.updateReservation(id, reservation);        return Response.noContent().build();    }    return Response.status(Response.Status.NOT_FOUND).build();}Własna klasa @Provider W poprzedniej części artykułu użyłem tej adnotacji to utworzenia filtra, który dodawał nagłówki. Tym razem posłuży ona do pomocy przy walidacji. Specyfikacja JAX-RS pozwala na utworzenie klasy, która będzie odpowiedzialna za obsługę wyjątków, które wystąpiły w trakcie przetwarzania żądania klienta. To zastosowanie idealnie nadaje się do obsługi błędów walidacji: @Providerpublic class ValidationExceptionMapper implements ExceptionMapper&lt;ConstraintViolationException&gt; {    public static class ErrorMessage {        public final String error;        public ErrorMessage(String error) {            this.error = error;        }    }    @Override    public Response toResponse(ConstraintViolationException exception) {        return Response                .status(Response.Status.BAD_REQUEST)                .entity(new ErrorMessage(exception.getMessage()))                .build();    }}Klasa ValidationExceptionMapper implementuje interfejs ExceptionMapper. Interfejs ten zawiera wyłącznie jedną metodę toResponse. Metoda ta zostaje wywołana jeśli zostanie rzucony wyjątek obsługiwany przez daną klasę. W moim przypadku tworzę nową odpowiedź, która zwraca kod błędu 400 wraz z dodatkowym komunikatem błędu zwróconym przez mechanizm walidacji.     W związku z błędem w bibliotece Jersey musiałem utworzyć klasę, która obsługuje wyjątek ConstraintViolationException. Po rozwiązaniu tego błędu klasa ta powinna obsługiwać wyjątek ValidationException. Zgodnie ze specyfikacją użycie adnotacji @Priority także powinno pomóc obejść ten problem. Dodatkowe materiały do nauki W tym miejscu poproszę Cię o uruchomienie tej aplikacji na swoim komputerze i testowanie jej przy pomocy programu curl. Taka zabawa na żywo potrafi sporo nauczyć. Kod źródłowy aplikacji znajdziesz na samouczkowym githubie. Zadanie do wykonania Kod źródłowy aplikacji użytej w artykule znajduje się na samouczkowym githubie. Twoim zadaniem jest rozszerzenie działania tej aplikacji. W obecnym kształcie aplikacja nie sprawdza czy dany stolik nie jest już zarezerwowany. Może to prowadzić do sytuacji, w której ten sam stolik będzie zarezerwowany w tym samym czasie dla więcej niż jednej osoby. Popraw aplikację w taki sposób, aby nie pozwalała na ponowną rezerwację już zarezerwowanego stolika. Więc jeśli stolik nr 1. jest zarezerwowany w godzinach od 17:00 do 18:30, to rezerwacja na ten sam stolik od 18:10 do 19:00 nie jest możliwa. Podsumowanie W artykule przeczytałeś o praktycznym zastosowaniu kilku specyfikacji z parasola Java EE. Na przykładzie mogłeś zobaczyć użycie walidacji czy wstrzykiwania zależności. Poznałeś też mechanizm obsługi wyjątków, w którym użyłem adnotacji @Provider. Użyłeś implementacji specyfikacji JSON-P i JSON-B pozwalających na proste obsługiwanie danych w formacie JSON. Całość opakowana została w webservice, oparty o specyfikację JAX-RS. Mam nadzieję, że przykłady użyte w artykule pozwoliły Ci spojrzeć na Java EE z innej strony. Jeśli którakolwiek część artykułu nie jest dla Ciebie jasna proszę daj znać. Postaram się pomóc. Jeśli nie chcesz ominąć kolejnych artykułów w przyszłości proszę dopisz się do samouczkowego newslettera i polub stronę Samouczka na Facebooku. Do następnego razu!             DAO to akronim od Data Access Object. Jest to często spotykany sposób na oznaczenie klas, które odpowiedzialne są za dostęp do danych. &#8617;               Mam na myśli tutaj jedną instancję klasy na każdą wirtualną maszynę Javy. Jeśli aplikacja uruchomiona jest w kliku kontenerach wówczas każdy z nich będzie miał osobną instancję. &#8617;               Raz jest to zwykła baza relacyjna, innym razem może to być plik na dysku. W przypadku niektórych aplikacji wymaganiem może okazać się użycie innych mechanizmów jak na przykład bazy “nosql”, czy rozproszone systemy plików. Wszystko zależy od wymagań stawianych przed daną aplikacją. &#8617;       ","categories": ["Kurs aplikacji webowych"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/rest-web-service-z-java-ee-czesc-2/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/01/22_rest_web_service_2_artykul.jpg"},{
        "title": "Strumienie w języku Java",
        "excerpt":"    To jest jeden z artykułów w ramach darmowego kursu programowania w Javie. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. W szczególności potrzebna będzie wiedza na temat kolekcji, typów generycznych i wyrażeń lambda. Czym są strumienie Strumienie służą do przetwarzania danych. Dane mogą być przechowywane w kolekcji, mogą być wynikiem pracy z wyrażeniami regularnymi. W strumień możesz opakować praktycznie dowolny zestaw danych. Strumienie pozwalają w łatwy sposób zrównoleglić pracę na danych. Dzięki temu przetwarzanie dużych zbiorów danych może być dużo szybsze. Strumienie kładą nacisk na operacje jakie należy przeprowadzić na danych. Niestety pojęcie strumienia jest dość szerokie. Możesz się z nim także spotkać w przypadku pracy z plikami. W tym artykule mówiąc o strumieniach mam na myśli klasy implementujące interfejs Stream. Strumień na przykładzie Proszę spójrz na przykład poniżej. Postaram się pokazać Ci dwa różne sposoby na zrealizowanie wymagań. Pierwszy ze sposobów będzie opierał się na pętli, drugi na strumieniach. public class BoardGame {    public final String name;    public final double rating;    public final BigDecimal price;    public final int minPlayers;    public final int maxPlayers;    public BoardGame(String name, double rating, BigDecimal price, int minPlayers, int maxPlayers) {        this.name = name;        this.rating = rating;        this.price = price;        this.minPlayers = minPlayers;        this.maxPlayers = maxPlayers;    }}Klasa BoardGame opisuje grę planszową. Przy jej pomocy możesz utworzyć listę gier: List&lt;BoardGame&gt; games = Arrays.asList(    new BoardGame(\"Terraforming Mars\", 8.38, new BigDecimal(\"123.49\"), 1, 5),    new BoardGame(\"Codenames\", 7.82, new BigDecimal(\"64.95\"), 2, 8),    new BoardGame(\"Puerto Rico\", 8.07, new BigDecimal(\"149.99\"), 2, 5),    new BoardGame(\"Terra Mystica\", 8.26, new BigDecimal(\"252.99\"), 2, 5),    new BoardGame(\"Scythe\", 8.3, new BigDecimal(\"314.95\"), 1, 5),    new BoardGame(\"Power Grid\", 7.92, new BigDecimal(\"145\"), 2, 6),    new BoardGame(\"7 Wonders Duel\", 8.15, new BigDecimal(\"109.95\"), 2, 2),    new BoardGame(\"Dominion: Intrigue\", 7.77, new BigDecimal(\"159.95\"), 2, 4),    new BoardGame(\"Patchwork\", 7.77, new BigDecimal(\"75\"), 2, 2),    new BoardGame(\"The Castles of Burgundy\", 8.12, new BigDecimal(\"129.95\"), 2, 4));Lista games zawiera 10 tytułów gier planszowych. Pochodzą one z listy najbardziej popularnych gier według portalu BGG1. Załóżmy, że chciałbyś zrobić znajomemu prezent. Chcesz kupić grę, gra powinna spełniać następujące warunki:   powinna pozwolić na grę w więcej niż 4 osoby,  powinna mieć ocenę wyższą niż 8,  powinna kosztować mniej niż 150 zł.Następnie chcesz wyświetlić nazwy gier spełniających takie wytyczne wielkimi literami. Warunki te możesz spełnić przy pomocy poniższego fragmentu kodu: for (BoardGame game : games) {    if (game.maxPlayers &gt; 4) {        if (game.rating &gt; 8) {            if (new BigDecimal(150).compareTo(game.price) &gt; 0) {                System.out.println(game.name.toUpperCase());            }        }    }}Prawda, że kod układa się w piękną strzałkę ;)? Taka struktura ma swoją nazwę: Arrow Anti-Pattern. Dobrze jest unikać tego typu zagnieżdżonych warunków. Jednym ze sposobów uniknięcia tego antywzorca może być użycie strumieni: games.stream()    .filter(g -&gt; g.maxPlayers &gt; 4)    .filter(g -&gt; g.rating &gt; 8)    .filter(g -&gt; new BigDecimal(150).compareTo(g.price) &gt; 0)    .map(g -&gt; g.name.toUpperCase())    .forEach(System.out::println);Oba sposoby pozwalają na uzyskanie tych samych wyników. Drugi sposób wykorzystuje strumienie i wyrażenia lambda. Operacje na strumieniach wykorzystując wzorzec łączenia metod (ang. method chaining), zwany także płynnym interfejsem (ang. fluent interface). Rozłożę teraz ten strumień na części pierwsze.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Analiza przykładowego strumienia Aby w ogóle mówić o operacjach na strumieniu należy go na początku utworzyć. W poprzednim przykładzie użyłem metody stream. Metoda ta jest metodą domyślną zaimplementowaną w interfejsie Collection. Pozwala ona na utworzenie strumienia na podstawie danych znajdujących się w danej kolekcji. Stream&lt;BoardGame&gt; gamesStream = games.stream();Strumienie zostały wprowadzone w Java 8. W tej wersji także dodano możliwość dodawania metod domyślnych do interfejsów. Te domyślne implementacje metod pozwoliły na dodanie nowych funkcjonalności nie psując kompatybilności wstecz. Interfejs Stream jest interfejsem generycznym. Przechowuje on informację o typie, który aktualnie znajduje się w danym strumieniu. W przykładzie powyżej utworzyłem strumień gamesStream zawierający instancje klasy BoardGame. Strumień ten utworzyłem na podstawie listy. Następnie filtruję strumień używając wyrażeń lambda. Zwróć uwagę na to, że każde wywołanie metody filter tworzy nową instancję klasy Stream. Każda linijka odpowiedzialna jest za filtr innego rodzaju. Pierwszy wybiera wyłącznie te gry, w które może grać więcej niż 4 graczy. Wśród tak odfiltrowanych gier następnie wybieram te, których ocena jest wyższa niż 8. Ostatnim zawężeniem jest wybranie gier, które kosztują mniej niż 150zł: Stream&lt;BoardGame&gt; filteredStream = gamesStream    .filter(g -&gt; g.maxPlayers &gt; 4)    .filter(g -&gt; g.rating &gt; 8)    .filter(g -&gt; new BigDecimal(150).compareTo(g.price) &gt; 0);W tym przypadku nie zapisywałem pośrednich strumieni do zmiennych. Zapisałem wyłącznie wynik, który otrzymam po użyciu wszystkich trzech filtrów. Następnie z każdej gry pobieram jej nazwę i zmieniam ją na pisaną wielkimi literami: Stream&lt;String&gt; namesStream = filteredStream    .map(g -&gt; g.name.toUpperCase());Strumień filteredStream zawiera instancje klasy BoardGame, z każdej z tych instancji pobieram nazwę. Nazwa ta jest następnie zwracana. Dzięki temu powstaje nowy strumień. Tym razem strumień zawiera zmienne typu String. Ostatnią fazą jest wyświetlenie tak wybranych danych. Używam do tego odwołania do metody println: namesStream.forEach(System.out::println);Operacje na strumieniu Operacje związane ze strumieniami można podzielić na trzy rozłączne grupy:   tworzenie strumienia,  przetwarzanie danych wewnątrz strumienia,  zakończenie strumienia.Każdy strumień ma dokładnie jedną metodę, która go tworzy na podstawie danych źródłowych2. Następnie dane te są przetwarzane przez dowolną liczbę operacji. Każda z tych operacji tworzy nowy strumień danych wywodzący się z poprzedniego. Na samym końcu strumień może mieć dokładnie jedną metodę kończącą pracę ze strumieniem. Wymagania dla operacji Każda z operacji wykonywanych na strumieniu musi spełniać jasno określone wymagania. Nie posiada stanu Operacja nie może posiadać stanu. Przykładem operacji, która taki stan posiada jest metoda modify: public class StatefullOperation {    private final Set&lt;Integer&gt; seen = new HashSet&lt;&gt;();    private int modify(int number) {        if (seen.contains(number)) {            return number;        }        seen.add(number);        return 0;    }    public static void main(String[] args) {        for (int i = 0; i &lt; 3; i++) {            Stream&lt;Integer&gt; numbers = Stream.of(1, 2, 3, 1, 2, 3, 1, 2, 3);            StatefullOperation requriements = new StatefullOperation();            int sum = numbers.parallel()                .map(requriements::modify)                .mapToInt(n -&gt; n.intValue()).sum();            System.out.println(sum);        }    }}Jeśli nie spełnisz tego wymagania może to prowadzić do dziwnych, niedeterministycznych wyników w trakcie równoległego przetwarzania strumienia danych (o przetwarzaniu równoległym przeczytasz w jednym z poniższych akapitów). Spróbuj uruchomić ten fragment wiele razy. Czy dostajesz takie same wyniki za każdym razem :)? Uwierz mi, nie chcesz szukać takich błędów w programach uruchomionych na środowisku produkcyjnym. Znam to, byłem tam, nie rób tego. Nie modyfikuje źródła danych Operacja nie może modyfikować źródła danych. Taka modyfikacja jest automatycznie wykryta w trakcie pracy ze strumieniem. Pokazuje ją poniższy fragment kodu: List&lt;Integer&gt; numbers = new ArrayList&lt;&gt;();numbers.add(1);numbers.add(2);numbers.stream()    .map(v -&gt; numbers.add(v) ? 1 : 0)    .forEach(System.out::println);Uruchomienie tego kodu kończy się rzuceniem wyjątku: 1Exception in thread \"main\" java.util.ConcurrentModificationException1    at java.util.ArrayList$ArrayListSpliterator.forEachRemaining(ArrayList.java:1380)    at java.util.stream.AbstractPipeline.copyInto(AbstractPipeline.java:481)    at java.util.stream.AbstractPipeline.wrapAndCopyInto(AbstractPipeline.java:471)    at java.util.stream.ForEachOps$ForEachOp.evaluateSequential(ForEachOps.java:151)    at java.util.stream.ForEachOps$ForEachOp$OfRef.evaluateSequential(ForEachOps.java:174)    at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:234)    at java.util.stream.ReferencePipeline.forEach(ReferencePipeline.java:418)    at pl.samouczekprogramisty.kursjava.streams.requirements.InterferingOperation.main(InterferingOperation.java:15)Rodzaje operacji na strumieniach Tworzenie strumieni Strumienie można tworzyć na wiele sposobów poniżej pokażę Ci kilka przykładów.   Strumień na podstawie kolekcji:Stream&lt;Integer&gt; stream1 = new LinkedList&lt;Integer&gt;().stream();  Strumień na podstawie tablicy:Stream&lt;Integer&gt; stream2 = Arrays.stream(new Integer[]{});  Strumień na podstawie łańcucha znaków rozdzielanego przez wyrażenie regularne:Stream&lt;String&gt; stream3 = Pattern.compile(\".\").splitAsStream(\"some longer sentence\");  Strumień typów prostych:DoubleStream doubles = DoubleStream.of(1, 2, 3);IntStream ints = IntStream.range(0, 123);LongStream longs = LongStream.generate(() -&gt; 1L);  Strumień danych losowych:DoubleStream randomDoubles = new Random().doubles();IntStream randomInts = new Random().ints();LongStream randomLongs = new Random().longs();  Pusty strumień:Stream.empty();  Strumień danych z pliku:try (Stream&lt;String&gt; lines = new BufferedReader(new FileReader(\"file.txt\")).lines()) {    // do something}Strumień danych z pliku musi być zamknięty. W przykładzie powyżej użyłem do tego konstrukcji try-with-resources. Strumień możesz także zamknąć wywołując na nim metodę close. Operacje na strumieniach Nie opiszę tutaj wszystkich metod dostępnych na strumieniach. Jeśli chcesz poznać ich więcej zachęcam do zapoznania się z dokumentacją interfejsu Stream.   filter - zwraca strumień zawierający tylko te elementy dla których filtr zwrócił wartość true,  map - każdy z elementów może zostać zmieniony do innego typu, nowy obiekt zawarty jest w nowym strumieniu,  peek - pozwala przeprowadzić operację na każdym elemencie w strumieniu, zwraca strumień z tymi samymi elementami,  limit - zwraca strumień ograniczony do zadanej liczby elementów, pozostałe są ignorowane.Kończenie strumienia Operacjami kończącymi są wszystkie, które zwracają typ inny niż Stream. Metody tego typu mogą także nie zwracać żadnych wartości.   forEach - wykonuje zadaną operację dla każdego elementu,  count - zwraca liczbę elementów w strumieniu,  allMatch - zwraca flagę informującą czy wszystkie elementy spełniają warunek. Przestaje sprawdzać na pierwszym elemencie, który tego warunku nie spełnia,  collect - pozwala na utworzenie nowego typu na podstawie elementów strumienia. Przy pomocy tej metody można na przykład utworzyć listę. Klasa Collectors zawiera sporo gotowych implementacji.Właściwości strumieni Leniwe rozstrzyganie Strumienie są leniwe :). Oznacza to, że przetwarzają elementy dopiero po wykonaniu metody kończącej. Dodatkowo niektóre operacje powodują wcześniejsze zakończenie czytania danych ze strumienia. Przykładem takiej operacji jest limit. Poniższy przykład pokaże Ci dokładnie te właściwości: IntStream numbersStream = IntStream.range(0, 8);System.out.println(\"Przed\");numbersStream = numbersStream.filter(n -&gt; n % 2 == 0);System.out.println(\"W trakcie 1\");numbersStream = numbersStream.map(n -&gt; {    System.out.println(\"&gt; \" + n);    return n;});System.out.println(\"W trakcie 2\");numbersStream = numbersStream.limit(2);System.out.println(\"W trakcie 3\");numbersStream.forEach(System.out::println);System.out.println(\"Po\");Po uruchomieniu tego kodu na konsoli będziesz mógł zobaczyć: PrzedW trakcie 1W trakcie 2W trakcie 3&gt; 00&gt; 22PoZauważ, że komunikaty “W trakcie X” zostały wyświetlone przed operacją map. Zwróć także uwagę na to, że przetwarzanie skończyło się po dwóch elementach. To sprawka metody limit. Przetwarzanie sekwencyjne i równoległe Strumienie mogą być przetwarzane sekwencyjnie bądź równolegle. Metoda stream tworzy sekwencyjny strumień danych. Metoda parallelStream tworzy strumień, który jest uruchamiany jednocześnie na kilku wątkach. To ile wątków zostanie uruchomionych zależy od procesora. Strumień sekwencyjny można przełączyć na równoległy wywołując na nim metodę parallel. Odwrotna operacja także jest możliwa dzięki metodzie sequential. Dobre praktyki W tym paragrafie postaram się zebrać dobre praktyki ułatwiające pracę ze strumieniami danych. Filtrowanie na początku W związku z tym, że operacje na strumieniach wykonywane są tylko wtedy gdy jest to konieczne warto ograniczyć liczbę elementów najwcześniej jak to możliwe. Dzięki takiej prostej operacji możemy znacząco ograniczyć liczbę elementów, na których wykonana będzie czasochłonna metoda. W przykładzie poniżej symuluję czasochłonne wykonanie przez Thread.sleep(100). Wywołanie to “usypia” wątek na 100 milisekund 3: public static int timeConsumingTransformation(int number) {    try {        Thread.sleep(100);    } catch (InterruptedException e) {        e.printStackTrace();    }    return number;}W pierwszym przykładzie czasochłonna metoda wykonana jest na każdej z liczb: int slowNumber = IntStream.range(1950, 2150)        .map(StreamsGoodPractices::timeConsumingTransformation)        .filter(n -&gt; n == 2000)        .sum();Lepszym rozwiązaniem, może być odwrócenie kolejności tych operacji. W tym przypadku czasochłonna metoda zostanie wywołana wyłącznie na przefiltrowanych elementach: int fastNumber = IntStream.range(1950, 2150)        .filter(n -&gt; n == 2000)        .map(StreamsGoodPractices::timeConsumingTransformation)        .sum();Unikaj skomplikowanych wyrażeń lambda Skomplikowane, wieloliniowe wyrażenie lambda może nie być czytelne. W takim przypadku, moim zdaniem, lepiej opakować kod w metodę i użyć odnośnika do metody wewnątrz strumienia. Proszę porównaj dwa poniższe przykłady IntStream.range(1950, 2150)    .filter(y -&gt; (y % 4 == 0 &amp;&amp; y % 100 != 0) || y % 400 == 0)    .forEach(System.out::println);IntStream.range(1950, 2150)    .filter(StreamsGoodPractices::isLeapYear)    .forEach(System.out::println);public static boolean isLeapYear(int year) {    boolean every4Years = year % 4 == 0;    boolean notEvery100Years = year % 100 != 0;    boolean every400Years = year % 400 == 0;    return (every4Years &amp;&amp; notEvery100Years) || every400Years;}Chociaż drugi przykład jest zdecydowanie dłuższy wydaje mi się, że jest tez bardziej czytelny. A czytelność kodu ma znaczenie :). Nie nadużywaj strumieni Jak ktoś umie obsługiwać młotek to każdy problem wygląda jak gwóźdź. Strumienie są jednym ze sposobów rozwiązania problemu. To nie jest prawda, że znając strumienie powinieneś zapomnieć o pętlach. Dobrze jest znać oba mechanizmy. Poza tym, niektórych konstrukcji nie da się uzyskać przy pomocy strumieni. Przykładem mogą być tu niektóre pętle ze słówkiem kluczowym break. Strumienie to nie struktury danych W poprzednich artykułach opisałem kilka struktur danych. Przykładem struktur danych może być lista wiązana czy mapa. Strumienie nie są strukturą danych. W odróżnieniu od struktur nie służą do przechowywania danych. Strumienie jedynie pomagają określić operacje, które na tych danych chcesz wykonać. Mówi się, że strumienie pozwalają w deklaratywny sposób opisać operacje na danych. Można to uprościć do stwierdzenia, że struktury służą do przechowywania danych a strumienie służą do opisywania algorytmów, operacji na danych. Zadania Na koniec przygotowałem dla Ciebie kilka zadań do rozwiązania, które pomogą Ci utrwalić wiedzę zdobytą w tym artykule:   Przerób poniższy fragment kodu tak żeby używał strumieni:    double highestRanking = 0;BoardGame bestGame = null;for (BoardGame game : BoardGame.GAMES) { if (game.name.contains(\"a\")) {     if (game.rating &gt; highestRanking) {         highestRanking = game.rating;         bestGame = game;     } }}System.out.println(bestGame.name);        Znajdź minimalny element w kolekcji używając strumieni i funkcji reduce. Twoja funkcja powinna działać jak istniejąca funkcja min.  Używając metody flatMap napisz strumień, który “spłaszczy” listę list.Jak zwykle zachęcam Cię do samodzielnego rozwiązania zadań, wtedy nauczysz się najwięcej. Jeśli jednak będziesz miał z czymś kłopot możesz rzucić okiem do przykładowych rozwiązań, które przygotowałem. Dodatkowe materiały do nauki Poniżej zebrałem dla Ciebie kilka dodatkowych źródeł, które pozwolą spojrzeć Ci na temat strumieni z innej strony.   Bardzo dobra dokumentacja pakietu java.util.stream,  Część I tutoriala dotyczącego strumieni na stronie Oracle,  Część II tutoriala dotyczącego strumieni na stronie Oracle,  Szczegółowy opis strumieni - Baeldung,  Kod źródłowy użyty w tym artykule.Podsumowanie Strumienie wraz z wyrażeniami lambda to bardzo użyteczne narzędzie. Po lekturze artykułu wiesz już czym są strumienie i jak z nimi pracować. Potrafisz utworzyć strumień i zaaplikować do niego zestaw operacji. Znasz dobre praktyki pracy ze strumieniami. Rozwiązując ćwiczenia utrwaliłeś wiedzę z artykułu w praktyce. Na koniec mam do Ciebie prośbę. Podziel się linkiem do artykułu ze swoimi znajomymi jeśli ten artykuł był dla Ciebie wartościowy. Jeśli nie chcesz pominąć kolejnych artykułów na blogu dopisz się do samouczkowego newslettera i polub profil Samouczka Programisty na Facebooku. Do następnego razu!             Sam bardzo często gram w planszówki ;). Grałem w większość wymienionych tu gier - mogę je z czystym sumieniem polecić. &#8617;               Dane źródłowe mogą także pochodzić z innego strumienia. &#8617;               To tylko przykładowa metoda, w praktyce taka czasochłonna operacja może polegać na przykład na pobraniu danych z bazy danych czy z pliku na dysku. &#8617;       ","categories": ["Kurs programowania Java"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/strumienie-w-jezyku-java/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/01/30_strumienie_w_jezyku_java_artykul.jpg"},{
        "title": "Protokół HTTP",
        "excerpt":"Czym jest protokół HTTP Według słownika języka polskiego protokół to:   zasady wymiany informacji i współpracy programów i urządzeń komputerowych Zatem protokół HTTP (ang. Hypertext Transfer Protocol) to zasady wymiany informacji i współpracy programów. Programami są serwery i klienty. Programy te wysyłają żądania (klienty) lub odpowiedzi (serwery). Przykładem klienta HTTP może być przeglądarka internetowa1. Klienty mogą interpretować uzyskane odpowiedzi, na przykład przeglądarka internetowa potrafi wyświetlić stronę internetową, która została przesłana przez serwer. Nawiasem mówiąc przeglądarka robi całkiem sporo rzeczy w tle… Wiesz, że do wyświetlania strony www.amazon.com przeglądarka wykonuje około 300 żądań HTTP? W końcowej części artykułu pokażę Ci jak to się dzieje. Komunikacja pomiędzy serwerem a klientem oparta jest na wielu innych protokołach. Ten zestaw protokołów nazywa się modelem ISO/OSI. Model ten zawiera warstwy. Każda warstwa, na bazie poprzednich, udostępnia dodatkowe funkcjonalności. Protokół HTTP znajduje się w najwyższej warstwie modelu, warstwie aplikacji. Klienty wysyłają żądania. Każde żądanie powiązane jest z zasobem. Zasobem może być obrazek, strona HTML czy plik z kodem JavaScript. Sam protokół HTTP nie określa czym dokładnie jest zasób. Określa jedynie sposób w jaki można dostać się do zasobów. Każdy zasób ma swój unikalny identyfikator. Ten identyfikator to URI (ang. Uniform Resource Identifier). Protokół HTTP dokładnie określa format komunikacji pomiędzy klientami i serwerami. Komunikacja ta oparta jest na wspomnianych już żądaniach i odpowiedziach. Protokół HTTP określa format tych wiadomości. Protokół HTTP jest bezstanowy. Oznacza to tyle, że każde zapytanie może być interpretowane w oderwaniu od pozostałych. Poza klientami i serwerami w komunikacji występują dodatkowe węzły. Na przykład mogą to być serwery, które zachowują kopię odpowiedzi przyspieszając komunikację. Mogą to być także elementy sieciowe pozwalające na sprawne dotarcie żądania do serwera. W tym artykule pominę te kwestie, moim zdaniem ich znajomość nie jest niezbędna do tworzenia aplikacji webowych. Teraz wprowadzę Cię w poszczególne elementy składające się na protokół HTTP. Adres czyli URL Wspomniałem wcześniej o URI. Podzbiorem URI są URL (ang. Uniform Resource Locator). URI można traktować jako zbiór znaków który pozwala na unikalną identyfikację zasobu. URL natomiast poza tym unikalnym identyfikatorem zawiera informację dotyczącą “położenia” danego zasobu. Często określenia te stosowane są zamiennie. Adres URL ma postać: scheme:[//[user[:password]@]host[:port]][/path][?query][#fragment]Przykładowy adres URL może wyglądać następująco: http://marcin:tajne@www.samouczekprogramisty.pl:80/nie/ma/tej?strony=1#identyfikator            Część adresu      Przykładowa wartość                  scheme      http              user      marcin              password      tajne              host      www.samouczekprogramisty.pl              port      80              /path      /nie/ma/tej              ?query      ?strony=1              #fragment      #identyfikator      Zgodnie ze specyfikacją HTTP wielkość liter nie ma znaczenia w częściach scheme i host. Wielkość liter w pozostałych elementach ma znaczenie2. Poniżej opiszę poszczególne części adresu URL. scheme W praktyce ta część adresu używana jest do określenia protokołu, najczęściej zobaczysz tu http czy https. W uproszczeniu można powiedzieć, że HTTPS (ang. Hypertext Transfer Protocol Secure) jest rozszerzeniem protokołu HTTP. To rozszerzenie pozwala na szyfrowanie połączenia pomiędzy klientem a serwerem. user:password user:password służą do uwierzytelniania. Uwierzytelnianie to proces, który polega na udowodnieniu, że klient wysyłający dane żądanie jest tym za kogo się podaje. Mechanizmu uwierzytelniania używasz praktycznie w każdym serwisie gdzie masz założone konto. W tym przypadku nazwa użytkownika i hasło przesyłane są jako część URL. Nie jest to bezpieczne w przypadku używania protokołu HTTP. Nawet przy komunikacji protokołem HTTPS adres URL może być zapamiętany przez przeglądarkę. Daje to możliwość przechwycenia nazwy użytkownika i hasła. W związku z tym nie jest to bezpieczny sposób na przesyłanie hasła czy nazwy użytkownika i należy go unikać3. host W przypadku protokołu HTTP sprowadza się to do nazwy domeny internetowej lub adresu IP. Przykładem domeny może być www.samouczekprogramisty.pl. Przykładowy adres IPv4 to 192.30.253.112. Jaka strona kryje się pod tym adresem :)? DNS (ang. Domain Name System) jest protokołem, który pozwala na tłumaczenie adresów IP na nazwy domen. port Port to numer. Numer ten jest wykorzystywany przez serwer. Serwer nasłuchuje ruch na danym porcie. To tak jak z numerem w bloku, domena to numer klatki a port to numer mieszkania ;). Protokoły mają swoje standardowe porty. Na przykład standardowym portem protokołu HTTP jest 80. Protokół HTTPS natomiast używa portu 443. W praktyce, ze względu na domyślne wartości, porty te często się pomija. Odpowiednia wartość pola scheme pozwala na określenie czy użytkownikowi chodzi o port 80 czy 443. Możesz także uruchomić serwer, który nasłuchuje na innym porcie. Przykładem może tu być Tomcat, który domyślnie uruchamia się na porcie 8080. W takim przypadku podanie portu jest konieczne. path Ta część adresu URL jest ścieżką, która określa zasób. Na przykład w adresie www.samouczekprogramisty.pl/kurs-programowania-java ścieżką jest /kurs-programowania-java. query Zawiera dodatkowe dane identyfikujące dany zasób. Ta część oddzielona jest od ścieżki znakiem ?. W praktyce zawiera pary klucz=wartość połączone znakiem &amp;. Na przykład: ?parametr=wartosc&amp;format=jsonfragment Ostatnia część adresu URL. W praktyce wykorzystywana jest do określenia fragmentu strony HTML, która powinna zostać pokazana użytkownikowi. Na przykład adres http://www.samouczekprogramisty.pl/strumienie-w-jezyku-java/#właściwości-strumieni przeniesie Cię do sekcji opisującej właściwości strumieni.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Żądanie i odpowiedź     W dalszej części artykułu będę używał programu curl jako klienta HTTP. Jest to program, który pozwala na łatwe wysyłanie zapytań do serwerów z linii poleceń. Jeśli nie chcesz używać tego programu możesz użyć narzędzi dla programistów dostępnych w Twojej przeglądarce:   Chrome,  Firefox,  Safari,  Opera,  Edge.Teraz przeanalizuję przykładowe zapytanie wraz z odesłaną odpowiedzią. Użyję do tego publicznego API Github’a. Github używa HTTPS, w analizie żądania/odpowiedzi pominę fragmenty dotyczące HTTPS. Żądanie HTTP Klient wysyła żądanie do serwera w formie wiadomości. Wiadomość ta ma dokładnie zdefiniowany format:   linia określająca czasownik HTTP, zasób i wersję protokołu,  linie zawierające nagłówki,  pustą linię określającą koniec nagłówków,  ciało wiadomości (jeśli istnieje).Jak wspomniałem wyżej użyję programu curl. Dodatkowo użyję przełącznika -v. Włącza on tryb lania wody ;). Wtedy curl raportuje dużo więcej informacji. Dane wysłane do serwera poprzedzone są znakiem &gt;. Odpowiedź poprzedzona jest &lt;. Poniżej pokazuję zapytanie do API Githuba. Wysyłam żądanie na adres https://api.github.com/users/kbl: $ curl -v https://api.github.com/users/kbl// ciach usunąłem część związaną z HTTPS&gt; GET /users/kbl HTTP/1.1&gt; Host: api.github.com&gt; User-Agent: curl/7.52.1&gt; Accept: */*&gt;Zacznę od analizowania pierwszej linijki GET /users/kbl HTTP/1.1. Na początku zawiera ona czasownik HTTP - GET (czasowniki opiszę dokładniej poniżej). Następnie zawiera część adresu URL, wszystko od części path. W moim przypadku jest to /users/kbl. Kolejną częścią jest protokół wraz z wersją HTTP/1.1. Trzy kolejne linijki zawierają tak zwane nagłówki HTTP, nagłówkom także poświęcę osobny podpunkt poniżej. W przypadku tego żądania, ciało wiadomości jest puste. Widzisz więc tylko pustą linię oddzielającą nagłówki od pominiętego ciała wiadomości. Odpowiedź HTTP Serwer odpowiada na żądanie klienta wysyłając odpowiedź4. Podobnie jak w przypadku zapytania format jest dokładnie określony:   linijka z wersją protokołu i statusem odpowiedzi,  linie zawierające nagłówki,  pustą linię określającą koniec nagłówków,  ciało wiadomości (jeśli istnieje).Tym razem odpowiedź, jest dużo dłuższa: &lt; HTTP/1.1 200 OK&lt; Server: GitHub.com&lt; Date: Tue, 06 Feb 2018 19:36:28 GMT&lt; Content-Type: application/json; charset=utf-8&lt; Content-Length: 1218&lt; Status: 200 OK&lt; X-RateLimit-Limit: 60&lt; X-RateLimit-Remaining: 55&lt; X-RateLimit-Reset: 1517949218&lt; Cache-Control: public, max-age=60, s-maxage=60&lt; Vary: Accept&lt; ETag: \"268c03d98e6e20c7824364d61b3f51b0\"&lt; Last-Modified: Mon, 09 Oct 2017 19:42:33 GMT&lt; X-GitHub-Media-Type: github.v3; format=json&lt; Access-Control-Expose-Headers: ETag, Link, Retry-After, X-GitHub-OTP, X-RateLimit-Limit, X-RateLimit-Remaining, X-RateLimit-Reset, X-OAuth-Scopes, X-Accepted-OAuth-Scopes, X-Poll-Interval&lt; Access-Control-Allow-Origin: *&lt; Content-Security-Policy: default-src 'none'&lt; Strict-Transport-Security: max-age=31536000; includeSubdomains; preload&lt; X-Content-Type-Options: nosniff&lt; X-Frame-Options: deny&lt; X-XSS-Protection: 1; mode=block&lt; X-Runtime-rack: 0.030276&lt; X-GitHub-Request-Id: 8AAA:602C:92D77:140069:5A7A03BC&lt;{  \"login\": \"kbl\",  // ciach  \"created_at\": \"2009-04-14T08:28:56Z\",  \"updated_at\": \"2017-10-09T19:42:33Z\"}Pierwsza linijka to wspomniany wcześniej protokół HTTP/1.1. Następnie status odpowiedzi 200 OK, podobnie jak w przypadku nagłówków i czasowników więcej o statusie przeczytasz w osobnym podpunkcie. Kolejne 22 linijki to nagłówki, po których występuje pusta linia. Podobnie jak przy żądaniu oddziela ona nagłówki od ciała wiadomości. W przypadku odpowiedzi ciało wiadomości zawiera dane w formacie JSON - zasób. Dla czytelności pominąłem tu większość ciała odpowiedzi. Zachęcam Cię do eksperymentowania z własnymi zapytaniami :). Do tych eksperymentów może Ci się przydać dokumentacja API. Czasowniki HTTP Specyfikacja HTTP definiuje 8 czasowników5. Każdy z tych czasowników powiązany jest z żądaniem wysyłanym przez klienta. Każde z żądań ma swoje zastosowania. Zanim przejdę do omówienia poszczególnych czasowników musisz wiedzieć czym jest cache6. Cache to mechanizm, który pozwala na zmniejszenie czasu oczekiwania na odpowiedź. Zakładając, że wykonasz dwa zapytania z rzędu o ten sam zasób wynik pierwszego zapytania może być zapisany w cache’u. W związku z tym drugie zapytanie może nie dotrzeć do serwera, odpowiedź może zostać pobrana z cache’a. GET Jest to podstawowe żądanie. Każde otworzenie strony internetowej zaczyna się od zapytania typu GET. Przeglądarka wysyła żądanie typu GET żeby otworzyć stronę internetową. Specyfikacja mówi, że żądanie to służy do pobrania aktualnej reprezentacji zasobu. W praktyce może to oznaczać pobranie aktualnej wersji strony znajdującej się pod danym adresem. Zakłada się, że żądania typu GET nie posiadają dołączonego ciała wiadomości. Odpowiedź na żądania typu GET może być przechowywana w cache’u. HEAD Zapytanie typu HEAD jest podobne do GET. Różni się jednym ważnym szczegółem. W przypadku tego zapytania odpowiedź serwera nie może zawierać ciała wiadomości. Zapytania tego typu są używane do sprawdzenia czy dany zasób się zmienił, czy do sprawdzania poprawności odnośników. Zysk z używania tego zapytania polega na tym, że ciało wiadomości nie jest przesyłane. Wyobraź sobie plik PDF, który zawiera 10MB danych. Można wysłać zapytanie typu HEAD, żeby sprawdzić czy zawartość tego pliku uległa zmianie. To czy plik jest nowszy można określić na podstawie nagłówków, które będą dołączone do odpowiedzi. Odpowiedź na żądania typu HEAD może być przechowywana w cache’u. POST Specyfikacja mówi, że żądania typu POST są przetwarzane przez serwer zgodnie z założeniami dla danego zasobu. Taki skomplikowany opis sprowadza się do:   używania POST do przesyłania zawartości formularzy,  dodawania nowego zasobu,  dodawanie danych do istniejącego zasobu.Odpowiedzi na żądania typu POST nie jest przechowywana w cache’u7. PUT W codziennym użytkowaniu żądania typu PUT służą do aktualizacji danego zasobu. Zgodnie ze specyfikacją ciało wiadomości powinno posłużyć do ustawienia stanu zasobu na serwerze. Zatem w przypadku gdy zasób nie istniał żądanie tego typu powinno go utworzyć. Jeśli zasób istnieje wówczas jego stan powinien być ustawiony na ten przekazany w ciele wiadomości. W większości znanych mi przypadków ten pierwszy aspekt jest pomijany, prawdopodobnie dla uproszczenia logiki aplikacji. Główna różnica pomiędzy zapytaniami POST i PUT polega na sposobie interpretowania ciała wiadomości. W przypadku zapytania typu POST to zasób decyduje jak przetworzyć otrzymaną wiadomość. W przypadku żądania typu PUT otrzymana wiadomość powinna posłużyć do ustawienia wartość zasobu. Odpowiedzi na żądanie typu PUT nie powinny być przechowywane w cache’u. Idempotentność Oznacza to tyle, że zapytania typu PUT są idempotentne. Zapytania, które są idempotentne można powtarzać wielokrotnie i zawsze doprowadzą one do tego samego stanu danego zasobu. DELETE Zapytania tego typu służą do usuwania zasobów. Na przykład w którymś z wcześniejszych zapytań dany zasób może być utworzony przy pomocy żądania typu POST. Następnie może on być usunięty przy pomocy DELETE. Odpowiedzi na żądania tego typu nie powinny zawierać ciała wiadomości. Odpowiedzi na żądania typu DELETE nie powinny być umieszczane w cache’u. CONNECT Żądania tego typu służą do utworzenia połączenia pomiędzy klientem a serwerem docelowym (za pomocą węzłów pośrednich). W praktyce nie będziesz używał tego typu żądań w trakcie pisania aplikacji webowych. Mi się to nigdy do tej pory nie zdarzyło :). OPTIONS Żądania typu OPTIONS używane są do pobrania informacji na temat możliwości komunikacji dla danego zasobu. W praktyce żądania tego typu używane są do sprawdzenia jakie żądania są obsługiwane przez serwer. Żądanie tego typu także wykorzystywane jest w mechanizmie CORS. Odpowiedzi na żądania typu OPTIONS nie powinny być przechowywane w cache’u. TRACE Żądanie tego typu służy do testowania. W odpowiedzi na to żądanie serwer powinien wysłać zapytanie, które otrzymał. Możliwa jest drobna modyfikacja otrzymanych nagłówków, na przykład serwer może usunąć nagłówki zawierające dane wrażliwe (na przykład ciasteczka). Żądanie typu TRACE nie może zawierać ciała wiadomości. Odpowiedzi na żądanie typu TRACE nie powinny być umieszczane w cache’u. Nagłówki HTTP Nagłówki dołączane są przez klienty do wysyłanych zapytań i przez serwery do wysyłanych odpowiedzi. Mają one postać nazwa-nagłówka: wartość-nagłówka. Zgodnie ze specyfikacją wielkość liter w nazwach nagłówków nie ma znaczenia. Wielkość liter w wartości nagłówka może mieć znaczenie, zależy to od aplikacji. Chociaż istnieje cała masa standardowych nagłówków możesz tworzyć swoje własne. Nagłówki wykorzystywane są do przesyłania metadanych na temat zasobów. Mogą zawierać na przykład informacje o formacie, statusie odpowiedzi czy dacie. Poniżej postaram się wyjaśnić kilka najczęściej spotykanych nagłówków:             Nagłówek      Znaczenie                  Accept      Klient informuje serwer o tym jaki format jest w stanie zrozumieć, może to być na przykład JSON: application/json              Accept-Encoding      Klient informuje serwer o tym jakie sposoby kodowania ciała wiadomości rozumie, może być użyty do określenia pożądanego algorytmu kompresji odpowiedzi              Access-Control-Allow-Methods      W odpowiedzi na zapytanie typu OPTIONS serwer informuje jakie inne czasowniki HTTP są dozwolone              Access-Control-Allow-Origin      Serwer informuje klienta jakie domeny uprawnione są do użycia odpowiedzi              Cache-Control      Nagłówek służący do zarządzania cache’owaniem. Dotyczy zarówno żądań jak i odpowiedzi              Connection      Zawiera informacje na temat połączenia pomiędzy klientem a serwerem              Content-Encoding      Serwer informuje klienta o sposobie kodowania ciała wiadomości              Content-Type      Odpowiednik nagłówka Accept wysyłany przez serwer informujący o formacie odpowiedzi              Cookie      Nagłówek służący do przesłania ciasteczka przez klienty do serwera              Date      Zawiera datę mówiącą od czasie wygenerowania żądania/odwiedzi              ETag      Zawiera identyfikator zasobu zwróconego przez serwer. Używany przez cache              Host      Zawiera domenę, do której wysyłane jest żądanie              Location      Zawiera informacje o położeniu zasobu, może być użyty na przykład przy przekierowaniach i tworzeniu nowych zasobów              Server      Serwer informuje klienty jakiego oprogramowania używa do obsługi odpowiedzi              Set-Cookie      Nagłówek służący do ustawienia ciasteczka              User-Agent      Nagłówek dołączany do zapytania informujący o tym jaki klient został użyty to jego wysłania      Ciasteczka Co prawda ciasteczka to nic innego jak nagłówki, jednak poświęcę im osobny podpunkt. W osobnym artykule możesz przeczytać o ciasteczkach w kontekście specyfikacji serwletów. Wiesz już, że protokół HTTP jest bezstanowy. Serwer HTTP nie może powiązać ze sobą zapytać pochodzących od tego samego klienta w jedną paczkę. Z pomocą przychodzą ciasteczka. Ciasteczka to specyficzne nagłówki, które są obsługiwane przez klienty. Serwer w odpowiedzi może wysłać nagłówek, który utworzy ciasteczko. Ciasteczko to jest przypisane do domeny (część host i path adresu URL). Przykładowy nagłówek do ustawienia ciasteczka może wyglądać następująco: Set-Cookie: &lt;nazwa ciasteczka&gt;=&lt;wartość ciasteczka&gt;W każdym kolejnym zapytaniu do tej domeny klient dołącza nagłówki ciasteczek. Dzięki temu aplikacja na serwerze może połączyć pojedyncze zapytania w sesje. Przykładowe ciasteczko w odpowiedzi dołączane jest przy pomocy nagłówka: Cookie: &lt;nazwa ciasteczka&gt;=&lt;wartość ciasteczka&gt;Pewnie kojarzysz formularze logowania, w których możesz zaznaczyć “zapamiętaj mnie”. Zaznaczenie tego pola powoduje wysłanie odpowiedzi przez serwer, w której znajduje się nagłówek z ciasteczkiem (nagłówek Set-Cookie). To ciasteczko zawiera unikalny klucz, który później jest dotłaczany przez klienta do każdego żądania do danej domeny (nagłówek Cookie). Dzięki temu każde kolejne zapytanie ma nagłówek z tym tokenem. Aplikacja na serwerze widząc ten token może potwierdzić tożsamość użytkownika. Niestety ciasteczka wykorzystywane są także do złych celów. Ciasteczka mogą być wykorzystywane jako jeden ze sposobów do śledzenia Twojego ruchu w sieci. Zdarzyło Ci się kliknąć na reklamę a później ta reklama pokazywała Ci się bez przerwy? Ciasteczka także mogły się do tego przyczynić8. Statusy HTTP Wiesz już, że każda odpowiedź od serwera zawiera między innymi informacje o statusie. Status ten jest podstawową informacją o tym czy żądanie się powiodło. Wszystkie statusy podzielone są na pięć grup. Statusy 1xx Szczerze nigdy w praktyce nie spotkałem się z użyciem tych statusów. Ta grupa statusów to statusy informacyjne. Informują klienty o tym, że zapytanie zostało otrzymane i jest przetwarzane. Statusy 2xx Statusy z tej grupy informują o tym, że zapytanie zostało poprawnie przetworzone. W zależności od kodu odpowiedzi wynik tego przetwarzania może być różny. Najczęściej używane statusy z tej grupy to:   200 OK - zapytanie zostało przetworzone poprawnie,  201 Created - zapytanie zostało przetworzone poprawnie i zasób został utworzony,  202 Accepted - zapytanie zostało przyjęte przez serwer, jednak jego przetwarzanie nie jest jeszcze ukończone,  204 No Content - zapytanie zostało przetworzone, ciało wiadomości jest puste.Statusy 3xx Statusy zaczynające się o 3 informują klienty o tym, że musi być podjęta dodatkowa akcja w celu skończenia przetwarzania zapytania. Statusy te wykorzystywane są do ustawiania przekierowań. Na przykład jeśli zmieniłbym adres samouczka z www.samouczekprogramisty.pl na cokolwiek innego wówczas żądanie wysłane pod www.samouczekprogramisty.pl powinno skończyć się statusem z grupy 3xx:   301 Moved Permanently - informuje klienta, że zasób został przeniesiony na stałe w inne miejsce. Ten status ma znaczenie duże dla twórców stron, którzy bazują na ruchu z wyszukiwarek. Taki status informuje wyszukiwarki o tym, że strona, która wcześniej była pod adresem X znajduje się w nowym miejscu.Statusy 4xx Statusy z tej grupy informują o błędzie klienta. Pewnie nie raz widziałeś błąd 404 ;). Serwer tymi statusami informuje o tym, że żądanie nie może być poprawnie przetworzone:   400 Bad Request - serwer informuje klienta o błędnym zapytaniu, które nie będzie przetworzone,  403 Forbidden - zasób wymaga uwierzytelnienia, po potwierdzeniu tożsamości może być dostępny,  404 Not Found - to pewnie znasz i widziałeś wielokrotnie, żądany zasób nie istnieje.Statusy 5xx Tutaj sprawa jest poważna. Serwer informuje klienty o błędzie po stronie serwera, które uniemożliwiają przetworzenie zapytania:   500 Internal Server Error - informacja dla klienta o tym, że serwer znalazł się w stanie, który uniemożliwia poprawne przetworzenie żądania,  502 Bad Gateway - na początku artykułu wspomniałem o tym, że może być wiele węzłów, które będą przekazywały zapytanie do serwera, który je finalnie obsłuży. Ten status informuje klienta o tym, że jeden z tych pośrednich węzłów dostał błędną odpowiedź od poprzedniego węzła,  503 Service Unavailable - ten błąd może informować klienta o tym, że serwer jest przeciążony. Ponowna próba może kończyć się poprawną odpowiedzią.Prawie 300 zapytań aby wyświetlić stronę Teraz jak już wiesz czym jest protokół HTTP wyjaśnię “tajemnicę” około 300 zapytań.         Do wyświetlenia www.amazon.com potrzeba około 300 zapytań  Przeglądarka jest klientem HTTP. Klienty mogą interpretować odpowiedź wysyłaną od serwera. Wpisując w pasek adresu www.amazon.com i naciskając ENTER wysyłasz jedno zapytanie. Jest to zapytanie typu GET o zasób www.amazon.com. W odpowiedzi serwer zwraca dokument HTML. Dokument ten jest interpretowany przez przeglądarkę, zawiera on znaczniki HTML. Takie jak img, script czy style. Każdy z tych znaczników może kończyć się kolejnym zapytaniem typu GET. Dodatkowo kod JavaScript interpretowany przez przeglądarkę może wykonywać dodatkowe zapytania. W sumie do wyświetlenia strony głównej sklepu Amazon potrzeba tych zapytań około 300. A wszystko zaczęło się od jednego, niewinnego GET :). Dodatkowe materiały Odsyłam Cię głównie do źródeł. Mam wrażenie, że artykuł jest na tyle szczegółowy, że bardziej dokładne informacje znajdziesz właśnie tam:   Zbiór materiałów fundacji Mozilla dotyczących HTTP,  Zbiór RFC dla HTTP 1.1:          RFC 7230      RFC 7231      RFC 7232      RFC 7233      RFC 7234      RFC 7235        RFC dla URIPodsumowanie Jeśli przeczytałeś i zrozumiałeś ten artykuł to śmiało możesz powiedzieć, że znasz protokół HTTP. Wiesz jak działa ten protokół, wiesz czym są zasoby. Poznałeś różnicę pomiędzy URI a URL. Znasz mechanizm działania nagłówków, poznałeś też główne statusy odpowiedzi. Moim zdaniem, poznając to wszystko wyszedłeś poza podstawową wiedzę na temat tego protokołu. Zapowiadało się niewinnie a wyszedł tasiemiec. Sporo napracowałem się przy tym artykule, więc będę Ci bardzo wdzięczny za udostępnienie go dalej :). Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Trzymaj się! :)             Ot, taki “patriotyzm lokalny” - aktualnie pracuję w firmie Opera Software ;). &#8617;               To czy wielkość liter jest rozróżniana zależy od aplikacji obsługującej dane żądanie. &#8617;               Potrafię sobie wyobrazić wyjątki od tej reguły. Na przykład w komunikacji, w której adres URL jest przesyłany zaszyfrowanym kanałem. &#8617;               Na jedno żądanie serwer może wysłać kilka odpowiedzi, na przykład dzieląc dużą odpowiedź na kilka mniejszych. &#8617;               RFC5789 rozszerza tę grupę o czasownik PATCH. &#8617;               Tutaj podobnie jak z webservice’em postanowiłem nie tłumaczyć tego określenia. Jest ono na tyle powszechne, że nawet nie wiem jakie byłoby dobre tłumaczenie. Schowek? Skrytka? ;) &#8617;               W większości przypadków, specyfikacja dopuszcza wyjątki od tej reguły. &#8617;               Ciasteczka nie są jedynym narzędziem używanym do śledzenia użytkownika. Podobnie sprawa wygląda z reklamami, to nie tylko ciasteczka mogą służyć do wybierania tych do wyświetlenia dla Ciebie. &#8617;       ","categories": ["Kurs aplikacji webowych"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/protokol-http/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/02/08_protokol_http_artykul.jpg"},{
        "title": "Samouczek na rozmowie - czy liczba jest cykliczna",
        "excerpt":"  To jest artykuł z serii “Samouczek na rozmowie”. W ramach tej serii staram się, między innymi, rozwiązywać zadania. Zadania te często zdarzają się na rozmowach kwalifikacyjnych. W trakcie rozwiązywania takich zadań umiejętność szacowania złożoności obliczeniowej jest niezwykle ważna. Przyda się też umiejętność pisania testów jednostkowych. Dzięki nim bardzo łatwo przetestujesz działanie algorytmu.   Podstawy złożoności obliczeniowej,  Test Driven Development na przykładzie,  Testy jednostkowe z JUnit,Podstawą jest oczywiście znajomość języka programowania, ja używał będę Javy jednak możesz użyć dowolnego języka programowania. W opisie problemu będę używał “pseudo kodu”. Przykładowe rozwiązania będą w języku Java.   Kurs programowania w języku Java.Czym jest liczba cykliczna Zanim przejdę do treści zadania musisz wiedzieć czym jest liczba cykliczna. Liczba cykliczna to liczba całkowita, której cykliczne permutacje cyfr są możliwe do uzyskania przez mnożenie liczby przez kolejne liczby naturalne. Przykładową liczbą cykliczną jest 142857. Wyniki mnożenia tej liczby przez pierwsze 6 liczb naturalnych dają jej permutacje cykliczne: 142857 * 1 = 142857142857 * 2 = 285714142857 * 3 = 428571142857 * 4 = 571428142857 * 5 = 714285142857 * 6 = 857142    Permutacja cykliczna może brzmieć jak coś skomplikowanego. W praktyce powstaje ona przez wstawianie pierwszego elementu danego łańcucha na koniec. Na przykład permutacjami cyklicznymi łańcucha znaków abcd są:   abcd  bcda  cdab  dabcZadanie do wykonania Napisz funkcję isCyclic, która jako argument dostaje dowolnie dużą dodatnią liczbę całkowitą w postaci łańcucha znaków. Liczba może być poprzedzona zerami, więc \"0123\" jest poprawnym wejściem programu. Zadaniem jest napisanie funkcji isCyclic, która sprawdzi czy dana liczba jest liczbą cykliczną. isCyclic(\"142857\") == trueisCyclic(\"012233\") == falseW przykładzie pierwsza liczba jest liczbą cykliczną. Druga linijka pokazuje przykład, dla którego isCyclic powinna zwrócić wartość false. Od czego zależy złożoność W przypadku tego zadania danymi wejściowymi jest łańcuch znaków. W zadaniach tego typu długość takiego łańcucha używana jest do szacowania złożoności obliczeniowej i pamięciowej. Zatem n użyte poniżej odnosi się właśnie do długości wejściowego łańcucha znaków. Najprostsze rozwiązanie problemu Zacznę od najprostszego rozwiązania problemu. Parametrem funkcji jest łańcuch znaków reprezentujący liczbę. Żeby zobaczyć czy ta liczba jest cykliczna wygeneruję wszystkie jej permutacje cykliczne i będę sprawdzał czy mnożąc liczbę przez kolejne wartości od 1 do N wynik będzie znajdował się we wcześniej przygotowanych permutacjach. Proszę spójrz na przykładowe rozwiązanie: public boolean isCyclicNaive(String number) {    String[] permutations = new String[number.length()];    for (int index = 0; index &lt; permutations.length; index++) {        permutations[index] = number.substring(index) + number.substring(0, index);    }    BigInteger value = new BigInteger(number);    String formatString = \"%0\" + number.length() + \"d\";    outerLoop: for (int multiplicator = 2; multiplicator &lt;= number.length(); multiplicator++) {        BigInteger multiplication = value.multiply(BigInteger.valueOf(multiplicator));        String formattedResult = String.format(formatString, multiplication);        for (String permutation : permutations) {            if (formattedResult.equals(permutation)) {                continue outerLoop;            }        }        return false;    }    return true;}Pierwsza pętla odpowiedzialna jest za tworzenie permutacji cyklicznych. Wewnątrz drugiej pętli sprawdzam czy mnożąc liczbę przez kolejne wartości od 2 do N uzyskam jedną z wcześniej przygotowanych permutacji. Posługuję się tutaj typem BigInteger aby móc pracować na liczbach większych niż te, które mogę przechowywać w zmiennej typu long. Złożoność obliczeniowa Pierwsza pętla ma złożoność Ο(n^2). Dzieje się tak ponieważ metoda substring ma złożoność Ο(n). Kolejna pętla jest zagnieżdżona i ma złożoność Ο(n^3). Tym razem złożoność “psuje” operacja multiply, która ma złożoność obliczeniową Ο(n^2). Więc finalnie złożoność obliczeniowa tego algorytmu to O(n^3). Złożoność pamięciowa W przypadku tego algorytmu przechowuję listę permutacji w tablicy. Tablica zawiera N permutacji. Każda permutacja ma długość N. Zatem finalna złożoność pamięciowa to Ο(n^2). Rozwiązanie bazujące na właściwościach liczb cyklicznych Czytając o liczbach cyklicznych dowiedziałem się kilku istotnych rzeczy:   liczby cykliczne tworzone są na podstawie liczb pierwszych,  długość liczby cyklicznej jest o jeden większa niż liczba pierwsza użyta do generowania liczby cyklicznej,  liczba cykliczna jest cyklicznym rozwinięciem ułamka 1/liczba pierwsza do generacji.Mając takie informacje podszedłem do problemu od drugiej strony. Zamiast sprawdzić czy dana liczba jest cykliczna wygenerowałem liczbę, która powstałaby na podstawie dzielenia 1/liczba pierwsza do generacji. Następnie porównuję tak uzyskaną liczbę z tą przekazaną jako argument metody. Jeśli są sobie równe wówczas przekazana liczba jest liczbą cykliczną. Proszę spójrz na implementację: public boolean isCyclicGeneration(String number) {    int base = 10;    int generatingPrime = number.length() + 1;    StringBuilder representation = new StringBuilder();    int step = 0;    int reminder = 1;    do {        step++;        int currentValueToDivide = reminder * base;        int currentDigit = currentValueToDivide / generatingPrime;        reminder = currentValueToDivide % generatingPrime;        representation.append(currentDigit);    } while (reminder != 1 &amp;&amp; step &lt; generatingPrime);    return number.equals(representation.toString());}Na początku ustawiam niezbędne zmienne. Następnie wewnątrz pętli obliczam kolejne wartości ułamka. Tak uzyskane liczby dodaję do bufora representation, który następnie porównuję z przekazaną liczbą. Warunek reminder != 1 wykrywa wystąpienie okresu w rozwinięciu dziesiętnym ułamka. Więcej na temat “okresu ułamka” przeczytasz w artykule opisującym liczby zmiennoprzecinkowe. Warunek step &lt; generatingPrime jest potrzebny, aby uniknąć nieskończonej pętli. Taki przypadek mógłby mieć miejsce jeśli metoda jako parametr otrzymałaby liczbę, która nie jest cykliczna. Złożoność obliczeniowa W przypadku tego rozwiązania występuje wyłącznie jedna pętla. Zatem złożoność obliczeniowa tego algorytmu to Ο(n). Złożoność pamięciowa Algorytm do działania potrzebuje kilku zmiennych. Jedna z nich, representation, urośnie do długości N. Zatem w tym przypadku złożoność pamięciowa tego algorytmu to O(n). Bardziej wydajne rozwiązanie problemu Masz jakiś pomysł? Z chęcią poznam Twoje podejście do rozwiązania tego problemu. Wrzuć swój kod na githuba i podziel się rozwiązaniem. Pamiętaj, żeby przetestować poprawność swojego rozwiązania. Możesz to zrobić przy pomocy testów jednostkowych, które przygotowałem. Wyślij mi swoje zadanie Zadanie omówione w tym artykule zostało przesłane przez jednego z czytelników. Jeśli chcesz abym spróbował omówić zadanie, na które Ty trafiłeś daj znać. Zastrzegam jednak, że nie jestem alfą i omegą. Potrafię sobie wyobrazić problemy, na które nie znajdę najlepszego rozwiązania. Niemniej jednak postaram się rozwiązać to zadanie w najlepszy znany mi sposób. Zadania możesz wysłać na mój adres e-mail marcin [małpka] samouczekprogramisty.pl. Często firmy zastrzegają sobie to, żeby nie rozpowszechniać zadań, które były na rozmowie kwalifikacyjnej. Jeśli tak było w Twoim przypadku proszę uszanuj wolę danej firmy i nie przesyłaj mi takiego zadania. Podsumowanie Po przeczytaniu artykułu znasz dwa sposoby rozwiązania zadanego problemu. Znasz złożoność pamięciową i obliczeniową każdego z rozwiązań. Jesteś o jedno zadanie lepiej przygotowany do rozmowy kwalifikacyjnej ;). Przykładowe rozwiązania, przedstawione w artykule znajdziesz na samouczkowym githubie. Kod zawiera także testy jednostkowe, których użyłem do weryfikacji poprawności działania algorytmów. Jeśli nie chcesz pominąć kolejnych artykułów z tej serii dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Jak zwykle, jeśli masz jakiekolwiek pytania proszę zadaj je w komentarzach. Postaram się pomóc ;). Do następnego razu! ","categories": ["Samouczek na rozmowie","Strefa zadaniowa"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/samouczek-na-rozmowie-czy-liczba-jest-cykliczna/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/02/16_rozmowa_kwalifikacyjna_liczba_cykliczna_zadanie_artykul.jpg"},{
        "title": "Wstęp do relacyjnych baz danych",
        "excerpt":"Czym jest baza danych Baza danych to zbiór danych zapisanych w odpowiednim formacie. Format zapisu danych pozwala na dostęp do danych. W zależności od zastosowania dane zapisywane są w różny sposób. Sposób zapisu danych ma wpływ na wydajność poszczególnych operacji (zapisu, odczytu, usunięcia i modyfikacji danych). Istnieje wiele rodzai baz danych. Jednym z najbardziej popularnych jest relacyjna baza danych. Określenie relacyjna baza danych opisuje bazę danych, w której dane zapisane są w postaci tak zwanych krotek. Krotki mają swoje atrybuty. Każda krotka zapisana jest w relacji. Operacje w relacyjnych bazach danych oparte są o algebrę relacji. Dostęp do danych możliwy jest dzięki użyciu SQL (ang. Structured Query Language). SQL to język charakterystyczny dla baz danych. Możesz spotkać się z wieloma implementacjami relacyjnych baz danych. Kilka najczęściej używanych implementacji możesz znaleźć poniżej:   PostgreSQL,  MySQL,  SQLite,  Oracle,  SQL Server,  HyperSQL.Bazy danych różnią się między sobą implementacją. Różnią się także wersją SQL, którą obsługują. Chociaż istnieje standard opisujący język SQL występują drobne różnice pomiędzy SQL obsługiwanym przez poszczególne bazy danych. Różne wersje SQL nazywane są dialektami. Samouczek Programisty jest jednym z partnerów konferencji infoShare 2018. infoShare 2018 to konferencja technologiczna odbywająca się 22-23 maja w Gdańsku. Na developerów czekają m.in. prelekcje z obszaru cybersecurity i machine learning, live coding oraz spotkania ze specjalistami, takimi jak: Filip Wolski, Trent McConaghy, Piotr Konieczny, Zbigniew Wojna czy Scott Helme. infoShare to także okazja do networkingu i udziału w imprezach towarzyszących. Sprawdź agendę i zarejestruj się na www.infoshare.pl.  Jak działa relacyjna baza danych Bazy danych używane w środowiskach produkcyjnych składają się z wielu komponentów. W dużym uproszczeniu można powiedzieć, że zawsze występują dwa: klient bazy danych i serwer bazy danych. Serwer bazy danych to program, który potrafi obsłużyć żądania wysyłane przez klienty. Serwer odpowiedzialny jest za zapisywanie i udostępnianie danych przechowywanych w bazie. Serwer używa pewnego portu, na którym nasłuchuje żądań od klientów. Na przykład PostgreSQL domyślnie używa portu 5432. W większości znanych mi przypadków serwery używają protokołu ODBC (ang. Open Database Connectivity) do komunikacji z klientami. Jest to protokół, który zapewnia spójny dostęp do danych, niezależny od serwera bazy danych. Sewery udostępniają także protokół JDBC (ang. Java Database Connectivity). Klienty wskazują serwer, z którym chcą się połączyć za pomocą URL. W przypadku bazy danych PostgreSQL URL może wyglądać następująco: jdbc:postgresql://some.server.host:5432/database_nameURL ten służy do połączenia się do serwera some.server.host na porcie 5432 używając protokołu jdbc:postgresql. database_name wskazuje bazę danych do której chcemy się połączyć. Jeśli chcesz przeczytać więcej o URL odsyłam Cię do artykułu na temat protokołu HTTP. Do obsługi takiego połączenia klient potrzebuje odpowiedniego sterownika. Sterownik to klasa obsługująca połączenie. Producenci bazy danych udostępniają takie sterowniki. Klienty używając języka SQL wysyłają żądania do serwera. Dotyczą one dostępu do danych zapisanych w bazie. Wcześniej wspomniany sterownik obsługuje komunikację pomiędzy klientem a serwerem. Serwer interpretuje te zapytania i pobiera dane z plików zachowanych na dysku serwera1. Następnie dane te są zwracane do klienta, po czym sterownik interpretuje dane przekazane zgodnie z protokołem, np. JDBC. Bardzo często zapytanie SQL zwraca przetworzone dane do klienta. Przetwarzanie surowych danych odbywa się po stronie serwera relacyjnej bazy danych.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Model relacyjny Za modelem relacyjnym stoi algebra relacji. Jest to matematyczny opis operacji wykonywanych na danych zachowanych w bazie. Możesz w nim przeczytać o sumie zbiorów, iloczynie kartezjańskim etc. Postaram się wytłumaczyć sposób działa baz bez użycia takich pojęć. Na potrzeby tego artykułu posłużę się wcześniej wspomnianym przykładem magazynu. Załóżmy, że w tym przypadku bazę danych możemy opisać kilkoma zdaniami:   W magazynie przechowujemy różne rodzaje towarów,  Poszczególne towary produkowane są przez różnych producentów,  Różni hurtownicy pobierają różne towary z magazynu,  Każdy producent ma jednego opiekuna handlowego.Encja Zrób proste ćwiczenie. Wybierz wszystkie rzeczowniki z listy, którą umieściłem wyżej. Możesz ją porównać z tą listą:   magazyn,  towar,  producent,  hurtownik,  opiekun handlowy.Można powiedzieć, że encje to rzeczowniki wyjęte z opisu bazy danych ;). Encje to rodzaje “obiektów” przechowywanych w bazie. Na przykład towar, czy producent. Odpowiednikiem encji w programowaniu obiektowym jest klasa. Zatem w przypadku bazy danych opisującej magazyn występuje pięć rodzai encji. Sama encja nie jest ściśle związana z modelem relacyjnym. Definicja ta jest jednak używana w trakcie projektowania baz danych. Atrybut Każda z encji ma swoje właściwości. Na przykład opiekun handlowy ma numer telefonu, imię czy nazwisko. Każdy z tych elementów to atrybut. Podobnie jak w programowaniu obiektowym instancje mają swoje atrybuty. Podobnie jak w języku programowania tak i tutaj atrybuty mają swoje typy. Relacyjne bazy danych obsługują różne typy. W większości przypadków typy z języków programowania mają swoje odpowiedniki w typach w bazie danych. Na przykład:             Typ w języku Java      Typ w PostgreSQL                  String      varchar              boolean      boolean              double      double precision              byte[]      bytea              int      integer      Istnieją jednak typy, które nie mają swojego dokładnego odwzorowania w niektórych językach programowania, na przykład:   box,  decimal(p, s),  polygon.Te różnice pokazują, że nie zawsze da się przenieść świat relacyjnej bazy danych do świata programowania obiektowego. Tematyce mapowania obiektowo-relacyjnego (ang. object-relational mapping) poświęcę osobny artykuł. Krotka Krotka to zbiór atrybutów. Upraszczając można powiedzieć, że krotka w modelu relacyjnym odpowiada instancji obiektu w programowaniu obiektowym2. Krotki często prezentowane są w postaci wiersza w tabeli gdzie każda kolumna odpowiada poszczególnym atrybutom. Przykładem krotki zawierającej towar może być:             Nazwa varchar      Stan magazynowy integer      Cena double precision                  trampki      10      99.99      Relacja W relacyjnym modelu bazy danych relacją określamy zbiór krotek. Skoro pojedyncza krotka to wiersz w tabeli, to zbiór krotek to cała tabela :). Istnieją różne konwencje nazywania relacji. W dalszej części artykułu będę używał liczby mnogiej od nazwy encji. Dla przykładu relacja przechowująca krotki towar będzie nazywała się towary. Musisz także wiedzieć, że relacją także możemy określać zależności jakie występują pomiędzy poszczególnymi tabelami. Na przykład tabela towary jest powiązana z tabelą producenci. Producent produkuje różne towary. Zatem pomiędzy producenci a towary występuje relacja jeden do wielu - jeden producent produkuje wiele towarów. Zbierając kilka krotek, relacja towary może wyglądać następująco:             Nazwa varchar      Stan magazynowy integer      Cena double precision                  trampki      10      99.99              sweter      0      299.99              lizak      2500      0.5              spinacz      500      0.01      W modelu relacyjnym krotki w relacji nie mogą się powtarzać (elementy w zbiorze są unikalne). W praktyce relacyjne bazy danych posługujące się SQL pozwalają na duplikaty wierszy w tabelach. Sam język SQL pozwala na pobranie unikalnych elementów z danej tabeli. Klucz główny Zbiór atrybutów (kolumn w tabeli) tworzy klucz główny. Klucz główny to unikalny identyfikator dla każdego wiersza w tabeli. W większości przypadków tabele zawierają dodatkową kolumnę, która zawiera identyfikator w postaci liczby:             Id integer (PK)      Nazwa varchar      …                  1      trampki      …              2      sweter      …              3      lizak      …              4      spinacz      …      W tabeli wyżej kolumna Id jest kluczem głównym (ang. primary key). Tworzenie kluczy głównych przy pomocy liczby pozwala na automatyczne tworzenie nowej wartości klucza dla nowego wiersza. Wystarczy podnieść o 1 największą wartość klucza głównego. Klucze główne składające się z wielu kolumn nazywa się kluczami złożonymi. Bazy danych optymalizują dostęp do danych przy pomocy klucza głównego. Oznacza to tyle, że pobranie wiersza z tabeli towary na podstawie kolumny Id będącej kluczem głównym może być bardziej wydajne niż pobranie tego samego wiersza na podstawie wartości kolumny Nazwa. Klucz obcy Wspomniałem wyżej, że tabele mogą być ze sobą powiązane. Te zależności pomiędzy tabelami pokazane są przez klucze obce (ang. foreign key). Klucz obcy to dodatkowa kolumna (lub kolumny), która pokazuje zależność. Na przykład tabela producenci może wyglądać następująco:             Id integer (PK)      Siedziba varchar      Rok założenia integer                  1      Wrocław      2007              2      Warszawa      1980              3      Kraków      1948      Dodatkowa kolumna producent_id znajdująca się wewnątrz tabeli towary pokazuje zależność pomiędzy towarami a producentami:             Id integer (PK)      Nazwa varchar      Producent id integer (FK)      …                  1      trampki      1      …              2      sweter      2      …              3      lizak      3      …              4      spinacz      3      …      Taka tabela pokazuje, że trampki produkowane są przez producenta z Wrocławia, swetry przez producenta z Warszawy. Producent z Krakowa produkuje lizaki i spinacze. Rodzaje powiązań Tabele mogą mieć trzy rodzaje zależności. Każdą z nich opiszę w osobnym podpunkcie. Jeden do jednego Przykładem takiej zależności może być samochód - numer rejestracyjny. Każdy numer rejestracyjny przypisany jest do jednego samochodu, podobnie każdy samochód ma tylko jeden numer rejestracyjny. W przypadku magazynu relacją tego typu może być opiekun handlowy - producent. Zależność tego typu reprezentuje dodatkowa kolumna w tabeli: producenci             Id integer (PK)      Siedziba varchar      Rok założenia integer                  …      …      …      opiekunowie             Id integer (PK)      Nazwisko varchar      Producent id integer (FK)                  …      …      …      Kolumna Producent id w tabeli opiekunowie wskazuje na producenta, za którego jest odpowiedzialny dany opiekun. Jeden do wielu Przykładem takiej zależności może być towar - producent. Każdy towar produkowany jest przez jednego producenta. Podobnie jak w przypadku reakcji jeden do jednego zależność tego typu uzyskuje się poprzez dodanie odpowiedniej kolumny: producenci             Id integer (PK)      Siedziba varchar      Rok założenia integer                  …      …      …      towary             Id integer (PK)      Nazwa varchar      …      Producent id integer (FK)                  …      …      …      …      Zauważ, że zarówno zależność jeden do wielu, jak i jeden do jednego możliwa jest przy pomocy pojedynczej kolumny. Zależność tego typu określa się także jako 1 do n. Wiele do wielu Zależność wiele do wielu może występować pomiędzy hurtownikami i towarami. Oznacza ona tyle, że wielu hurtowników zaopatruje się w wiele towarów. Ten sam towar pobierany jest przez wielu hurtowników. W przypadku takiej zależności niezbędna jest dodatkowa tabela, która połączy ze sobą dwie tabele: towary             Id integer (PK)      Nazwa varchar      …      Producent id integer (FK)                  …      …      …      …      hurtownicy             Id integer (PK)      Nazwa hurtowni varchar                  …      …      towary_hurtownicy             Towar id integer (FK)      Hurtownik id integer (FK)                  …      …      W tym przypadku tabela towary_hurtownicy ma dwa klucze obce. Jeden z nich pokazuje na tabelę towary drugi na hurtownicy. Zauważ, że w przypadku tej tabeli kluczem głównym, który identyfikuje każdy wiersz może być para tych kolumn. Jest to tak zwany klucz złożony. Zależność tego typu określa się także jako n do m. Dodatkowe materiały do nauki   Bazy danych - wykłady na UW,  Model relacyjny - artykuł na Wikipedii,  Model relacyjny - wykład na AGH.Zadanie do wykonania Dasz radę zaprojektować bazę danych, do przechowania informacji o wykładach w trakcie konferencji? Spróbuj zrobić to na podstawie agendy znajdującej się na stronie infoShare. Podsumowanie W dzisiejszym artykule przeczytałeś o bazach danych. Poznałeś sposób komunikacji pomiędzy klientem a serwerem. Dowiedziałeś się czym jest model relacyjny. Wiesz czym jest relacja, krotka czy atrybut w kontekście modelu relacyjnego. Zdobytą wiedzę mogłeś przećwiczyć rozwiązując zadanie do wykonania. Te postawy pozwolą Ci lepiej zrozumieć SQL i mapowanie obiektowo relacyjne. Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz ominąć kolejnych artykułów proszę zapisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Trzymaj się i do następnego razu!             Jest to duże uproszczenie. Bazy danych są programami, które są przystosowane do obsługi dużej liczby zapytań. Znane mi relacyjne bazy danych wspierają ACID. Zapytania często podlegają optymalizacji. Przetwarzanie danych zgodnie z zapytaniem SQL to także robota serwera. Czynniki te sprawiają, że dostęp do danych to coś więcej niż zwykłe “pobieranie danych z dysku”. &#8617;               Nie jest to do końca prawda, na przykład w przypadku relacji wiele do wielu krotki w relacji łączącej nie muszą mieć odpowiadającego im obiektu w języku programowania. &#8617;       ","categories": ["Bazy danych"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/wstep-do-relacyjnych-baz-danych/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/03/06_wstep_do_relacyjnych_baz_danych.jpg"},{
        "title": "Projekt Informator wprowadzenie",
        "excerpt":"Projekt Informator Informator to kolejny większy projekt (po Pogodynce), który będę realizował na blogu. Moim celem jest zaimplementowanie gotowego webservice’u, który przy pomocy REST API będzie zwracał dane w formacie JSON. Projekt będę tworzył w oparciu o biblioteki Spring i Hibernate. Czym będzie Informator Informator to projekt, którego głównym celem będzie napisanie webservice’u. Webservice ten będzie miał za zadanie informować o szczegółach konferencji infoShare 2018. Informator za pośrednictwem protokołu HTTP będzie udostępniał dane o wydarzeniu w formacie JSON. Planuję, że będzie on zawierał trzy niezależne “endpoint’y”:   prelegenci,  wykłady/rozmowy/wydarzenia,  sceny.Samouczek Programisty jest jednym z partnerów konferencji infoShare 2018. infoShare 2018 to konferencja technologiczna odbywająca się 22-23 maja w Gdańsku. Na developerów czekają m.in. prelekcje z obszaru cybersecurity i machine learning, live coding oraz spotkania ze specjalistami, takimi jak: Filip Wolski, Trent McConaghy, Piotr Konieczny, Zbigniew Wojna czy Scott Helme. infoShare to także okazja do networkingu i udziału w imprezach towarzyszących. Sprawdź agendę i zarejestruj się na www.infoshare.pl.  Prelegenci Endpoint ten będzie zwracał szczegóły dotyczące prelegentów. Dzięki niemu będzie można dowiedzieć się czegoś więcej o prowadzących. Wykłady, rozmowy, wydarzenia Endpoint ten będzie zwracał informacje na temat wydarzeń, które będą miały miejsce w trakcie konferencji. Poza opisem zwracał będzie także informacje takie jak miejsce i czas wydarzenia. Dodatkowo będzie udostępniał informacje o prelegentach/uczestnikach danego wydarzenia. Sceny Dzięki temu endpoint’owi będzie można poznać grafik obowiązujący na każdej ze scen. Architektura i wdrożenie projektu Ze strony architektonicznej nie jest to skomplikowany projekt. Wręcz przeciwnie, to aplikacja webowa, która wyłącznie serwuje dane zapisane w bazie danych. Celowo nie planuję udostępnienia funkcjonalności modyfikowania czy usuwania danych. Baza danych zasilona będzie statycznymi danymi. Dzięki takiemu podejściu nie muszę implementować mechanizmu uwierzytelniania i autoryzacji. Także walidacja danych wejściowych będzie ograniczona. Aplikację chcę uruchomić w chmurze. Nie zdecydowałem się jeszcze na konkretnego dostawcę. Na tym etapie nie chcę podejmować decyzji, którego dostawcę wybrać ;). Możliwe, że będzie to Heroku lub Google Cloud. Prowadzenie projektu Podobnie jak w przypadku Pogodynki założyłem specjalną listę zadań na Trello. Lista ta będzie ewoluowała w czasie, aktualnie zawiera podstawowe zadania niezbędne do realizacji. Dzięki tej liście i repozytorium kodu na bieżąco będziesz mógł śledzić postęp prac nad projektem. Zależy mi na uruchomieniu tego projektu do końca kwietnia. Mam nadzieję, że uda mi się dotrzymać terminu, który sobie narzuciłem. Trzymaj kciuki ;). Testy Oczywiście projekt zawierał będzie testy jednostkowe, które będą skupiały się na poszczególnych komponentach. Dodatkowo planuję napisać testy integracyjne, które będą sprawdzały poprawność działania mapowania obiektowo-relacyjnego. Założeniem tych testów będzie tworzenie nowej instancji bazy danych w pamięci przed uruchomieniem każdego testu. Planuję także stworzenie zestawu testów integracyjnych. Utworzę je używając SoapUI. Dzięki takiemu podejściu będę miał kompletny zestaw testów automatycznych potwierdzających poprawność działania aplikacji. Podsumowanie Projekt Informator jest w powijakach, dopiero zacząłem nad nim pracę. Mam nadzieję, że tym krótkim artykułem zachęciłem Cię do śledzenia rozwoju projektu. Narzędzia i biblioteki, których użyję w trakcie pracy nad Informatorem są bardzo często wykorzystywane w projektach produkcyjnych. Mam nadzieję, że artykuł przypadł Ci do gustu. Jeśli nie chcesz pominąć kolejnych artykułów na blogu dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu! ","categories": ["Projekty","Projekt Informator"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/projekt-informator-wprowadzenie/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/03/20_projekt_informator_wprowadzenie.jpg"},{
        "title": "Projekt Informator wdrożenie w chmurze",
        "excerpt":"Projekt Informator Projekt informator to REST’owy web service, działający w oparciu o Spring i Hibernate. Jeśli chcesz przeczytać więcej o projekcie i jego założeniach zapraszam do wprowadzenia. Samouczek Programisty jest jednym z partnerów konferencji infoShare 2018. infoShare 2018 to konferencja technologiczna odbywająca się 22-23 maja w Gdańsku. Na developerów czekają m.in. prelekcje z obszaru cybersecurity i machine learning, live coding oraz spotkania ze specjalistami, takimi jak: Filip Wolski, Trent McConaghy, Piotr Konieczny, Zbigniew Wojna czy Scott Helme. infoShare to także okazja do networkingu i udziału w imprezach towarzyszących. Sprawdź agendę i zarejestruj się na www.infoshare.pl.  Czym jest chmura W uproszczeniu można powiedzieć, że chmura to środowisko, w którym uruchamia się aplikacje. Chmura to zestaw dużej liczby maszyn, które można “wynająć” na potrzeby swoich aplikacji. W takim środowisku dostawca zapewnia mechanizmy administrowania maszynami i aplikacjami, które są na nich wdrażane (ang. deployed). We wszystkich znanych mi chmurach dostawca pobiera opłaty za wykorzystywane zasoby. To znaczy, że jeśli nasza aplikacja potrzebuje większej liczby maszyn/mocniejszych maszyn, wówczas dostaniemy większy rachunek do zapłacenia. Dostawcy “rozwiązań chmurowych” oferują różne usługi. W przypadku Informatora używał będę wyłącznie podstawowych maszyn. Dodatkowo aplikacja korzystała będzie z bazy danych udostępnionej w chmurze. Dostawca rozwiązań chmurowych W przypadku Informatora, zależało mi wyłącznie na cenie. Chciałem, żeby do moich zastosowań chmura była darmowa :). Jednym z dostawców, który udostępnia maszyny za darmo1 jest Heroku. Oczywiście istnieją też inni dostawcy. Najwięksi z nich to:   Google Cloud Platform,  Amazon Web Services2,  Microsoft Azure Cloud Computing Platform.Informator - stan projektu Aplikacja używa najnowszych wersji biblioteki Spring MVC i Hibernate. W trakcie pisania tego artykułu najnowszymi wersjami były:   Spring 5.0.4  Hibernate 5.2.16Aktualnie aplikacja to wyłącznie szkielet, który pozwala na pobranie encji z bazy danych i wyświetlenie jej w formacie JSON w odpowiedzi. Zachęcam do sprawdzenia źródeł projektu, pozwolą one zobaczyć przykładową konfigurację bez użycia Spring Boot. Obecnie aplikacja zawiera jeden endpoint /speakers, który pozwala na pobranie informacji o prelegencie na podstawie identyfikatora. Aby aplikacja mogła pobrać dane z bazy muszą one być do niej wrzucone ręcznie. Na potrzeby testów utworzyłem kilka wierszy w tabeli uzupełniając je przykładowymi danymi:         Przykładowe zapytanie do Informatora  Heroku Nigdy wcześniej nie wdrażałem aplikacji w Javie na Heroku i muszę powiedzieć, że dostawca ten przygotował bardzo dobrą dokumentację. Poniżej postaram się pokazać jak wygląda proces instalacji aplikacji krok po kroku. Jak wspomniałem wcześniej, Informator to projekt “hobbystyczny”. W związku z tym, używam wyłącznie darmowe usługi Heroku. Na pewno nie sprawdziłyby się one w przypadku produkcyjnych aplikacji. Wdrożenie aplikacji na Heroku Cały proces należy zacząć od utworzenia konta na Heroku. Następnie można dodawać nowe aplikacje:         Dodawanie nowej aplikacji w Heroku          Nazwanie nowej aplikacji  Następnie w zakładce Resources należy dodać komponent bazy danych. W przypadku Informatora jest to PostgreSQL.         Aktywacja PostgreSQL na Heroku  Zdecydowałem się na instalowanie aplikacji prosto z GitHub’a. Heroku domyślnie pozwala na taką integrację. Wymaga to zezwolenia na GitHub’ie do pobierania informacji o repozytoriach przez Heroku:         Połączenie Heroku z GitHub’em  Sam proces instalacji aplikacji sprowadza się do naciśnięcia przycisku Deploy Branch. Wówczas Heroku pobiera aktualną wersję kodu i próbuje go uruchomić. Aby projekt mógł być uruchomiony na Heroku musi być odpowiednio przygotowany. O tym przygotowaniu przeczytasz w jednym z punktów poniżej:         Instalacja z gałęzi Git’a  Przygotowanie aplikacji do Heroku Gradle Do budowania Informatora używam Gradle. W przypadku tego projektu użyłem także webapp-runner. Dzięki tej bibliotece można uruchomić aplikację przy pomocy komendy java -jar webapp-runner.jar Informator.war. Właśnie ta komenda uruchamiana jest przez Heroku. Heroku w trakcie instalowania aplikacji3 wywołuje zadanie stage. Definicja tego zadania w build.gradle wygląda następująco: task stage() {    dependsOn clean, war}war.mustRunAfter cleantask copyToLib(type: Copy) {    into \"$buildDir/server\"    from(configurations.compile) {        include \"webapp-runner*\"    }}stage.dependsOn(copyToLib)tasks.stage.doLast() {    delete fileTree(dir: \"build/distributions\")    delete fileTree(dir: \"build/assetCompile\")    delete fileTree(dir: \"build/distributions\")    delete fileTree(dir: \"build/libs\", exclude: \"*.war\")}Konfiguracja ta zapewnia, że plik webapp-runner.jar będzie znajdował się w katalogu build/server. Dodatkowo każde uruchomienie stage zapewni zbudowanie pliku war na nowo. Aby biblioteka webapp-runner była dostępna trzeba dodać ją do zależności: dependencies {    compile 'com.github.jsimone:webapp-runner:8.5.29.0'}Plik Procfile Procfile to plik konfiguracyjny wymagany przez Heroku. Wewnątrz tego pliku znajdują się komendy, które określają jak mają zachować się maszyny w trakcie instalowania aplikacji. Heroku działa w oparciu o tak zwane kontenery nazywane “dynosami”. Plik Procfile pokazuje komendy jakie mają być uruchomione na poszczególnych kontenerach. Dla przykładu, kontener odpowiedzialny za serwer HTTP uruchamia następujące polecenie: cd build ; java -jar server/webapp-runner-*.jar --expand-war --port $PORT libs/*.warPolecenie to wywoływane jest po uruchomieniu zadania stage, które opisałem wcześniej. Dzięki tej kolejności na “dynosie” zbudowana jest aplikacja, którą można uruchomić przy użyciu wspomnianego wyżej webapp-runner’a. Połączenie z bazą danych Heroku dynamiczne tworzy bazy danych. Informacja gdzie dokładnie ta baza danych się znajduje przechowywana jest w zmiennej środowiskowej. Zmienna środowiskowa, która zawiera URL do bazy danych nazywa się JDBC_DATABASE_URL4. Zmienna ta powinna być użyta do utworzenia instancji DataSource: @BeanDataSource dataSource() {    DriverManagerDataSource dataSource = new DriverManagerDataSource();    dataSource.setDriverClassName(\"org.postgresql.Driver\");    dataSource.setUrl(System.getenv(\"JDBC_DATABASE_URL\"));    return dataSource;}Podsumowanie Aktualnie aplikacja to szkielet, na którym będę dobudowywał kolejne funkcjonalności. Główny etap konfiguracji jest już ukończony. Po przeczytaniu tego artykułu i przejrzeniu kodu źródłowego wiesz w jaki sposób zainstalować aplikację opartą o Spring MVC i Hibernate na Heroku. Jeśli nie robiłeś tego nigdy wcześniej zachęcam do samodzielnych prób, wtedy nauczysz się najwięcej. Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Proszę podziel się linkiem do artykułu ze znajomymi, którym może on pomóc. Może to dzięki Tobie uda mi się dotrzeć do nowych czytelników? ;) Do następnego razu!             Oczywiście są tu ograniczenia, firma też musi na czymś zarabiać ;). &#8617;               Tak właściwie to Heroku używa AWS do oferowania swoich usług. &#8617;               Dokładny sposób uruchamiania zależy m.in. od narzędzia użytego do budowania projektu. &#8617;               W zależności od sposobu łączenia się z bazą danych można użyć jednej z kilku zmiennych, na przykład DATABASE_URL czy SPRING_DATASOURCE_URL. &#8617;       ","categories": ["Projekty","Projekt Informator"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/projekt-informator-wdrozenie-w-chmurze/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/04/03_projekt_informator_wdrozenie_w_chmurze.jpg"},{
        "title": "Testy jednostkowe z JUnit 5",
        "excerpt":"  Jest to kolejny artykuł poświęcony tematyce testów, który napisałem na Samouczku. Zachęcam Cię także do przeczytania poprzednich artykułów:   Testy jednostkowe z JUnit 4 - artykuł wprowadza w świat testów. Przeczytasz w nim między innymi o tym czym są asercje czy po co piszemy testy. Jeśli nie pisałeś wcześniej testów to tutaj powinieneś zacząć,  Test driven development na przykładzie - artykuł o podejściu do pisania testów nazywanym test driven development. Opisuję w nim cały cykl RED, GREEN, REFACTOR popierając go przykładami.W tym artykule będę zakładał, że wiesz czym są testy. W treści artykułu czasami będę porównywał wersję JUnit 5 z poprzednią, jednak znajomość JUnit 4 nie jest niezbędna. Testy jednostkowe z JUnit 5 Powody powstania JUnit 5 JUnit 4 to monolit. Jeden plik JAR (ang. Java Archive), który zawiera całą bibliotekę. Ten plik zawiera między innymi:   klasy odpowiedzialne za wyszukiwanie testów,  klasy odpowiedzialna za uruchamianie testów,  klasy zawierające API do pisania testów (np. @Test czy implementacje asercji).Jak widzisz łamie to jedną z podstawowych reguł dobrego podejścia do tworzenia kodu obiektowego: rób jedną rzecz i rób ją dobrze1. Poza tym IDE do uruchamiania testów i wyświetlania wyników używały prywatnej implementacji. Między innymi z tych powodów ewolucyjne rozwijanie biblioteki JUnit nie było możliwe. Nawet zmiana niektórych atrybutów powodowała, że IDE błędnie wyświetlało wyniki testów. Z tego powodu powstała inicjatywa rozwijania kolejnej wersji tej biblioteki. JUnit 5 jako platforma JUnit 5 to trzy niezależne komponenty2:   platforma do uruchamiania testów: JUnit Platform,  API używane do pisania testów: JUnit Jupiter,  API używane do uruchamia testów napisanych w starszych wersjach JUnit na platformie JUnit 5: JUnit Vintage.W swojej codziennej pracy używa się JUnit Jupiter, czyli samego API, które pozwala na tworzenie testów. To właśnie JUnit Jupiter zawiera adnotacje, który są niezbędne w trakcie pisania testów. W trakcie uruchamiania testów pośrednio używa się też JUnit Platform, na przykład uruchamiając testy w IDE. Pierwszy test jednostkowy z JUnit 5 Projekt będę budował przy użyciu Gradle. Przykładowy test będzie służył do sprawdzenia, programu odpowiedzialnego za konwersję jednostek wagi. Każda z jednostek implementowała będzie interfejs znacznikowy WeightUnit: public interface WeightUnit {    int SCALE = 4;    RoundingMode ROUNDING_MODE = RoundingMode.CEILING;}Klasa Pound reprezentuje funty: public class Pound implements WeightUnit {    public static final BigDecimal POUND_TO_KILOGRAM_RATIO = new BigDecimal(\"0.453592\").setScale(SCALE, ROUNDING_MODE);    public final BigDecimal value;    public Pound(BigDecimal value) {        if (BigDecimal.ZERO.compareTo(value) &gt; 0) {            throw new IllegalArgumentException(\"Weight can't be negative!\");        }        this.value = value.setScale(SCALE, ROUNDING_MODE);    }    public Kilogram toKilograms() {        return new Kilogram(value.multiply(POUND_TO_KILOGRAM_RATIO).setScale(SCALE, ROUNDING_MODE));    }}Jej odpowiednik dla kilogramów to klasa Kilogram: public class Kilogram implements WeightUnit {    public final BigDecimal value;    public Kilogram(BigDecimal value) {        if (BigDecimal.ZERO.compareTo(value) &gt; 0) {            throw new IllegalArgumentException(\"Weight can't be negative!\");        }        this.value = value.setScale(SCALE, ROUNDING_MODE);    }    public Pound toPounds() {        return new Pound(value.divide(Pound.POUND_TO_KILOGRAM_RATIO, SCALE, ROUNDING_MODE));    }}Przykładowy zestaw testów może wyglądać następująco: import org.junit.jupiter.api.Test;import java.math.BigDecimal;import static org.junit.jupiter.api.Assertions.assertEquals;class UnitConverterTest {    @Test    void shouldConvertZeroKilogramValue() {        Pound pounds = new Kilogram(BigDecimal.ZERO).toPounds();        assertEquals(BigDecimal.ZERO.setScale(4), pounds.value);    }    @Test    void shouldConvertZeroPoundValue() {        Kilogram kilograms = new Pound(BigDecimal.ZERO).toKilograms();        assertEquals(BigDecimal.ZERO.setScale(4), kilograms.value);    }    @Test    void shouldConvert1Pound() {        assertEquals(new BigDecimal(\"0.4536\"), new Pound(BigDecimal.ONE).toKilograms().value);    }    @Test    void shouldConvert1Kilogram() {        assertEquals(new BigDecimal(\"2.2046\"), new Kilogram(BigDecimal.ONE).toPounds().value);    }}Zwróć uwagę na to, że zarówno klasa UnitConverterTest jak i wszystkie metody nie są publiczne. JUnit 5, w odróżnieniu od swojego poprzednika, nie wymaga aby klasa/metody z testami były dostępne publicznie. Kolejną różnicą jest pakiet, w którym znajdują się klasy użyte do tworzenia testów: org.junit.jupiter.api. Jest to bazowy pakiet zawierający wszystkie elementy niezbędne do pisania testów. Metody oznaczone adnotacją @Test to testy. Metody te nie mogą zwracać żadnej wartości, nie mogą być prywatne ani statyczne. Wewnątrz testów używa się asercji. Asercje dostarczone przez JUnit zgrupowane są wewnątrz klasy Assertions. W przykładach powyżej użyłem asercji assertEquals.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Możliwości JUnit 5 Cykl życia testów Podobnie jak w poprzedniej wersji JUnit 5 określa cykl życia testów. Dzięki temu możesz odpowiednio przygotować warunki do uruchomienia testów. JUnit tworzy nową instancję klasy przed każdym uruchomieniem testu. Jeśli chcesz zmienić to zachowanie możesz użyć adnotacji @TestInstance, dzięki tej adnotacji możesz wymusić współdzielenie instancji klasy pomiędzy testami. Moim zdaniem, w większości przypadków nie powinieneś jednak tego robić. Dobrą praktyką jest pisanie testów, które są od siebie niezależne. Do zarządzania cyklem życia służą następujące adnotacje:   @BeforeEach,  @AfterEach,  @BeforeAll,  @AfterAll.Zmiana nazwy testu JUnit 5 pozwala na manipulowanie nazwą testu. Dzięki temu możesz opisać test używając znaków, które nie są dopuszczalne w nazwie metody. Służy do tego adnotacja @DisplayName: @Test@DisplayName(\"0.1 pounds to kilograms ♥ ♦ ♣ ♠\")void shouldConvertFractions() {    assertEquals(new BigDecimal(\"0.0454\"), new Pound(new BigDecimal(\"0.1\")).toKilograms().value);}Testowanie wyjątków W odróżnieniu od JUnit 4, JUnit 5 nie pozwala na określenie oczekiwanego wyjątku w elemencie adnotacji @Test. W nowym podejściu użyte są wyrażenia lambda. Kod, który ma rzucić wyjątek powinien implementować interfejs funkcyjny Executable. W najprostszym przypadku jest to wyrażenie lambda. Metoda assertThrows przyjmuje:   klasę wyjątku, który powinien być rzucony  implementację interfejsu, która powinna ten wyjątek rzucić:@Testvoid shouldntAcceptNegativeWeightInPounds() {    IllegalArgumentException exception = assertThrows(        IllegalArgumentException.class,        () -&gt; new Pound(new BigDecimal(-1))    );    assertEquals(\"Weight can't be negative!\", exception.getMessage());}assertThrows zwraca instancję wyjątku, który został rzucony. Ograniczanie czasu działania testów JUnit 5 pozwala na testowanie czy wykonanie fragmentu kodu będzie trwało krócej niż założony z góry okres. Służą do tego asercje:   assertTimeout,  assertTimeoutPreemptively.Obie asercje przyjmują argumenty:   instancję klasy Duration określającą maksymalny czas działania,  implementację interfejsu funkcyjnego Executable, to ten sam interfejs, który jest użyty w przypadku assertThrows.@Testvoid shouldTransalteUnitsBlazinglyFast() {    assertTimeout(Duration.ofMillis(10), () -&gt; new Kilogram(BigDecimal.TEN).toPounds());}assertTimeout uruchamia przekazany fragment kodu w tym samym wątku i czeka na jego zakończenie. Po zakończeniu sprawdza czy założony czas został przekroczony. assertTimeoutPreemptively uruchamia przekazany fragment kodu w innym wątku i kończy go natychmiast po przekroczeniu założonego czasu. Zagnieżdżanie testów JUnit 5 pozwala na wykorzystywanie klas wewnętrznych. Wraz z adnotacjami do zarządzania cyklem życia pozwala to na lepszą organizację testów. Służy do tego adnotacja @Nested. Przykład poniżej pokazuje klasę ExceptionHandling, która zawiera jeden test. Klasa ta jest zagnieżdżona wewnątrz UnitConverterTest: class UnitConverterTest {    @Test    void shouldConvertZeroKilogramValue() {        Pound pounds = new Kilogram(BigDecimal.ZERO).toPounds();        assertEquals(BigDecimal.ZERO.setScale(44), pounds.value);    }    @Nested    class ExceptionHandling {        @Test        void shouldntAcceptNegativeWeightInPounds() {            IllegalArgumentException exception = assertThrows(IllegalArgumentException.class, () -&gt; new Pound(new BigDecimal(-1)));            assertEquals(\"Weight can't be negative!\", exception.getMessage());        }    }}Łączenie kilku asercji Dobrą praktyką pisania testów jest używanie jednej asercji na każdy test. Takie podejście pozwala zobaczyć wszystkie asercje, które nie zostały spełnione. Prosty przykład poniżej pokazuje tę sytuację. Test jednostkowy, który zawiera te dwie linijki nigdy nie dojdzie do uruchomienia drugiej z nich: assertTrue(false);assertFalse(true);Przez to zachowanie nie zobaczysz od razu wszystkich błędnych asercji. JUnit 5 pozwala na obejście tego problemu dzięki użyciu asercji assertAll: @Testvoid shouldntAcceptNullValue() {    assertAll(        () -&gt; assertThrows(NullPointerException.class, () -&gt; new Kilogram(null)),        () -&gt; assertThrows(NullPointerException.class, () -&gt; new Pound(null))    );}assertAll przyjmuje listę3 implementacji interfejsu Executable. Podobnie jak poprzednio zazwyczaj są to wyrażenia lambda. W przykładzie powyżej niezależnie od wyniku pierwszej asercji druga także zostanie wywołana. Obie zostaną uwzględnione w wynikach działania testów. Powtarzanie testów Zdarzyło mi się pisać testy, które zawierały pętle. Pętle te służyły do powtórzenia dokładnie tego samego testu wielokrotnie. Pisałem takie testy w sytuacji gdy dochodziło do wyścigu i czasami dany test przechodził, czasami nie. JUnit 5 umożliwia pisanie tego typu testów bez użycia pętli. Służy do tego adnotacja @RepeatedTest: @RepeatedTest(3)void shouldAlwaysReturnTheSameValue() {    assertEquals(new BigDecimal(\"29.4840\").setScale(4), new Pound(new BigDecimal(65)).toKilograms().value);}W przykładzie powyżej test zostanie wywołany trzy razy. Ignorowanie testów JUnit 5 pozwala na ignorowanie testów. Najprostszym sposobem jest dodanie adnotacji @Disabled. Mechanizm rozszerzeń JUnit 5 w odróżnieniu od JUnit 4 nie posiada @Rule, @ClassRule czy @RunWith. JUnit5 łączy te funkcjonalności w jedną. Ta funkcjonalność nazywa się rozszerzeniami. Główną adnotacją, która zarządza rozszerzeniami jest @ExtendWith. Adnotacja jako element akceptuje klasę implementującą interfejs Extension. Mechanizm rozszerzeń jest głównie wykorzystywany wraz z innymi bibliotekami. Na przykład przez Spring do umożliwienia wstrzykiwania zależności czy przez Mockito do tworznia mocków. Przykładowe rozszerzenie Przykład poniżej pokazuje rozszerzenie, które wyświetla na konsoli napis Samouczek extension :). Rozszerzenie to zostało zaaplikowane do jednego z testów: public class SamouczekExtension implements BeforeEachCallback {    @Override    public void beforeEach(ExtensionContext context) {        System.out.println(\"Samouczek extension :)\");    }}@Test@ExtendWith(SamouczekExtension.class)void shouldConvertZeroPoundValue() {    Kilogram kilograms = new Pound(BigDecimal.ZERO).toKilograms();    assertEquals(BigDecimal.ZERO.setScale(4), kilograms.value);}Tworzenie własnych adnotacji JUnit 5 pozwala na tworzenie własnych adnotacji poprzez łączenie tych dostarczonych przez bibliotekę. W przykładzie poniżej możesz zobaczyć rozszerzenie, które przytoczyłem wyżej. Tym razem rozszerzenie to jest aplikowane przez dodanie własnej adnotacji @SamouczekBefore do metody z testem: @Target({ ElementType.TYPE, ElementType.METHOD })@Retention(RetentionPolicy.RUNTIME)@ExtendWith(SamouczekExtension.class)public @interface SamouczekBefore {}@Test@SamouczekBeforevoid shouldConvert1Pound() {    assertEquals(new BigDecimal(\"0.4536\"), new Pound(BigDecimal.ONE).toKilograms().value);}Takie podejście pozwala na tworzenie bardziej czytelnych testów. Moim zdaniem jednak nie powinno się przesadzać z używaniem tej funkcjonalności. Może ona powodować trudności w zrozumieniu kodu przez programistów, którzy są nowi w danym projekcie. Uruchamianie testów JUnit 5 Jak wspomniałem wyżej różne narzędzia używały wewnętrznego API biblioteki JUnit to uruchamiania i wyświetlania wyników testów. W związku z tym zmiana wersji biblioteki JUnit wymaga także zmiany w różnych narzędziach. Aby używać JUnit 5 w IDE musi się ono poprawnie integrować z nową wersją biblioteki. Od jakiegoś już czasu główne IDE mają takie wsparcie:   IntelliJ Idea 2016.2  Eclipse OxygenJUnit 5 z Gradle Gradle od wersji 4.6 wspiera natywnie uruchamianie testów przy pomocy JUnit Platform. Dodanie kilku linijek do build.gradle pozwala na uruchamianie testów przy pomocy Gradle: dependencies {    testImplementation group: 'org.junit.jupiter', name: 'junit-jupiter-api', version: '5.1.0'    testRuntimeOnly group: 'org.junit.jupiter', name: 'junit-jupiter-engine', version: '5.1.0'}test {    useJUnitPlatform()}Materiały dodatkowe JUnit 5 ma bardzo dobrą dokumentację. Na YouTube znajdziesz też całkiem sporo prezentacji, które opisują nowe podejście. Poniżej zebrałem dla Ciebie materiały, które są dobrym uzupełnieniem dla treści artykułu:   Dokumentacja biblioteki JUnit,  Prezentacja z Devoxx prowadzona przez Lead Developer’a biblioteki JUnit,  JUnit 5 z innej perspektywy, integracja ze Spring 5,  Kampania na Indiegogo sponsorująca rozwój JUnit 5,  Kod źródłowy przykładów użytych w artykule.Zadania do wykonania       Napisz program, który będzie pomagał w prowadzeniu kantoru. Kantor powinien obsługiwać wymianę trzech par walutowych:           PLN - EUR,      PLN - USD,      EUR - USD.        Właściciel kantoru z góry określa przelicznik referencyjny i spread dla każdej pary walutowej. W bardziej rozwiniętej wersji kantor powinien pobierać przelicznik referencyjny używając API. Możesz na przykład użyć tego.     Napisz ten program używając podejścia TDD.         Zrefaktoryzuj kod źródłowy przykładów użytych w artykule tak aby Weight było klasą, której konstruktor akceptuje dwa parametry:           WeightUnit unit - typ wyliczeniowy określający rodzaj jednostki. Powinien mieć wartości POUND i KILOGRAM,      BigDecimal value - wartość wagi w danej jednostce.        Dodatkowo klasa ta powinna zawierać metody:           Weight convert(WeightUnit convertTo) - zwraca instancję Weight reprezentującą wagę w nowej jednostce,      BigDecimal getValue() - zwaraca wagę,      WeightUnit getUnit() - zwaraca jednostkę, w której wyrażona jest waga.        Użyj istniejących testów i metodyki TDD do przeprowadzenia refaktoringu kodu.   Zachęcam Cię do samodzielnego rozwiązania zadań, wtedy nauczysz się najwięcej. Podziel się linkiem do swojego rozwiązania w komentarzu :). Podsumowanie Po lekturze tego artykułu wiesz czym jest JUnit 5. Znasz komponenty składające się na tę bibliotekę. Rozwiązałeś zadanie, które pozwoliło Ci użyć JUnit 5 w praktyce. Od dzisiaj możesz zacząć pisać testy używając wyłącznie JUnit 5 ;). W artykule tym celowo pominąłem część funkcjonalności udostępnionych przez JUnit 5. Zachęcam Cię do zajrzenia do materiałów dodatkowych, szczególnie dokumentacji. Jeśli masz jakiekolwiek pytania, proszę zadaj je w komentarzu. Jeśli nie chcesz ominąć kolejnych artykułów na blogu dopisz się do samouczkowego newslettera i polub Samouczka na Facebook’u. Do następnego razu!             W oryginale SRP (ang. Single Responsibility Principle) to pierwsza literka z akronimu SOLID. &#8617;               Komponenty te są także podzielone na mniejsze elementy dystrybuowane w osobnych plikach JAR. &#8617;               Metoda assertAll jest przeciążona i akceptuje różne rodzaje parametrów, zaczynając od “varargs” a na strumieniach kończąc. &#8617;       ","categories": ["Programista rzemieślnik"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/testy-jednostkowe-z-junit5/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/04/13_testy_jednostkowe_z_junit5.jpg"},{
        "title": "Książki dla programistów",
        "excerpt":"Dlaczego warto czytać książki W trakcie prowadzenia bloga zauważyłem, że dobre przedstawienie materiału jest kluczowe. Można mieć ogromną wiedzę i jednocześnie nie móc jej sensownie przekazać. Moim zdaniem książki to dobre źródło zorganizowanej wiedzy. Autor książki musi włożyć sporo wysiłku w przygotowanie materiału w taki sposób, aby był przejrzysty i dobrze zorganizowany. Książki są przydatne, jednak nie powinieneś na nich poprzestawać. Blogi, dokumentacja techniczna, grupy dyskusyjne, praktyczne eksperymentowanie itp. to wszystko powinno pomóc Ci być na bieżąco. Sam pracuję zawodowo jako programista od 2007 roku, cały czas uczę się nowych rzeczy, książki są tu bardzo pomocne. Po polsku czy po angielsku Książki techniczne mają to do siebie, że w oryginale pisane są po angielsku (w ogromnej większości). Angielski to język, którego używa się na co dzień w pracy w branży IT. Często książki, które są tłumaczone na język polski są nieaktualne1. W Polsce wychodzi pierwsza edycja po polsku, a po angielsku jest już jej nowsza wersja. Moim zdaniem, właśnie z tego powodu, książki techniczne warto czytać po angielsku. Dodatkowo w trakcie lektury można podszlifować trochę znajomość tego języka i poznać słownictwo techniczne. Zestaw książek Książki, które tutaj prezentuję to subiektywny wybór tych, które najbardziej zapadły mi w pamięć. Część z nich to “klasyki”, które ugruntowały swoją pozycję. Nie jest to lista kompletna i zawiera tytuły, na które natknąłem się pracując jako programista Java. Część z linków do książek to tak zwane linki afiliacyjne. Oznacza to tyle, że jeśli kupisz książkę używając tych odnośników cena książki dla Ciebie się nie zmienia, a ja mogę dostać prowizję za przyprowadzenie nowego klienta do sklepu (jeśli nie miałeś wcześniej konta w sklepie). Prowadzenie projektu The Mythical Man-Month - Frederick P. Brooks         The Mythical Man-Month - Frederick P. Brooks  Zgadnij, ile ta książka ma lat? Przedmowa do pierwszego wydania była napisana w 1974 roku. Bez mała pół wieku. Tak, to książka o IT, gdzie biblioteki i narzędzia zmieniają się częściej niż pory roku. A ta książka cały czas ma rację bytu. To w niej przeczytałem o tym, że dokładanie ludzi do już spóźnionego projektu opóźni go jeszcze bardziej. Przykłady odnoszące się do technologii mogą być przeterminowane, jednak książkę nadal warto przeczytać. Death March - Edward Yourdon         Death March - Edward Yourdon  Do tej książki mam sentyment :). Opisuje projekt, w którym pracowałem. Tytułowy marsz śmierci, wszyscy wiedzą o nierealnych terminach, wymaganiach itp. a i tak brną dalej.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Architektura i wzorce projektowe Design Patterns - Gamma, Helm, Johnson, Vlissides         Design Patterns - Gamma, Helm, Johnson, Vlissides  Możliwe, że słyszałeś o GoF albo Gang of Four. Tak właśnie mówi się o autorach tej książki. Klasyk. Ta książka to encyklopedia wzorców projektowych. Każdy wzorzec ma przykładową implementację, diagramy, powody powstania, inne powiązane wzorce, konsekwencje jego użycia itd. Patterns Of Enterprise Application Architecture - Martin Fowler         Patterns Of Enterprise Application Architecture - Martin Fowler  Ciężka książka. Dosłownie i w przenośni. Delikatnie mniej encyklopedyczne podejście do wzorców projektowych. Mogę się doczepić do słowa Enterprise, które swego czasu było czymś modnym (jak dzisiaj Blockchain, Data Science czy niedawno Big Data). W tej książce przeczytasz o wzorcach, których używasz na co dzień w wielu popularnych bibliotekach (Spring czy Hibernate to standardowy przykład). Dobre praktyki Clean Code - Robert C. Martin         Clean Code - Robert C. Martin  Książka, która pozwala spojrzeć inaczej na swój kod. Niezależnie od tego jak długo programujesz na pewno znajdziesz w niej opis błędów, które popełniasz. Ja znalazłem sporo swoich. Jeśli Design Patterns to encyklopedia wzorców projektowych, to tę książkę nazwałbym encyklopedią dobrych praktyk przy pracy z kodem źródłowym. Chociaż przykłady pokazane są w języku Java mam wrażenie, że programiści innych języków też mogą z tej książki bardzo dużo wynieść. Jeśli miałbym Ci wskazać wyłącznie jedną książkę spośród wszystkich, które tu wymieniłem to wybór padłby właśnie na Clean Code. Test-Driven Development By Example - Kent Beck         Test-Driven Development By Example - Kent Beck  Ta książka otworzyła mi oczy ;). Przerabiając przykłady z tej książki nauczyłem się TDD. Jeśli do tej pory nie miałeś styczności z Test Driven Development mogę śmiało polecić tę książkę. Refactoring - Martin Fowler         Refactoring - Martin Fowler  Kolejne encyklopedyczne zestawienie. Książka zawiera zbiór możliwych refaktoryzacji. Dodatkowo zobaczysz refaktoryzację przykładowej aplikacji, gdzie autor sukcesywnie poprawia jakość kodu. Po przeczytaniu tej książki praca ze starym kodem nie jest już taka straszna, teraz mam wielką frajdę z polepszania jakości kodu :). Autor na swoim blogu zapowiedział drugą edycję tej książki. Przykłady w drugiej mają być napisane w JavaScript. Autor planuje poświęcić więcej uwagi refaktoryzacji funkcji2. Różne Masterminds of Programming - Federico Biancuzzi         Masterminds of Programming - Federico Biancuzzi  Chciałem zajrzeć do głowy programistów, którym nie dorastam do pięt. Ta książka to zestaw wywiadów z twórcami różnych języków programowania. Przydaje się jako odskocznia od ściśle technicznych tytułów. The Productive Programmer - Neal Ford         The Productive Programmer - Neal Ford  Moim zdaniem ta książka przyda się głównie początkującym programistom. Jeśli nie słyszałeś wcześniej o DRY, czy YAGNI to ta książka może Ci pomóc. Książka opisuje kilka dobrych praktyk, pomagających w organizacji pracy programisty. Jeśli jednak masz już za sobą kilka lat programowania prawdopodobnie znasz większość wspomnianych tu wskazówek. Książki dotyczące Javy Poniższych książek nie mam już w swojej prywatnej biblioteczce. Głównie dlatego, że były mi przydatne na etapie uczenia się języka Java, teraz już nie są. Drugim powodem jest to, że się przeterminowały. Jak ja czytałem te książki Java 5 to była nowość ;). Niemniej jednak, opiszę Ci książki, które mi pomogły - może znajdziesz inne pozycje tych samych autorów.       Head First Servlets and JSP - Basham, Sierra, Bates - Książka jest przegadana, ma ponad 900 stron. Przepraszam, przerysowana ;). Jeśli szukasz “łopatologicznego” wytłumaczenia jak działają strony JSP czy serwlety to może to być dobre źródło. Jeśli nie lubisz rysunków w książce pomiń tę pozycję.         Java Puzzlers - Bloch, Gafter - Przypomina mi się moja pierwsza praca. Właśnie tam z kolegami z zespołu przerabialiśmy tę książkę. Książka to zestaw “pułapek”, które pokazują zachowanie Javy, które jest czasami bardzo dziwne. Niestety książka nie doczekała się nowego wydania więc polecam ją jedynie jako ciekawostkę.         Java od podstaw do technologii - Krzysztof Barteczko - Jest to jedyna książka po polsku, którą wspomniałem. To z tej książki nauczyłem się składni języka Java. Szczególnie pierwszy tom był przydatny.   Effective Java - Joshua Bloch Świetny podręcznik do poznania języka Java. Pamiętam, że czytałem między innymi tę książkę przygotowując się do certyfikatu z języka Java. Jest to wyjątek od trzech tytułów wspomnianych wyżej, ten doczekał się nowego wydania. Niestety nie miałem przyjemności czytać tego najnowszego, jednak tego autora można spokojnie polecić :). Co teraz czytam? Do niedawna byłem w trakcie czytania 3 książek jednocześnie. Bardzo mocno staram się oduczyć tego podejścia. Więc na dzisiaj na tapecie mam jedną książkę ;). The Go Programming Language - Donovan, Kernighan         The Go Programming Language - Donovan, Kernighan  Aktualnie w wolnych chwilach uczę się nowego języka, tym razem padło na Go. Chociaż nie przeczytałem całej książki muszę powiedzieć, że jest świetna. Nie jest ona jednak kierowana do początkujących programistów. Prezentowane przykłady i sposób wprowadzania materiału zakładają, że Go nie jest pierwszym językiem, którym czytelnik się posługuje. Podsumowanie W jednym zdaniu: książki warto czytać. Jeśli Twoim zdaniem pominąłem jakieś ważne pozycje proszę daj znać w komentarzach. Twoja rekomendacja na pewno przyda się nie tylko mi. Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu!             Oczywiście nie jest to prawda dla niektórych tytułów, które są “ponadczasowe” ;). &#8617;               W JavaScript funkcje są tak zwanymi obiektami first class, w Javie można porównać je do wyrażeń lambda. &#8617;       ","categories": ["Wiedza ogólna"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/ksiazki-dla-programistow/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/04/23_ksiazki_dla_programistow.jpg"},{
        "title": "Zmiana branży - zostań programistą",
        "excerpt":"Zmiana branży, czyli jak zostać programistą Oto kilka z najczęściej zadawanych mi pytań przez czytelnika Samouczka:   Czy mogę się przebranżowić?  Czy nie jestem na to za stary?  Czy po ukończeniu kursu X będę mógł zostać programistą?Niestety na pytania tego typu nie mam dobrych odpowiedzi. Głównie dlatego, że sam jestem informatykiem z wykształcenia. Więc moje odpowiedzi na te pytania to domysły1. Nie lubię takich odpowiedzi :). Dlatego właśnie poprosiłem o pomoc osoby, które się przekwalifikowały. Artykuł jest bardzo długi, jednak gorąco zachęcam do przeczytania całości. Chłopaki mają naprawdę ciekawe historie, którymi chcieli się anonimowo podzielić. Czasami znajdziesz też mój komentarz dotyczący punktu widzenia prezentowanego przez chłopaków. Będzie on umieszczony w ramce takiej jak ta. Osoby, którym się udało Tomek Tomek ma 32 lata, zanim został programistą był marynarzem z wykształcenia. Sfrustrowany dorywczymi pracami po odejściu z morza zdecydował się zostać programistą. Zaczął od C#, aktualnie pracuje z JavaScript. O tym jak marynarz został programistą   Czym zajmowałeś się wcześniej? W jakim zawodzie pracowałeś?Kim jesteś z wykształcenia? Z wykształcenia jestem marynarzem. Skończyłem nawigację w Szkole Morskiej w Gdyni, przez siedem lat pracowałem aktywnie w zawodzie. Najpierw jako marynarz pokładowy, później jako oficer. Oprócz tego pracowałem też w handlu, na infolinii i nawet jako picker w magazynie w Wielkiej Brytanii.   Miałeś wcześniej styczność z programowaniem? Minimalną. W liceum napisałem kilka aplikacji w C++ uruchamianych w linii poleceń. Zrobiłem też jakiś podstawowy kurs online HTML i CSS, który sobie odświeżyłem rok przed rozpoczęciem przebranżawiania.   Ile czasu poświęciłeś na przekwalifikowanie się (ile godzin dziennie/tygodniowo się uczyłeś)? Przez pierwsze 5 miesięcy poświęcałem na naukę od 4 do 12 godzin dziennie. Przez następne dwa miesiące, około 20 godzin tygodniowo. 5 * 30 * 8h + 2 * 4 * 20h = 1200h + 160h = 1360h. W pierwszych siedmiu miesiącach swojej nauki poświęcił na nią około 1400 godzin. Przebranżowienie jest możliwe, ale wymaga dużo pracy.   Jak długo przygotowywałeś się przed wysłaniem pierwszego CV? W ogóle. Pełen żywioł. Zadanie rekrutacyjne robiłem trzy dni, poznając przy okazji cud natury jakim jest Stack Overflow oraz ból związany z szukaniem dangling comma przez dwie doby. Czytanie konsoli to była dla mnie magia, której wówczas nie znałem.     Tutaj Tomek miał na myśli prosty błąd, jeden przecinek za dużo. Takie błędy to zmora początkujących programistów. Chociaż bardziej zaawansowani też czasami na coś takiego trafią. Upór i wytrwałość to cechy, które moim zdaniem są bardzo pożądane u każdego programisty. Przykład Tomka właśnie to pokazuje. Szukanie przecinka przez dwa dni potrafi naprawdę wkurzyć. Znam to, byłem tam…   Kiedy zacząłeś pracować jako programista? Pierwszą pracę jako Junior Web Developer podjąłem siedem miesięcy po rozpoczęciu nauki.   Dlaczego zdecydowałeś się przekwalifikować? Po odejściu z morza podejmowałem się każdej pracy, w tym śmieciowej. Pracując na infolinii jednego z operatorów komórkowych stwierdziłem, że naprawdę jestem więcej wart niż te 1400 zł na rękę przy umowie-zlecenie.   Od czego zacząłeś naukę programowania? Robiłem to bardzo chaotycznie. Od podjęcia decyzji o zmianie branży do faktycznego podjęcia pierwszej pracy minęło siedem i pół miesiąca. Zaczynałem chcąc nauczyć się C#2 i ekosystemu .NET, który miał mi dać podstawy do nauki Javy. Wybrałem te języki, bo bardzo wzbraniałem się przed programowaniem aplikacji webowych, zupełnie nie znając realiów branży, chciałem pisać aplikacje desktop’owe3 i zupełnie nie miałem pojęcia co robię. Nie wiedziałem, że Java to back-end4. Wtedy nie wiedziałem nawet co to back-end! Myślałem, że rynek jest przesycony, a JavaScript to nie jest “prawdziwe” programowanie. Pech chciał, że mniej więcej po trzech miesiącach nauki znalazłem ogłoszenie na Junior Support Developera ze znajomością jQuery5. Jedno z zadań wymagało użycia jQuery. Pracy nie dostałem, ale spojrzałem na język. Później pojechałem na wspomniany kurs Javy, absolutne podstawy z linią poleceń. Tak naprawdę nic, czego nie przerobiłem już w C#. Tam też dowiedziałem się, jak rynek wygląda naprawdę i że web, czy to na front-end’zie, czy to na back-end’zie, jest najbardziej rozwojową gałęzią. Dowiedziałem się również, że Javą gardzę absolutnie i nie zamierzam ruszać jej długim kijem. Zostałem przy .NET ;). Tak szczerze to tego rodzaju “święte wojny” w IT zdarzają się bardzo często. Na początku mojej drogi miałem podobnie jak Tomek, z tym, że odwrotnie. Nie chciałem dotykać niczego co wypuścił Microsoft. Teraz już nie podchodzę do tego tak restrykcyjnie, ale stare przyzwyczajenia zostały. Następne dwa miesiące spędziłem na dużo mniej intensywnej nauce, około 20 godzin tygodniowo. Nie byłem pewien tego C#, brakowało mi kierunku i miałem wrażenie, że niczego się nie nauczyłem. Poza tym jednym zadaniem rekrutacyjnym w jQuery, nie ruszałem JavaScript’u w ogóle. Podstaw potrzebnych na przebrnięcie rozmowy kwalifikacyjnej nauczyłem się w pociągu relacji Toruń - Szczecin. Ta podróż trwa około sześciu godzin. To pokazuje, że po zdobyciu podstaw w jednym języku nauka kolejnych jest dużo łatwiejsza. Oczywiście Tomek po tych sześciu godzinach nie był biegłym w JavaScript, ale znał podstawy.   Z jakimi technologiami aktualnie pracujesz? Jestem Full-stack JavaScript Developerem. Pracuję z JavaScript w dialekcie ES2015+. Znam i nie znoszę TypeScript.  Technologie i biblioteki, które używam to:   front-end - React/Redux + Native, AngularJS, Angular (2+), Cordova, Electron,  back-end - Node.js + Express, Hapi, Sails. Ruszam GraphQL.Oprócz tego staram się pozostać na bieżąco z katalogiem NPM i miałem różnego rodzaju przygody z rxJS, D3 czy nawet Phaser.   Co sprawiało Ci największe problemy w trakcie przekwalifikowania się? Jak te problemy rozwiązałeś? Brak kierunku i mentora. Nie miałem nikogo, kto by mi powiedział co dalej. Również tak dość metafizycznie. Stack Overflow wszystkiego nie załatwi, a z doświadczenia wiem, że nic nie zastąpi gumowej kaczki, programowania w parach i sprawdzania kodu (ang. code review).   Jak i gdzie zdobywałeś materiały do nauki? Czy możesz polecić źródła z których korzystałeś? Dlaczego akurat te?   Google, Google i jeszcze raz Google. Trzeba jedynie nauczyć się poprawnego stawiania pytań,  Ucząc się C# korzystałem z legendarnego już (i moim zdaniem słabego) kursu Boba Tabora na Channel 9,  Codeschool nauczyło mnie AngularJS’a,  YouTube,  Pluralsight,  Microsoft daje darmowy, czasowy dostęp do kosmicznej ilości usług (od Azure po właśnie Pluralsight). Jedyny warunek, to mieć konto MS, które zresztą polecam. Głównie ze względu na darmowe Visual Studio For Team and Services. Dzięki temu dostajesz dostęp do prywatnego, nieograniczonego repozytorium Git.  Co ułatwiało Ci naukę? Miałeś jakieś sposoby na łatwiejsze zapamiętywanie? Godzina nauki, fajka, godzina nauki, pół godziny w HearthStone. Nie przyznam się ile godzin spędziłem na tej grze, albo na oglądaniu rozgrywek na YouTube… ;)   Jak poszły Ci pierwsze rozmowy? Co sprawiło Ci największy problem? Wyłganie jakiejkolwiek wiedzy. Nie oszukujmy się - nasza branża cierpi na krytyczny niedobór ludzi, więc samouków są masy. Możliwe, że większość. Praktycznie każdy z nas, prędzej czy później, będzie mieć syndrom oszusta. 90% CV Junior Developer’ów, które widziałem, to stek kłamstw. Sztuka tkwi w zamaskowaniu tego. Nauczysz się tego w trakcie. To muszę jasno powiedzieć. Uważam, że nie można kłamać w CV. Kłamstwo ma krótkie nogi i nie popłaca. Masz za mało w CV? Popracuj solidnie kolejny miesiąc, dwa i dodaj projekt, który w tym czasie zrealizujesz. Dalej mało? Popracuj kolejny miesiąc, ukończ darmowy kurs na Coursera/Udemy. Dalej mało? Wystąp na lokalnym spotkaniu dla programistów i opowiedz o czymś, czego się nauczyłeś itp.   Gdzie wysłałeś 5-10 pierwszych CV? Jak wybierałeś te firmy? Nie miałem wówczas konta na LinkedIn, więc wrzuciłem swoje CV na Monster Polska. Dziś “szukam” pracy tylko za pomocą LinkedIn. W profilu mam zaznaczoną otwartość na oferty, więc oferty płyną wartkim strumieniem. W swojej karierze wysłałem CV na JEDNO ogłoszenie - to z zadaniem rekrutacyjnym w jQuery. Wiele firm wykorzystuje LinkedIn jako bazę kandydatów. Bardzo często wyszukują potencjalnych pracowników na tym portalu. Otrzymywanie ofert zatrudnienia w ten sposób to norma w branży IT.   Jakie masz wskazówki, rady dla osób, które chcą się przekwalifikować? Nic odkrywczego. Cierpliwość i wytrwałość. Jeśli masz ten komfort, który miałem ja - potraktuj naukę jak pracę i podchodź do niej tak, jak do etatu: określony z góry czas CODZIENNIE. Opanuj też słowa-klucze, żebyś chociaż brzmiał, że wiesz o co chodzi. Bo przez pierwszy rok i tak nie będziesz wiedział, a cała praca - czy to nauka, czy to etat - będzie przypominać błądzenie pijanego dziecka z nożem we mgle.   Jakie masz plany dotyczące dalszej nauki/rozwoju?   Architektura JavaScript i pełne przekwalifikowanie na NodeJS Developera  uczenie innych,  powrót do C#/.NET,  może Python?  Jak oceniasz pracę jako programista? Nie wyobrażam sobie robić nic innego.   Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Szymon Szymon ma 28 lat. Z wykształcenia jest matematykiem, jednak postanowił spróbować swoich sił jako programista. Pracuje jako programista od trzech lat. Zrezygnował ze swojej pierwszej pracy jako programista na rzecz bardziej rozwojowego stażu. O tym jak matematyk został programistą   Czym zajmowałeś się wcześniej? W jakim zawodzie pracowałeś? Wcześniej pracowałem 11 miesięcy jako informatyk, totalny wyzysk. Zdecydowałem się przez to przebranżowić.   Kim jesteś z wykształcenia? Z wykształcenia jestem matematykiem. Studiowałem matematykę na Politechnice.   Miałeś wcześniej styczność z programowaniem? Pierwszą styczność z programowaniem miałem właśnie podczas studiów (Pascal, programowanie obiektowe w C#, podstawy relacyjnych baz danych, strony internetowe z HTML i CSS, algorytmy z Matlab’em, witryny internetowe z C# i .NET). Po trzecim roku studiów zdecydowałem się bardziej dokształcić w kierunku IT w Policealnej Szkole Weekendowej jako technik informatyk. Szkoła trwała dwa lata. Miałem tam między innymi bazy danych (PostgreSQL), HTML, CSS, JavaScript oraz troszeczkę PHP. Po studiach zacząłem pracę jako informatyk taki à la helpdesk. Pół roku później skończyłem zaoczną szkołę. Załapałem się na dwa kursy/szkolenia finansowane ze środków Unii Europejskiej. Jeden był 10 dniowym kursem po 8 godzin dziennie “Programowanie w języku Java”. Drugie szkolenie trwało bodajże 5 dni “Przygotowanie do certyfikatu OCPJP6”. Niestety go nie zdałem, nikt go w sumie z naszej grupie nie zdał.   Ile czasu poświęciłeś na przekwalifikowanie się (ile godzin dziennie/tygodniowo się uczyłeś)? Na naukę programowania starałem się poświecić minimum godzinne dziennie co nie zawsze mi wychodziło.   Jak długo przygotowywałeś się przed wysłaniem pierwszego CV? Do wysłania pierwszego CV nie przygotowałem się zbyt długo. Przez co myślę, że nie byłem na zbyt wysokim poziomie, co skutkowało negatywnymi decyzjami na rozmowach.   Kiedy zacząłeś pracować jako programista? Pracę jako programista zacząłem w 25 urodziny. Obecnie mam 28 lat.   Dlaczego zdecydowałeś się przekwalifikować? Zdecydowałem się przekwalifikować, gdyż wiedziałem, że programowanie jest bardziej dochodowe niż inne zawody w IT.   Od czego zacząłeś naukę programowania? Samodzielną naukę programowania zacząłem od przerabiania zagadnień ze szkoleń, w których wziąłem udział w ramach projektów z UE.   Z jakimi technologiami aktualnie pracujesz? Obecnie pracuję z Java 8, Java EE, HTML, CSS, JavaScript, TypeScript, Angular, EclipseLink, PostgreSQL, Oracle, tak w skrócie. Jako środowiska używam IntelliJ Idea.   Co sprawiało Ci największe problemy w trakcie przekwalifikowania się? Największą trudnością w nauce programowania było moje lenistwo oraz to, że jak najszybciej chciałem zmienić pracę. Przez kolejne odmowy podczas rozmów kwalifikacyjnych odechciewało mi się coraz bardziej.   Jak i gdzie zdobywałeś materiały do nauki? Czy możesz polecić źródła z których korzystałeś? Dlaczego akurat te? Materiały do nauki pozyskiwałem z YouTube. Jest tam pełno darmowych szkoleń. Niestety większość kursów, które znajdowałem, tworzyli/prowadzili Hindusi. Moim zdaniem ich angielski akcent pozostawia wiele do życzenia.   Co ułatwiało Ci naukę? Miałeś jakieś sposoby na łatwiejsze zapamiętywanie? Nie miałem sposobów na zapamiętywanie, ani niczego co by mi ułatwiało naukę.   Jak poszły Ci pierwsze rozmowy? Co sprawiło Ci największy problem? Chodziłem na rozmowy (spokojnie szacuję, że było ich około 20) i bez skutku. Zawsze czegoś mi brakowało pod względem technicznym. Wysłałem CV do mojej obecnej firmy, zaprosili mnie na rozmowę. Pierwszy etap to wstępna rozmowa przez telefon po niemiecku, którą przeszedłem pozytywnie. Powtarzam to wszystkim, którzy pytają się czy łatwo jest znaleźć pierwszą pracę. W moim przypadku wysłałem chyba z 40 CV, żeby zdobyć pierwszą pracę. Dzisiaj zrobiłbym to inaczej, ale wtedy masowo wysyłałem CV. W odróżnieniu od Szymona, mnie firmy nawet nie chciały zapraszać na rozmowy kwalifikacyjne. Jeśli dobrze pamiętam byłem wtedy na trzech. Drugi etap rozmowy trwał około dwóch godzin. Różne zadania na kartce, pytania o moje wcześniejsze doświadczenie. Na rozmowie okazało się tak samo jak na wcześniejszych rozmowach, że za mało umiem między innymi  z Javy, ale nie dyskredytowało mnie to. Firma bowiem oferuje staże dla świeżych absolwentów oraz studentów ostatnich lat studiów. Sporo firm początkujących programistów zatrudnia nie za posiadaną wiedzę, a za potencjał. Jeśli pracodawca zobaczy, że kandydat ma braki, ale ma też chęć do nauki, to może przymknąć oko na niektóre niedociągnięcia. Technologii można się nauczyć. Szczególnie jeśli w zespole będzie osoba, która chętnie dzieli się wiedzą. Po sześciu miesiącach opuściłem swoją pierwszą firmę, w której pracowałem jako programista na rzecz obiecująco zapowiadającego się stażu. Java, AngularJS to było coś. Po trzech miesiącach płatnego stażu przyjęli mnie na umowę o prace. Jednak przez pierwsze trzy miesiące w godzinach pracy odbywałem kurs niemieckiego, co było wymagane przez pracodawcę. Potem zaczął się pierwszy projekt, potem kolejny. Siedzę w obecnej firmę już ponad dwa lata.   Gdzie wysłałeś 5-10 pierwszych CV? Jak wybierałeś te firmy? Zacząłem wysyłać CV do różnych firm, które poszukiwały młodszego programisty Java. Niestety poza znajomością Javy wymagana była ode mnie np. znajomość baz danych. Między innymi tę umiejętność wspomniałem w artykule Od zera do developera. Duża liczba pracodawców szuka początkujących programistów, którzy znają coś więcej niż tylko składnię języka programowania. Odezwał się do mnie mój przyszły pracodawca. Mała firemka, wówczas trzyosobowa wliczając szefa. Na rozmowie kwalifikacyjnej nie weryfikował specjalnie mojej wiedzy technicznej. Przyjął mnie do pracy. Po 2 tygodniach opanowałem podstawy Hibernate (konfiguracja w XML). Po czasie widziałem, że nie nauczę się tutaj za dużo i szukałem dalej.   Jakie masz wskazówki, rady dla osób, które chcą się przekwalifikować? Młodszym kolegom mogę polecić wybór studiów informatycznych. Sam poszedłem na matematykę, ale jak miałbym możliwość ponownego wyboru to wybrałbym informatykę.  Kolegom, którzy chcą się przekwalifikować, systematyczną naukę, wytrwałość i cierpliwość. Mi niestety brakowało cierpliwości. Gdybym był bardziej cierpliwy z tym co robiłem, uniknąłbym rozczarowań związanych z nieudanymi rozmowami. Zauważyłeś tu wzorzec? Szymon podobnie jak Tomek polecają cierpliwość i systematyczną naukę. To naprawdę jest klucz. Ja zawsze powtarzam, że nic “samo się nie zrobi”. Do przekwalifikowania potrzebna jest Twoja ciężka i systematyczna praca.   Jakie masz plany dotyczące dalszej nauki/rozwoju? Na chwilę obecną pracuję jako Full-stack Developer. W przyszłości chciałbym powrócić do większego wykorzystania tego, czego się nauczyłem na studiach więc coś z Big Data: Scala i Apache Spark. Chyba, że do tego czasu trendy się zmienią. Może już się zmieniły?   Jak oceniasz pracę jako programista? Pracę jako programista oceniam bardzo pozytywnie. Nie ma co jej porównywać do poprzedniego stanowiska jakim było informatyk na helpdesku. Dużo przeróżnych i ciekawych zadań, nowe wyzwania i nieustanna nauka. Programista to zawód, w którym moim zdaniem musisz się ciągle rozwijać. Jeśli oczekujesz, że nauczysz się programować i masz spokój to jesteś w błędzie. Pracuję ponad dziesięć lat i bez przerwy widzę braki w swojej wiedzy, bez przerwy uczę się czegoś nowego. Marek Marek postanowił zostać programistą w wieku 24 lat będąc już po studiach na Politechnice Wrocławskiej na wydziale Mechaniki i Budowy Maszyn. O tym jak projektant-konstruktor został programistą Jako programista zacząłem pracować w styczniu 2017 roku. Wcześniej ukończyłem studia na Politechnice Wrocławskiej - Mechanikę i Budowę Maszyn. Zawód postanowiłem zmienić w wieku 24 lat. Czyli w sumie, ani specjalnie późno, ani specjalnie wcześnie. Warto powiedzieć, że na Mechanice i Budowie Maszyn styczności z programowaniem nie miałem praktycznie żadnej. Mogę nawet powiedzieć, że kiedy jako przedmiot dodatkowy miałem na pierwszym roku programowanie C++, to go nie zaliczyłem. Totalnie nie ogarniałem o co chodzi w programowaniu. Właściwie moje jedyne doświadczenie z programowaniem czegokolwiek to było tworzenie prostych programów do sterowników PLC w graficznym interfejsie. Czyli coś takiego jak Scratch, tylko że wersja bardziej “inżynierska”. Czyli zamiast funkcji do wykonania, zawory do zamknięcia. A zamiast zmiennych podanych przez użytkownika, jakieś czujniki, które pobierały dane. Oczywiście bez żadnego wnikania w sprzętowe szczegóły, po prostu kwadracik który podaje bieżące wyniki pomiarów. Na zmianę ścieżki zawodowej zdecydowałem się po prawie dwóch latach pracy w zawodzie. Najpierw pracowałem jako pracownik (stażysta) działu R&amp;D6. A potem jako projektant-konstruktor. Na podjęcie decyzji o zmianie zawodu miało wpływ kilka czynników. Między innymi to, że podczas poszukiwania nowej pracy (dalej jako mechanik) kilka razy odbiłem się od oferty pracy poprzez swoje wymagania finansowe, które nie były jakoś specjalnie wygórowane. Więc podjąłem decyzję, że spróbuję się przebranżowić. Na samym początku głównie ze względu na zarobki i perspektywy rozwoju,które dla inżynierów mechaników w naszym kraju niestety są dość mizerne i obarczone dużą odpowiedzialnością. Na sam początek chciałem zacząć dość klasycznie, czyli od C++.   Praca jako programista rzeczywiście jest dość dobrze płatna. Co więcej w miastach gdzie jest duża konkurencja pracownicy dostają szereg dodatkowych profitów. Na przykład firma Opera Software, w której pracuję oferuje swoim pracownikom:   dostęp do piłkarzyków, bilarda, konsol do gier, flippera, planszówek etc. w trakcie pracy,  fundusze na materiały do nauki (książki, konferencje),  budżet na integrację zespołu,  prywatną opiekę medyczną (także dla rodziny pracownika),  dopłatę do parkingu,  kartę Multisport,  dopłaty do innych aktywności sportowych,  kanapki w pracy,  masaże w trakcie pracy,  owoce w pracy,  soki/napoje energetyczne w pracy,  różne rodzaje darmowych kaw, herbat, ziół, płatków, mleko, wodę etc.Tutaj znowu pojawiła się dla mnie pewna bariera poznawcza. Warto powiedzieć, że na samym początku nie potrafiłem rozróżnić int od float, a samo wykonywanie czegokolwiek w IDE stanowiło dla mnie czarną magię, serio. Byłem totalnym programistycznym tłukiem. Umiałem obchodzić się z komputerem, ale cokolwiek związanego z programowaniem było dla mnie czarną magią. Wiedza wymagana do efektywnej pracy jako programista jest olbrzymia. Często początkujący nie wiedzą nawet od czego zacząć. W jednym z artykułów zebrałem listę wymaganych umiejętności aby rozpocząć pracę. Na całe szczęście na weselu mojego kolegi udało mi się trafić na kogoś, kto siedział w branży IT przez kilka lat. Tak od słowa do słowa polecił mi, żeby zamiast uczyć się C++ spróbować Javy. I dzięki Bogu za to! Nie dość, że Java ma dużo niższy próg wejścia (niż C czy C++), to jeszcze na chwilę obecną jest dużo więcej ofert pracy z nią związanych. A tym samym dużo większe szanse na staż czy jakikolwiek start. Doszło więc do tego, że musiałem zdecydować z czego się uczyć. Oczywiście Google.pl “best sources to learn Java” i wertowanie Quory, Stack Overflow etc. Na tym etapie cały czas jeszcze zastanawiałem się nad jakimś bootcamp’em czy ewentualnie studiami z zakresu programowania. Całe (nie)szczęście na jedno i drugie nie było mnie w danym momencie stać. Zacząłem więc od darmowych kursów Javy dostępnych w internecie. Z tego co pamiętam pierwszy z kursów dostępny był chyba na stronie Coursera - beznadziejny. Wystarczy nadmienić, że programowania uczono w nim w IDE (werble…) BlueJ, co było totalną masakrą. Jednak i tym razem miałem farta i po chwili trafiłem na kurs Javy na Udemy od Johna Purcella, który zresztą cały czas polecam wszystkim znajomym próbującym zacząć przygodę z programowaniem. Tutaj było już o niebo lepiej. Starałem się programować 3-4 godziny dziennie. Miałem zamiar jak najszybciej zacząć pracować w zawodzie. Uczyłęm się w domu i w wolnych chwilach w pracy oglądałem jego filmiki i próbowałem pisać własne programy. Takie pisanie programów równolegle z prowadzącym kurs, pomagało mi zapamiętać to, co robiłem. Dodatkowo robiłem sobie jakieś małe zadania, żeby przypomnieć sobie co było na poprzednich lekcjach. Po tym pierwszym kursie było już tylko lepiej. Od tego samego autora znalazłem więcej kursów, które dotyczyły innych zagadnień w Javie. Wystarczy powiedzieć chociażby o Spring’u, Swing’u, wielowątkowości, wzorcach projektowych. Dodatkowo okazało się, że sam autor kursów jest bardzo pomocną osobą. Zawsze odpowiadał na maile i pomagał w sprawach, w których miałem problemy. Ba, nawet raz dał mi darmowy dostęp do jednego ze swoich kursów, gdy nie miałem kasy, aby go wykupić. Za to do dzisiaj wysyłam mu donate’y na PayPal’a. Starałem się też jak najwięcej czytać o programowaniu. Nie tylko o samej Javie, ale ogólnie o architekturze komputera etc. Wiadomo, trochę pomogła elektronika, która była na studiach, ale ogólnie to i tak jak uczenie od zera. Pomocny okazał się też darmowy kurs Harvardu CS50. Serio, świetnie są tam omówione podstawowe zagadnienia. Jeśli szukasz książek dla programistów zapraszam do artykułu. Znajdziesz w nim listę kilkunastu książek, które przydadzą się na różnych poziomach zaawansowania. Po jakichś 5 miesiącach takiej nauki podjąłem decyzję, że czas zacząć próbować startować na staż/juniorskie pozycje. Mimo, iż w sumie moja wiedza nie była jakaś zabójcza. Poprzeglądałem oferty pracy z Javy i słałem CV gdzie popadnie, gdzie w miarę spełniałem wymagania. Dodatkowo zauważyłem, że do programowania jest mi potrzebne coś więcej niż Java. Czyli np. SQL, XML, HTML, CSS, JavaScript. Starałem się więc dodatkowo ogarnąć coś, chociaż powierzchownie, z tych tematów, aby na rozmowach nie wychodzić na totalnego ignoranta. Wcześniej wspomniałem o tym, że pracodawcy często patrzą na potencjał. Właśnie takie przygotowywanie się do rozmowy przez “liźnięcie” tematu może pomóc. Pokazujesz w ten sposób, że zależy Ci na tej pozycji. Powinieneś jasno powiedzieć, że nie znasz tematu, ale niedawno zacząłeś się go uczyć. W międzyczasie podjąłem też studia informatyczne na prywatnej uczelni, ale okazały się one totalną stratą czasu i pieniędzy. Dobra rada dla przekwalifikowujących się, olejcie uczelnie, ogarnijcie dobrze jeden język. Znajdźcie jakąś pracę i dopiero potem idźcie na studia. Szczerze to nie wiem czy wyciągnąłby tak ogólne wnioski na podstawie jednej uczelni. Zgadzam się z Markiem, co do tego, że “sprzedawcy marzeń” to strata czasu i pieniędzy. Jeśli ktoś mówi Ci, że po trzymiesięcznym kursie będziesz programistą, nie mając wcześniej doświadczenia, to moim zdaniem kłamie. Udało mi się dostać na kilka rozmów kwalifikacyjnych. Tutaj poszło już w miarę z górki. Z trzech rozmów, na których byłem, jedna zakończyła się propozycją pracy, druga propozycją stażu. Doszedł do tego jeszcze świetny szef, który rzeczywiście chciał dać mi szansę i pomagał mi przy rozwoju w początkowych fazach mojej pracy. No i w tej pierwszej pracy siedzę do dzisiaj. Projektuję wewnętrzny system banku w nowej Javie EE, w oparciu o REST i utrzymując jeszcze starą wersję zbudowaną na Struts. Chociaż większość programistów to introwertycy, to staramy się być naprawdę pomocni. Jest spora szansa, że w pracy znajdziesz kogoś kto chętnie odpowie na Twoje pytania. Cały czas uczę się dodatkowych rzeczy. “Łyknąłem” trochę uczenia maszynowego, uczę się Androida. W tym momencie staram się ogarnąć libGDX, żeby zacząć robić proste gierki na Androida. Jako następne na celowniku mam Unity i naukę C# przy okazji. W międzyczasie pogłębiam wiedzę z Javy i ogarniam Springa 5. Już wspominałem, że programowanie to ciągła nauka. Jak tylko dowiesz się więcej z jednego zakresu zauważysz braki w innym miejscu. Mogę powiedzieć, że znalazłem w programowaniu coś dla siebie. Mimo, że początkowo do zmiany branży skłoniły mnie zarobki. Jako konstruktor z perspektywy czasu mogę powiedzieć, że byłem dosyć kiepski. Jako programista czuję się zdecydowanie pewniej w zawodzie. Rozwinęło się to w pewien rodzaj pasji. Sam w wolnych chwilach piszę artykuły o programowaniu i rzeczach związanych z programowaniem na blogu it-leaders. Tomasz Tomasz to dwudziestopięciolatek, który w lutym 2018 roku zaczął pracę jako programista. Ukończył studia z tytułem magistra inżyniera budownictwa ze specjalizacją inżynieria mostowa. Poniżej możesz przeczytać jego historię. O tym jak budowniczy mostów został programistą   Czym zajmowałeś się wcześniej? W jakim zawodzie pracowałeś? Wcześniej pracowałem jako asystent projektanta mostowego. Do moich zadań należało przygotowywanie obliczeń nośności mostów. Obliczenia te wykonywałem w Excelu. Potem, by je przyśpieszyć, zacząłem używać C++ i tak już zaczęła się moja przygoda z programowaniem. Odkryłem, że programowanie można wykorzystać nie tylko w branży budowlanej.   Miałeś wcześniej styczność z programowaniem? Pierwsza moja styczność z programowaniem to czasy gimnazjum, czyli budowanie stron w HTML i CSS. W liceum mieliśmy na informatyce proste zadania do rozwiązania w Pascalu. Nie byłem tak bardzo zakręcony na punkcie programowania, żeby każdą chwile wolną w gimnazjum i liceum spędzać przed komputerem. Większość czasu wolnego spędzałem grając w nogę z kolegami z osiedla.   Ile czasu poświęciłeś na przekwalifikowanie się, ile godzin dziennie/tygodniowo się uczyłeś? Ciężko powiedzieć ile czasu poświeciłem. Po pracy siadałem codziennie tak na 2 godzinki i robiłem kursy online albo pisałem własne programy. W sobotę lubiłem wybrać się do swojej ulubionej kawiarni i tam ćwiczyć swój warsztat.   Jak długo przygotowywałeś się przed wysłaniem pierwszego CV? Myślę, że potrzebowałem mniej więcej rok czasu. Oczywiście pierwsza rozmowa kwalifikacyjna musiała pójść źle :). Na pytania teoretyczne odpowiedziałem poprawnie, ale niestety nie dałem rady z napisaniem programu, zabrakło mi wiedzy praktycznej. Prezentowanie siebie na rozmowach kwalifikacyjnych, to też umiejętność. Jak wszystkiego, uczymy się jej przez praktykę. Innymi słowy każda kolejna rozmowa to więcej doświadczeń, które pozwolą Ci lepiej wypaść na kolejnych rozmowach.   Dlaczego zdecydowałeś się przekwalifikować? To w sumie wyszło bardzo naturalnie. Zawsze interesowałem się informatyką, bardzo lubię sobie upraszczać życie, a jeszcze bardziej jak coś się samo robi. Jestem samoukiem, a co jest wspaniałe w nauce programowania to to, że wszystko jest na wyciągnięcie ręki. To znaczy, że potrzebne materiały znajdziesz w większości za darmo. Jedyne czego potrzebujesz to czasu i dużej motywacji.   Od czego zacząłeś naukę programowania? Od rozmów, wielu rozmów. Wielu moich dobrych kolegów jest z wykształcenia informatykami. Jak się spotykaliśmy to często temat schodził na programowanie. Czasem udało nam się nawet coś razem popisać. I tak od rozmowy do rozmowy odkryłem, że programowanie ma olbrzymi potencjał. Potem pojawiły się kursy na Udemy i Pluralsight, ale tak na poważnie to zacząłem swoje programowanie od książki “Symfonia C++”. Chyba do końca życia nie zapomnę tej książki. Gwiazdkolot do tłumaczenia wskaźników, “Można żyć bez Coca-Coli, ale po co?” itp. Książka jest bardzo popularna wśród studentów. Autor w bardzo przystępny sposób tłumaczy podstawy C++. Bardziej zaawansowane konstrukcje omówione są w kontynuacji “Pasja C++”. Tę drugą zostawiłem sobie po studiach z sentymentu :).   Z jakimi technologiami aktualnie pracujesz? Obecnie pracuję z takimi technologiami jak C# i SQL do ogarniania backend’u aplikacji webowej oraz React z TypeScript’em po stronie front-end’u.   Co sprawiało Ci największe problemy w trakcie przekwalifikowania się? Największym problemem był wybór materiałów do nauki, ponieważ istnieje tak wiele źródeł, że teraz nie sztuką jest odszukanie materiałów, ale jak myślę trafna selekcja tych informacji.   Jak i gdzie zdobywałeś materiały do nauki? Czy możesz polecić źródła z których korzystałeś? Dlaczego akurat te? Tak jak wcześniej pisałem, głównie kursy online na Udemy albo Pluralsight. Warto zwrócić uwagę czy kurs jest aktualny, jaką ma ocenę i ile widzów. Z całego serca radzę by samemu spróbować napisać coś choćby bardzo małego, prostego. Nie bójcie się kompilatora, on podpowiada, gdzie jest błąd :). Jest bardzo pomocny. Podpisuję się pod tym obiema rękami i nogami. Programowania uczymy się programując. Im więcej praktyki tym lepiej, praktykę można zdobyć właśnie przez pisanie programów.   Co ułatwiało Ci naukę? Miałeś jakieś sposoby na łatwiejsze zapamiętywanie? W programowaniu ważniejsze od zapamiętywania, jest nauczenie się szukania informacji. Niestety system edukacji w jakim zostałem wychowany nakładał wielki nacisk na zapamiętywanie. Nikt nas nie uczył, jak mamy się uczyć, jak szukać informacji, a wydaje mi się, że byłoby to bardzo pomocne. Nie przejmuj się, jeśli czegoś nie pamiętasz, jak tylko potrafsz to znaleźć w Internecie :).   Jak poszły Ci pierwsze rozmowy? Co sprawiło Ci największy problem? O tym już wyżej pisałem. Pierwsza poszła średnio-dobrze. Dzięki niej już na kolejnej dużo mniej się stresowałem i wiedziałem czego się spodziewać.   Jakie masz wskazówki, rady dla osób, które chcą się przekwalifikować? Życzę Wam dużo motywacji, czasu i czerpania radości z programowania, bo to naprawdę fajne! :)   Jakie masz plany dotyczące dalszej nauki/rozwoju? Chciałbym pisać więcej po stronie backend’u. Poznać nowe możliwości C# których jeszcze nie znam.   Jak oceniasz pracę jako programista? Jest to praca, która wymaga ciągłej gotowości do rozwoju. Codziennie może zaskoczyć Cię jakiś problem, którego w tym momencie nie potrafisz rozwiązać i musisz szukać. Koledzy z zespołu i w większości programiści są bardzo otwarci i gotowi do pomocy. Zdajemy sobie sprawę ze ktoś może czegoś nie wiedzieć. Informatyka jest tak wielką dziedziną, że jedna osoba nie jest w stanie wszystkiego wiedzieć. I to jest super! Bo dzięki temu łatwiej prosić o pomoc drugą osobę. To jest też trudne, bo trzeba się przyznać, że się czegoś nie wie, ale warto pytać. Jak dla mnie nie ma lepszej pracy, niż praca jako programista. Codziennie uczysz się czegoś nowego, nowe wyzwania, wspaniali ludzie, świetna atmosfera w zespole. Bardzo się cieszę z decyzji jaką podjąłem by zakończyć karierę mostową i rozpocząć karierę jako programista :). Ania Nie rozmawiałem z Anią na temat przekwalifikowania. Jednak jej historia jest dostępna w internecie ;). Jeśli chcesz ją przeczytać to zapraszam na blog, którego prowadzi razem z Jakubem Kobiety do kodu. Jeśli nie znałeś go wcześniej to znajdziesz tam sporo artykułów wartych przeczytania. Podsumowanie Mam nadzieję, że historie, które przeczytałeś będą dla Ciebie dobrą motywacją. Postaram się zebrać najważniejsze punkty:   przebranżowienie jest możliwe,  przebranżowienie wymaga bardzo dużo konsekwentnej, regularnej pracy i nauki,  żaden płatny kurs nie zrobi z nikogo programisty bez jego własnej pracy,  posiadanie mentora, osoby bardziej doświadczonej znacząco przyspiesza naukę,  programowanie to ciągła nauka, nawet po zdobyciu pracy w zawodzie,  zdobycie pierwszej pracy jest ciężkie, sam wysłałem blisko 40 CV zanim dostałem tę pierwszą,  pieniądze też mogą być dobrym motywatorem, jednak na dłuższą metę może być ciężko ze znalezieniem chęci do dalszej nauki, która jest kluczowa.A teraz jeszcze kilka łyżek dziegdziu, tak żeby zgasić huraoptymizm:   przytoczyłem historię osób, którym się udało. Pamiętaj jednak, że ludzie nie lubią się dzielić swoimi porażkami. Innymi słowy na każdą osobę, której się udało przypada X, które nie dały rady,  nikt nie potrafi przewidzieć jak ta branża będzie wyglądała za 5, 10 czy 15 lat. Może uczenia maszynowe i sztuczna inteligencja rozwiną się na tyle, że praca niektórych programistów będzie zbędna i koniunktura się odwróci?  pamiętaj, że przebranżawiając się rywalizujesz z osobami, które kształcą/kształciły się w tym kierunku,  często jest tak, że osoby będące na studiach nie mają tak dużych zobowiązań jak osoba, która chce się przebranżowić. Studenci przeważnie nie mają rodziny na utrzymaniu, czy dużych zobowiązań finansowych7. Innymi słowy przebranżawiając się możesz sporo ryzykować.Jeśli myślisz, że chcę Cię odwieść od przebranżowienia, to masz rację. Jeśli mimo tego zostaniesz, to osiągniesz to co sobie założyłeś. Tylko będąc wystarczająco zdeterminowanym możesz to osiągnąć. To jak będzie? Dasz radę przekwalifikować się na programistę? Wiesz już, że to nie jest łatwe. Wiesz, że wymaga to sporo wysiłku. Podejmiesz wyzwanie? Jakąkolwiek decyzję podejmiesz gratuluję wyboru :). Nikt tej decyzji nie podejmie za Ciebie. Podziel się swoją opinią w komentarzu, a może Tobie już udało się przekwalifikować? Na koniec mam do Ciebie prośbę. Jeśli artykuł przypadł Ci do gustu proszę podziel się nim ze swoimi znajomymi. W ten sposób pomożesz mi dotrzeć do nowych czytelników - z góry dziękuję. Jeśli chcesz otrzymywać informacje o nowych artykułach proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Do następnego razu!             Tak swoją drogą, moje domysły okazały się słuszne ;). &#8617;               Język programowania składniowo bardzo podobny do Javy wypuszczony przez Microsoft. &#8617;               Aplikacje okienkowe, na przykład przeglądarka internetowa może być aplikacją desktop’ową. &#8617;               Back-end to programowanie po stronie serwera. Pisanie programów, które będą uruchamiane na serwerze. Dla odróżnienia front-end to część aplikacji, która uruchamiana jest przez klienty. W kontekście aplikacji webowych do front-endu używa się głównie HTML, CSS i JavaScript. Osoba pracująca zarówno z back-end’em i front-end’em często określana jest mianem full stack’a. &#8617;               jQuery to jedna z popularnych bibliotek napisana w JavaScript, która ułatwia pracę z front-end’em. &#8617;               można to przetłumaczyć jako dział badań i rozwoju (ang. research and development). &#8617;               Mam świadomość, że tu mocno generalizuję. Wydaje mi się jednak, że statystycznie tak to właśnie wygląda. Tak jak piszę - wydaje mi się, więc będę wdzięczny jeśli pokażesz dane, które wyprowadzą mnie z błędu. &#8617;       ","categories": ["Różne"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/zmiana-branzy-zostan-programista/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/05/01_zmiana_branzy_zostan_programista.jpg"},{
        "title": "Projekt Informator zasilenie bazy, Spring i błędy jako JSON",
        "excerpt":"Projekt Informator Projekt informator to REST’owy web service, działający w oparciu o Spring i Hibernate. Jeśli chcesz przeczytać więcej o projekcie i jego założeniach zapraszam do wprowadzenia. W jednym z poprzednich artykułów przeczytasz też o wdrożeniu projektu w chmurze. Samouczek Programisty jest jednym z partnerów konferencji infoShare 2018. infoShare 2018 to konferencja technologiczna odbywająca się 22-23 maja w Gdańsku. Na developerów czekają m.in. prelekcje z obszaru cybersecurity i machine learning, live coding oraz spotkania ze specjalistami, takimi jak: Filip Wolski, Trent McConaghy, Piotr Konieczny, Zbigniew Wojna czy Scott Helme. infoShare to także okazja do networkingu i udziału w imprezach towarzyszących. Sprawdź agendę i zarejestruj się na www.infoshare.pl.  Baza danych W projekcie do mapowania obiektowo relacyjnego używam biblioteki Hibernate jako implementacji JPA (ang. Java Persistence API). W tym przypadku tworzenie schematu bazy danych zostawiam JPA. Poniżej widzisz konfigurację obiektu zarządzanego przez kontener Spring’a. Służy on do tworzenia instancji implementującej interfejs EntityManager: @BeanLocalContainerEntityManagerFactoryBean entityManagerFactory() {    LocalContainerEntityManagerFactoryBean factory = new LocalContainerEntityManagerFactoryBean();    factory.setJpaVendorAdapter(new HibernateJpaVendorAdapter());    factory.setPackagesToScan(\"pl.samouczekprogramisty.informator.model\");    factory.setDataSource(dataSource());    Properties jpaProperties = new Properties();    jpaProperties.setProperty(\"hibernate.dialect\", \"org.hibernate.dialect.PostgreSQLDialect\");    jpaProperties.setProperty(\"hibernate.show_sql\", \"true\");    jpaProperties.setProperty(\"hibernate.format_sql\", \"true\");    jpaProperties.setProperty(\"hibernate.hbm2ddl.auto\", \"validate\");    // create database schema if missing    jpaProperties.setProperty(\"javax.persistence.schema-generation.database.action\", \"create\");    factory.setJpaProperties(jpaProperties);    return factory;}  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Zasilenie bazy danych Niestety organizatorzy konferencji nie przygotowali źródła danych, które w łatwy sposób można użyć do zasilenia bazy danych. Jedyne źródło to oficjalna strona www konferencji. Na początku skupiłem się nad zasileniem tabeli zawierającej dane dotyczące prelegentów. W projekcie Informator prelegent reprezentowany jest przez instancję klasy Speaker: @Entitypublic class Speaker {    @Id    @GeneratedValue(strategy = GenerationType.SEQUENCE, generator = \"speaker_seq\")    @SequenceGenerator(name = \"speaker_seq\")    private Integer id;    private Integer infoshareId;    private Category category;    private String name;    private URL linkedinProfile;    private URL twitterProfile;    private URL facebookProfile;    private URL githubProfile;    @Column(columnDefinition = \"text\")    private String description;    // getters/setters}Analizując zapytania HTTP, które są wykonywane w tle zauważyłem adres w postaci: https://infoshare.pl/speaker2.php?cid=48&amp;id=XXX&amp;year=2018&amp;agenda_id=99999&amp;fancybox=trueW adresie tym XXX zastąpione jest identyfikatorem prelegenta. Strona z prelegentami zawiera listę wszystkich osób występujących na każdej ze scen. Żeby wyciągnąć informacje o wszystkich prelegentach potrzeba ponad 200 zapytań. Z racji tego, że jest to dość żmudne i czasochłonne zadanie napisałem skrypt1, który wyciąga niezbędne dane. W wyniku działania tego skryptu powstał plik speakers.sql. Wewnątrz tego pliku znajdują się instrukcje SQL (ang. Structured Query Language), które dodają wiersze do tabeli speaker. Przykładowe zapytanie z tego pliku wygląda następująco: INSERT INTO speaker (\tid,\tinfoshareid,\tcategory,\tdescription,\tfacebookprofile,\tgithubprofile,\tlinkedinprofile,\ttwitterprofile,\tname)VALUES (\tnextval('speaker_seq'),\t954,\t0, 'Stephen Haunts is a veteran sof(...)',\tNULL,\tNULL,\tNULL,\t'https://twitter.com/stephenhaunts',\t'Stephen Haunt');Formatowanie odpowiedzi Mając rzeczywiste dane w bazie danych webservice może odpowiadać bardziej sensownymi danymi: $ curl http://localhost:8080/speakers/7 -s | json_pp{   \"category\" : \"STARTUP\",   \"description\" : \"Kamila Wincenciak is a member of Ali(...)\",   \"name\" : \"Kamila Wincenciak\",   \"githubProfile\" : null,   \"twitterProfile\" : null,   \"facebookProfile\" : null,   \"linkedinProfile\" : \"https://www.linkedin.com/in/kamila-wincenciak-27560130/\"}Zabrałem się za kolejny etap, czyli obsługę błędów. Przypadkami, które trzeba obsłużyć są brak rekordu w bazie i złe dane wprowadzone przez użytkownika. Oba przypadki pokazane są poniżej. Proszę zwróć uwagę na zwracane nagłówki i status odpowiedzi: $ curl http://localhost:8080/speakers/-1 -vs | json_pp*   Trying 127.0.0.1...* Connected to localhost (127.0.0.1) port 8080 (#0)&gt; GET /speakers/-1 HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.47.0&gt; Accept: */*&gt; &lt; HTTP/1.1 404 &lt; Content-Type: application/json&lt; Content-Length: 148&lt; Date: Wed, 20 Jun 2018 21:09:42 GMT&lt; { [148 bytes data]* Connection #0 to host localhost left intact{   \"responseCode\" : 404,   \"exceptionClass\" : \"pl.samouczekprogramisty.informator.exceptions.NotFoundException\",   \"message\" : \"Speaker with id -1 wasn't found!\"}$ curl http://localhost:8080/speakers/aa -vs | json_pp*   Trying 127.0.0.1...* Connected to localhost (127.0.0.1) port 8080 (#0)&gt; GET /speakers/aa HTTP/1.1&gt; Host: localhost:8080&gt; User-Agent: curl/7.47.0&gt; Accept: */*&gt; &lt; HTTP/1.1 400 &lt; Content-Type: application/json&lt; Content-Length: 108&lt; Date: Wed, 20 Jun 2018 21:09:16 GMT&lt; Connection: close&lt; { [108 bytes data]* Closing connection 0{   \"message\" : \"For input string: \\\"aa\\\"\",   \"responseCode\" : 400,   \"exceptionClass\" : \"java.lang.NumberFormatException\"}Konfiguracja Spring a obsługa błędów Aby móc w ten sposób formatować błędy użyłem kombinacji adnotacji ControllerAdvice i ExceptionHandler: @ControllerAdvice@SuppressWarnings(\"unused\")@ResponseBodypublic class InformatorExceptionHandler {    private static ObjectMapper mapper = new ObjectMapper();    public static class ErrorResponse {        private static final MultiValueMap&lt;String, String&gt; HEADERS = new LinkedMultiValueMap&lt;&gt;(                Collections.singletonMap(HttpHeaders.CONTENT_TYPE, Collections.singletonList(MediaType.APPLICATION_JSON_VALUE))        );        private final Exception exception;        private HttpStatus responseStatus;        ErrorResponse(HttpStatus responseStatus, Exception exception) {            this.exception = exception;            this.responseStatus = responseStatus;        }        ResponseEntity&lt;String&gt; buildResponse() {            try {                return new ResponseEntity&lt;&gt;(mapper.writeValueAsString(this), HEADERS, responseStatus);            } catch (JsonProcessingException e) {                throw new RuntimeException(e);            }        }        // getters    }    @ExceptionHandler(NotFoundException.class)    public ResponseEntity&lt;String&gt; handleNotFound(NotFoundException exception) {        return new ErrorResponse(HttpStatus.NOT_FOUND, exception).buildResponse();    }    @ExceptionHandler(NumberFormatException.class)    public ResponseEntity&lt;String&gt; handleNumberFormat(NumberFormatException exception) {        return new ErrorResponse(HttpStatus.BAD_REQUEST, exception).buildResponse();    }}Klasa oznaczona adnotacją ControllerAdvice zawiera w sobie metody, które są użyte w wielu kontrolerach. Możemy powiedzieć, że są to metody przekrojowe. Przykładem takich metod są te oznaczone adnotacją ExceptionHandler. Każda z nich odpowiada za obsługę innego typu wyjątku. Niestety w tym przypadku Spring nie deserializuje obiektu odpowiedzi do żądanego formatu dlatego napisałem klasę pomocniczą ErrorResponse, która przygotowuje odpowiedź w formacie JSON. Podsumowanie Aplikacja aktualnie jest w stanie wyświetlić informacje o prelegencie na podstawie rzeczywistych danych pobranych ze strony organizatora konferencji. Dodatkowo aplikacja poprawnie reaguje na różnego rodzaju błędy odpowiadając w formacie JSON. Zachęcam Cię do przeanalizowania kodu źródłowego aplikacji, w ten sposób utrwalisz zdobytą wiedzę. Po przeczytaniu tego artykułu i przejrzeniu kodu źródłowego wiesz w jaki sposób można obsługiwać błędy w webservice’ach. Poznałeś też sposób na zasilanie bazy danych na podstawie informacji umieszczonych na innych stronach. Jeśli nie chcesz pominąć kolejnych artykułów na Samouczku proszę dopisz się do samouczkowego newslettera i polub Samouczka na Facebooku. Proszę podziel się linkiem do artykułu ze znajomymi, którym może on pomóc. Może to dzięki Tobie uda mi się dotrzeć do nowych czytelników? ;) Do następnego razu!             Po godzinach pracy, w wolnym czasie uczę się języka Go. Wiem, że najlepszy sposób na naukę to praktyka. Dlatego właśnie napisałem ten skrypt używając tego języka. Mam świadomość, że nie jest idealny i wymaga sporo poprawek, ale jak na początek nauki jest OK ;). &#8617;       ","categories": ["Projekty","Projekt Informator"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/projekt-informator-zasilenie-bazy-spring-i-bledy-jako-json/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/06/20_projekt_informator_zasilenie_bazy_spring_i_bledy_jako_json.jpeg"},{
        "title": "Pobieranie danych z bazy - SELECT",
        "excerpt":"  To jest jeden z artykułów w ramach praktycznego kursu SQL. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Każde zapytanie z kursu możesz wykonać samodzielnie. Potrzebujesz do tego środowiska opisanego w pierwszym artykule kursu. Bardzo mocno Cię do tego zachęcam. Moim zdaniem najwięcej nauczysz się samodzielnie eksperymentując z zapytaniami. Wprowadzenie do języka SQL Język SQL (ang. Structured Query Language) powstał kilkadziesiąt lat temu. Służy do pobierania i przetwarzania danych zapisanych w bazie danych. Język ten został ustandaryzowany i na przestrzeni kilkudziesięciu lat powstało wiele wersji tego standardu.   Niestety treść standardów nie jest dostępna bezpłatnie. Jeśli będziesz chcieć uzupełnić swoją wiedzę, to dokumentacja bazy danych, której używasz jest bardzo dobrym źródłem. Popularne bazy danych dokładnie opisują swoją implementację standardu SQL:   SQL implementowany przez SQLite,  SQL implementowany przez PostgreSQL,  SQL implementowany przez MySQL,  SQL implementowany przez Oracle.Język SQL jest językiem deklaratywnym. Oznacza to tyle, że instrukcje tego języka opisują co chcemy osiągnąć, a nie jak to zrobić. Dla porównania można powiedzieć, że język Java nie jest językiem deklaratywnym. Programując w języku Java mówisz o tym jak chcesz coś zrobić. Język SQL oparty jest na zapytaniach. Przykładowe zapytanie SQL może wyglądać tak: SELECT *  FROM genre WHERE name = 'Rock'   AND genreid &lt; 20;SQL to nie baza danych Definicji bazy danych może być wiele. Jednak nie znam żadnej, która mówiłaby, że baza danych to SQL. SQL to język, który pomaga dogadać się z bazą danych. Baza danych to dane, to ich zbiór. W relacyjnych bazach danych są one zorganizowane w tabele. W jednej bazie danych przeważnie znajduje się wiele tabel. Tabele zawierają wiersze i kolumny. Na przykład tabela genre zawiera nazwy gatunków muzycznych: | genreid | name   ||---------|--------|| 1       | 'Rock' || 2       | 'Jazz' |Tabela, którą pokazałem wyżej zawiera dwa wiersze i dwie kolumny: genreid i name. Można powiedzieć, że baza danych to zbiór tabel zawierających dane. Język SQL pomaga w łatwym operowaniu na danych. SQL ukrywa w sobie sposób w jaki dane są przetwarzane, zwraca wyłącznie finalny wynik. Bazy danych także ukrywają sposób przechowywania danych. Użytkownika nie interesuje sposób ich zapisu a jedynie to, co chce uzyskać przy pomocy zapytania SQL1. Podział SQL Zapytania w SQL możemy podzielić na kilka rozłącznych grup. Każda z tych grup zawiera różne rodzaje zapytań. Grupy zostały wydzielone na podstawie zadań realizowanych przez poszczególne zapytania. Możemy wyszczególnić następujące grupy:   DQL (ang. Data Query Language)  DML (ang. Data Manipulation Language)  DDL (ang. Data Definition Language)Dodatkowo czasami wyróżnia się też grupy:   DCL (ang. Data Control Language)  TCL (ang. Transaction Control Language)DQL DQL składa się wyłącznie z zapytań typu SELECT. Zapytania te służą do odpytywania (ang. query) bazy danych. Innymi słowy służą do pobierania danych z bazy danych. Zapytania typu SELECT są najczęściej używane. Poniżej możesz zobaczyć zapytanie, które pobiera wszystkie kolumny i wiersze z tabeli genre. SELECT *  FROM genre;Na razie nie przejmuj się składnią zapytania, omówię ją szczegółowo poniżej. DML DML służy do tworzenie, modyfikowania i usuwania danych. W skład tej grupy wchodzą zapytania:   INSERT - dodaje wiersze do tabeli,  UPDATE - aktualizuje wiersze w tabeli,  DELETE - usuwa wiersze z tabeli.DDL Wiesz już, że relacyjne bazy danych składają się z tabel. Dodatkowo w bazach występują inne obiekty jak indeksy (ang. index), klucze obce (ang. foreign key), klucze główne (ang. primary key), ograniczenia (ang. constraint), wyzwalacze (ang. trigger) czy widoki (ang. view). Część języka odpowiedzialna za zarządzanie tymi obiektami to DDL. Zapytania należące do DDL to:   CREATE - tworzą obiekty bazy danych,  ALTER - modyfikują tabele bazy danych,  DROP - usuwają obiekty bazy danych,  TRUNCATE - usuwa wszystkie dane z tabeli2.DCL Bazy danych często pozwalają na zarządzanie dostępem do danych. Realizowane jest to przy pomocy kont użytkowników3. DCL służy do manipulacji prawami dostępu do danych przypisanych do poszczególnych kont:   GRANT - nadaje uprawnienia,  REVOKE - usuwa uprawnienia.TCL Na początku przygody z SQL nie musisz przejmować się transakcjami. Opiszę je dokładniej w kolejnych artykułach w ramach kursu. Teraz w zupełności wystarczy wiedza o tym, że istnieje coś takiego jak transakcja. Do zarządzania transakcjami służą zapytania:   BEGIN - rozpoczyna transakcję,  COMMIT - zatwierdza transakcję,  ROLLBACK - wycofuje transakcję,  SAVEPOINT - zapisuje punkt przywracania aktualnej transakcji.SQL a wielkość liter SQL jest językiem, w którym wielkość liter w słowach kluczowych i identyfikatorach nie ma znaczenia. Wyjątkiem są tu identyfikatory, które są otoczone znakiem cudzysłowu \"4. Na przykład oba poniższe zapytania są równoważne: SELECT * FROM genre WHERE genreid = 1;SELECT * frOM geNRe wherE GenReID = 1;Chociaż wielkość liter nie ma znaczenia, moim zdaniem dobrą praktyką jest pisanie słów kluczowych wielkimi literami. W codziennej pracy także staram się unikać nadawania nazw, które wymagają otoczenia \". Dodatkowo zawsze staram się formatować zapytania żeby były bardziej czytelne: SELECT *  FROM genre WHERE genreid = 1;  Pobierz opracowania zadań z rozmów kwalifikacyjnych Przygotowałem rozwiązania kilku zadań z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy ponad 600 Samouków, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail. Przygotowanie środowiska Moim zdaniem najlepszym sposobem na naukę jest praktyka. Właśnie z tego powodu chcę pomóc przygotować Ci środowisko, w którym możliwe będzie testowanie zapytań. Aby móc ćwiczyć na bieżąco wszystkie zagadnienia, które będę opisywał będziesz potrzebować serwera bazy danych. Jak wspomniałem w artykule opisującym relacyjne bazy danych jest wiele silników baz danych. Ze względu na łatwą instalację (właściwie to jej brak), w kursie używał będę bazy danych SQLite. Baza ta jest w zupełności wystarczająca na potrzeby kursu. Oczywiście, jeśli chcesz wykonywać ćwiczenia używając bardziej zaawansowanych baz danych możesz to zrobić ;). Instalacja bazy danych Zacznij od pobrania narzędzi SQLite. W zależności od systemu operacyjnego, na którym pracujesz pobierz odpowiednią wersję:   Windows - Precompiled Binaries for Windows,  Linux - Precompiled Binaries for Linux,  Mac OS X - Precompiled Binaries for Mac OS X (x86).Plik do pobrania to archiwum zip rozpoczynające się od sqlite-tools-. Wewnątrz tego archiwum znajduje się program sqlite.exe (lub sqlite, w zależności od Twojego systemu operacyjnego). Program ten pozwala na pracę z bazą danych SQLite. Jak widzisz w tym przypadku właściwie nie ma potrzeby instalacji żadnego programu, wystarczy rozpakować archiwum zip. W przypadku baz danych używanych w środowiskach produkcyjnych proces ten jest dużo bardziej skomplikowany. Import gotowej bazy danych W internecie istnieje wiele zbiorów danych. Jednym z nich jest ten udostępniony przez projekt Chinook. Jest to testowa baza danych reprezentująca sklep z muzyką. Sama baza nie jest duża, jednak w zupełności wystarczy na omówienie podstawowych możliwości SQL. Pobierz przykładową bazę danychi zachowaj ją w pliku Chinook_Sqlite.sqlite, następnie uruchom program sqlite3. Po uruchomieniu wpisz komendę, która otworzy pobraną bazę danych: .open &lt;ścieżka do pobranego pliku&gt;Żeby sprawdzić, czy wszystko działa poprawnie możesz wpisać komendę .tables, powinna ona wypisać wszystkie tabele znajdujące się bazie danych.         Otworzenie bazy danych w sqlite  Komendy zaczynające się od . (na przykład .open czy .tables) to wewnętrzne polecenia SQLite. Jest ich dużo więcej. Jeśli chcesz je zobaczyć użyj polecenia .help. Zapytania SELECT Założeniem tego kursu jest to, że będzie on praktyczny od samego początku do końca. Wszystkie zapytania, które tutaj pokazuję możesz wykonać samodzielnie używając środowiska, które wcześniej opisałem. Schemat tabeli Zanim przejdę do tłumaczenia zapytań SELECT chciałbym zwrócić Twoją uwagę na budowę tabeli. Wiesz już, że tabela składa się z wierszy i kolumn. Każda kolumna przechowuje dane pewnego typu. Mogą to być na przykład łańcuchy znaków czy liczby. Można powiedzieć, że tabela ma swój schemat. SQLite ma wewnętrzne polecenie, które pozwala pokazać schemat tabeli - .schema. Na przykład schemat tabeli Invoice wygląda tak: sqlite&gt; .schema InvoiceCREATE TABLE [Invoice](    [InvoiceId] INTEGER  NOT NULL,    [CustomerId] INTEGER  NOT NULL,    [InvoiceDate] DATETIME  NOT NULL,    [BillingAddress] NVARCHAR(70),    [BillingCity] NVARCHAR(40),    [BillingState] NVARCHAR(40),    [BillingCountry] NVARCHAR(40),    [BillingPostalCode] NVARCHAR(10),    [Total] NUMERIC(10,2)  NOT NULL,    CONSTRAINT [PK_Invoice] PRIMARY KEY  ([InvoiceId]),    FOREIGN KEY ([CustomerId]) REFERENCES [Customer] ([CustomerId])                ON DELETE NO ACTION ON UPDATE NO ACTION);CREATE UNIQUE INDEX [IPK_Invoice] ON [Invoice]([InvoiceId]);CREATE INDEX [IFK_InvoiceCustomerId] ON [Invoice] ([CustomerId]);To co widzisz, to zapytania typu DDL, które tworzą tabelę i obiekty z nią powiązane. Powyższe zapytana poza tabelą tworzą indeksy, klucze obce i klucz główny. Istnieją także bazy danych, które pozwalają przechowywać dane w strukturze, która nie ma sztywno określonego schematu. Podobnie jak relacyjne bazy danych mają one swoje wady i zalety. Typy danych Typy obsługiwanych danych mogą znacznie różnić się pomiędzy różnymi silnikami baz danych. Różnice te jednak nie przeszkadzają w nauce języka SQL. Tabela Invoice składa się z dziewięciu kolumn. Kolumna InvoiceId jest kluczem głównym tabeli. Każda z kolumn ma przypisany typ. Typ określa rodzaj danych przechowywanych w danej kolumnie5. Na przykład kolumna InvoiceDate jest typu DATETIME, kolumny tego typu służą do przechowywania daty i czasu. Innymi typami, które występują w tej tabeli są:   INTEGER - służy on do przechowywania liczb całkowitych,  NVARCHAR(x) - służy on do przechowywania łańcuchów znaków do długości x,  NUMERIC(x, y) - służy do przechowywania liczb rzeczywistych, które mają do x cyfr z y po przecinku.Innymi popularnymi typami są6:   BLOB - służy do przechowywania danych binarnych (ang. binary large object),  DATETIME - służy do przechowywania daty i czasu,  DATE - służy do przechowywania daty,  BOOLEAN - służy do przechowywania wartości logicznych,  TEXT - służy do przechowywania łańcuchów znaków gdzie ciężko jest oszacować maksymalną długość tekstu, lub wahania długości tekstu są duże.Składnia zapytania SELECT Zapytanie SELECT w swojej najprostszej formie wygląda tak: SELECT *  FROM invoice;To zapytanie zawiera dwa słowa kluczowe: SELECT i FROM. Pomiędzy tymi słowami znajduje się lista kolumn, które powinny zostać zwrócone. Znak * w tym kontekście oznacza “pobierz wszystkie”. Po słowie kluczowym FROM występuje nazwa tabeli - invoice. Całe zapytanie jest zakończone średnikiem. Spróbuj wykonać to zapytanie na swojej kopii bazy danych: sqlite&gt; SELECT * FROM invoice;1|2|2009-01-01 00:00:00|Theodor-Heuss-Straße 34|Stuttgart||Germany|70174|1.982|4|2009-01-02 00:00:00|Ullevålsveien 14|Oslo||Norway|0171|3.96(...)Filtrowanie przy pomocy WHERE Pobieranie całej tabeli nie zawsze jest przydatne. Bardzo często zapytania SELECT filtrują pobierane dane. Aby filtrować dane zwracane przez zapytanie musisz użyć słowa kluczowego WHERE i warunków, które filtrują dane: SELECT *  FROM invoice WHERE billingcity = 'Dublin' AND total &gt; 5    OR billingcity = 'Boston' AND total &lt; 3 AND total &gt; 1;Zapytanie wyżej ma kilka warunków. Każdy z nich oddzielony jest słowem kluczowym OR (logiczne lub) i AND (logiczne i). W tym przypadku zostaną zwrócone wszystkie wiersze dla których spełniony jest jeden z warunków:   kolumna billingcity ma wartość Dublin i kolumna total zawiera liczbę większą od 5,  kolumna billingcity ma wartość Boston i kolumna total zawiera liczbę z przedziału (1, 3).Słowo kluczowe AND ma wyższy priorytet niż OR. Czasami dla większej czytelności możesz użyć nawiasów. Poniższe zapytanie da dokładnie ten sam wynik co poprzednie: SELECT *  FROM invoice WHERE (billingcity = 'Dublin' AND total &gt; 5)    OR (billingcity = 'Boston' AND total &lt; 3 AND total &gt; 1);Spróbuj wywołać to zapytanie na swojej kopii bazy danych: sqlite&gt; SELECT * FROM invoice WHERE billingcity = 'Dublin' AND total &gt; 5 OR billingcity = 'Boston' AND total &lt; 3 AND total &gt; 1;10|46|2009-02-03 00:00:00|3 Chatham Street|Dublin|Dublin|Ireland||5.94189|23|2011-04-18 00:00:00|69 Salem Street|Boston|MA|USA|2113|1.98(...)Magiczna wartość NULL Każdy wiersz w tabeli może mieć wartość, która pasuje do typu przechowywanego przez daną kolumnę. W SQL jest jeszcze specjalna wartość. Jest nią NULL. Możesz ją porównać do pustej wartości w językach programowania. W Javie i JavaScript byłby to null, w Pythonie None, w Ruby i Go nil itd. Istotne jest rozróżnienie pomiędzy pustą wartością a NULL. Na przykład pusty łańcuch znaków to zupełnie coś innego niż NULL. Wartość ta jest traktowana w specyficzny sposób w przypadku porównań. Do sprawdzania czy kolumna w wierszu ma wartość NULL służy wyrażenie IS NULL. Aby sprawdzić, czy dana kolumna nie ma wartości NULL używa się wyrażenia IS NOT NULL. Na przykład poniższe zapytanie zwróci jedynie te wiersze dla których kolumna billingcountry ma wartość inną niż USA i billingstate nie ma wartości NULL: SELECT *  FROM invoice WHERE billingstate IS NOT NULL   AND billingcountry != 'USA';Wybór kolumn Użycie klauzuli WHERE pozwala na odfiltrowanie części wierszy. W przypadku kolumn mechanizm jest podobny. Jeśli chcesz wybrać podzbiór kolumn, a nie wszystkie, to musisz wskazać te, które Cię interesują: SELECT invoicedate      ,billingcity      ,total  FROM invoice WHERE billingcountry = 'Poland';Powyższe zapytanie zwróci wyłącznie te faktury, które zostały wystawione w Polsce. Wynik będzie zawierał tylko trzy wskazane kolumny. Zwróć uwagę, że klauzula WHERE może używać kolumn, które nie są zwracane w wyniku wykonania zapytania. To dopiero początek Rysunek poniżej pokazuje składnię zapytania SELECT w SQLite. W artykule tym omówiłem wyłącznie podstawowe elementy.         Składania zapytania SELECT  W kolejnych artykułach omówię między innymi pozostałe elementy składni zapytania SELECT. Zadania do wykonania Na koniec mam dla Ciebie kilka zadań, w których przećwiczysz materiał z tego artykułu. Postaraj się napisać zapytania samodzielnie, wtedy nauczysz się najwięcej:   Napisz zapytanie, które zwróci wszystkie gatunki muzyczne z tabeli genre,  Napisz zapytanie, które zwróci wszystkie stany w USA, w których wystawiono fakturę na kwotę większą niż 15,  Napisz zapytanie, które zwróci wszystkie kraje, w których wystawiono fakturę na kwotę mniejszą niż 10 pomiędzy ‘2013-12-05 00:00:00’ i ‘2013-12-09 00:00:00’,  Napisz zapytanie, które zwróci wszystkie miasta i kraje gdzie wartość kolumny billingstate równa się NULL i wartość zamówienia jest większa niż 17 oraz te gdzie wartość zamówienia jest mniejsza niż 1, billingstate nie ma wartości NULL i zostały wystawione po ‘2013-09-20 00:00:00’.Dodatkowe materiały do nauki Jeśli chcesz spojrzeć na temat z innej perspektywy polecam przeczytanie poniższych materiałów. Pozwoli Ci to poszerzyć swoją wiedzę związaną z językiem SQL i jego składnią.   Artykuł na temat SQL na Wikipedii,  Dokumentacja SQLite.Podsumowanie Po przeczytaniu tego artykułu wiesz czym jest język SQL. Potrafisz podzielić zapytania języka SQL na grupy. Znasz podstawy zapytania typu SELECT. Potrafisz zastosować w praktyce zapytania tego typu do pobrania danych z bazy. Innymi słowy masz solidne podstawy, dzięki którym możesz przejść do kolejnego etapu nauki języka SQL. Przyznam Ci się, że miałem problem z zakończeniem tego artykułu. Mam świadomość, że nie jest kompletny, ale postanowiłem podzielić go na mniejsze, łatwiejsze do przyswojenia części. W kolejnych artykułach z cyklu możesz spodziewać się pogłębienia tematu. Na koniec proszę Cię o polecenie tego artykułu Twoim znajomym, którym może się on przydać. Dzięki Tobie uda mi się dotrzeć do nowych czytelników. Z góry dziękuję ;). Jeśli cokolwiek nie będzie dla Ciebie jasne proszę daj znać w komentarzach, postaram się pomóc. Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę polub Samouczka na Facebooku i dodaj swój adres e-mail do samouczkowego newslettera. Do następnego razu!             Na pewnym etapie zaawansowania znajomość wewnętrznych mechanizmów działania bazy danych jest bardzo ważna. Pozwala ona na tworzenie zapytań, które są bardziej wydajne. &#8617;               Chociaż TRUNCATE jest podobne do zapytania typu DELETE jest klasyfikowane jako DDL. Wynika to z faktu, że zapytania TRUNCATE nie mogą być cofnięte. Zapytania typu DELETE mogą być cofnięte w ramach trwającej transakcji. &#8617;               Pomijam tu ustawienia na poziomie konfiguracji silnika bazy danych. Te ustawienia mogą wymagać restartu silnika. Przykładem może tu być plik konfiguracyjny pg_hba.conf istniejący w bazie danych PostgreSQL. &#8617;               To zachowanie zależy od silnika bazy danych. Niektóre silniki inaczej interpretują identyfikatory otoczone \", inne nie. &#8617;               To stwierdzenie nie jest do końca prawdziwe dla SQLite, jednak ma zastosowanie w innych silnikach baz danych. W przypadku SQLite typ danych określany jest na podstawie zawartości a nie typu kolumny. To zachowanie jest raczej wyjątkiem w świecie relacyjnych baz danych. Po szczegóły odsyłam Cię do dokumentacji SQLite. &#8617;               W przypadku SQLite wszystkie typy danych są przekształcane na “typy pierwotne”: NULL, INTEGER, REAL, TEXT, BLOB. Dane na dysku zawsze zapisane są jako jeden z typów pierwotnych. &#8617;       ","categories": ["Bazy danych","Kurs SQL"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/pobieranie-danych-z-bazy-select/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/06/28_pobieranie_danych_z_bazy_select_artykul.jpeg"},{
        "title": "Klauzula WHERE w zapytaniach SQL",
        "excerpt":"  To jest jeden z artykułów w ramach praktycznego kursu SQL. Proszę zapoznaj się z pozostałymi częściami, mogą one być pomocne w zrozumieniu materiału z tego artykułu. Każde zapytanie z kursu możesz wykonać samodzielnie. Potrzebujesz do tego środowiska opisanego w pierwszym artykule kursu. Bardzo mocno Cię do tego zachęcam. Moim zdaniem najwięcej nauczysz się samodzielnie eksperymentując z zapytaniami. Klauzula WHERE W artykule opisującym podstawy zapytania SELECT wspomniałem o klauzuli WHERE. Po przeczytaniu tamtego artykułu wiesz, że klauzula WHERE służy do filtrowania danych zwróconych przez zapytania typu SELECT. Klauzula WHERE używana jest także w zapytaniach typu UPDATE, INSERT i DELETE. W pierwszym przypadku ogranicza zbiór wierszy, który powinien zostać zaktualizowany. W przypadku zapytania typu DELETE ogranicza zbiór wierszy, który powinien zostać usunięty. W zapytaniach typu INSERT używany jest z podzapytaniami (o podzapytaniach przeczytasz w jednym z kolejnych artykułów). Informacje, które przeczytasz w tym artykule można odnieść do wszystkich czterech rodzai zapytań. Literały w SQL Zanim przejdę do omawiania warunków musisz poznać literały. Używałem ich już w poprzednim artykule bez dodatkowego wyjaśnienia. Tutaj poświęcę im osobny paragraf. Najprostszym rodzajem literałów są liczby, zapisuje się je podobnie jak w językach programowania: 42, 12.34. Liczby mogą być zapisane także w notacji naukowej 1.34E-5 lub szesnastkowo 0xBACA1. Często będziesz także używać łańcuchów znaków. Łańcuch znaków powinien być otoczony apostrofami, na przykład 'Samouczek Programisty'. Innym przykładem literału jest NULL, który określa pustą wartość. Znaki specjalne w SQL W SQL występują znaki specjalne. Do tej pory wprowadziłem '. Jeśli chcesz aby Twoje zapytanie dotyczyło wierszy, które zawierają ' musisz poprzedzić go drugim znakiem '. Spójrz na przykład poniżej, posługuję się w nim konstrukcją LIKE, którą opisuję w jednym z kolejnych akapitów. Zapytanie zwraca wszystkie wiersze, w których kolumna title zawiera znak ': SELECT *  FROM album WHERE title LIKE '%''%';Warunki Łączenie warunków Każdy z warunków, który opiszę można ze sobą łączyć używając operatorów AND lub OR. AND ma pierwszeństwo przed OR. Można także użyć nawiasów (), aby określić pierwszeństwo wykonania warunków. Używanie nawiasów nie zawsze jest obowiązkowe. Jednak moim zdaniem często warto ich używać. Dzięki nim bardziej skomplikowane zapytania mogą być bardziej czytelne. Nawiasy w przykładzie poniżej są zbędne, nie mają wpływu na kolejność wykonywania operacji: x OR y AND zx OR (y AND z)Nawiasy w przykładzie poniżej zmieniają kolejność wykonywania operacji, więc nie można ich pominąć bez zmiany znaczenia zapytania: (x OR y) AND zNegacja warunków Poza operatorami łączenia, które już znasz, istnieje także operator negacji warunku. Służy do tego operator NOT. Ten operator ma wyższy priorytet niż OR czy AND. Także i w tym przypadku możesz użyć nawiasów aby zmienić kolejność wykonywanych operacji. Poniższy przykład pokazuje przypadek, w którym nawiasy nie mają wpływu na kolejność wykonywanych porównań: (NOT x) OR yNOT x OR yJednak umieszczenie nawiasów w innym miejscu zupełnie zmienia warunek, który musi zostać spełniony przez zwracane wiersze: NOT (x OR y)&lt;, &lt;=, =, !=, &gt;, &gt;=` Zacznę od najprostszych typów porównań. Podobne operatory występują także w językach programowania. Operatory porównują ze sobą wartości po obu stronach.   A &lt; B - wiersz spełnia warunek jeśli A jest mniejsze od B,  A &lt;= B - wiersz spełnia warunek jeśli A jest mniejsze bądź równe B,  A = B - wiersz spełnia warunek jeśli A jest równe B,  A != B - wiersz spełnia warunek jeśli A jest różne od B,  A &gt; B - wiersz spełnia warunek jeśli A jest większe od B,  A &gt;= B - wiersz spełnia warunek jeśli A jest większe bądź równe B.Na przykład zapytanie poniżej wyświetli tylko te wiersze z tabeli invoice, których wartość kolumny total będzie większa niż 14 i mniejsza niż 15: SELECT invoiceid      ,total  FROM invoice WHERE total &gt; 14   AND total &lt; 15;Następne zapytanie zwróci jedynie te wiersze, dla których kolumna total ma wartość 21.68: SELECT invoiceid      ,total      ,billingcountry  FROM invoice WHERE total = 21.86;Operatory = i != mają dwie postacie. W tym samym celu możesz także użyć odpowiednio == i &lt;&gt;. Porównywanie łańcuchów znaków W przypadku języka SQL operatory służą one do porównywania wartości kolumn. Mogą być użyte nie tylko do typów liczbowych. Dzięki tym operatorom można na przykład porównywać łańcuchy znaków. Zapytanie poniżej zwróci tylko te wiersze dla których kolumna billingcountry będzie większa niż A i mniejsza niż C. Innymi słowy zapytanie to zwróci wiersze, dla których billingcountry zawiera kraje zaczynające się na literę A albo B: SELECT *  FROM invoice WHERE billingcountry &gt; 'A'   AND billingcountry &lt; 'C';Porównywanie dat SQLite nie ma specjalnego typu do przechowywania dat. Do tego celu używane mogą być łańcuchy znaków lub liczby. W związku z tym porównywanie dat sprowadza się do porównywania tych typów danych. Na przykład zapytanie poniżej zwróci wszystkie wiersze, które zawierają faktury wystawione w Polsce od 26 maja 2012 roku. SELECT *  FROM invoice WHERE billingcountry = 'Poland'   AND invoicedate &gt; '2012-05-26';Przy porównaniach tego typu musisz uważać. Powyższe zapytanie zwróci wiersz, który zawiera datę 2012-05-26 00:00:00. Jeśli zmieniłbym warunek na invoicedate &gt; '2012-05-26 00:00:00' wówczas ten wiersz zostałby pominięty. BETWEEN Do określenia zakresu, w którym powinna znaleźć się wartość kolumny możesz użyć BETWEEN. Zapytanie poniżej zwróci wszystkie wiersze, dla których wartość kolumny total jest większa bądź równa 10.91 i mniejsza bądź równa 11.96: SELECT *  FROM invoice WHERE total BETWEEN 10.91 AND 11.96;Porównanie total BETWEEN 10.91 AND 11.96 jest tożsame porównaniu total &gt;= 10.91 AND total &lt;= 11.96. Warunek BETWEEN można poprzedzić NOT LIKE SQL pozwala także na bardziej swobodne porównywanie łańcuchów znaków. Do tego celu używa się konstrukcji LIKE. W tym przypadku możesz użyć dwóch symboli, które mają specjalne znaczenie:   % - oznacza dowolną liczbę znaków,  _ - oznacza jeden znak.Mechanizm ten można porównać do bardzo uproszczonych wyrażeń regularnych:   % odpowiada .* w wyrażeniach regularnych,  _ odpowiada . w wyrażeniach regularnych.Proszę spójrz na przykład poniżej. W przykładzie tym wyświetlam wyłącznie wiersze, w których wartość kolumny billingcountry pasuje do określenia %land. Innymi słowy wyświetlam wyłącznie te wiersze, które kończą się na land: SELECT *  FROM invoice WHERE billingcountry  LIKE '%land';Poniższe zapytanie jest lekką modyfikacją powyższego. Jak widzisz użyłem w nim % dwa razy. W tym przypadku wyświetlone zostaną wiersze, w których kolumna billingcountry zawiera ciąg znaków land: SELECT *  FROM invoice WHERE billingcountry  LIKE '%land%';Słowo kluczowe LIKE możesz poprzedzić NOT. Warunek NOT x LIKE y jest tożsamy warunkowi x NOT LIKE y. Jeśli chcesz aby znaki _ czy % były traktowane dosłownie musisz posłużyć się wyrażeniem ESCAPE. Proszę spójrz na przykład poniżej. Zapytanie zwraca wszystkie wiersze, dla których wewnątrz kolumny track występuje znak %: SELECT *  FROM track WHERE name LIKE '%e%%' ESCAPE 'e';Literał po ESCAPE może zawierać pojedynczy znak. Symbol ten jest użyty do poprzedzenia symbolu, który powinien być traktowany dosłownie. W przykładzie powyżej użyłem 'e'. IS NULL Niektóre wiersze mogą mieć puste kolumny. Puste, czyli takie, które nie są uzupełnione żadną wartością. W takim przypadku mówi się, że kolumna ma wartość NULL. Aby filtrować wiersze na podstawie tej wartości należy użyć wyrażenia IS NULL. Na przykład zapytanie poniżej pokazuje tylko te kraje, dla których wartość kolumny billingstate ma wartość NULL: SELECT *  FROM invoice WHERE billingstate IS NULL;Zwróć uwagę na to, że kolumna zawierająca łańcuch znaków '' (pusty łańcuch znaków) i wartość NULL to dwie zupełne różne rzeczy. Podobnie jak w przypadku LIKE także tutaj możesz użyć słowa kluczowego NOT. Warunki NOT x IS NULL i x IS NOT NULL są tożsame. IN Jeśli chcesz zwrócić wiersze, dla których kolumna przyjmuje jedną z określonych wartości możesz użyć IN. Zapytanie poniżej zwróci wszystkie wiersze z tabeli invoice, dla których billingcountry ma wartość 'USA' i billingstate jedną z wartości 'CA' lub 'TX': SELECT *  FROM invoice WHERE billingcountry = 'USA'   AND billingstate IN ('CA', 'TX');Użycie IN jest tożsame odpowiedniej liczbie warunków połączonych OR. Czym jest wstrzykiwanie SQL (ang. SQL Injection) Wstrzykiwanie SQL jest jednym z podstawowych ataków na aplikacje używające baz danych. Polega on na odpowiednim spreparowaniu danych wejściowych. W takim przypadku poza zapytaniem, które przygotuje programista wykonywane może być także to wprowadzone przez użytkownika. Proszę spójrz na przykład w języku Java. W ten sposób na pewno będzie Ci łatwiej zrozumieć ten typ ataku. Załóżmy, że w aplikacji próbujesz zaimplementować moduł logowania2. Użytkownik w formularzu wprowadza swój e-mail i hasło. Aby upewnić się, że podane dane są prawidłowe pobierane są wiersze, które pasują do przekazanych danych logowania. Programista napisał szablon zapytania, który następnie uzupełniany jest danymi od użytkownika: String emailProvidedByUser = \"...\";String passwordProvidedByUser = \"...\";String queryTemplate = \"SELECT password_hash FROM users WHERE email = '%s';\"String query = String.format(queryTemplate, emailProvidedByUser);String paswordHashInDatabase = executeQuery(query);boolean loginSuccessfull = magicHash(passwordProvidedByUser).equals(paswordHashInDatabase);Jeśli użytkownik wprowadzi email zenek@parapet.pl i hasło tajnehaslo to logowanie przebiegnie pomyślnie :). Problem zacznie się jeśli użytkownik zacznie być złośliwy. Co stanie się jeśli użytkownik wprowadzi email '; DELETE FROM users WHERE 1 = 1 OR email = ' i dowolne hasło? Do bazy zostanie wysłane następujące zapytanie: SELECT password_hash  FROM users WHERE email = ''; DELETE FROM users WHERE 1 = 1    OR email = '';Właściwie są to dwa zapytania. Bardziej istotne jest drugie z nich. Po jego wykonaniu z tabeli users zostaną usunięte wszystkie wiersze. To raczej nie jest efekt, którego spodziewał się programista ;). Zapobieganie SQL Injection Ręczne budowanie zapytań SQL poprzez łączenie łańcuchów znaków przeważnie nie jest dobrym rozwiązaniem. Używaj do tego celu dedykowanych bibliotek. W Języku Java może to być na przykład Hibernate. W Pythonie SQLalchemy też świetnie daje sobie z tym radę. Jestem pewien, że w innych językach programowania istnieją podobne rozwiązania. Biblioteki te domyślnie odpowiednio traktują dane, które służą do wypełniania szablonów zapytań. Jeśli chcesz budować zapytania “ręcznie”. Pamiętaj o odpowiednim traktowaniu danych pochodzących od użytkownika. Takim danym nigdy nie można ufać. Musisz założyć, że każdy użytkownik jest złośliwy i będzie chciał zepsuć Twoją aplikację. W najprostszym scenariuszu użycie '' w miejscu każdego znaku ' w danych pochodzących od użytkownika powinno pomóc. Zadania do wykonania Poniżej znajdziesz zestaw zadań, które pomogą Ci przećwiczyć materiał omówiony w tym artykule. Napisz zapytanie, które:   zwróci wszystkie wiersze z tabeli track, dla których: unitprice jest mniejsze niż 1 i znak % zawarty jest w kolumnie name oraz kolumna name kończy się na e,  zwróci wszystkie wiersze z tabeli invoice, które mają uzupełnioną kolumnę billingstate i nie są ze Stanów Zjednoczonych,  zwróci wszystkie wiersze z tabeli invoice, które dotyczą Polski, Czech albo Węgier dla których wartość faktury przekracza 10,  zwróci imiona pracowników z tabeli employee, które dotyczą pracowników urodzonych w latach 60.Podsumowanie Warunki masz już za sobą. Po rozwiązaniu zadań potrafisz sprawnie posługiwać się różnymi warunkami w języku SQL. Wiesz jak wygląda atak SQL injection i jak można się przed nim bronić. Jeśli znasz kogoś komu ta wiedza może się przydać proszę przekaż odnośnik do tego artykułu. Dzięki temu pomożesz mi dotrzeć do nowych czytelników a na tym właśnie mi zależy. Z góry dziękuję :). Jeśli nie chcesz pominąć kolejnych artykułów na blogu proszę polub Samouczka na Facebooku i dodaj swój adres e-mail do samouczkowego newslettera. Trzymaj się i do następnego razu!             To zależy od silnika bazy danych. SQLite wspiera literały tego typu. &#8617;               Do tej pory nie spotkałem się jeszcze z sytuacją, w której mechanizm logowania musiałbym pisać od podstaw samemu. Nie rób tego samodzielnie, użyj gotowego, sprawdzonego rozwiązania. &#8617;       ","categories": ["Bazy danych","Kurs SQL"],
        "tags": [],
        "url": "http://www.samouczekprogramisty.pl/klauzula-where-w-zapytaniach-sql/",
        "teaser":"http://www.samouczekprogramisty.pl/assets/images/2018/07/13_klauzula_where_w_zapytaniach_sql_artykul.jpeg"}]
