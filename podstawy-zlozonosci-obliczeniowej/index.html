<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.24.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="pl" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>Podstawy złożoności obliczeniowej - Samouczek Programisty</title>
<meta name="description" content="W artykule tym przeczytasz o złożoności obliczeniowej. Dowiesz się dlaczego jest ona ważna i kiedy jest wykorzystywana. Przeczytasz o tym czym jest notacja Ο (dużego O), Ω (omega) i Θ (theta). Na przykładach algorytmów poznasz najczęściej używane funkcje w notacji Ο. Po lekturze określenia złożoność liniowa czy złożoność logarytmiczna nie powinny być dla Ciebie problemem. Zapraszam!">


  <meta name="author" content="Marcin Pietraszek">
  
  <meta property="article:author" content="Marcin Pietraszek">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="pl">
<meta property="og:site_name" content="Samouczek Programisty">
<meta property="og:title" content="Podstawy złożoności obliczeniowej">
<meta property="og:url" content="https://www.samouczekprogramisty.pl/podstawy-zlozonosci-obliczeniowej/">


  <meta property="og:description" content="W artykule tym przeczytasz o złożoności obliczeniowej. Dowiesz się dlaczego jest ona ważna i kiedy jest wykorzystywana. Przeczytasz o tym czym jest notacja Ο (dużego O), Ω (omega) i Θ (theta). Na przykładach algorytmów poznasz najczęściej używane funkcje w notacji Ο. Po lekturze określenia złożoność liniowa czy złożoność logarytmiczna nie powinny być dla Ciebie problemem. Zapraszam!">



  <meta property="og:image" content="https://www.samouczekprogramisty.pl/assets/images/2017/11/13_zlozonosc_obliczeniowa_artykul.jpg">





  <meta property="article:published_time" content="2017-11-13T00:00:00+01:00">



  <meta property="article:modified_time" content="2019-01-29T21:45:00+01:00">



  

  


<link rel="canonical" href="https://www.samouczekprogramisty.pl/podstawy-zlozonosci-obliczeniowej/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "Marcin Pietraszek",
      "url": "https://www.samouczekprogramisty.pl/"
    
  }
</script>







<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="Samouczek Programisty Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="preload" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'">
<noscript><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css"></noscript>



    <link rel="shortcut icon" href="/assets/images/favicon.ico" /> 
<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.0.13/css/all.css" integrity="sha384-DNOHZ68U8hZfKXOrtjWvjxusGo9WQnrNx2sqG0tfsghAvtVlRW3tvkXWZh58N9jp" crossorigin="anonymous">

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
          <a class="site-logo" href="/"><img src="/assets/images/logo.gif" alt="Samouczek Programisty"></a>
        
        <a class="site-title" href="/">
          Samouczek Programisty
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/kurs-programowania-java/">Kurs programowania Java</a>
            </li><li class="masthead__menu-item">
              <a href="/kurs-aplikacji-webowych/">Kurs aplikacji webowych</a>
            </li><li class="masthead__menu-item">
              <a href="/kurs-sql/">Kurs SQL</a>
            </li><li class="masthead__menu-item">
              <a href="/kontakt/">Kontakt</a>
            </li></ul>
        
        <button class="search__toggle" type="button">
          <span class="visually-hidden">Toggle search</span>
          <i class="fas fa-search"></i>
        </button>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Przełącz menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      
  







<div class="page__hero--overlay"
  style=" background-image: linear-gradient(rgba(0, 0, 0, 0.5), rgba(0, 0, 0, 0.5)), url('/assets/images/2017/11/13_zlozonosc_obliczeniowa_artykul.jpg');"
>
  
    <div class="wrapper">
      <h1 id="page-title" class="page__title" itemprop="headline">
        
          Podstawy złożoności obliczeniowej

        
      </h1>
      
        <p class="page__lead">W artykule tym przeczytasz o złożoności obliczeniowej. Dowiesz się dlaczego jest ona ważna i kiedy jest wykorzystywana. Przeczytasz o tym czym jest notacja Ο (dużego O), Ω (omega) i Θ (theta). Na przykładach algorytmów poznasz najczęściej używane funkcje w notacji Ο. Po lekturze określenia złożoność liniowa czy złożoność logarytmiczna nie powinny być dla Ciebie problemem. Zapraszam!
</p>
      
      

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          13 minut(y)
        
      </span>
    
  </p>


      
      
    </div>
  
  
    <span class="page__hero-caption"><a href="https://www.flickr.com/photos/lytfyre/6489338411/sizes/l">© lytfyre</a>
</span>
  
</div>




  
    



<nav class="breadcrumbs">
  <ol itemscope itemtype="https://schema.org/BreadcrumbList">
    
    
    
      
        <li itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem">
          <a href="https://www.samouczekprogramisty.pl/" itemprop="item"><span itemprop="name">Strona główna</span></a>
          <meta itemprop="position" content="1" />
        </li>
        <span class="sep">/</span>
      
      
        <li class="current">Podstawy złożoności obliczeniowej</li>
      
    
  </ol>
</nav>

  


<div id="main" role="main">

  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="Podstawy złożoności obliczeniowej">
    <meta itemprop="description" content="W artykule tym przeczytasz o złożoności obliczeniowej. Dowiesz się dlaczego jest ona ważna i kiedy jest wykorzystywana. Przeczytasz o tym czym jest notacja Ο (dużego O), Ω (omega) i Θ (theta). Na przykładach algorytmów poznasz najczęściej używane funkcje w notacji Ο. Po lekturze określenia złożoność liniowa czy złożoność logarytmiczna nie powinny być dla Ciebie problemem. Zapraszam!">
    <meta itemprop="datePublished" content="November 13, 2017">
    <meta itemprop="dateModified" content="January 29, 2019">

    <div class="page__inner-wrap">
      

      <section class="page__content" itemprop="text">
        <aside class="sidebar__right ">
          
          <nav class="toc">
            <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> Spis treści</h4></header>
            <ul id="toc" class="section-nav">
<li class="toc-entry toc-h2"><a href="#teoria-obliczeń">Teoria obliczeń</a></li>
<li class="toc-entry toc-h2"><a href="#dlaczego-używamy-złożoności-obliczeniowej">Dlaczego używamy złożoności obliczeniowej</a>
<ul>
<li class="toc-entry toc-h3"><a href="#przykład-wyznaczania-złożoności-obliczeniowej">Przykład wyznaczania złożoności obliczeniowej</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#złożoność-obliczeniowa-a-funkcja">Złożoność obliczeniowa a funkcja</a>
<ul>
<li class="toc-entry toc-h3"><a href="#oszacowania-rzędu-złożoności-funkcji">Oszacowania rzędu złożoności funkcji</a></li>
<li class="toc-entry toc-h3"><a href="#notacja-ο-dużego-o">Notacja Ο (dużego O)</a></li>
<li class="toc-entry toc-h3"><a href="#notacja-ω-omega">Notacja Ω (omega)</a></li>
<li class="toc-entry toc-h3"><a href="#notacja-θ-theta">Notacja Θ (theta)</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#rząd-złożoności-obliczeniowej">Rząd złożoności obliczeniowej</a>
<ul>
<li class="toc-entry toc-h3"><a href="#ο1">Ο(1)</a></li>
<li class="toc-entry toc-h3"><a href="#οn">Ο(n)</a></li>
<li class="toc-entry toc-h3"><a href="#οlogn">Ο(log(n))</a></li>
<li class="toc-entry toc-h3"><a href="#οnlogn">Ο(nlog(n))</a></li>
<li class="toc-entry toc-h3"><a href="#οn2">Ο(n^2)</a></li>
<li class="toc-entry toc-h3"><a href="#οnx">Ο(n^x)</a></li>
<li class="toc-entry toc-h3"><a href="#οxn">Ο(x^n)</a></li>
<li class="toc-entry toc-h3"><a href="#οn-1">Ο(n!)</a></li>
</ul>
</li>
<li class="toc-entry toc-h2"><a href="#najlepszy-średni-i-najgorszy-przypadek">Najlepszy, średni i najgorszy przypadek</a></li>
<li class="toc-entry toc-h2"><a href="#dodatkowe-materiały-do-nauki">Dodatkowe materiały do nauki</a></li>
<li class="toc-entry toc-h2"><a href="#podsumowanie">Podsumowanie</a></li>
</ul>
          </nav>
          <hr />
          
          <div class="mailerlite__form">
            <script type="text/javascript" src="https://static.mailerlite.com/data/webforms/698980/y1i5k0.js?v7"></script>
          </div>
          <hr />
          <div class="fb-page">
            <a href="https://www.facebook.com/SamouczekProgramisty"><img src="/assets/images/facebook_logo.gif" alt="Profil Samouczka na Facebooku"/></a>
          </div>
        </aside>
        <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>

<div class="notice--warning">
  
<p>Artykuł ten zawiera jedynie podstawy związane z zagadnieniem złożoności obliczeniowej. Bynajmniej nie wyczerpuje tematu. Teoria obliczeń to osobny dział informatyki. Jeśli chcesz go zgłębić zachęcam Cię do przejrzenia dodatkowych materiałów do nauki.</p>

<p>Mam świadomość, że tłumaczenie złożoności obliczeniowej bez wspominania o maszynie Turinga to profanacja. Jednak dla zupełnie początkujących w temacie takie podejście wydaje mi się łatwiejsze.</p>

</div>

<h2 id="teoria-obliczeń">Teoria obliczeń</h2>

<p>Teoria obliczeń to dział informatyki. Jedną z gałęzi tego działu jest teoria złożoności obliczeniowej. W uproszczeniu można powiedzieć, że zajmuje się ona oszacowaniem wydajności czasowej i pamięciowej algorytmów. Teoria złożoności obliczeniowej bazuje na wielu modelach, które służą do łatwego porównywania algorytmów.</p>

<h2 id="dlaczego-używamy-złożoności-obliczeniowej">Dlaczego używamy złożoności obliczeniowej</h2>

<p>Komputerów na świecie są miliony. Wiele z nich bardzo się od siebie różni. Mają różny procesor, inny moduł RAM. Część z nich używa bardziej wydajnych dysków, które pozwalają na szybszy dostęp do danych. Dla części z nich dane dostępne są na zdalnych maszynach, do których trzeba łączyć się przez sieć. Są też mega-komputery, maszyny o ogromnej mocy obliczeniowej, czy smartfony w kieszeniach.</p>

<p>W związku z tą różnorodnością pojawia się potrzeba wspólnej miary. Miary, która jest niezależna od zmiennych czynników. Może ona pomóc zorientować się w wydajności danego algorytmu, przyporządkować go do zdefiniowanej klasy algorytmów. Tutaj w grę wkraczają modele, o których wspomniałem wcześniej. Modele te upraszczają zawiłości związane z różnorodnością sprzętu.</p>

<p>Mamy zatem wspólną bazę – model. Dalej jednak pozostaje pytanie: w jaki sposób mierzyć wydajność poszczególnych algorytmów? Mierzenie czasu jest mało praktyczne. Na modelu nie możemy mierzyć czasu. Mierzenie czasu nie ma większego sensu na komputerze z powodu różnorodności sprzętu. Otrzymane wyniki nie byłby miarodajne w przypadku innego komputera.</p>

<p>Mierzymy więc zatem liczbę operacji wykonanych na modelu. Następnie próbujemy znaleźć funkcję, która będzie opisywała liczbę operacji w zależności od wejścia algorytmu. Funkcje te możemy porównywać ze sobą.</p>

<h3 id="przykład-wyznaczania-złożoności-obliczeniowej">Przykład wyznaczania złożoności obliczeniowej</h3>

<p>Załóżmy że chcemy policzyć sumę elementów tablicy. Może nam w tym pomóc następujący algorytm:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Ile mamy w nim operacji? <code class="language-plaintext highlighter-rouge">int sum = 0;</code>, przypisanie to jedna operacja. Następnie mamy pętlę <code class="language-plaintext highlighter-rouge">for</code>. Jej ciało zawiera jedną operację. Sama pętla wykona się dokładnie tyle razy ile jest elementów tablicy <code class="language-plaintext highlighter-rouge">numbers</code>. Liczbę tych elementów określmy jako <code class="language-plaintext highlighter-rouge">n</code>. Na końcu mamy instrukcję <code class="language-plaintext highlighter-rouge">return sum;</code>. Jest to ostatnia operacja.</p>

<p>Dodając te operacje do siebie otrzymujemy wzór:</p>

\[f(n) = 1 + n + 1 = n + 2\]

<p>Zatem złożoność naszego algorytmu opisana jest przez funkcję <code class="language-plaintext highlighter-rouge">f(n) = n + 2</code>.</p>

<p class="notice--info">Tak dla przypomnienia ;). Funkcje możesz pamiętać z matematyki. Na przykład funkcja <code class="language-plaintext highlighter-rouge">f(x) = ax^2 + bx + c</code> opisuje <a href="https://pl.wikipedia.org/wiki/Parabola_(matematyka)">parabolę</a>.</p>

<h2 id="złożoność-obliczeniowa-a-funkcja">Złożoność obliczeniowa a funkcja</h2>

<p>Złożoność obliczeniową określamy jako funkcję danych wejściowych algorytmu. Wyznacza się ją jak opisałem w poprzednim punkcie – licząc operacje.</p>

<p>O ile dla naukowców znalezienie dokładnej funkcji może być bardzo istotne, to w praktyce wystarczą jej oszacowania. Takie oszacowania to notacja Ο (dużego O), notacja Ω (omega) i notacja Θ (theta).</p>

<h3 id="oszacowania-rzędu-złożoności-funkcji">Oszacowania rzędu złożoności funkcji</h3>

<p>Na tapetę bierzemy przykładową funkcję:</p>

\[f(n) = n^3 - 6n^2 + 4n + 12\]

<p>Możemy założyć, że funkcja ta dokładnie opisuje złożoność obliczeniową jakiegoś algorytmu. Argument <code class="language-plaintext highlighter-rouge">n</code> to rozmiar danych wejściowych do algorytmu. Wykres<sup id="fnref:grafy" role="doc-noteref"><a href="#fn:grafy" class="footnote" rel="footnote">1</a></sup> tej funkcji wygląda następująco:</p>

<figure class="">
  <img src="/assets/images/2017/11/13_wykres_funkcji_n3_6n2_4n_12.png" alt="" /><figcaption>
      Wykres funkcji <code class="language-plaintext highlighter-rouge">f(n) = n^3 - 6n^2 + 4n + 12</code>

    </figcaption></figure>

<h3 id="notacja-ο-dużego-o">Notacja Ο (dużego O)</h3>

<p>Notacja ta zakłada, że istnieje funkcja <code class="language-plaintext highlighter-rouge">g(n)</code>, dla której spełniona jest poniższa własność:</p>

\[\forall n \geqslant n_0 : f(n) \leqslant c * g(n)\]

<p>Teraz przetłumaczę te matematyczne hieroglify :). Własność ta oznacza, że wynik funkcji <code class="language-plaintext highlighter-rouge">g(n)</code> pomnożony przez jakąś stałą <code class="language-plaintext highlighter-rouge">c</code> będzie większy bądź równy wynikowi funkcji <code class="language-plaintext highlighter-rouge">f(n)</code>. Własność ta jest spełniona dla wszystkich <code class="language-plaintext highlighter-rouge">n</code>, które będą większe od <code class="language-plaintext highlighter-rouge">n0</code>. Jeszcze łatwiej wygląda to na wykresie:</p>

<figure class="">
  <img src="/assets/images/2017/11/13_wykres_funkcji_n3_6n2_4n_12_notacja_O.png" alt="" /><figcaption>
      Oszacowanie z góry, notacja Ο.

    </figcaption></figure>

<p>Powyższy wykres pokazuje dwie funkcje. Pierwszą, którą już znasz z poprzedniego wykresu. Druga to wykres funkcji <code class="language-plaintext highlighter-rouge">g(n) = n^3</code>. Jak widzisz od pewnego punktu zielona linia jest zawsze ponad czerwoną linią. To nic innego jak oszacowanie z góry. To właśnie jest notacja Ο. Zatem w naszym przypadku nasza funkcja <code class="language-plaintext highlighter-rouge">f(n)</code> ma złożoność <code class="language-plaintext highlighter-rouge">Ο(n^3)</code>.</p>

<p>W mojej dotychczasowej praktyce notacja Ο jest najczęściej spotykana do określania złożoności algorytmów.</p>

<p class="notice--info">Notacja Ο jest oszacowaniem z góry. Zatem można powiedzieć, że jeśli algorytm ma złożoność <code class="language-plaintext highlighter-rouge">Ο(n^2)</code> to ma także złożoność <code class="language-plaintext highlighter-rouge">Ο(n^3)</code> czy nawet <code class="language-plaintext highlighter-rouge">Ο(n!)</code>. Jednak <code class="language-plaintext highlighter-rouge">Ο(n^2)</code> może być najlepszym oszacowaniem złożoności danego algorytmu.</p>

<p class="notice--info">Z racji tego, że jest to oszacowanie pomijamy w nim wszelkiego rodzaju stałe. Zatem <code class="language-plaintext highlighter-rouge">Ο(2n + 123)</code>, <code class="language-plaintext highlighter-rouge">Ο(2n)</code> i <code class="language-plaintext highlighter-rouge">Ο(n)</code> to ta sama złożoność obliczeniowa. Stałe te i tak nie mają znaczenia przy odpowiednio dużych wartościach <code class="language-plaintext highlighter-rouge">n</code>.</p>

<div class="notice--success text-center">
  
<p><span class="c_almost-header">Pobierz opracowania zadań z rozmów kwalifikacyjnych</span></p>

<p>Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy <strong>ponad 6147 Samouków</strong>, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.</p>

<script type="text/javascript" src="https://static.mailerlite.com/data/webforms/704312/f8q4i2.js?v4"></script>


</div>

<h3 id="notacja-ω-omega">Notacja Ω (omega)</h3>

<p>Notacja ta różni się od poprzedniej własnością, którą spełnia nowa funkcja:</p>

\[\forall n \geqslant n_0 : f(n) \geqslant c * g(n)\]

<p>Własność ta oznacza, że wynik funkcji <code class="language-plaintext highlighter-rouge">g(n)</code> pomnożony przez jakąś stałą <code class="language-plaintext highlighter-rouge">c</code> będzie mniejszy bądź równy wynikowi funkcji <code class="language-plaintext highlighter-rouge">f(n)</code>. Własność ta jest spełniona dla wszystkich <code class="language-plaintext highlighter-rouge">n</code>, które będą większe od <code class="language-plaintext highlighter-rouge">n0</code>. Ponownie wykres pomoże Ci to zrozumieć:</p>

<figure class="">
  <img src="/assets/images/2017/11/13_wykres_funkcji_n3_6n2_4n_12_notacja_omega.png" alt="" /><figcaption>
      Oszacowanie z dołu, notacja Ω.

    </figcaption></figure>

<p>Na wykresie widoczne są dwie funkcje. Pierwszą znasz. Druga to wykres funkcji <code class="language-plaintext highlighter-rouge">g(n) = n^2</code>. “Ostatni” punkt przecięcia tych dwóch wykresów, to <code class="language-plaintext highlighter-rouge">n0</code><sup id="fnref:punkt" role="doc-noteref"><a href="#fn:punkt" class="footnote" rel="footnote">2</a></sup>. Od tego miejsca wykres funkcji <code class="language-plaintext highlighter-rouge">g(n)</code> jest zawsze pod wykresem funkcji <code class="language-plaintext highlighter-rouge">f(n)</code>. Możemy powiedzieć, że funkcja <code class="language-plaintext highlighter-rouge">f(n)</code> ma złożoność <code class="language-plaintext highlighter-rouge">Ω(n^2)</code>.</p>

<h3 id="notacja-θ-theta">Notacja Θ (theta)</h3>

<p>Można powiedzieć, że notacja Θ to połączenie notacji Ο i Ω. W tym przypadku funkcja użyta do oszacowania musi spełniać zależność:</p>

\[\forall n \geqslant n_0 : c_1 * g(n) \geqslant f(n) \geqslant c_2 * g(n)\]

<p>Tłumacząc to na polski można powiedzieć, że wynik funkcji <code class="language-plaintext highlighter-rouge">g(n)</code> pomnożony przez stałą <code class="language-plaintext highlighter-rouge">c1</code> będzie większy bądź równy wartości funkcji <code class="language-plaintext highlighter-rouge">f(n)</code>. Jednocześnie będzie mniejszy bądź równy wartości funkcji <code class="language-plaintext highlighter-rouge">f(n)</code> jeśli pomnożymy go przez stałą <code class="language-plaintext highlighter-rouge">c2</code>. Ponownie wykres może pomóc to zrozumieć:</p>

<figure class="">
  <img src="/assets/images/2017/11/13_wykres_funkcji_n3_6n2_4n_12_notacja_theta.png" alt="" /><figcaption>
      Dokładne oszacowanie rzędu, notacja Θ.

    </figcaption></figure>

<p>W naszym przypadku funkcję <code class="language-plaintext highlighter-rouge">g(n)</code> możemy opisać wzorem <code class="language-plaintext highlighter-rouge">g(n) = (n-4)^3</code>. Stałe mają odpowiednio wartości <code class="language-plaintext highlighter-rouge">c1 = 5</code>, <code class="language-plaintext highlighter-rouge">c2 = 1</code>. Wykres oznaczony kolorem niebieskim to wynik funkcji <code class="language-plaintext highlighter-rouge">g(n)</code> przemnożony przez stałą <code class="language-plaintext highlighter-rouge">c1</code>. Wykres oznaczony kolorem fioletowym to wynik funkcji <code class="language-plaintext highlighter-rouge">g(n)</code> przemnożony przez stałą <code class="language-plaintext highlighter-rouge">c2</code>.</p>

<p class="notice--info">Jak wcześniej wspomniałem notacja Ο jest najczęściej spotykana. W dalszej części artykułu będę odnosił się tylko do tej notacji.</p>

<h2 id="rząd-złożoności-obliczeniowej">Rząd złożoności obliczeniowej</h2>

<p>Tu także skupię się na przykładzie wzoru wałkowanego wcześniej:</p>

\[f(n) = n^3 - 6n^2 + 4n + 12\]

<p>Jak wspomniałem wcześniej w praktyce nie potrzebujemy tak dokładnego wzoru wystarczy jedynie zgrubne oszacowanie, które uwzględnia najbardziej istotny element funkcji. Który element funkcji jest najbardziej istotny? Ten, który ma największy wpływ na ostateczny wynik funkcji. Jak to sprawdzić? Wystarczy pod <code class="language-plaintext highlighter-rouge">n</code> podstawić bardzo dużą liczbę i zobaczyć, który element będzie miał największą wartość. Na przykład:</p>

<table>
  <thead>
    <tr>
      <th>Element</th>
      <th>Wartość przy <code class="language-plaintext highlighter-rouge">n = 1'000'000'000</code></th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">n^3</code></td>
      <td>1’000’000’000’000’000’000’000’000’000</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">6n^2</code></td>
      <td>6’000’000’000’000’000’000</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">4n</code></td>
      <td>4’000’000’000</td>
    </tr>
    <tr>
      <td><code class="language-plaintext highlighter-rouge">12</code></td>
      <td>12</td>
    </tr>
  </tbody>
</table>

<p>Jak widzisz, przy odpowiednio dużych wartościach <code class="language-plaintext highlighter-rouge">n</code> część “elementów równania” jest mniej istotna. W przypadku funkcji powyżej najszybciej rosnącym elementem jest <code class="language-plaintext highlighter-rouge">n^3</code>. Ma on największy wpływ na ostateczny wynik funkcji.</p>

<p>Wiesz już z powyższych rozważań, że funkcja f(n) ma złożoność <code class="language-plaintext highlighter-rouge">Ο(n^3)</code>. Jest to tak zwana złożoność wielomianowa. Istnieje kilka popularnych rzędów złożoności obliczeniowej.</p>

<h3 id="ο1"><code class="language-plaintext highlighter-rouge">Ο(1)</code></h3>

<p>Złożoność stała, niezależna od liczby danych wejściowych. Mówimy, że problem o złożoności <code class="language-plaintext highlighter-rouge">Ο(1)</code> możemy rozwiązać w stałym czasie niezależnie od wielkości danych wejściowych. Przykład problemu, dla którego istnieje algorytm <code class="language-plaintext highlighter-rouge">Ο(1)</code>:</p>

<blockquote>
  <p>Na wejściu programu jest tablica liczb o długości N. Liczby są posortowane rosnąco. Pomiędzy dwoma sąsiadującymi liczbami różnica jest stała. Znajdź sumę liczb w tablicy.</p>
</blockquote>

<p>Problem to nic innego jak obliczenie sumy <a href="https://pl.wikipedia.org/wiki/Ci%C4%85g_arytmetyczny">ciągu arytmetycznego</a>. Istnieje na to wzór, który można zaimplementować:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">numbers</span> <span class="o">==</span> <span class="kc">null</span> <span class="o">||</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">==</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="mi">0</span><span class="o">]</span> <span class="o">+</span> <span class="n">numbers</span><span class="o">[</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">])</span> <span class="o">*</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>W tym przypadku nie potrzebujemy iterować po elementach tablicy. Niezależnie od wielkości tablicy wejściowej możemy obliczyć sumę ciągu w stałym czasie.</p>

<h3 id="οn"><code class="language-plaintext highlighter-rouge">Ο(n)</code></h3>

<p>Złożoność liniowa. Jest to specyficzny przypadek złożoności wielomianowej. Czas rozwiązania problemu jest wprost proporcjonalny do wielkości danych wejściowych. Przykład problemu, dla którego istnieje algorytm <code class="language-plaintext highlighter-rouge">Ο(n)</code>:</p>

<blockquote>
  <p>Na wejściu programu jest tablica liczb o długości N. Znajdź sumę wszystkich liczb w tablicy wejściowej.</p>
</blockquote>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span> <span class="nf">sum</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
        <span class="n">sum</span> <span class="o">+=</span> <span class="n">number</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">sum</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Aby znaleźć tę sumę należy sprawdzić wszystkie elementy tablicy. Musimy zatem odbyć N kroków.</p>

<h3 id="οlogn"><code class="language-plaintext highlighter-rouge">Ο(log(n))</code></h3>

<p>Złożoność logarytmiczna, czas rozwiązania zależy od wyniku logarytmu<sup id="fnref:podstawa" role="doc-noteref"><a href="#fn:podstawa" class="footnote" rel="footnote">3</a></sup> z wielkości danych wejściowych. Przykład problemu, dla którego istnieje algorytm <code class="language-plaintext highlighter-rouge">Ο(log(n))</code>:</p>

<blockquote>
  <p>Na wejściu programu jest posortowana tablica liczb o długości N. Sprawdź czy liczba x istnieje w tablicy wejściowej.</p>
</blockquote>

<p>To popularny algorytm przeszukiwania binarnego. Jego nazwa pochodzi od tego, że przy każdej iteracji algorytmu dzielimy przeszukiwany zbiór na dwie równe<sup id="fnref:rowne" role="doc-noteref"><a href="#fn:rowne" class="footnote" rel="footnote">4</a></sup> części. Algorytmy, które dzielą w ten sposób problem na mniejsze problemy przeważnie są zależne od logarytmu wielkości danych wejściowych.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">boolean</span> <span class="nf">binarySearch</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">,</span> <span class="kt">int</span> <span class="n">number</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">indexLow</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">indexHigh</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">indexLow</span> <span class="o">&lt;=</span> <span class="n">indexHigh</span><span class="o">)</span> <span class="o">{</span>
        <span class="kt">int</span> <span class="n">indexMiddle</span> <span class="o">=</span> <span class="n">indexLow</span> <span class="o">+</span> <span class="o">(</span><span class="n">indexHigh</span> <span class="o">-</span> <span class="n">indexLow</span><span class="o">)</span> <span class="o">/</span> <span class="mi">2</span><span class="o">;</span>

        <span class="k">if</span> <span class="o">(</span><span class="n">number</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="o">[</span><span class="n">indexMiddle</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">indexHigh</span> <span class="o">=</span> <span class="n">indexMiddle</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">number</span> <span class="o">&gt;</span> <span class="n">numbers</span><span class="o">[</span><span class="n">indexMiddle</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">indexLow</span> <span class="o">=</span> <span class="n">indexMiddle</span> <span class="o">+</span> <span class="mi">1</span><span class="o">;</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="k">return</span> <span class="kc">true</span><span class="o">;</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="kc">false</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<h3 id="οnlogn"><code class="language-plaintext highlighter-rouge">Ο(nlog(n))</code></h3>

<p>Złożoność liniowo-logarytmiczna. Czas rozwiązania problemu jest wprost proporcjonalny do iloczynu wielkości danych wejściowych i ich logarytmu. Przykładem problemu dla którego istnieje algorytm o złożoności <code class="language-plaintext highlighter-rouge">Ο(nlog(n))</code> jest:</p>

<blockquote>
  <p>Na wejściu programu jest tablica liczb. Zwróć tablicę, która będzie zawierała te same elementy, które są w tablicy wejściowej. Tablica wynikowa powinna być posortowana w porządku rosnącym.</p>
</blockquote>

<p>Powyższy problem to sortowanie. Jeden z ze standardowych problemów w informatyce. Algorytmem sortującym, który ma złożoność obliczeniową <code class="language-plaintext highlighter-rouge">Ο(nlog(n))</code> jest sortowanie przez scalanie (ang. <em>merge sort</em>):</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">if</span> <span class="o">(</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">return</span> <span class="n">numbers</span><span class="o">;</span>
    <span class="o">}</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">first</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">/</span> <span class="mi">2</span><span class="o">];</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">second</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="n">first</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">first</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">first</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">second</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">second</span><span class="o">[</span><span class="n">i</span><span class="o">]</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">first</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">i</span><span class="o">];</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="nf">merge</span><span class="o">(</span><span class="n">sort</span><span class="o">(</span><span class="n">first</span><span class="o">),</span> <span class="n">sort</span><span class="o">(</span><span class="n">second</span><span class="o">));</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">merge</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">first</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">second</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span><span class="o">[]</span> <span class="n">merged</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">first</span><span class="o">.</span><span class="na">length</span> <span class="o">+</span> <span class="n">second</span><span class="o">.</span><span class="na">length</span><span class="o">];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">indexFirst</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">indexSecond</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">indexMerged</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">indexMerged</span> <span class="o">&lt;</span> <span class="n">merged</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">indexMerged</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">indexFirst</span> <span class="o">&gt;=</span> <span class="n">first</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">merged</span><span class="o">[</span><span class="n">indexMerged</span><span class="o">]</span> <span class="o">=</span> <span class="n">second</span><span class="o">[</span><span class="n">indexSecond</span><span class="o">++];</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">indexSecond</span> <span class="o">&gt;=</span> <span class="n">second</span><span class="o">.</span><span class="na">length</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">merged</span><span class="o">[</span><span class="n">indexMerged</span><span class="o">]</span> <span class="o">=</span> <span class="n">first</span><span class="o">[</span><span class="n">indexFirst</span><span class="o">++];</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="o">(</span><span class="n">first</span><span class="o">[</span><span class="n">indexFirst</span><span class="o">]</span> <span class="o">&lt;=</span> <span class="n">second</span><span class="o">[</span><span class="n">indexSecond</span><span class="o">])</span> <span class="o">{</span>
            <span class="n">merged</span><span class="o">[</span><span class="n">indexMerged</span><span class="o">]</span> <span class="o">=</span> <span class="n">first</span><span class="o">[</span><span class="n">indexFirst</span><span class="o">++];</span>
        <span class="o">}</span>
        <span class="k">else</span> <span class="o">{</span>
            <span class="n">merged</span><span class="o">[</span><span class="n">indexMerged</span><span class="o">]</span> <span class="o">=</span> <span class="n">second</span><span class="o">[</span><span class="n">indexSecond</span><span class="o">++];</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">merged</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Algorytm dzieli tablicę na części do czasu aż każda z nich będzie miała długość 1. Następnie scala je ze sobą. Każde takie scalenie to koszt <code class="language-plaintext highlighter-rouge">Ο(n)</code>. W związku z tym, że tablicę wejściową dzieliliśmy za każdym razem na pół takich scaleń mamy <code class="language-plaintext highlighter-rouge">log(n)</code>. Zatem wynikowa złożoność algorytmu to <code class="language-plaintext highlighter-rouge">Ο(nlog(n))</code>.</p>

<p>Jak widzisz obliczanie złożoności obliczeniowej bardziej skomplikowanych algorytmów nie jest takie łatwe.</p>

<h3 id="οn2"><code class="language-plaintext highlighter-rouge">Ο(n^2)</code></h3>

<p>Złożoność kwadratowa. Jest to specyficzny przypadek złożoności wielomianowej. Przykładowy problem może być ten, który użyłem wyżej – posortowanie tablicy. Tym razem jednak algorytm jest mniej wydajny. <a href="https://pl.wikipedia.org/wiki/Sortowanie_b%C4%85belkowe">Sortowanie bąbelkowe</a> charakteryzuje się złożonością obliczeniową <code class="language-plaintext highlighter-rouge">Ο(n^2)</code>:</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">sort</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span> <span class="n">i</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span> <span class="o">-</span> <span class="mi">1</span><span class="o">;</span> <span class="n">j</span><span class="o">++)</span> <span class="o">{</span>
            <span class="k">if</span> <span class="o">(</span><span class="n">numbers</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">&gt;</span> <span class="n">numbers</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">])</span> <span class="o">{</span>
                <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">];</span>
                <span class="n">numbers</span><span class="o">[</span><span class="n">j</span> <span class="o">+</span> <span class="mi">1</span><span class="o">]</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">j</span><span class="o">];</span>
                <span class="n">numbers</span><span class="o">[</span><span class="n">j</span><span class="o">]</span> <span class="o">=</span> <span class="n">temp</span><span class="o">;</span>
            <span class="o">}</span>
        <span class="o">}</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">numbers</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Mamy tutaj dwie zagnieżdżone pętle. Każda z nich iteruje po <code class="language-plaintext highlighter-rouge">n</code> elementach. W związku z tym otrzymujemy złożoność <code class="language-plaintext highlighter-rouge">Ο(n^2)</code>.</p>

<h3 id="οnx"><code class="language-plaintext highlighter-rouge">Ο(n^x)</code></h3>

<p>Złożoność wielomianowa. Jak już wiesz złożoność liniowa i złożoność kwadratowa są specyficznymi przypadkami złożoności wielomianowej. Ze względu na częste występowanie wyszczególniłem je jako osobne rzędy złożoności. Przykłady problemów i rozwiązań znajdziesz w poprzednich punktach.</p>

<h3 id="οxn"><code class="language-plaintext highlighter-rouge">Ο(x^n)</code></h3>

<p>Jest to złożoność wykładnicza, jej przykładem może być <code class="language-plaintext highlighter-rouge">Ο(2^n)</code>. Problemem, który ma rozwiązanie o złożoności co najmniej <code class="language-plaintext highlighter-rouge">Ο(2^n)</code> jest:</p>

<blockquote>
  <p>Na wejściu programu jest tablica unikalnych liczb. Zwróć tablicę, która będzie zawierała wszystkie możliwe podzbiory elementów tablicy wejściowej.</p>
</blockquote>

<p>Wynika to z faktu, że wszystkich możliwych podzbiorów zbioru, który ma <code class="language-plaintext highlighter-rouge">n</code> elementów jest dokładnie <code class="language-plaintext highlighter-rouge">2^n</code>. Poniższy algorytm ma złożoność <code class="language-plaintext highlighter-rouge">Ο(log(n)2^n)</code>.</p>

<div class="language-java highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">public</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[][]</span> <span class="nf">powerSet</span><span class="o">(</span><span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">two_pow_n</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">numbers</span><span class="o">.</span><span class="na">length</span><span class="o">;</span>

    <span class="kt">int</span><span class="o">[][]</span> <span class="n">powerSet</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">two_pow_n</span><span class="o">][];</span>
    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">subsetIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">subsetIndex</span> <span class="o">&lt;</span> <span class="n">two_pow_n</span><span class="o">;</span> <span class="n">subsetIndex</span><span class="o">++)</span> <span class="o">{</span>
        <span class="n">powerSet</span><span class="o">[</span><span class="n">subsetIndex</span><span class="o">]</span> <span class="o">=</span> <span class="n">pickNumbers</span><span class="o">(</span><span class="n">subsetIndex</span><span class="o">,</span> <span class="n">numbers</span><span class="o">);</span>
    <span class="o">}</span>
    <span class="k">return</span> <span class="n">powerSet</span><span class="o">;</span>
<span class="o">}</span>

<span class="kd">private</span> <span class="kd">static</span> <span class="kt">int</span><span class="o">[]</span> <span class="nf">pickNumbers</span><span class="o">(</span><span class="kt">int</span> <span class="n">subsetIndex</span><span class="o">,</span> <span class="kt">int</span><span class="o">[]</span> <span class="n">numbers</span><span class="o">)</span> <span class="o">{</span>
    <span class="kt">int</span> <span class="n">howManyOnes</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span>
    <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">subsetIndex</span><span class="o">;</span>
    <span class="k">while</span> <span class="o">(</span><span class="n">temp</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">temp</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">howManyOnes</span><span class="o">++;</span>
        <span class="o">}</span>
        <span class="n">temp</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="kt">int</span><span class="o">[]</span> <span class="n">subset</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="o">[</span><span class="n">howManyOnes</span><span class="o">];</span>

    <span class="k">for</span> <span class="o">(</span><span class="kt">int</span> <span class="n">charIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">,</span> <span class="n">lastElementIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="o">;</span> <span class="n">subsetIndex</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="o">;</span> <span class="n">charIndex</span><span class="o">++)</span> <span class="o">{</span>
        <span class="k">if</span> <span class="o">(</span><span class="n">subsetIndex</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="o">)</span> <span class="o">{</span>
            <span class="n">subset</span><span class="o">[</span><span class="n">lastElementIndex</span><span class="o">++]</span> <span class="o">=</span> <span class="n">numbers</span><span class="o">[</span><span class="n">charIndex</span><span class="o">];</span>
        <span class="o">}</span>
        <span class="n">subsetIndex</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="o">;</span>
    <span class="o">}</span>

    <span class="k">return</span> <span class="n">subset</span><span class="o">;</span>
<span class="o">}</span>
</code></pre></div></div>

<p>Wynika to z faktu, że pętla wewnątrz metody <code class="language-plaintext highlighter-rouge">powerSet</code> wywołana jest dokładnie <code class="language-plaintext highlighter-rouge">2^n</code> razy. Natomiast wewnątrz metody <code class="language-plaintext highlighter-rouge">pickNumbers</code> są dwie pętle. Każda z nich ma złożoność <code class="language-plaintext highlighter-rouge">Ο(log(n))</code>. Zatem finalna złożoność algorytmu to <code class="language-plaintext highlighter-rouge">Ο(log(n)2^n)</code>.</p>

<p>Spróbuj uruchomić ten kod z tablicą wejściową z 30 elementami, życzę powodzenia ;).</p>

<h3 id="οn-1"><code class="language-plaintext highlighter-rouge">Ο(n!)</code></h3>

<p>Jest to złożoność typu silnia.  Dla przypomnienia silnia <code class="language-plaintext highlighter-rouge">n</code>, albo inaczej <code class="language-plaintext highlighter-rouge">n!</code> to iloczyn wszystkich liczb od 1 do <code class="language-plaintext highlighter-rouge">n</code>. Na przykład <code class="language-plaintext highlighter-rouge">3! = 1 * 2 * 3 = 6</code>. Przykładem problemu, dla którego istnieje naiwny algorytm o tej złożoności to <a href="https://pl.wikipedia.org/wiki/Problem_komiwoja%C5%BCera">problem komiwojażera</a>:</p>

<blockquote>
  <p>Na wejściu programu jest <code class="language-plaintext highlighter-rouge">n</code> miast oraz odległości pomiędzy każdą parą miast. Zakładając, że komiwojażer zaczyna z miasta A i ma dojść do miasta B jaką trasę powinien pokonać aby była ona najkrótsza?</p>
</blockquote>

<p>Nie silę się nawet na naiwny algorytm dla tego problemu, nie jest on możliwy do uruchomienia na dzisiejszych komputerach dla problemów odpowiednio dużych. Wyobraź sobie, skalę możliwych rozwiązań. <code class="language-plaintext highlighter-rouge">(60 - 1)!/2 ~= 6,9 * 10^79</code><sup id="fnref:wyjasnienie" role="doc-noteref"><a href="#fn:wyjasnienie" class="footnote" rel="footnote">5</a></sup>. Szacowana liczba atomów wodoru w widzialnym wszechświecie to około <a href="https://en.wikipedia.org/wiki/Observable_universe#Matter_content_.E2.80.93_number_of_atoms"><code class="language-plaintext highlighter-rouge">10^80</code></a>. Przekładając to na problem wyżej, możliwych dróg pomiędzy 60 miastami jest tylko 31% mniej niż atomów wodoru w widzialnym wszechświecie ;).</p>

<h2 id="najlepszy-średni-i-najgorszy-przypadek">Najlepszy, średni i najgorszy przypadek</h2>

<p>Ten sam algorytm może zachowywać się zupełnie inaczej w przypadku innych danych wejściowych. Nie mówię tu o wielkości problemu, wielkości danych wejściowych. A o instancji problemu.</p>

<p>Jeśli algorytm jako dane wejściowe przyjmuje tablicę liczb to wielkością problemu może być 5 – tablica o długości 5. Natomiast instancji tego problemu jest nieskończenie wiele: <code class="language-plaintext highlighter-rouge">[1, 2, 3, 4, 5]</code>, <code class="language-plaintext highlighter-rouge">[-1, 2, -3, 4, -5]</code> czy <code class="language-plaintext highlighter-rouge">[5, 4, 3, 2, 1]</code>. Algorytm może mieć różną złożoność obliczeniową określoną w notacji <code class="language-plaintext highlighter-rouge">Ο</code> w zależności od instancji problemu. Są także algorytmy, których złożoność obliczeniowa jest niezależna od instancji problemu.</p>

<p>W zależności od wymagań w wyborze algorytmu bierze się pod uwagę złożoność odpowiedniego przypadku.</p>

<h2 id="dodatkowe-materiały-do-nauki">Dodatkowe materiały do nauki</h2>

<p>Informacji na temat teorii obliczeń i złożoności obliczeniowej w internecie jest sporo. Jednak dość ciężko jest znaleźć jakiekolwiek informacje, które są na początkującym poziomie. Niemniej jednak poniżej starałem się zebrać materiały, które mogą być interesujące:</p>

<ul>
  <li><a href="http://cpp0x.pl/kursy/Teoria-w-Informatyce/424">Kilka krótkich artykułów opisujących podstawy teorii obliczeń</a>,</li>
  <li><a href="http://theory.cs.princeton.edu/complexity/">Computational Complexity: A Modern Approach</a>, szkic książki o złożoności obliczeniowej. Jej ostateczna wersja dostępna jest na <a href="http://amzn.to/2zxrqqs">Amazonie</a>,</li>
  <li><a href="https://plato.stanford.edu/entries/computational-complexity/">Artykuł na temat złożoności obliczeniowej z uniwersytetu Stanford</a>,</li>
  <li><a href="https://www.wolframalpha.com/examples/ComputationalComplexity.html">Sekcja Wolfram Alpha poświęcona złożoności obliczeniowej</a>,</li>
  <li><a href="https://pl.wikipedia.org/wiki/Asymptotyczne_tempo_wzrostu">Artykuł na Wikipedii na temat funkcji służących do szacowania</a>,</li>
  <li><a href="https://codility.com/media/train/1-TimeComplexity.pdf">Artykuł o złożoności obliczeniowej na Codility</a><sup id="fnref:marek" role="doc-noteref"><a href="#fn:marek" class="footnote" rel="footnote">6</a></sup>,</li>
  <li><a href="https://github.com/SamouczekProgramisty/MaterialyRozne/tree/master/02_computational_complexity/src/main/java/pl/samouczekprogramisty/misc/complexity">Fragmenty kodu użyte w tym artykule</a>.</li>
</ul>

<h2 id="podsumowanie">Podsumowanie</h2>

<p>Jeśli zrozumiałeś ten artykuł możesz śmiało powiedzieć, że wiesz czym jest złożoność obliczeniowa. Wiesz jak ją szacować, znasz przykłady algorytmów z najczęściej spotykanych rzędów złożoności obliczeniowej. Znasz kilka notacji do określania złożoności. Dowiedziałeś się też ile jest atomów wodoru we wszechświecie ;). W każdym razie masz za sobą spory kawałek lektury i sporo wiedzy.</p>

<p>Na koniec mam do Ciebie prośbę. Proszę podziel się tym artykułem ze swoimi znajomymi, sporo się nad nim napracowałem. Mam nadzieję, że będzie mógł pomóc jak największej grupie osób. Jeśli nie chcesz ominąć kolejnych artykułów w przyszłości polub Samouczka na Facebooku i zapisz się do newslettera. Do następnego razu!</p>
<div class="footnotes" role="doc-endnotes">
  <ol>
    <li id="fn:grafy" role="doc-endnote">
      <p>Wykresy użyte w tym artykule stworzyłem przy pomocy <a href="https://graphsketch.com/">graphsketch</a>. <a href="#fnref:grafy" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:punkt" role="doc-endnote">
      <p>To oczywiście kolejne uproszczenie, punkt to para dwóch liczb. <code class="language-plaintext highlighter-rouge">n0</code> jest jedną z nich – tą na osi poziomej. Dasz radę wyznaczyć drugą współrzędną? ;) <a href="#fnref:punkt" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:podstawa" role="doc-endnote">
      <p>Podstawą logarytmu przeważnie jest 2. Zdarzają się także algorytmy, w których logarytm ma inną podstawę. <a href="#fnref:podstawa" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:rowne" role="doc-endnote">
      <p>Oczywiście, w przypadku tablicy o nieparzystej długości jedna z części nie będzie “równiejsza” od drugiej ;). <a href="#fnref:rowne" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:wyjasnienie" role="doc-endnote">
      <p>Z pierwszego miasta mamy możliwość pójść do 59 miast, następnie możemy wybrać 58 miast, itd. Wynik dzielony jest przez 2 ponieważ nie ma znaczenia czy pójdziemy z miasta A do miasta B czy odwrotnie. <a href="#fnref:wyjasnienie" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
    <li id="fn:marek" role="doc-endnote">
      <p>Wielkie dzięki dla Marka za podesłanie linka do tego artykułu. <a href="#fnref:marek" class="reversefootnote" role="doc-backlink">&#8617;</a></p>
    </li>
  </ol>
</div>

        

<div class="notice--success text-center">
  
<p><span class="c_almost-header">Pobierz opracowania zadań z rozmów kwalifikacyjnych</span></p>

<p>Przygotowałem rozwiązania kilku zadań algorytmicznych z rozmów kwalifikacyjnych. Rozkładam je na czynniki pierwsze i pokazuję różne sposoby ich rozwiązania. Dołącz do grupy <strong>ponad 6147 Samouków</strong>, którzy jako pierwsi dowiadują się o nowych treściach na blogu, a prześlę je na Twój e-mail.</p>

<script type="text/javascript" src="https://static.mailerlite.com/data/webforms/698960/m0b4d5.js?v4"></script>


</div>

        
      </section>

      <footer class="page__meta">
        
        


  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Kategorie: </strong>
    <span itemprop="keywords">
    
      <a href="/kategorie/#programowanie" class="page__taxonomy-item" rel="tag">Programowanie</a><span class="sep">, </span>
    
      <a href="/kategorie/#wiedza-og%C3%B3lna" class="page__taxonomy-item" rel="tag">Wiedza ogólna</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Ostatnia aktualizacja:</strong> <time datetime="2019-01-29">2019-01-29</time></p>
        
        <p><strong><i class="fas fa-fw fa-child" aria-hidden="true"></i> Autor: </strong><a href="/o-mnie/">Marcin Pietraszek</a></p>
        <hr />
        <p>
          Nie popełnia błędów tylko ten, kto nic nie robi ;). Bardzo możliwe, że znajdziesz błąd, literówkę, coś co wymaga poprawy. Jeśli chcesz możesz samodzielnie 
          <a href="https://github.com/SamouczekProgramisty/samouczekprogramisty.github.io/edit/source/_posts/2017-11-13-podstawy-zlozonosci-obliczeniowej.md">poprawić tę stronę</a>. Jeśli nie chcesz poprawiać błędu, który udało Ci się znaleźć będę wdzięczny jeśli go 
          <a href="https://github.com/SamouczekProgramisty/samouczekprogramisty.github.io/issues/new?title=Błąd%20na%20stronie:%20_posts/2017-11-13-podstawy-zlozonosci-obliczeniowej.md">zgłosisz</a>. Z góry dziękuję!
        </p>
      </footer>
    </div>

    
      <div class="page__comments">
  
  
      <h4 class="page__comments-title">Zostaw komentarz</h4>
      <section id="disqus_thread"></section>
    
</div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">Także może Ci się spodobać</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/2019/02/02_watki_w_jezyku_java_artykul.jpg" alt="">
      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/watki-w-jezyku-java/" rel="permalink">Wątki w języku Java
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          10 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Artykuł ten opisuje wątki w języku Java. Po jego lekturze dowiesz się czym jest wątek, jaki ma cykl życia i jak go uruchomić. Dowiesz się czym jest synchroni...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/2018/01/08_struktury_danych_tablica_asocjacyjna_artykul.jpg" alt="">
      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/struktury-danych-tablica-asocjacyjna/" rel="permalink">Struktury danych – tablica asocjacyjna
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          12 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">W artykule tym przeczytasz o tablicy asocjacyjnej zwanej także słownikiem czy mapą. Dowiesz się jak działa ta struktura. Pokażę Ci przykładową implementację ...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/2018/05/01_zmiana_branzy_zostan_programista.jpg" alt="">
      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/zmiana-branzy-zostan-programista/" rel="permalink">Zmiana branży – zostań programistą
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          26 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Na rynku IT brakuje pracowników. Uczelnie nie nadążają z dostarczaniem nowych specjalistów. Popyt znacząco przewyższa podaż przez co rynek IT jest rynkiem pr...</p>
  </article>
</div>

        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
      <div class="archive__item-teaser">
        <img src="/assets/images/2016/11/28_wyrazenia_regularne_artykul.jpg" alt="">
      </div>
    
    <h2 class="archive__item-title no_toc" itemprop="headline">
      
        <a href="/wyrazenia-regularne-w-jezyku-java/" rel="permalink">Wyrażenia regularne w języku Java
</a>
      
    </h2>
    

  <p class="page__meta">
    

    

    
      
      

      <span class="page__meta-readtime">
        <i class="far fa-clock" aria-hidden="true"></i>
        
          16 minut(y)
        
      </span>
    
  </p>


    <p class="archive__item-excerpt" itemprop="description">Artykuł ten poświęcony jest wyrażeniom regularnym. Dowiesz się w nim czym są wyrażenia regularne, jak i kiedy ich używać. Poznasz klasy biblioteki standardow...</p>
  </article>
</div>

        
      </div>
    </div>
  
  
</div>

    </div>

    
      <div class="search-content">
        <div class="search-content__inner-wrap"><div class="search-searchbar"></div>
  <div class="search-hits"></div></div>

      </div>
    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">

    
      <li><strong>Śledź:</strong></li>
    

    
      
        
          <li><a href="https://www.facebook.com/SamouczekProgramisty" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i> Facebook</a></li>
        
      
        
          <li><a href="https://github.com/SamouczekProgramisty" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i> GitHub</a></li>
        
      
        
          <li><a href="https://www.youtube.com/channel/UCisPQ5nxB6yw3SfJPFWKTEg" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-youtube" aria-hidden="true"></i> YouTube</a></li>
        
      
    

    <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
  </ul>

  <ul>
    <li><a href="https://www.samouczekprogramisty.pl/o-mnie/">O mnie</a></li>
    <li><a href="https://www.samouczekprogramisty.pl/o-blogu/">O blogu</a></li>
    <li><a href="https://www.samouczekprogramisty.pl/polityka-prywatnosci/">Polityka prywatności</a></li>
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2015-2022 Marcin Pietraszek</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>


<!-- Including InstantSearch.js library and styling -->
<script src="https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch.min.js"></script>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch.min.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/instantsearch.js@2.3.3/dist/instantsearch-theme-algolia.min.css">

<script>
// Instanciating InstantSearch.js with Algolia credentials
const search = instantsearch({
  appId: 'BAIWADE3K7',
  apiKey: '4a78df6a4d9f820ebbdb0a35f834b174',
  indexName: 'prod_samouczek',
  searchParameters: {
    restrictSearchableAttributes: [
      'title',
      'content'
    ]
  }
});

const hitTemplate = function(hit) {
  const url = hit.url;
  const title = hit._highlightResult.title.value;
  const content = hit._highlightResult.html.value;

  return `
    <div class="list__item">
      <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
        <h2 class="archive__item-title" itemprop="headline"><a href="${url}">${title}</a></h2>
        <div class="archive__item-excerpt" itemprop="description">${content}</div>
      </article>
    </div>
  `;
}

// Adding searchbar and results widgets
search.addWidget(
  instantsearch.widgets.searchBox({
    container: '.search-searchbar',
    poweredBy: true,
    placeholder: 'Szukaj...'
  })
);
search.addWidget(
  instantsearch.widgets.hits({
    container: '.search-hits',
    templates: {
      item: hitTemplate,
      empty: 'Brak wyników',
    }
  })
);

// Starting the search only when toggle is clicked
$(document).ready(function () {
  $(".search__toggle").on("click", function() {
    if(!search.started) {
      search.start();
    }
  });
});
</script>





  <!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-XZ470HJYWP"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-XZ470HJYWP', { 'anonymize_ip': true});
</script>






    
  <script>
    var disqus_config = function () {
      this.page.url = "https://www.samouczekprogramisty.pl/podstawy-zlozonosci-obliczeniowej/";  // Replace PAGE_URL with your page's canonical URL variable
      this.page.identifier = ""; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
    };
    (function() { // DON'T EDIT BELOW THIS LINE
      var d = document, s = d.createElement('script');
      s.src = 'https://samouczekprogramisty.disqus.com/embed.js';
      s.setAttribute('data-timestamp', +new Date());
      (d.head || d.body).appendChild(s);
    })();
  </script>
<noscript>Proszę włacz obsługę JavaScript żeby móc zobaczyć komentarze.</noscript>


  





  </body>
</html>
